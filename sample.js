var Lw = Object.defineProperty;
var Vw = (n, e, t) => e in n ? Lw(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var Mw = (n, e) => () => (e || n((e = { exports: {} }).exports, e), e.exports);
var Ii = (n, e, t) => (Vw(n, typeof e != "symbol" ? e + "" : e, t), t);
var c6 = Mw((Ue, He) => {
  function Bw(n, e) {
    for (var t = 0; t < e.length; t++) {
      const i = e[t];
      if (typeof i != "string" && !Array.isArray(i)) {
        for (const s in i)
          if (s !== "default" && !(s in n)) {
            const o = Object.getOwnPropertyDescriptor(i, s);
            o && Object.defineProperty(n, s, o.get ? o : {
              enumerable: !0,
              get: () => i[s]
            });
          }
      }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function rn({ emitter: n, activator: e, callback: t, contextElements: i }) {
    n.listenTo(document, "mousedown", (s, o) => {
      if (!e())
        return;
      const r = typeof o.composedPath == "function" ? o.composedPath() : [], a = typeof i == "function" ? i() : i;
      for (const l of a)
        if (l.contains(o.target) || r.includes(l))
          return;
      t();
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function ja(n) {
    class e extends n {
      disableCssTransitions() {
        this._isCssTransitionsDisabled = !0;
      }
      enableCssTransitions() {
        this._isCssTransitionsDisabled = !1;
      }
      constructor(...i) {
        super(...i), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin();
      }
      initializeCssTransitionDisablerMixin() {
        this.extendTemplate({
          attributes: {
            class: [
              this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
            ]
          }
        });
      }
    }
    return e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function an({ view: n }) {
    n.listenTo(n.element, "submit", (e, t) => {
      t.preventDefault(), n.fire("submit");
    }, { useCapture: !0 });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ka({ keystrokeHandler: n, focusTracker: e, gridItems: t, numberOfColumns: i, uiLanguageDirection: s }) {
    const o = typeof i == "number" ? () => i : i;
    n.set("arrowright", r((c, u) => s === "rtl" ? l(c, u.length) : a(c, u.length))), n.set("arrowleft", r((c, u) => s === "rtl" ? a(c, u.length) : l(c, u.length))), n.set("arrowup", r((c, u) => {
      let d = c - o();
      return d < 0 && (d = c + o() * Math.floor(u.length / o()), d > u.length - 1 && (d -= o())), d;
    })), n.set("arrowdown", r((c, u) => {
      let d = c + o();
      return d > u.length - 1 && (d = c % o()), d;
    }));
    function r(c) {
      return (u) => {
        const d = t.find((m) => m.element === e.focusedElement), h = t.getIndex(d), f = c(h, t);
        t.get(f).focus(), u.stopPropagation(), u.preventDefault();
      };
    }
    function a(c, u) {
      return c === u - 1 ? 0 : c + 1;
    }
    function l(c, u) {
      return c === 0 ? u - 1 : c - 1;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ow() {
    try {
      return navigator.userAgent.toLowerCase();
    } catch (n) {
      return "";
    }
  }
  const Jt = Ow(), B = {
    isMac: ef(Jt),
    isWindows: Nw(Jt),
    isGecko: Dw(Jt),
    isSafari: Fw(Jt),
    isiOS: zw(Jt),
    isAndroid: Uw(Jt),
    isBlink: Hw(Jt),
    features: {
      isRegExpUnicodePropertySupported: $w()
    }
  };
  function ef(n) {
    return n.indexOf("macintosh") > -1;
  }
  function Nw(n) {
    return n.indexOf("windows") > -1;
  }
  function Dw(n) {
    return !!n.match(/gecko\/\d+/);
  }
  function Fw(n) {
    return n.indexOf(" applewebkit/") > -1 && n.indexOf("chrome") === -1;
  }
  function zw(n) {
    return !!n.match(/iphone|ipad/i) || ef(n) && navigator.maxTouchPoints > 0;
  }
  function Uw(n) {
    return n.indexOf("android") > -1;
  }
  function Hw(n) {
    return n.indexOf("chrome/") > -1 && n.indexOf("edge/") < 0;
  }
  function $w() {
    let n = !1;
    try {
      n = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
    } catch (e) {
    }
    return n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function tf(n, e, t, i) {
    t = t || function(l, c) {
      return l === c;
    };
    const s = Array.isArray(n) ? n : Array.prototype.slice.call(n), o = Array.isArray(e) ? e : Array.prototype.slice.call(e), r = Ww(s, o, t);
    return i ? Gw(r, o.length) : qw(o, r);
  }
  function Ww(n, e, t) {
    const i = ec(n, e, t);
    if (i === -1)
      return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
    const s = tc(n, i), o = tc(e, i), r = ec(s, o, t), a = n.length - r, l = e.length - r;
    return { firstIndex: i, lastIndexOld: a, lastIndexNew: l };
  }
  function ec(n, e, t) {
    for (let i = 0; i < Math.max(n.length, e.length); i++)
      if (n[i] === void 0 || e[i] === void 0 || !t(n[i], e[i]))
        return i;
    return -1;
  }
  function tc(n, e) {
    return n.slice(e).reverse();
  }
  function qw(n, e) {
    const t = [], { firstIndex: i, lastIndexOld: s, lastIndexNew: o } = e;
    return o - i > 0 && t.push({
      index: i,
      type: "insert",
      values: n.slice(i, o)
    }), s - i > 0 && t.push({
      index: i + (o - i),
      type: "delete",
      howMany: s - i
    }), t;
  }
  function Gw(n, e) {
    const { firstIndex: t, lastIndexOld: i, lastIndexNew: s } = n;
    if (t === -1)
      return Array(e).fill("equal");
    let o = [];
    return t > 0 && (o = o.concat(Array(t).fill("equal"))), s - t > 0 && (o = o.concat(Array(s - t).fill("insert"))), i - t > 0 && (o = o.concat(Array(i - t).fill("delete"))), s < e && (o = o.concat(Array(e - s).fill("equal"))), o;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Vn(n, e, t) {
    t = t || function(p, b) {
      return p === b;
    };
    const i = n.length, s = e.length;
    if (i > 200 || s > 200 || i + s > 300)
      return Vn.fastDiff(n, e, t, !0);
    let o, r;
    if (s < i) {
      const p = n;
      n = e, e = p, o = "delete", r = "insert";
    } else
      o = "insert", r = "delete";
    const a = n.length, l = e.length, c = l - a, u = {}, d = {};
    function h(p) {
      const b = (d[p - 1] !== void 0 ? d[p - 1] : -1) + 1, v = d[p + 1] !== void 0 ? d[p + 1] : -1, y = b > v ? -1 : 1;
      u[p + y] && (u[p] = u[p + y].slice(0)), u[p] || (u[p] = []), u[p].push(b > v ? o : r);
      let L = Math.max(b, v), M = L - p;
      for (; M < a && L < l && t(n[M], e[L]); )
        M++, L++, u[p].push("equal");
      return L;
    }
    let f = 0, m;
    do {
      for (m = -f; m < c; m++)
        d[m] = h(m);
      for (m = c + f; m > c; m--)
        d[m] = h(m);
      d[c] = h(c), f++;
    } while (d[c] !== l);
    return u[c].slice(1);
  }
  Vn.fastDiff = tf;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function ic() {
    return function n() {
      n.called = !0;
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Pt {
    /**
     * @param source The emitter.
     * @param name The event name.
     */
    constructor(e, t) {
      this.source = e, this.name = t, this.path = [], this.stop = ic(), this.off = ic();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Te = new Array(256).fill("").map((n, e) => ("0" + e.toString(16)).slice(-2));
  function Ze() {
    const n = Math.random() * 4294967296 >>> 0, e = Math.random() * 4294967296 >>> 0, t = Math.random() * 4294967296 >>> 0, i = Math.random() * 4294967296 >>> 0;
    return "e" + Te[n >> 0 & 255] + Te[n >> 8 & 255] + Te[n >> 16 & 255] + Te[n >> 24 & 255] + Te[e >> 0 & 255] + Te[e >> 8 & 255] + Te[e >> 16 & 255] + Te[e >> 24 & 255] + Te[t >> 0 & 255] + Te[t >> 8 & 255] + Te[t >> 16 & 255] + Te[t >> 24 & 255] + Te[i >> 0 & 255] + Te[i >> 8 & 255] + Te[i >> 16 & 255] + Te[i >> 24 & 255];
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Ut = {
    get(n = "normal") {
      return typeof n != "number" ? this[n] || this.normal : n;
    },
    highest: 1e5,
    high: 1e3,
    normal: 0,
    low: -1e3,
    lowest: -1e5
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function nf(n, e) {
    const t = Ut.get(e.priority);
    for (let i = 0; i < n.length; i++)
      if (Ut.get(n[i].priority) < t) {
        n.splice(i, 0, e);
        return;
      }
    n.push(e);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const jw = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
  class g extends Error {
    /**
     * Creates an instance of the CKEditorError class.
     *
     * @param errorName The error id in an `error-name` format. A link to this error documentation page will be added
     * to the thrown error's `message`.
     * @param context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
     * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
     * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
     * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
     * to check if the object works as the context.
     * @param data Additional data describing the error. A stringified version of this object
     * will be appended to the error message, so the data are quickly visible in the console. The original
     * data object will also be later available under the {@link #data} property.
     */
    constructor(e, t, i) {
      super(Kw(e, i)), this.name = "CKEditorError", this.context = t, this.data = i;
    }
    /**
     * Checks if the error is of the `CKEditorError` type.
     */
    is(e) {
      return e === "CKEditorError";
    }
    /**
     * A utility that ensures that the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
     * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
     * of a {@link module:utils/ckeditorerror~CKEditorError} error.
     *
     * @param err The error to rethrow.
     * @param context An object connected through properties with the editor instance. This context will be used
     * by the watchdog to verify which editor should be restarted.
     */
    static rethrowUnexpectedError(e, t) {
      if (e.is && e.is("CKEditorError"))
        throw e;
      const i = new g(e.message, t);
      throw i.stack = e.stack, i;
    }
  }
  function z(n, e) {
    console.warn(...Zw(n, e));
  }
  function sf(n) {
    return `
Read more: ${jw}#error-${n}`;
  }
  function Kw(n, e) {
    const t = /* @__PURE__ */ new WeakSet(), s = e ? ` ${JSON.stringify(e, (r, a) => {
      if (typeof a == "object" && a !== null) {
        if (t.has(a))
          return `[object ${a.constructor.name}]`;
        t.add(a);
      }
      return a;
    })}` : "", o = sf(n);
    return n + s + o;
  }
  function Zw(n, e) {
    const t = sf(n);
    return e ? [n, e, t] : [n, t];
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Jw = "41.3.1", Xw = new Date(2024, 3, 16);
  /* istanbul ignore next -- @preserve */
  if (globalThis.CKEDITOR_VERSION)
    throw new g("ckeditor-duplicated-modules", null);
  globalThis.CKEDITOR_VERSION = Jw;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Di = Symbol("listeningTo"), Kr = Symbol("emitterId"), vt = Symbol("delegations"), of = G(Object);
  function G(n) {
    if (!n)
      return of;
    class e extends n {
      on(i, s, o) {
        this.listenTo(this, i, s, o);
      }
      once(i, s, o) {
        let r = !1;
        const a = (l, ...c) => {
          r || (r = !0, l.off(), s.call(this, l, ...c));
        };
        this.listenTo(this, i, a, o);
      }
      off(i, s) {
        this.stopListening(this, i, s);
      }
      listenTo(i, s, o, r = {}) {
        let a, l;
        this[Di] || (this[Di] = {});
        const c = this[Di];
        mr(i) || rf(i);
        const u = mr(i);
        (a = c[u]) || (a = c[u] = {
          emitter: i,
          callbacks: {}
        }), (l = a.callbacks[s]) || (l = a.callbacks[s] = []), l.push(o), tb(this, i, s, o, r);
      }
      stopListening(i, s, o) {
        const r = this[Di];
        let a = i && mr(i);
        const l = r && a ? r[a] : void 0, c = l && s ? l.callbacks[s] : void 0;
        if (!(!r || i && !l || s && !c))
          if (o)
            gr(this, i, s, o), c.indexOf(o) !== -1 && (c.length === 1 ? delete l.callbacks[s] : gr(this, i, s, o));
          else if (c) {
            for (; o = c.pop(); )
              gr(this, i, s, o);
            delete l.callbacks[s];
          } else if (l) {
            for (s in l.callbacks)
              this.stopListening(i, s);
            delete r[a];
          } else {
            for (a in r)
              this.stopListening(r[a].emitter);
            delete this[Di];
          }
      }
      fire(i, ...s) {
        try {
          const o = i instanceof Pt ? i : new Pt(this, i), r = o.name;
          let a = lf(this, r);
          if (o.path.push(this), a) {
            const c = [o, ...s];
            a = Array.from(a);
            for (let u = 0; u < a.length && (a[u].callback.apply(this, c), o.off.called && (delete o.off.called, this._removeEventListener(r, a[u].callback)), !o.stop.called); u++)
              ;
          }
          const l = this[vt];
          if (l) {
            const c = l.get(r), u = l.get("*");
            c && nc(c, o, s), u && nc(u, o, s);
          }
          return o.return;
        } catch (o) {
          /* istanbul ignore next -- @preserve */
          g.rethrowUnexpectedError(o, this);
        }
      }
      delegate(...i) {
        return {
          to: (s, o) => {
            this[vt] || (this[vt] = /* @__PURE__ */ new Map()), i.forEach((r) => {
              const a = this[vt].get(r);
              a ? a.set(s, o) : this[vt].set(r, /* @__PURE__ */ new Map([[s, o]]));
            });
          }
        };
      }
      stopDelegating(i, s) {
        if (this[vt])
          if (!i)
            this[vt].clear();
          else if (!s)
            this[vt].delete(i);
          else {
            const o = this[vt].get(i);
            o && o.delete(s);
          }
      }
      _addEventListener(i, s, o) {
        eb(this, i);
        const r = Zr(this, i), a = Ut.get(o.priority), l = {
          callback: s,
          priority: a
        };
        for (const c of r)
          nf(c, l);
      }
      _removeEventListener(i, s) {
        const o = Zr(this, i);
        for (const r of o)
          for (let a = 0; a < r.length; a++)
            r[a].callback == s && (r.splice(a, 1), a--);
      }
    }
    return e;
  }
  [
    "on",
    "once",
    "off",
    "listenTo",
    "stopListening",
    "fire",
    "delegate",
    "stopDelegating",
    "_addEventListener",
    "_removeEventListener"
  ].forEach((n) => {
    G[n] = of.prototype[n];
  });
  function Yw(n, e) {
    const t = n[Di];
    return t && t[e] ? t[e].emitter : null;
  }
  function rf(n, e) {
    n[Kr] || (n[Kr] = e || Ze());
  }
  function mr(n) {
    return n[Kr];
  }
  function af(n) {
    return n._events || Object.defineProperty(n, "_events", {
      value: {}
    }), n._events;
  }
  function Qw() {
    return {
      callbacks: [],
      childEvents: []
    };
  }
  function eb(n, e) {
    const t = af(n);
    if (t[e])
      return;
    let i = e, s = null;
    const o = [];
    for (; i !== "" && !t[i]; )
      t[i] = Qw(), o.push(t[i]), s && t[i].childEvents.push(s), s = i, i = i.substr(0, i.lastIndexOf(":"));
    if (i !== "") {
      for (const r of o)
        r.callbacks = t[i].callbacks.slice();
      t[i].childEvents.push(s);
    }
  }
  function Zr(n, e) {
    const t = af(n)[e];
    if (!t)
      return [];
    let i = [t.callbacks];
    for (let s = 0; s < t.childEvents.length; s++) {
      const o = Zr(n, t.childEvents[s]);
      i = i.concat(o);
    }
    return i;
  }
  function lf(n, e) {
    let t;
    return !n._events || !(t = n._events[e]) || !t.callbacks.length ? e.indexOf(":") > -1 ? lf(n, e.substr(0, e.lastIndexOf(":"))) : null : t.callbacks;
  }
  function nc(n, e, t) {
    for (let [i, s] of n) {
      s ? typeof s == "function" && (s = s(e.name)) : s = e.name;
      const o = new Pt(e.source, s);
      o.path = [...e.path], i.fire(o, ...t);
    }
  }
  function tb(n, e, t, i, s) {
    e._addEventListener ? e._addEventListener(t, i, s) : n._addEventListener.call(e, t, i, s);
  }
  function gr(n, e, t, i) {
    e._removeEventListener ? e._removeEventListener(t, i) : n._removeEventListener.call(e, t, i);
  }
  var cf = typeof global == "object" && global && global.Object === Object && global, ib = typeof self == "object" && self && self.Object === Object && self, ct = cf || ib || Function("return this")(), pt = ct.Symbol, uf = Object.prototype, nb = uf.hasOwnProperty, sb = uf.toString, pn = pt ? pt.toStringTag : void 0;
  function ob(n) {
    var e = nb.call(n, pn), t = n[pn];
    try {
      n[pn] = void 0;
      var i = !0;
    } catch (o) {
    }
    var s = sb.call(n);
    return i && (e ? n[pn] = t : delete n[pn]), s;
  }
  var rb = Object.prototype, ab = rb.toString;
  function lb(n) {
    return ab.call(n);
  }
  var cb = "[object Null]", ub = "[object Undefined]", sc = pt ? pt.toStringTag : void 0;
  function qt(n) {
    return n == null ? n === void 0 ? ub : cb : sc && sc in Object(n) ? ob(n) : lb(n);
  }
  function Je(n) {
    return n != null && typeof n == "object";
  }
  var db = "[object Symbol]";
  function Fo(n) {
    return typeof n == "symbol" || Je(n) && qt(n) == db;
  }
  function hb(n, e) {
    for (var t = -1, i = n == null ? 0 : n.length, s = Array(i); ++t < i; )
      s[t] = e(n[t], t, n);
    return s;
  }
  var $e = Array.isArray, fb = 1 / 0, oc = pt ? pt.prototype : void 0, rc = oc ? oc.toString : void 0;
  function df(n) {
    if (typeof n == "string")
      return n;
    if ($e(n))
      return hb(n, df) + "";
    if (Fo(n))
      return rc ? rc.call(n) : "";
    var e = n + "";
    return e == "0" && 1 / n == -fb ? "-0" : e;
  }
  var mb = /\s/;
  function gb(n) {
    for (var e = n.length; e-- && mb.test(n.charAt(e)); )
      ;
    return e;
  }
  var pb = /^\s+/;
  function wb(n) {
    return n && n.slice(0, gb(n) + 1).replace(pb, "");
  }
  function J(n) {
    var e = typeof n;
    return n != null && (e == "object" || e == "function");
  }
  var ac = NaN, bb = /^[-+]0x[0-9a-f]+$/i, _b = /^0b[01]+$/i, vb = /^0o[0-7]+$/i, yb = parseInt;
  function lc(n) {
    if (typeof n == "number")
      return n;
    if (Fo(n))
      return ac;
    if (J(n)) {
      var e = typeof n.valueOf == "function" ? n.valueOf() : n;
      n = J(e) ? e + "" : e;
    }
    if (typeof n != "string")
      return n === 0 ? n : +n;
    n = wb(n);
    var t = _b.test(n);
    return t || vb.test(n) ? yb(n.slice(2), t ? 2 : 8) : bb.test(n) ? ac : +n;
  }
  function Ft(n) {
    return n;
  }
  var Cb = "[object AsyncFunction]", kb = "[object Function]", Tb = "[object GeneratorFunction]", Eb = "[object Proxy]";
  function di(n) {
    if (!J(n))
      return !1;
    var e = qt(n);
    return e == kb || e == Tb || e == Cb || e == Eb;
  }
  var pr = ct["__core-js_shared__"], cc = function() {
    var n = /[^.]+$/.exec(pr && pr.keys && pr.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  }();
  function Ab(n) {
    return !!cc && cc in n;
  }
  var xb = Function.prototype, Sb = xb.toString;
  function pi(n) {
    if (n != null) {
      try {
        return Sb.call(n);
      } catch (e) {
      }
      try {
        return n + "";
      } catch (e) {
      }
    }
    return "";
  }
  var Ib = /[\\^$.*+?()[\]{}|]/g, Pb = /^\[object .+?Constructor\]$/, Rb = Function.prototype, Lb = Object.prototype, Vb = Rb.toString, Mb = Lb.hasOwnProperty, Bb = RegExp(
    "^" + Vb.call(Mb).replace(Ib, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function Ob(n) {
    if (!J(n) || Ab(n))
      return !1;
    var e = di(n) ? Bb : Pb;
    return e.test(pi(n));
  }
  function Nb(n, e) {
    return n == null ? void 0 : n[e];
  }
  function wi(n, e) {
    var t = Nb(n, e);
    return Ob(t) ? t : void 0;
  }
  var Jr = wi(ct, "WeakMap"), uc = Object.create, Db = /* @__PURE__ */ function() {
    function n() {
    }
    return function(e) {
      if (!J(e))
        return {};
      if (uc)
        return uc(e);
      n.prototype = e;
      var t = new n();
      return n.prototype = void 0, t;
    };
  }();
  function Fb(n, e, t) {
    switch (t.length) {
      case 0:
        return n.call(e);
      case 1:
        return n.call(e, t[0]);
      case 2:
        return n.call(e, t[0], t[1]);
      case 3:
        return n.call(e, t[0], t[1], t[2]);
    }
    return n.apply(e, t);
  }
  function hf(n, e) {
    var t = -1, i = n.length;
    for (e || (e = Array(i)); ++t < i; )
      e[t] = n[t];
    return e;
  }
  var zb = 800, Ub = 16, Hb = Date.now;
  function $b(n) {
    var e = 0, t = 0;
    return function() {
      var i = Hb(), s = Ub - (i - t);
      if (t = i, s > 0) {
        if (++e >= zb)
          return arguments[0];
      } else
        e = 0;
      return n.apply(void 0, arguments);
    };
  }
  function Wb(n) {
    return function() {
      return n;
    };
  }
  var go = function() {
    try {
      var n = wi(Object, "defineProperty");
      return n({}, "", {}), n;
    } catch (e) {
    }
  }(), qb = go ? function(n, e) {
    return go(n, "toString", {
      configurable: !0,
      enumerable: !1,
      value: Wb(e),
      writable: !0
    });
  } : Ft;
  const Gb = qb;
  var jb = $b(Gb);
  function Kb(n, e) {
    for (var t = -1, i = n == null ? 0 : n.length; ++t < i && e(n[t], t, n) !== !1; )
      ;
    return n;
  }
  var Zb = 9007199254740991, Jb = /^(?:0|[1-9]\d*)$/;
  function zo(n, e) {
    var t = typeof n;
    return e = e == null ? Zb : e, !!e && (t == "number" || t != "symbol" && Jb.test(n)) && n > -1 && n % 1 == 0 && n < e;
  }
  function Uo(n, e, t) {
    e == "__proto__" && go ? go(n, e, {
      configurable: !0,
      enumerable: !0,
      value: t,
      writable: !0
    }) : n[e] = t;
  }
  function hs(n, e) {
    return n === e || n !== n && e !== e;
  }
  var Xb = Object.prototype, Yb = Xb.hasOwnProperty;
  function Za(n, e, t) {
    var i = n[e];
    (!(Yb.call(n, e) && hs(i, t)) || t === void 0 && !(e in n)) && Uo(n, e, t);
  }
  function ln(n, e, t, i) {
    var s = !t;
    t || (t = {});
    for (var o = -1, r = e.length; ++o < r; ) {
      var a = e[o], l = i ? i(t[a], n[a], a, t, n) : void 0;
      l === void 0 && (l = n[a]), s ? Uo(t, a, l) : Za(t, a, l);
    }
    return t;
  }
  var dc = Math.max;
  function Qb(n, e, t) {
    return e = dc(e === void 0 ? n.length - 1 : e, 0), function() {
      for (var i = arguments, s = -1, o = dc(i.length - e, 0), r = Array(o); ++s < o; )
        r[s] = i[e + s];
      s = -1;
      for (var a = Array(e + 1); ++s < e; )
        a[s] = i[s];
      return a[e] = t(r), Fb(n, this, a);
    };
  }
  function e0(n, e) {
    return jb(Qb(n, e, Ft), n + "");
  }
  var t0 = 9007199254740991;
  function Ja(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= t0;
  }
  function Ho(n) {
    return n != null && Ja(n.length) && !di(n);
  }
  function i0(n, e, t) {
    if (!J(t))
      return !1;
    var i = typeof e;
    return (i == "number" ? Ho(t) && zo(e, t.length) : i == "string" && e in t) ? hs(t[e], n) : !1;
  }
  function ff(n) {
    return e0(function(e, t) {
      var i = -1, s = t.length, o = s > 1 ? t[s - 1] : void 0, r = s > 2 ? t[2] : void 0;
      for (o = n.length > 3 && typeof o == "function" ? (s--, o) : void 0, r && i0(t[0], t[1], r) && (o = s < 3 ? void 0 : o, s = 1), e = Object(e); ++i < s; ) {
        var a = t[i];
        a && n(e, a, i, o);
      }
      return e;
    });
  }
  var n0 = Object.prototype;
  function Xa(n) {
    var e = n && n.constructor, t = typeof e == "function" && e.prototype || n0;
    return n === t;
  }
  function s0(n, e) {
    for (var t = -1, i = Array(n); ++t < n; )
      i[t] = e(t);
    return i;
  }
  var o0 = "[object Arguments]";
  function hc(n) {
    return Je(n) && qt(n) == o0;
  }
  var mf = Object.prototype, r0 = mf.hasOwnProperty, a0 = mf.propertyIsEnumerable, po = hc(/* @__PURE__ */ function() {
    return arguments;
  }()) ? hc : function(n) {
    return Je(n) && r0.call(n, "callee") && !a0.call(n, "callee");
  };
  function l0() {
    return !1;
  }
  var gf = typeof Ue == "object" && Ue && !Ue.nodeType && Ue, fc = gf && typeof He == "object" && He && !He.nodeType && He, c0 = fc && fc.exports === gf, mc = c0 ? ct.Buffer : void 0, u0 = mc ? mc.isBuffer : void 0, qn = u0 || l0, d0 = "[object Arguments]", h0 = "[object Array]", f0 = "[object Boolean]", m0 = "[object Date]", g0 = "[object Error]", p0 = "[object Function]", w0 = "[object Map]", b0 = "[object Number]", _0 = "[object Object]", v0 = "[object RegExp]", y0 = "[object Set]", C0 = "[object String]", k0 = "[object WeakMap]", T0 = "[object ArrayBuffer]", E0 = "[object DataView]", A0 = "[object Float32Array]", x0 = "[object Float64Array]", S0 = "[object Int8Array]", I0 = "[object Int16Array]", P0 = "[object Int32Array]", R0 = "[object Uint8Array]", L0 = "[object Uint8ClampedArray]", V0 = "[object Uint16Array]", M0 = "[object Uint32Array]", te = {};
  te[A0] = te[x0] = te[S0] = te[I0] = te[P0] = te[R0] = te[L0] = te[V0] = te[M0] = !0;
  te[d0] = te[h0] = te[T0] = te[f0] = te[E0] = te[m0] = te[g0] = te[p0] = te[w0] = te[b0] = te[_0] = te[v0] = te[y0] = te[C0] = te[k0] = !1;
  function B0(n) {
    return Je(n) && Ja(n.length) && !!te[qt(n)];
  }
  function Ya(n) {
    return function(e) {
      return n(e);
    };
  }
  var pf = typeof Ue == "object" && Ue && !Ue.nodeType && Ue, Mn = pf && typeof He == "object" && He && !He.nodeType && He, O0 = Mn && Mn.exports === pf, wr = O0 && cf.process, Ki = function() {
    try {
      var n = Mn && Mn.require && Mn.require("util").types;
      return n || wr && wr.binding && wr.binding("util");
    } catch (e) {
    }
  }(), gc = Ki && Ki.isTypedArray, Qa = gc ? Ya(gc) : B0, N0 = Object.prototype, D0 = N0.hasOwnProperty;
  function wf(n, e) {
    var t = $e(n), i = !t && po(n), s = !t && !i && qn(n), o = !t && !i && !s && Qa(n), r = t || i || s || o, a = r ? s0(n.length, String) : [], l = a.length;
    for (var c in n)
      (e || D0.call(n, c)) && !(r && // Safari 9 has enumerable `arguments.length` in strict mode.
      (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      s && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      o && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
      zo(c, l))) && a.push(c);
    return a;
  }
  function bf(n, e) {
    return function(t) {
      return n(e(t));
    };
  }
  var F0 = bf(Object.keys, Object), z0 = Object.prototype, U0 = z0.hasOwnProperty;
  function H0(n) {
    if (!Xa(n))
      return F0(n);
    var e = [];
    for (var t in Object(n))
      U0.call(n, t) && t != "constructor" && e.push(t);
    return e;
  }
  function fs(n) {
    return Ho(n) ? wf(n) : H0(n);
  }
  function $0(n) {
    var e = [];
    if (n != null)
      for (var t in Object(n))
        e.push(t);
    return e;
  }
  var W0 = Object.prototype, q0 = W0.hasOwnProperty;
  function G0(n) {
    if (!J(n))
      return $0(n);
    var e = Xa(n), t = [];
    for (var i in n)
      i == "constructor" && (e || !q0.call(n, i)) || t.push(i);
    return t;
  }
  function cn(n) {
    return Ho(n) ? wf(n, !0) : G0(n);
  }
  var _f = ff(function(n, e) {
    ln(e, cn(e), n);
  }), j0 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, K0 = /^\w*$/;
  function el(n, e) {
    if ($e(n))
      return !1;
    var t = typeof n;
    return t == "number" || t == "symbol" || t == "boolean" || n == null || Fo(n) ? !0 : K0.test(n) || !j0.test(n) || e != null && n in Object(e);
  }
  var Gn = wi(Object, "create");
  function Z0() {
    this.__data__ = Gn ? Gn(null) : {}, this.size = 0;
  }
  function J0(n) {
    var e = this.has(n) && delete this.__data__[n];
    return this.size -= e ? 1 : 0, e;
  }
  var X0 = "__lodash_hash_undefined__", Y0 = Object.prototype, Q0 = Y0.hasOwnProperty;
  function e1(n) {
    var e = this.__data__;
    if (Gn) {
      var t = e[n];
      return t === X0 ? void 0 : t;
    }
    return Q0.call(e, n) ? e[n] : void 0;
  }
  var t1 = Object.prototype, i1 = t1.hasOwnProperty;
  function n1(n) {
    var e = this.__data__;
    return Gn ? e[n] !== void 0 : i1.call(e, n);
  }
  var s1 = "__lodash_hash_undefined__";
  function o1(n, e) {
    var t = this.__data__;
    return this.size += this.has(n) ? 0 : 1, t[n] = Gn && e === void 0 ? s1 : e, this;
  }
  function hi(n) {
    var e = -1, t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
      var i = n[e];
      this.set(i[0], i[1]);
    }
  }
  hi.prototype.clear = Z0;
  hi.prototype.delete = J0;
  hi.prototype.get = e1;
  hi.prototype.has = n1;
  hi.prototype.set = o1;
  function r1() {
    this.__data__ = [], this.size = 0;
  }
  function $o(n, e) {
    for (var t = n.length; t--; )
      if (hs(n[t][0], e))
        return t;
    return -1;
  }
  var a1 = Array.prototype, l1 = a1.splice;
  function c1(n) {
    var e = this.__data__, t = $o(e, n);
    if (t < 0)
      return !1;
    var i = e.length - 1;
    return t == i ? e.pop() : l1.call(e, t, 1), --this.size, !0;
  }
  function u1(n) {
    var e = this.__data__, t = $o(e, n);
    return t < 0 ? void 0 : e[t][1];
  }
  function d1(n) {
    return $o(this.__data__, n) > -1;
  }
  function h1(n, e) {
    var t = this.__data__, i = $o(t, n);
    return i < 0 ? (++this.size, t.push([n, e])) : t[i][1] = e, this;
  }
  function Lt(n) {
    var e = -1, t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
      var i = n[e];
      this.set(i[0], i[1]);
    }
  }
  Lt.prototype.clear = r1;
  Lt.prototype.delete = c1;
  Lt.prototype.get = u1;
  Lt.prototype.has = d1;
  Lt.prototype.set = h1;
  var jn = wi(ct, "Map");
  function f1() {
    this.size = 0, this.__data__ = {
      hash: new hi(),
      map: new (jn || Lt)(),
      string: new hi()
    };
  }
  function m1(n) {
    var e = typeof n;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null;
  }
  function Wo(n, e) {
    var t = n.__data__;
    return m1(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
  }
  function g1(n) {
    var e = Wo(this, n).delete(n);
    return this.size -= e ? 1 : 0, e;
  }
  function p1(n) {
    return Wo(this, n).get(n);
  }
  function w1(n) {
    return Wo(this, n).has(n);
  }
  function b1(n, e) {
    var t = Wo(this, n), i = t.size;
    return t.set(n, e), this.size += t.size == i ? 0 : 1, this;
  }
  function Vt(n) {
    var e = -1, t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
      var i = n[e];
      this.set(i[0], i[1]);
    }
  }
  Vt.prototype.clear = f1;
  Vt.prototype.delete = g1;
  Vt.prototype.get = p1;
  Vt.prototype.has = w1;
  Vt.prototype.set = b1;
  var _1 = "Expected a function";
  function tl(n, e) {
    if (typeof n != "function" || e != null && typeof e != "function")
      throw new TypeError(_1);
    var t = function() {
      var i = arguments, s = e ? e.apply(this, i) : i[0], o = t.cache;
      if (o.has(s))
        return o.get(s);
      var r = n.apply(this, i);
      return t.cache = o.set(s, r) || o, r;
    };
    return t.cache = new (tl.Cache || Vt)(), t;
  }
  tl.Cache = Vt;
  var v1 = 500;
  function y1(n) {
    var e = tl(n, function(i) {
      return t.size === v1 && t.clear(), i;
    }), t = e.cache;
    return e;
  }
  var C1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, k1 = /\\(\\)?/g, T1 = y1(function(n) {
    var e = [];
    return n.charCodeAt(0) === 46 && e.push(""), n.replace(C1, function(t, i, s, o) {
      e.push(s ? o.replace(k1, "$1") : i || t);
    }), e;
  });
  function il(n) {
    return n == null ? "" : df(n);
  }
  function qo(n, e) {
    return $e(n) ? n : el(n, e) ? [n] : T1(il(n));
  }
  var E1 = 1 / 0;
  function un(n) {
    if (typeof n == "string" || Fo(n))
      return n;
    var e = n + "";
    return e == "0" && 1 / n == -E1 ? "-0" : e;
  }
  function nl(n, e) {
    e = qo(e, n);
    for (var t = 0, i = e.length; n != null && t < i; )
      n = n[un(e[t++])];
    return t && t == i ? n : void 0;
  }
  function Kn(n, e, t) {
    var i = n == null ? void 0 : nl(n, e);
    return i === void 0 ? t : i;
  }
  function vf(n, e) {
    for (var t = -1, i = e.length, s = n.length; ++t < i; )
      n[s + t] = e[t];
    return n;
  }
  var sl = bf(Object.getPrototypeOf, Object), A1 = "[object Object]", x1 = Function.prototype, S1 = Object.prototype, yf = x1.toString, I1 = S1.hasOwnProperty, P1 = yf.call(Object);
  function Ne(n) {
    if (!Je(n) || qt(n) != A1)
      return !1;
    var e = sl(n);
    if (e === null)
      return !0;
    var t = I1.call(e, "constructor") && e.constructor;
    return typeof t == "function" && t instanceof t && yf.call(t) == P1;
  }
  function Cf(n, e, t) {
    var i = -1, s = n.length;
    e < 0 && (e = -e > s ? 0 : s + e), t = t > s ? s : t, t < 0 && (t += s), s = e > t ? 0 : t - e >>> 0, e >>>= 0;
    for (var o = Array(s); ++i < s; )
      o[i] = n[i + e];
    return o;
  }
  function R1(n, e, t) {
    var i = n.length;
    return t = t === void 0 ? i : t, !e && t >= i ? n : Cf(n, e, t);
  }
  var L1 = "\\ud800-\\udfff", V1 = "\\u0300-\\u036f", M1 = "\\ufe20-\\ufe2f", B1 = "\\u20d0-\\u20ff", O1 = V1 + M1 + B1, N1 = "\\ufe0e\\ufe0f", D1 = "\\u200d", F1 = RegExp("[" + D1 + L1 + O1 + N1 + "]");
  function kf(n) {
    return F1.test(n);
  }
  function z1(n) {
    return n.split("");
  }
  var Tf = "\\ud800-\\udfff", U1 = "\\u0300-\\u036f", H1 = "\\ufe20-\\ufe2f", $1 = "\\u20d0-\\u20ff", W1 = U1 + H1 + $1, q1 = "\\ufe0e\\ufe0f", G1 = "[" + Tf + "]", Xr = "[" + W1 + "]", Yr = "\\ud83c[\\udffb-\\udfff]", j1 = "(?:" + Xr + "|" + Yr + ")", Ef = "[^" + Tf + "]", Af = "(?:\\ud83c[\\udde6-\\uddff]){2}", xf = "[\\ud800-\\udbff][\\udc00-\\udfff]", K1 = "\\u200d", Sf = j1 + "?", If = "[" + q1 + "]?", Z1 = "(?:" + K1 + "(?:" + [Ef, Af, xf].join("|") + ")" + If + Sf + ")*", J1 = If + Sf + Z1, X1 = "(?:" + [Ef + Xr + "?", Xr, Af, xf, G1].join("|") + ")", Y1 = RegExp(Yr + "(?=" + Yr + ")|" + X1 + J1, "g");
  function Q1(n) {
    return n.match(Y1) || [];
  }
  function e_(n) {
    return kf(n) ? Q1(n) : z1(n);
  }
  function t_(n) {
    return function(e) {
      e = il(e);
      var t = kf(e) ? e_(e) : void 0, i = t ? t[0] : e.charAt(0), s = t ? R1(t, 1).join("") : e.slice(1);
      return i[n]() + s;
    };
  }
  var i_ = t_("toUpperCase");
  function n_() {
    this.__data__ = new Lt(), this.size = 0;
  }
  function s_(n) {
    var e = this.__data__, t = e.delete(n);
    return this.size = e.size, t;
  }
  function o_(n) {
    return this.__data__.get(n);
  }
  function r_(n) {
    return this.__data__.has(n);
  }
  var a_ = 200;
  function l_(n, e) {
    var t = this.__data__;
    if (t instanceof Lt) {
      var i = t.__data__;
      if (!jn || i.length < a_ - 1)
        return i.push([n, e]), this.size = ++t.size, this;
      t = this.__data__ = new Vt(i);
    }
    return t.set(n, e), this.size = t.size, this;
  }
  function ot(n) {
    var e = this.__data__ = new Lt(n);
    this.size = e.size;
  }
  ot.prototype.clear = n_;
  ot.prototype.delete = s_;
  ot.prototype.get = o_;
  ot.prototype.has = r_;
  ot.prototype.set = l_;
  function c_(n, e) {
    return n && ln(e, fs(e), n);
  }
  function u_(n, e) {
    return n && ln(e, cn(e), n);
  }
  var Pf = typeof Ue == "object" && Ue && !Ue.nodeType && Ue, pc = Pf && typeof He == "object" && He && !He.nodeType && He, d_ = pc && pc.exports === Pf, wc = d_ ? ct.Buffer : void 0, bc = wc ? wc.allocUnsafe : void 0;
  function Rf(n, e) {
    if (e)
      return n.slice();
    var t = n.length, i = bc ? bc(t) : new n.constructor(t);
    return n.copy(i), i;
  }
  function h_(n, e) {
    for (var t = -1, i = n == null ? 0 : n.length, s = 0, o = []; ++t < i; ) {
      var r = n[t];
      e(r, t, n) && (o[s++] = r);
    }
    return o;
  }
  function Lf() {
    return [];
  }
  var f_ = Object.prototype, m_ = f_.propertyIsEnumerable, _c = Object.getOwnPropertySymbols, ol = _c ? function(n) {
    return n == null ? [] : (n = Object(n), h_(_c(n), function(e) {
      return m_.call(n, e);
    }));
  } : Lf;
  function g_(n, e) {
    return ln(n, ol(n), e);
  }
  var p_ = Object.getOwnPropertySymbols, Vf = p_ ? function(n) {
    for (var e = []; n; )
      vf(e, ol(n)), n = sl(n);
    return e;
  } : Lf;
  function w_(n, e) {
    return ln(n, Vf(n), e);
  }
  function Mf(n, e, t) {
    var i = e(n);
    return $e(n) ? i : vf(i, t(n));
  }
  function Qr(n) {
    return Mf(n, fs, ol);
  }
  function b_(n) {
    return Mf(n, cn, Vf);
  }
  var ea = wi(ct, "DataView"), ta = wi(ct, "Promise"), ia = wi(ct, "Set"), vc = "[object Map]", __ = "[object Object]", yc = "[object Promise]", Cc = "[object Set]", kc = "[object WeakMap]", Tc = "[object DataView]", v_ = pi(ea), y_ = pi(jn), C_ = pi(ta), k_ = pi(ia), T_ = pi(Jr), ni = qt;
  (ea && ni(new ea(new ArrayBuffer(1))) != Tc || jn && ni(new jn()) != vc || ta && ni(ta.resolve()) != yc || ia && ni(new ia()) != Cc || Jr && ni(new Jr()) != kc) && (ni = function(n) {
    var e = qt(n), t = e == __ ? n.constructor : void 0, i = t ? pi(t) : "";
    if (i)
      switch (i) {
        case v_:
          return Tc;
        case y_:
          return vc;
        case C_:
          return yc;
        case k_:
          return Cc;
        case T_:
          return kc;
      }
    return e;
  });
  const Zn = ni;
  var E_ = Object.prototype, A_ = E_.hasOwnProperty;
  function x_(n) {
    var e = n.length, t = new n.constructor(e);
    return e && typeof n[0] == "string" && A_.call(n, "index") && (t.index = n.index, t.input = n.input), t;
  }
  var wo = ct.Uint8Array;
  function rl(n) {
    var e = new n.constructor(n.byteLength);
    return new wo(e).set(new wo(n)), e;
  }
  function S_(n, e) {
    var t = e ? rl(n.buffer) : n.buffer;
    return new n.constructor(t, n.byteOffset, n.byteLength);
  }
  var I_ = /\w*$/;
  function P_(n) {
    var e = new n.constructor(n.source, I_.exec(n));
    return e.lastIndex = n.lastIndex, e;
  }
  var Ec = pt ? pt.prototype : void 0, Ac = Ec ? Ec.valueOf : void 0;
  function R_(n) {
    return Ac ? Object(Ac.call(n)) : {};
  }
  function Bf(n, e) {
    var t = e ? rl(n.buffer) : n.buffer;
    return new n.constructor(t, n.byteOffset, n.length);
  }
  var L_ = "[object Boolean]", V_ = "[object Date]", M_ = "[object Map]", B_ = "[object Number]", O_ = "[object RegExp]", N_ = "[object Set]", D_ = "[object String]", F_ = "[object Symbol]", z_ = "[object ArrayBuffer]", U_ = "[object DataView]", H_ = "[object Float32Array]", $_ = "[object Float64Array]", W_ = "[object Int8Array]", q_ = "[object Int16Array]", G_ = "[object Int32Array]", j_ = "[object Uint8Array]", K_ = "[object Uint8ClampedArray]", Z_ = "[object Uint16Array]", J_ = "[object Uint32Array]";
  function X_(n, e, t) {
    var i = n.constructor;
    switch (e) {
      case z_:
        return rl(n);
      case L_:
      case V_:
        return new i(+n);
      case U_:
        return S_(n, t);
      case H_:
      case $_:
      case W_:
      case q_:
      case G_:
      case j_:
      case K_:
      case Z_:
      case J_:
        return Bf(n, t);
      case M_:
        return new i();
      case B_:
      case D_:
        return new i(n);
      case O_:
        return P_(n);
      case N_:
        return new i();
      case F_:
        return R_(n);
    }
  }
  function Of(n) {
    return typeof n.constructor == "function" && !Xa(n) ? Db(sl(n)) : {};
  }
  var Y_ = "[object Map]";
  function Q_(n) {
    return Je(n) && Zn(n) == Y_;
  }
  var xc = Ki && Ki.isMap, ev = xc ? Ya(xc) : Q_, tv = "[object Set]";
  function iv(n) {
    return Je(n) && Zn(n) == tv;
  }
  var Sc = Ki && Ki.isSet, nv = Sc ? Ya(Sc) : iv, sv = 1, ov = 2, rv = 4, Nf = "[object Arguments]", av = "[object Array]", lv = "[object Boolean]", cv = "[object Date]", uv = "[object Error]", Df = "[object Function]", dv = "[object GeneratorFunction]", hv = "[object Map]", fv = "[object Number]", Ff = "[object Object]", mv = "[object RegExp]", gv = "[object Set]", pv = "[object String]", wv = "[object Symbol]", bv = "[object WeakMap]", _v = "[object ArrayBuffer]", vv = "[object DataView]", yv = "[object Float32Array]", Cv = "[object Float64Array]", kv = "[object Int8Array]", Tv = "[object Int16Array]", Ev = "[object Int32Array]", Av = "[object Uint8Array]", xv = "[object Uint8ClampedArray]", Sv = "[object Uint16Array]", Iv = "[object Uint32Array]", X = {};
  X[Nf] = X[av] = X[_v] = X[vv] = X[lv] = X[cv] = X[yv] = X[Cv] = X[kv] = X[Tv] = X[Ev] = X[hv] = X[fv] = X[Ff] = X[mv] = X[gv] = X[pv] = X[wv] = X[Av] = X[xv] = X[Sv] = X[Iv] = !0;
  X[uv] = X[Df] = X[bv] = !1;
  function Gi(n, e, t, i, s, o) {
    var r, a = e & sv, l = e & ov, c = e & rv;
    if (t && (r = s ? t(n, i, s, o) : t(n)), r !== void 0)
      return r;
    if (!J(n))
      return n;
    var u = $e(n);
    if (u) {
      if (r = x_(n), !a)
        return hf(n, r);
    } else {
      var d = Zn(n), h = d == Df || d == dv;
      if (qn(n))
        return Rf(n, a);
      if (d == Ff || d == Nf || h && !s) {
        if (r = l || h ? {} : Of(n), !a)
          return l ? w_(n, u_(r, n)) : g_(n, c_(r, n));
      } else {
        if (!X[d])
          return s ? n : {};
        r = X_(n, d, a);
      }
    }
    o || (o = new ot());
    var f = o.get(n);
    if (f)
      return f;
    o.set(n, r), nv(n) ? n.forEach(function(b) {
      r.add(Gi(b, e, t, b, n, o));
    }) : ev(n) && n.forEach(function(b, v) {
      r.set(v, Gi(b, e, t, v, n, o));
    });
    var m = c ? l ? b_ : Qr : l ? cn : fs, p = u ? void 0 : m(n);
    return Kb(p || n, function(b, v) {
      p && (v = b, b = n[v]), Za(r, v, Gi(b, e, t, v, n, o));
    }), r;
  }
  var Pv = 4;
  function zf(n) {
    return Gi(n, Pv);
  }
  var Rv = 1, Lv = 4;
  function ut(n) {
    return Gi(n, Rv | Lv);
  }
  var Vv = 1, Mv = 4;
  function al(n, e) {
    return e = typeof e == "function" ? e : void 0, Gi(n, Vv | Mv, e);
  }
  var Bv = "__lodash_hash_undefined__";
  function Ov(n) {
    return this.__data__.set(n, Bv), this;
  }
  function Nv(n) {
    return this.__data__.has(n);
  }
  function bo(n) {
    var e = -1, t = n == null ? 0 : n.length;
    for (this.__data__ = new Vt(); ++e < t; )
      this.add(n[e]);
  }
  bo.prototype.add = bo.prototype.push = Ov;
  bo.prototype.has = Nv;
  function Dv(n, e) {
    for (var t = -1, i = n == null ? 0 : n.length; ++t < i; )
      if (e(n[t], t, n))
        return !0;
    return !1;
  }
  function Fv(n, e) {
    return n.has(e);
  }
  var zv = 1, Uv = 2;
  function Uf(n, e, t, i, s, o) {
    var r = t & zv, a = n.length, l = e.length;
    if (a != l && !(r && l > a))
      return !1;
    var c = o.get(n), u = o.get(e);
    if (c && u)
      return c == e && u == n;
    var d = -1, h = !0, f = t & Uv ? new bo() : void 0;
    for (o.set(n, e), o.set(e, n); ++d < a; ) {
      var m = n[d], p = e[d];
      if (i)
        var b = r ? i(p, m, d, e, n, o) : i(m, p, d, n, e, o);
      if (b !== void 0) {
        if (b)
          continue;
        h = !1;
        break;
      }
      if (f) {
        if (!Dv(e, function(v, y) {
          if (!Fv(f, y) && (m === v || s(m, v, t, i, o)))
            return f.push(y);
        })) {
          h = !1;
          break;
        }
      } else if (!(m === p || s(m, p, t, i, o))) {
        h = !1;
        break;
      }
    }
    return o.delete(n), o.delete(e), h;
  }
  function Hv(n) {
    var e = -1, t = Array(n.size);
    return n.forEach(function(i, s) {
      t[++e] = [s, i];
    }), t;
  }
  function $v(n) {
    var e = -1, t = Array(n.size);
    return n.forEach(function(i) {
      t[++e] = i;
    }), t;
  }
  var Wv = 1, qv = 2, Gv = "[object Boolean]", jv = "[object Date]", Kv = "[object Error]", Zv = "[object Map]", Jv = "[object Number]", Xv = "[object RegExp]", Yv = "[object Set]", Qv = "[object String]", ey = "[object Symbol]", ty = "[object ArrayBuffer]", iy = "[object DataView]", Ic = pt ? pt.prototype : void 0, br = Ic ? Ic.valueOf : void 0;
  function ny(n, e, t, i, s, o, r) {
    switch (t) {
      case iy:
        if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
          return !1;
        n = n.buffer, e = e.buffer;
      case ty:
        return !(n.byteLength != e.byteLength || !o(new wo(n), new wo(e)));
      case Gv:
      case jv:
      case Jv:
        return hs(+n, +e);
      case Kv:
        return n.name == e.name && n.message == e.message;
      case Xv:
      case Qv:
        return n == e + "";
      case Zv:
        var a = Hv;
      case Yv:
        var l = i & Wv;
        if (a || (a = $v), n.size != e.size && !l)
          return !1;
        var c = r.get(n);
        if (c)
          return c == e;
        i |= qv, r.set(n, e);
        var u = Uf(a(n), a(e), i, s, o, r);
        return r.delete(n), u;
      case ey:
        if (br)
          return br.call(n) == br.call(e);
    }
    return !1;
  }
  var sy = 1, oy = Object.prototype, ry = oy.hasOwnProperty;
  function ay(n, e, t, i, s, o) {
    var r = t & sy, a = Qr(n), l = a.length, c = Qr(e), u = c.length;
    if (l != u && !r)
      return !1;
    for (var d = l; d--; ) {
      var h = a[d];
      if (!(r ? h in e : ry.call(e, h)))
        return !1;
    }
    var f = o.get(n), m = o.get(e);
    if (f && m)
      return f == e && m == n;
    var p = !0;
    o.set(n, e), o.set(e, n);
    for (var b = r; ++d < l; ) {
      h = a[d];
      var v = n[h], y = e[h];
      if (i)
        var L = r ? i(y, v, h, e, n, o) : i(v, y, h, n, e, o);
      if (!(L === void 0 ? v === y || s(v, y, t, i, o) : L)) {
        p = !1;
        break;
      }
      b || (b = h == "constructor");
    }
    if (p && !b) {
      var M = n.constructor, D = e.constructor;
      M != D && "constructor" in n && "constructor" in e && !(typeof M == "function" && M instanceof M && typeof D == "function" && D instanceof D) && (p = !1);
    }
    return o.delete(n), o.delete(e), p;
  }
  var ly = 1, Pc = "[object Arguments]", Rc = "[object Array]", xs = "[object Object]", cy = Object.prototype, Lc = cy.hasOwnProperty;
  function uy(n, e, t, i, s, o) {
    var r = $e(n), a = $e(e), l = r ? Rc : Zn(n), c = a ? Rc : Zn(e);
    l = l == Pc ? xs : l, c = c == Pc ? xs : c;
    var u = l == xs, d = c == xs, h = l == c;
    if (h && qn(n)) {
      if (!qn(e))
        return !1;
      r = !0, u = !1;
    }
    if (h && !u)
      return o || (o = new ot()), r || Qa(n) ? Uf(n, e, t, i, s, o) : ny(n, e, l, t, i, s, o);
    if (!(t & ly)) {
      var f = u && Lc.call(n, "__wrapped__"), m = d && Lc.call(e, "__wrapped__");
      if (f || m) {
        var p = f ? n.value() : n, b = m ? e.value() : e;
        return o || (o = new ot()), s(p, b, t, i, o);
      }
    }
    return h ? (o || (o = new ot()), ay(n, e, t, i, s, o)) : !1;
  }
  function ms(n, e, t, i, s) {
    return n === e ? !0 : n == null || e == null || !Je(n) && !Je(e) ? n !== n && e !== e : uy(n, e, t, i, ms, s);
  }
  var dy = 1, hy = 2;
  function fy(n, e, t, i) {
    var s = t.length, o = s, r = !i;
    if (n == null)
      return !o;
    for (n = Object(n); s--; ) {
      var a = t[s];
      if (r && a[2] ? a[1] !== n[a[0]] : !(a[0] in n))
        return !1;
    }
    for (; ++s < o; ) {
      a = t[s];
      var l = a[0], c = n[l], u = a[1];
      if (r && a[2]) {
        if (c === void 0 && !(l in n))
          return !1;
      } else {
        var d = new ot();
        if (i)
          var h = i(c, u, l, n, e, d);
        if (!(h === void 0 ? ms(u, c, dy | hy, i, d) : h))
          return !1;
      }
    }
    return !0;
  }
  function Hf(n) {
    return n === n && !J(n);
  }
  function my(n) {
    for (var e = fs(n), t = e.length; t--; ) {
      var i = e[t], s = n[i];
      e[t] = [i, s, Hf(s)];
    }
    return e;
  }
  function $f(n, e) {
    return function(t) {
      return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t));
    };
  }
  function gy(n) {
    var e = my(n);
    return e.length == 1 && e[0][2] ? $f(e[0][0], e[0][1]) : function(t) {
      return t === n || fy(t, n, e);
    };
  }
  function py(n, e) {
    return n != null && e in Object(n);
  }
  function wy(n, e, t) {
    e = qo(e, n);
    for (var i = -1, s = e.length, o = !1; ++i < s; ) {
      var r = un(e[i]);
      if (!(o = n != null && t(n, r)))
        break;
      n = n[r];
    }
    return o || ++i != s ? o : (s = n == null ? 0 : n.length, !!s && Ja(s) && zo(r, s) && ($e(n) || po(n)));
  }
  function by(n, e) {
    return n != null && wy(n, e, py);
  }
  var _y = 1, vy = 2;
  function yy(n, e) {
    return el(n) && Hf(e) ? $f(un(n), e) : function(t) {
      var i = Kn(t, n);
      return i === void 0 && i === e ? by(t, n) : ms(e, i, _y | vy);
    };
  }
  function Cy(n) {
    return function(e) {
      return e == null ? void 0 : e[n];
    };
  }
  function ky(n) {
    return function(e) {
      return nl(e, n);
    };
  }
  function Ty(n) {
    return el(n) ? Cy(un(n)) : ky(n);
  }
  function Ey(n) {
    return typeof n == "function" ? n : n == null ? Ft : typeof n == "object" ? $e(n) ? yy(n[0], n[1]) : gy(n) : Ty(n);
  }
  function Ay(n) {
    return function(e, t, i) {
      for (var s = -1, o = Object(e), r = i(e), a = r.length; a--; ) {
        var l = r[n ? a : ++s];
        if (t(o[l], l, o) === !1)
          break;
      }
      return e;
    };
  }
  var Wf = Ay();
  function xy(n, e) {
    return n && Wf(n, e, fs);
  }
  var _r = function() {
    return ct.Date.now();
  }, Sy = "Expected a function", Iy = Math.max, Py = Math.min;
  function Rt(n, e, t) {
    var i, s, o, r, a, l, c = 0, u = !1, d = !1, h = !0;
    if (typeof n != "function")
      throw new TypeError(Sy);
    e = lc(e) || 0, J(t) && (u = !!t.leading, d = "maxWait" in t, o = d ? Iy(lc(t.maxWait) || 0, e) : o, h = "trailing" in t ? !!t.trailing : h);
    function f(A) {
      var R = i, S = s;
      return i = s = void 0, c = A, r = n.apply(S, R), r;
    }
    function m(A) {
      return c = A, a = setTimeout(v, e), u ? f(A) : r;
    }
    function p(A) {
      var R = A - l, S = A - c, ee = e - R;
      return d ? Py(ee, o - S) : ee;
    }
    function b(A) {
      var R = A - l, S = A - c;
      return l === void 0 || R >= e || R < 0 || d && S >= o;
    }
    function v() {
      var A = _r();
      if (b(A))
        return y(A);
      a = setTimeout(v, p(A));
    }
    function y(A) {
      return a = void 0, h && i ? f(A) : (i = s = void 0, r);
    }
    function L() {
      a !== void 0 && clearTimeout(a), c = 0, i = l = s = a = void 0;
    }
    function M() {
      return a === void 0 ? r : y(_r());
    }
    function D() {
      var A = _r(), R = b(A);
      if (i = arguments, s = this, l = A, R) {
        if (a === void 0)
          return m(l);
        if (d)
          return clearTimeout(a), a = setTimeout(v, e), f(l);
      }
      return a === void 0 && (a = setTimeout(v, e)), r;
    }
    return D.cancel = L, D.flush = M, D;
  }
  function na(n, e, t) {
    (t !== void 0 && !hs(n[e], t) || t === void 0 && !(e in n)) && Uo(n, e, t);
  }
  function Ry(n) {
    return Je(n) && Ho(n);
  }
  function sa(n, e) {
    if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
      return n[e];
  }
  function Ly(n) {
    return ln(n, cn(n));
  }
  function Vy(n, e, t, i, s, o, r) {
    var a = sa(n, t), l = sa(e, t), c = r.get(l);
    if (c) {
      na(n, t, c);
      return;
    }
    var u = o ? o(a, l, t + "", n, e, r) : void 0, d = u === void 0;
    if (d) {
      var h = $e(l), f = !h && qn(l), m = !h && !f && Qa(l);
      u = l, h || f || m ? $e(a) ? u = a : Ry(a) ? u = hf(a) : f ? (d = !1, u = Rf(l, !0)) : m ? (d = !1, u = Bf(l, !0)) : u = [] : Ne(l) || po(l) ? (u = a, po(a) ? u = Ly(a) : (!J(a) || di(a)) && (u = Of(l))) : d = !1;
    }
    d && (r.set(l, u), s(u, l, i, o, r), r.delete(l)), na(n, t, u);
  }
  function qf(n, e, t, i, s) {
    n !== e && Wf(e, function(o, r) {
      if (s || (s = new ot()), J(o))
        Vy(n, e, r, t, qf, i, s);
      else {
        var a = i ? i(sa(n, r), o, r + "", n, e, s) : void 0;
        a === void 0 && (a = o), na(n, r, a);
      }
    }, cn);
  }
  function My(n) {
    var e = n == null ? 0 : n.length;
    return e ? n[e - 1] : void 0;
  }
  var Gf = /[\\^$.*+?()[\]{}|]/g, By = RegExp(Gf.source);
  function jf(n) {
    return n = il(n), n && By.test(n) ? n.replace(Gf, "\\$&") : n;
  }
  var Oy = "[object String]";
  function Vc(n) {
    return typeof n == "string" || !$e(n) && Je(n) && qt(n) == Oy;
  }
  function Ny(n, e) {
    return e.length < 2 ? n : nl(n, Cf(e, 0, -1));
  }
  function fi(n) {
    return Je(n) && n.nodeType === 1 && !Ne(n);
  }
  function _o(n, e) {
    return ms(n, e);
  }
  function Dy(n, e, t) {
    t = typeof t == "function" ? t : void 0;
    var i = t ? t(n, e) : void 0;
    return i === void 0 ? ms(n, e, void 0, t) : !!i;
  }
  function Fy(n, e) {
    var t = {};
    return e = Ey(e), xy(n, function(i, s, o) {
      Uo(t, s, e(i, s, o));
    }), t;
  }
  var ll = ff(function(n, e, t) {
    qf(n, e, t);
  });
  function zy(n, e) {
    return e = qo(e, n), n = Ny(n, e), n == null || delete n[un(My(e))];
  }
  function Uy(n, e, t, i) {
    if (!J(n))
      return n;
    e = qo(e, n);
    for (var s = -1, o = e.length, r = o - 1, a = n; a != null && ++s < o; ) {
      var l = un(e[s]), c = t;
      if (l === "__proto__" || l === "constructor" || l === "prototype")
        return n;
      if (s != r) {
        var u = a[l];
        c = i ? i(u, l, a) : void 0, c === void 0 && (c = J(u) ? u : zo(e[s + 1]) ? [] : {});
      }
      Za(a, l, c), a = a[l];
    }
    return n;
  }
  function Hy(n, e, t) {
    return n == null ? n : Uy(n, e, t);
  }
  var $y = "Expected a function";
  function Zi(n, e, t) {
    var i = !0, s = !0;
    if (typeof n != "function")
      throw new TypeError($y);
    return J(t) && (i = "leading" in t ? !!t.leading : i, s = "trailing" in t ? !!t.trailing : s), Rt(n, e, {
      leading: i,
      maxWait: e,
      trailing: s
    });
  }
  function Wy(n, e) {
    return n == null ? !0 : zy(n, e);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const vo = Symbol("observableProperties"), Go = Symbol("boundObservables"), yo = Symbol("boundProperties"), Pi = Symbol("decoratedMethods"), Mc = Symbol("decoratedOriginal"), Kf = $(G());
  function $(n) {
    if (!n)
      return Kf;
    class e extends n {
      set(i, s) {
        if (J(i)) {
          Object.keys(i).forEach((r) => {
            this.set(r, i[r]);
          }, this);
          return;
        }
        vr(this);
        const o = this[vo];
        if (i in this && !o.has(i))
          throw new g("observable-set-cannot-override", this);
        Object.defineProperty(this, i, {
          enumerable: !0,
          configurable: !0,
          get() {
            return o.get(i);
          },
          set(r) {
            const a = o.get(i);
            let l = this.fire(`set:${i}`, i, r, a);
            l === void 0 && (l = r), (a !== l || !o.has(i)) && (o.set(i, l), this.fire(`change:${i}`, i, l, a));
          }
        }), this[i] = s;
      }
      bind(...i) {
        if (!i.length || !Bc(i))
          throw new g("observable-bind-wrong-properties", this);
        if (new Set(i).size !== i.length)
          throw new g("observable-bind-duplicate-properties", this);
        vr(this);
        const s = this[yo];
        i.forEach((r) => {
          if (s.has(r))
            throw new g("observable-bind-rebind", this);
        });
        const o = /* @__PURE__ */ new Map();
        return i.forEach((r) => {
          const a = { property: r, to: [] };
          s.set(r, a), o.set(r, a);
        }), {
          to: qy,
          toMany: Gy,
          _observable: this,
          _bindProperties: i,
          _to: [],
          _bindings: o
        };
      }
      unbind(...i) {
        if (!this[vo])
          return;
        const s = this[yo], o = this[Go];
        if (i.length) {
          if (!Bc(i))
            throw new g("observable-unbind-wrong-properties", this);
          i.forEach((r) => {
            const a = s.get(r);
            a && (a.to.forEach(([l, c]) => {
              const u = o.get(l), d = u[c];
              d.delete(a), d.size || delete u[c], Object.keys(u).length || (o.delete(l), this.stopListening(l, "change"));
            }), s.delete(r));
          });
        } else
          o.forEach((r, a) => {
            this.stopListening(a, "change");
          }), o.clear(), s.clear();
      }
      decorate(i) {
        vr(this);
        const s = this[i];
        if (!s)
          throw new g("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: i });
        this.on(i, (o, r) => {
          o.return = s.apply(this, r);
        }), this[i] = function(...o) {
          return this.fire(i, o);
        }, this[i][Mc] = s, this[Pi] || (this[Pi] = []), this[Pi].push(i);
      }
      // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.
      // This is needed in case of:
      //  1. Have x.foo() decorated.
      //  2. Call x.stopListening()
      //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)
      stopListening(i, s, o) {
        if (!i && this[Pi]) {
          for (const r of this[Pi])
            this[r] = this[r][Mc];
          delete this[Pi];
        }
        super.stopListening(i, s, o);
      }
    }
    return e;
  }
  [
    "set",
    "bind",
    "unbind",
    "decorate",
    "on",
    "once",
    "off",
    "listenTo",
    "stopListening",
    "fire",
    "delegate",
    "stopDelegating",
    "_addEventListener",
    "_removeEventListener"
  ].forEach((n) => {
    $[n] = Kf.prototype[n];
  });
  function vr(n) {
    n[vo] || (Object.defineProperty(n, vo, {
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(n, Go, {
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(n, yo, {
      value: /* @__PURE__ */ new Map()
    }));
  }
  function qy(...n) {
    const e = Ky(...n), t = Array.from(this._bindings.keys()), i = t.length;
    if (!e.callback && e.to.length > 1)
      throw new g("observable-bind-to-no-callback", this);
    if (i > 1 && e.callback)
      throw new g("observable-bind-to-extra-callback", this);
    e.to.forEach((s) => {
      if (s.properties.length && s.properties.length !== i)
        throw new g("observable-bind-to-properties-length", this);
      s.properties.length || (s.properties = this._bindProperties);
    }), this._to = e.to, e.callback && (this._bindings.get(t[0]).callback = e.callback), Xy(this._observable, this._to), Jy(this), this._bindProperties.forEach((s) => {
      Zf(this._observable, s);
    });
  }
  function Gy(n, e, t) {
    if (this._bindings.size > 1)
      throw new g("observable-bind-to-many-not-one-binding", this);
    this.to(
      ...jy(n, e),
      // ...using given callback to parse attribute values.
      t
    );
  }
  function jy(n, e) {
    const t = n.map((i) => [i, e]);
    return Array.prototype.concat.apply([], t);
  }
  function Bc(n) {
    return n.every((e) => typeof e == "string");
  }
  function Ky(...n) {
    if (!n.length)
      throw new g("observable-bind-to-parse-error", null);
    const e = { to: [] };
    let t;
    return typeof n[n.length - 1] == "function" && (e.callback = n.pop()), n.forEach((i) => {
      if (typeof i == "string")
        t.properties.push(i);
      else if (typeof i == "object")
        t = { observable: i, properties: [] }, e.to.push(t);
      else
        throw new g("observable-bind-to-parse-error", null);
    }), e;
  }
  function Zy(n, e, t, i) {
    const s = n[Go], o = s.get(t), r = o || {};
    r[i] || (r[i] = /* @__PURE__ */ new Set()), r[i].add(e), o || s.set(t, r);
  }
  function Jy(n) {
    let e;
    n._bindings.forEach((t, i) => {
      n._to.forEach((s) => {
        e = s.properties[t.callback ? 0 : n._bindProperties.indexOf(i)], t.to.push([s.observable, e]), Zy(n._observable, t, s.observable, e);
      });
    });
  }
  function Zf(n, e) {
    const i = n[yo].get(e);
    let s;
    i.callback ? s = i.callback.apply(n, i.to.map((o) => o[0][o[1]])) : (s = i.to[0], s = s[0][s[1]]), Object.prototype.hasOwnProperty.call(n, e) ? n[e] = s : n.set(e, s);
  }
  function Xy(n, e) {
    e.forEach((t) => {
      const i = n[Go];
      let s;
      i.get(t.observable) || n.listenTo(t.observable, "change", (o, r) => {
        s = i.get(t.observable)[r], s && s.forEach((a) => {
          Zf(n, a.property);
        });
      });
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Yy {
    constructor() {
      this._replacedElements = [];
    }
    /**
     * Hides the `element` and, if specified, inserts the the given element next to it.
     *
     * The effect of this method can be reverted by {@link #restore}.
     *
     * @param element The element to replace.
     * @param newElement The replacement element. If not passed, then the `element` will just be hidden.
     */
    replace(e, t) {
      this._replacedElements.push({ element: e, newElement: t }), e.style.display = "none", t && e.parentNode.insertBefore(t, e.nextSibling);
    }
    /**
     * Restores what {@link #replace} did.
     */
    restore() {
      this._replacedElements.forEach(({ element: e, newElement: t }) => {
        e.style.display = "", t && t.remove();
      }), this._replacedElements = [];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function oa(n) {
    let e = 0;
    for (const t of n)
      e++;
    return e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ee(n, e) {
    const t = Math.min(n.length, e.length);
    for (let i = 0; i < t; i++)
      if (n[i] != e[i])
        return i;
    return n.length == e.length ? "same" : n.length < e.length ? "prefix" : "extension";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function We(n) {
    return !!(n && n[Symbol.iterator]);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function tt(n, e, t = {}, i = []) {
    const s = t && t.xmlns, o = s ? n.createElementNS(s, e) : n.createElement(e);
    for (const r in t)
      o.setAttribute(r, t[r]);
    (Vc(i) || !We(i)) && (i = [i]);
    for (let r of i)
      Vc(r) && (r = n.createTextNode(r)), o.appendChild(r);
    return o;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Jf {
    /**
     * Creates an instance of the {@link ~Config} class.
     *
     * @param configurations The initial configurations to be set. Usually, provided by the user.
     * @param defaultConfigurations The default configurations. Usually, provided by the system.
     */
    constructor(e, t) {
      this._config = {}, t && this.define(Oc(t)), e && this._setObjectToTarget(this._config, e);
    }
    set(e, t) {
      this._setToTarget(this._config, e, t);
    }
    define(e, t) {
      this._setToTarget(this._config, e, t, !0);
    }
    /**
     * Gets the value for a configuration entry.
     *
     * ```ts
     * config.get( 'name' );
     * ```
     *
     * Deep configurations can be retrieved by separating each part with a dot.
     *
     * ```ts
     * config.get( 'toolbar.collapsed' );
     * ```
     *
     * @param name The configuration name. Configuration names are case-sensitive.
     * @returns The configuration value or `undefined` if the configuration entry was not found.
     */
    get(e) {
      return this._getFromSource(this._config, e);
    }
    /**
     * Iterates over all top level configuration names.
     */
    *names() {
      for (const e of Object.keys(this._config))
        yield e;
    }
    /**
     * Saves passed configuration to the specified target (nested object).
     *
     * @param target Nested config object.
     * @param name The configuration name or an object from which take properties as
     * configuration entries. Configuration names are case-sensitive.
     * @param value The configuration value. Used if a name is passed.
     * @param isDefine Define if passed configuration should overwrite existing one.
     */
    _setToTarget(e, t, i, s = !1) {
      if (Ne(t)) {
        this._setObjectToTarget(e, t, s);
        return;
      }
      const o = t.split(".");
      t = o.pop();
      for (const r of o)
        Ne(e[r]) || (e[r] = {}), e = e[r];
      if (Ne(i)) {
        Ne(e[t]) || (e[t] = {}), e = e[t], this._setObjectToTarget(e, i, s);
        return;
      }
      s && typeof e[t] != "undefined" || (e[t] = i);
    }
    /**
     * Get specified configuration from specified source (nested object).
     *
     * @param source level of nested object.
     * @param name The configuration name. Configuration names are case-sensitive.
     * @returns The configuration value or `undefined` if the configuration entry was not found.
     */
    _getFromSource(e, t) {
      const i = t.split(".");
      t = i.pop();
      for (const s of i) {
        if (!Ne(e[s])) {
          e = null;
          break;
        }
        e = e[s];
      }
      return e ? Oc(e[t]) : void 0;
    }
    /**
     * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
     *
     * @param target Nested config object.
     * @param configuration Configuration data set
     * @param isDefine Defines if passed configuration is default configuration or not.
     */
    _setObjectToTarget(e, t, i) {
      Object.keys(t).forEach((s) => {
        this._setToTarget(e, s, t[s], i);
      });
    }
  }
  function Oc(n) {
    return al(n, Qy);
  }
  function Qy(n) {
    return fi(n) || typeof n == "function" ? n : void 0;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ht(n) {
    if (n) {
      if (n.defaultView)
        return n instanceof n.defaultView.Document;
      if (n.ownerDocument && n.ownerDocument.defaultView)
        return n instanceof n.ownerDocument.defaultView.Node;
    }
    return !1;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Co(n) {
    const e = Object.prototype.toString.apply(n);
    return e == "[object Window]" || e == "[object global]";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Xf = Me(G());
  function Me(n) {
    if (!n)
      return Xf;
    class e extends n {
      listenTo(i, s, o, r = {}) {
        if (Ht(i) || Co(i)) {
          const a = {
            capture: !!r.useCapture,
            passive: !!r.usePassive
          }, l = this._getProxyEmitter(i, a) || new eC(i, a);
          this.listenTo(l, s, o, r);
        } else
          super.listenTo(i, s, o, r);
      }
      stopListening(i, s, o) {
        if (Ht(i) || Co(i)) {
          const r = this._getAllProxyEmitters(i);
          for (const a of r)
            this.stopListening(a, s, o);
        } else
          super.stopListening(i, s, o);
      }
      /**
       * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.
       *
       * @param node DOM Node of the ProxyEmitter.
       * @param options Additional options.
       * @param options.useCapture Indicates that events of this type will be dispatched to the registered
       * listener before being dispatched to any EventTarget beneath it in the DOM tree.
       * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
       * and prevents blocking browser's main thread by this event handler.
       * @returns ProxyEmitter instance bound to the DOM Node.
       */
      _getProxyEmitter(i, s) {
        return Yw(this, Yf(i, s));
      }
      /**
       * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.
       *
       * @param node DOM Node of the ProxyEmitter.
       */
      _getAllProxyEmitters(i) {
        return [
          { capture: !1, passive: !1 },
          { capture: !1, passive: !0 },
          { capture: !0, passive: !1 },
          { capture: !0, passive: !0 }
        ].map((s) => this._getProxyEmitter(i, s)).filter((s) => !!s);
      }
    }
    return e;
  }
  [
    "_getProxyEmitter",
    "_getAllProxyEmitters",
    "on",
    "once",
    "off",
    "listenTo",
    "stopListening",
    "fire",
    "delegate",
    "stopDelegating",
    "_addEventListener",
    "_removeEventListener"
  ].forEach((n) => {
    Me[n] = Xf.prototype[n];
  });
  class eC extends G() {
    /**
     * @param node DOM Node that fires events.
     * @param options Additional options.
     * @param options.useCapture Indicates that events of this type will be dispatched to the registered
     * listener before being dispatched to any EventTarget beneath it in the DOM tree.
     * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
     * and prevents blocking browser's main thread by this event handler.
     */
    constructor(e, t) {
      super(), rf(this, Yf(e, t)), this._domNode = e, this._options = t;
    }
    /**
     * Registers a callback function to be executed when an event is fired.
     *
     * It attaches a native DOM listener to the DOM Node. When fired,
     * a corresponding Emitter event will also fire with DOM Event object as an argument.
     *
     * **Note**: This is automatically called by the
     * {@link module:utils/emittermixin~Emitter#listenTo `Emitter#listenTo()`}.
     *
     * @param event The name of the event.
     */
    attach(e) {
      if (this._domListeners && this._domListeners[e])
        return;
      const t = this._createDomListener(e);
      this._domNode.addEventListener(e, t, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[e] = t;
    }
    /**
     * Stops executing the callback on the given event.
     *
     * **Note**: This is automatically called by the
     * {@link module:utils/emittermixin~Emitter#stopListening `Emitter#stopListening()`}.
     *
     * @param event The name of the event.
     */
    detach(e) {
      let t;
      this._domListeners[e] && (!(t = this._events[e]) || !t.callbacks.length) && this._domListeners[e].removeListener();
    }
    /**
     * Adds callback to emitter for given event.
     *
     * @internal
     * @param event The name of the event.
     * @param callback The function to be called on event.
     * @param options Additional options.
     */
    _addEventListener(e, t, i) {
      this.attach(e), G().prototype._addEventListener.call(this, e, t, i);
    }
    /**
     * Removes callback from emitter for given event.
     *
     * @internal
     * @param event The name of the event.
     * @param callback The function to stop being called.
     */
    _removeEventListener(e, t) {
      G().prototype._removeEventListener.call(this, e, t), this.detach(e);
    }
    /**
     * Creates a native DOM listener callback. When the native DOM event
     * is fired it will fire corresponding event on this ProxyEmitter.
     * Note: A native DOM Event is passed as an argument.
     *
     * @param event The name of the event.
     * @returns The DOM listener callback.
     */
    _createDomListener(e) {
      const t = (i) => {
        this.fire(e, i);
      };
      return t.removeListener = () => {
        this._domNode.removeEventListener(e, t, this._options), delete this._domListeners[e];
      }, t;
    }
  }
  function tC(n) {
    return n["data-ck-expando"] || (n["data-ck-expando"] = Ze());
  }
  function Yf(n, e) {
    let t = tC(n);
    for (const i of Object.keys(e).sort())
      e[i] && (t += "-" + i);
    return t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let ra;
  try {
    ra = { window, document };
  } catch (n) {
    /* istanbul ignore next -- @preserve */
    ra = { window: {}, document: {} };
  }
  const E = ra;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function iC(n) {
    const e = [];
    let t = n;
    for (; t && t.nodeType != Node.DOCUMENT_NODE; )
      e.unshift(t), t = t.parentNode;
    return e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function nC(n) {
    return n instanceof HTMLTextAreaElement ? n.value : n.innerHTML;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Qf(n) {
    const e = n.ownerDocument.defaultView.getComputedStyle(n);
    return {
      top: parseInt(e.borderTopWidth, 10),
      right: parseInt(e.borderRightWidth, 10),
      bottom: parseInt(e.borderBottomWidth, 10),
      left: parseInt(e.borderLeftWidth, 10)
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function ce(n) {
    return Object.prototype.toString.call(n) == "[object Text]";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function jo(n) {
    return Object.prototype.toString.apply(n) == "[object Range]";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function em(n) {
    return !n || !n.parentNode || n.offsetParent === E.document.body ? null : n.offsetParent;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const tm = ["top", "right", "bottom", "left", "width", "height"];
  class O {
    /**
     * Creates an instance of rect.
     *
     * ```ts
     * // Rect of an HTMLElement.
     * const rectA = new Rect( document.body );
     *
     * // Rect of a DOM Range.
     * const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
     *
     * // Rect of a window (web browser viewport).
     * const rectC = new Rect( window );
     *
     * // Rect out of an object.
     * const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
     *
     * // Rect out of another Rect instance.
     * const rectE = new Rect( rectD );
     *
     * // Rect out of a ClientRect.
     * const rectF = new Rect( document.body.getClientRects().item( 0 ) );
     * ```
     *
     * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
     * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
     * to get the inner part of the rect.
     *
     * @param source A source object to create the rect.
     */
    constructor(e) {
      const t = jo(e);
      if (Object.defineProperty(this, "_source", {
        // If the source is a Rect instance, copy it's #_source.
        value: e._source || e,
        writable: !0,
        enumerable: !1
      }), aa(e) || t)
        if (t) {
          const i = O.getDomRangeRects(e);
          Ss(this, O.getBoundingRect(i));
        } else
          Ss(this, e.getBoundingClientRect());
      else if (Co(e)) {
        const { innerWidth: i, innerHeight: s } = e;
        Ss(this, {
          top: 0,
          right: i,
          bottom: s,
          left: 0,
          width: i,
          height: s
        });
      } else
        Ss(this, e);
    }
    /**
     * Returns a clone of the rect.
     *
     * @returns A cloned rect.
     */
    clone() {
      return new O(this);
    }
    /**
     * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.
     *
     * @param x Desired horizontal location.
     * @param y Desired vertical location.
     * @returns A rect which has been moved.
     */
    moveTo(e, t) {
      return this.top = t, this.right = e + this.width, this.bottom = t + this.height, this.left = e, this;
    }
    /**
     * Moves the rect in–place by a dedicated offset.
     *
     * @param x A horizontal offset.
     * @param y A vertical offset
     * @returns A rect which has been moved.
     */
    moveBy(e, t) {
      return this.top += t, this.right += e, this.left += e, this.bottom += t, this;
    }
    /**
     * Returns a new rect a a result of intersection with another rect.
     */
    getIntersection(e) {
      const t = {
        top: Math.max(this.top, e.top),
        right: Math.min(this.right, e.right),
        bottom: Math.min(this.bottom, e.bottom),
        left: Math.max(this.left, e.left),
        width: 0,
        height: 0
      };
      if (t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0)
        return null;
      {
        const i = new O(t);
        return i._source = this._source, i;
      }
    }
    /**
     * Returns the area of intersection with another rect.
     *
     * @returns Area of intersection.
     */
    getIntersectionArea(e) {
      const t = this.getIntersection(e);
      return t ? t.getArea() : 0;
    }
    /**
     * Returns the area of the rect.
     */
    getArea() {
      return this.width * this.height;
    }
    /**
     * Returns a new rect, a part of the original rect, which is actually visible to the user and is relative to the,`body`,
     * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
     * other than `"visible"`.
     *
     * If there's no such visible rect, which is when the rect is limited by one or many of
     * the ancestors, `null` is returned.
     *
     * **Note**: This method does not consider the boundaries of the viewport (window).
     * To get a rect cropped by all ancestors and the viewport, use an intersection such as:
     *
     * ```ts
     * const visibleInViewportRect = new Rect( window ).getIntersection( new Rect( source ).getVisible() );
     * ```
     *
     * @returns A visible rect instance or `null`, if there's none.
     */
    getVisible() {
      const e = this._source;
      let t = this.clone();
      if (Nc(e))
        return t;
      let i = e, s = e.parentNode || e.commonAncestorContainer, o;
      for (; s && !Nc(s); ) {
        const r = sC(s) === "visible";
        i instanceof HTMLElement && Dc(i) === "absolute" && (o = i);
        const a = Dc(s);
        if (r || o && (a === "relative" && r || a !== "relative")) {
          i = s, s = s.parentNode;
          continue;
        }
        const l = new O(s), c = t.getIntersection(l);
        if (c)
          c.getArea() < t.getArea() && (t = c);
        else
          return null;
        i = s, s = s.parentNode;
      }
      return t;
    }
    /**
     * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
     * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
     * instances.
     *
     * @param anotherRect A rect instance to compare with.
     * @returns `true` when Rects are equal. `false` otherwise.
     */
    isEqual(e) {
      for (const t of tm)
        if (this[t] !== e[t])
          return !1;
      return !0;
    }
    /**
     * Checks whether a rect fully contains another rect instance.
     *
     * @param anotherRect
     * @returns `true` if contains, `false` otherwise.
     */
    contains(e) {
      const t = this.getIntersection(e);
      return !!(t && t.isEqual(e));
    }
    /**
     * Recalculates screen coordinates to coordinates relative to the positioned ancestor offset.
     */
    toAbsoluteRect() {
      const { scrollX: e, scrollY: t } = E.window, i = this.clone().moveBy(e, t);
      if (aa(i._source)) {
        const s = em(i._source);
        s && oC(i, s);
      }
      return i;
    }
    /**
     * Excludes scrollbars and CSS borders from the rect.
     *
     * * Borders are removed when {@link #_source} is an HTML element.
     * * Scrollbars are excluded from HTML elements and the `window`.
     *
     * @returns A rect which has been updated.
     */
    excludeScrollbarsAndBorders() {
      const e = this._source;
      let t, i, s;
      if (Co(e))
        t = e.innerWidth - e.document.documentElement.clientWidth, i = e.innerHeight - e.document.documentElement.clientHeight, s = e.getComputedStyle(e.document.documentElement).direction;
      else {
        const o = Qf(e);
        t = e.offsetWidth - e.clientWidth - o.left - o.right, i = e.offsetHeight - e.clientHeight - o.top - o.bottom, s = e.ownerDocument.defaultView.getComputedStyle(e).direction, this.left += o.left, this.top += o.top, this.right -= o.right, this.bottom -= o.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
      }
      return this.width -= t, s === "ltr" ? this.right -= t : this.left += t, this.height -= i, this.bottom -= i, this;
    }
    /**
     * Returns an array of rects of the given native DOM Range.
     *
     * @param range A native DOM range.
     * @returns DOM Range rects.
     */
    static getDomRangeRects(e) {
      const t = [], i = Array.from(e.getClientRects());
      if (i.length)
        for (const s of i)
          t.push(new O(s));
      else {
        let s = e.startContainer;
        ce(s) && (s = s.parentNode);
        const o = new O(s.getBoundingClientRect());
        o.right = o.left, o.width = 0, t.push(o);
      }
      return t;
    }
    /**
     * Returns a bounding rectangle that contains all the given `rects`.
     *
     * @param rects A list of rectangles that should be contained in the result rectangle.
     * @returns Bounding rectangle or `null` if no `rects` were given.
     */
    static getBoundingRect(e) {
      const t = {
        left: Number.POSITIVE_INFINITY,
        top: Number.POSITIVE_INFINITY,
        right: Number.NEGATIVE_INFINITY,
        bottom: Number.NEGATIVE_INFINITY,
        width: 0,
        height: 0
      };
      let i = 0;
      for (const s of e)
        i++, t.left = Math.min(t.left, s.left), t.top = Math.min(t.top, s.top), t.right = Math.max(t.right, s.right), t.bottom = Math.max(t.bottom, s.bottom);
      return i == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new O(t));
    }
  }
  function Ss(n, e) {
    for (const t of tm)
      n[t] = e[t];
  }
  function Nc(n) {
    return aa(n) ? n === n.ownerDocument.body : !1;
  }
  function aa(n) {
    return n !== null && typeof n == "object" && n.nodeType === 1 && typeof n.getBoundingClientRect == "function";
  }
  function Dc(n) {
    return n instanceof HTMLElement ? n.ownerDocument.defaultView.getComputedStyle(n).position : "static";
  }
  function sC(n) {
    return n instanceof HTMLElement ? n.ownerDocument.defaultView.getComputedStyle(n).overflow : "visible";
  }
  function oC(n, e) {
    const t = new O(e), i = Qf(e);
    let s = 0, o = 0;
    s -= t.left, o -= t.top, s += e.scrollLeft, o += e.scrollTop, s -= i.left, o -= i.top, n.moveBy(s, o);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Y {
    /**
     * Creates an instance of the `ResizeObserver` class.
     *
     * @param element A DOM element that is to be observed for resizing. Note that
     * the element must be visible (i.e. not detached from DOM) for the observer to work.
     * @param callback A function called when the observed element was resized. It passes
     * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
     * object with information about the resize event.
     */
    constructor(e, t) {
      Y._observerInstance || Y._createObserver(), this._element = e, this._callback = t, Y._addElementCallback(e, t), Y._observerInstance.observe(e);
    }
    /**
     * The element observed by this observer.
     */
    get element() {
      return this._element;
    }
    /**
     * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
     */
    destroy() {
      Y._deleteElementCallback(this._element, this._callback);
    }
    /**
     * Registers a new resize callback for the DOM element.
     */
    static _addElementCallback(e, t) {
      Y._elementCallbacks || (Y._elementCallbacks = /* @__PURE__ */ new Map());
      let i = Y._elementCallbacks.get(e);
      i || (i = /* @__PURE__ */ new Set(), Y._elementCallbacks.set(e, i)), i.add(t);
    }
    /**
     * Removes a resize callback from the DOM element. If no callbacks are left
     * for the element, it removes the element from the native observer.
     */
    static _deleteElementCallback(e, t) {
      const i = Y._getElementCallbacks(e);
      i && (i.delete(t), i.size || (Y._elementCallbacks.delete(e), Y._observerInstance.unobserve(e))), Y._elementCallbacks && !Y._elementCallbacks.size && (Y._observerInstance = null, Y._elementCallbacks = null);
    }
    /**
     * Returns are registered resize callbacks for the DOM element.
     */
    static _getElementCallbacks(e) {
      return Y._elementCallbacks ? Y._elementCallbacks.get(e) : null;
    }
    /**
     * Creates the single native observer shared across all `ResizeObserver` instances.
     */
    static _createObserver() {
      Y._observerInstance = new E.window.ResizeObserver((e) => {
        for (const t of e) {
          const i = Y._getElementCallbacks(t.target);
          if (i)
            for (const s of i)
              s(t);
        }
      });
    }
  }
  Y._observerInstance = null;
  Y._elementCallbacks = null;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Fc(n, e) {
    n instanceof HTMLTextAreaElement && (n.value = e), n.innerHTML = e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function dn(n) {
    return (e) => e + n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Is(n) {
    let e = 0;
    for (; n.previousSibling; )
      n = n.previousSibling, e++;
    return e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function im(n, e, t) {
    n.insertBefore(t, n.childNodes[e] || null);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Bn(n) {
    return n && n.nodeType === Node.COMMENT_NODE;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function rC(n) {
    try {
      E.document.createAttribute(n);
    } catch (e) {
      return !1;
    }
    return !0;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function mi(n) {
    return !!(n && n.getClientRects && n.getClientRects().length);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ko({ element: n, target: e, positions: t, limiter: i, fitInViewport: s, viewportOffsetConfig: o }) {
    di(e) && (e = e()), di(i) && (i = i());
    const r = em(n), a = aC(o), l = new O(n), c = zc(e, a);
    let u;
    if (!c || !a.getIntersection(c))
      return null;
    const d = {
      targetRect: c,
      elementRect: l,
      positionedElementAncestor: r,
      viewportRect: a
    };
    if (!i && !s)
      u = new nm(t[0], d);
    else {
      if (i) {
        const h = zc(i, a);
        h && (d.limiterRect = h);
      }
      u = lC(t, d);
    }
    return u;
  }
  function zc(n, e) {
    const t = new O(n).getVisible();
    return t ? t.getIntersection(e) : null;
  }
  function aC(n) {
    n = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, n);
    const e = new O(E.window);
    return e.top += n.top, e.height -= n.top, e.bottom -= n.bottom, e.height -= n.bottom, e;
  }
  function lC(n, e) {
    const { elementRect: t } = e, i = t.getArea(), s = n.map((a) => new nm(a, e)).filter((a) => !!a.name);
    let o = 0, r = null;
    for (const a of s) {
      const { limiterIntersectionArea: l, viewportIntersectionArea: c } = a;
      if (l === i)
        return a;
      const u = c ** 2 + l ** 2;
      u > o && (o = u, r = a);
    }
    return r;
  }
  class nm {
    /**
     * Creates an instance of the {@link module:utils/dom/position~PositionObject} class.
     *
     * @param positioningFunction function The function that defines the expected
     * coordinates the positioned element should move to.
     * @param options options object.
     * @param options.elementRect The positioned element rect.
     * @param options.targetRect The target element rect.
     * @param options.viewportRect The viewport rect.
     * @param options.limiterRect The limiter rect.
     * @param options.positionedElementAncestor Nearest element ancestor element which CSS position is not "static".
     */
    constructor(e, t) {
      const i = e(t.targetRect, t.elementRect, t.viewportRect, t.limiterRect);
      if (!i)
        return;
      const { left: s, top: o, name: r, config: a } = i;
      this.name = r, this.config = a, this._positioningFunctionCoordinates = { left: s, top: o }, this._options = t;
    }
    /**
     * The left value in pixels in the CSS `position: absolute` coordinate system.
     * Set it on the positioned element in DOM to move it to the position.
     */
    get left() {
      return this._absoluteRect.left;
    }
    /**
     * The top value in pixels in the CSS `position: absolute` coordinate system.
     * Set it on the positioned element in DOM to move it to the position.
     */
    get top() {
      return this._absoluteRect.top;
    }
    /**
     * An intersection area between positioned element and limiter within viewport constraints.
     */
    get limiterIntersectionArea() {
      const e = this._options.limiterRect;
      return e ? e.getIntersectionArea(this._rect) : 0;
    }
    /**
     * An intersection area between positioned element and viewport.
     */
    get viewportIntersectionArea() {
      return this._options.viewportRect.getIntersectionArea(this._rect);
    }
    /**
     * An already positioned element rect. A clone of the element rect passed to the constructor
     * but placed in the viewport according to the positioning function.
     */
    get _rect() {
      return this._cachedRect ? this._cachedRect : (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top), this._cachedRect);
    }
    /**
     * An already absolutely positioned element rect. See ({@link #_rect}).
     */
    get _absoluteRect() {
      return this._cachedAbsoluteRect ? this._cachedAbsoluteRect : (this._cachedAbsoluteRect = this._rect.toAbsoluteRect(), this._cachedAbsoluteRect);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Uc(n) {
    const e = n.parentNode;
    e && e.removeChild(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function cC({ target: n, viewportOffset: e = 0, ancestorOffset: t = 0, alignToTop: i, forceScroll: s }) {
    const o = cl(n);
    let r = o, a = null;
    for (e = hC(e); r; ) {
      let l;
      r == o ? l = Hc(n) : l = Hc(a), dC({
        parent: l,
        getRect: () => $c(n, r),
        alignToTop: i,
        ancestorOffset: t,
        forceScroll: s
      });
      const c = $c(n, r);
      if (uC({
        window: r,
        rect: c,
        viewportOffset: e,
        alignToTop: i,
        forceScroll: s
      }), r.parent != r) {
        if (a = r.frameElement, r = r.parent, !a)
          return;
      } else
        r = null;
    }
  }
  function uC({ window: n, rect: e, alignToTop: t, forceScroll: i, viewportOffset: s }) {
    const o = e.clone().moveBy(0, s.bottom), r = e.clone().moveBy(0, -s.top), a = new O(n).excludeScrollbarsAndBorders(), l = [r, o], c = t && i, u = l.every((p) => a.contains(p));
    let { scrollX: d, scrollY: h } = n;
    const f = d, m = h;
    c ? h -= a.top - e.top + s.top : u || (om(r, a) ? h -= a.top - e.top + s.top : sm(o, a) && (t ? h += e.top - a.top - s.top : h += e.bottom - a.bottom + s.bottom)), u || (rm(e, a) ? d -= a.left - e.left + s.left : am(e, a) && (d += e.right - a.right + s.right)), (d != f || h !== m) && n.scrollTo(d, h);
  }
  function dC({ parent: n, getRect: e, alignToTop: t, forceScroll: i, ancestorOffset: s = 0, limiterElement: o }) {
    const r = cl(n), a = t && i;
    let l, c, u;
    const d = o || r.document.body;
    for (; n != d; )
      c = e(), l = new O(n).excludeScrollbarsAndBorders(), u = l.contains(c), a ? n.scrollTop -= l.top - c.top + s : u || (om(c, l) ? n.scrollTop -= l.top - c.top + s : sm(c, l) && (t ? n.scrollTop += c.top - l.top - s : n.scrollTop += c.bottom - l.bottom + s)), u || (rm(c, l) ? n.scrollLeft -= l.left - c.left + s : am(c, l) && (n.scrollLeft += c.right - l.right + s)), n = n.parentNode;
  }
  function sm(n, e) {
    return n.bottom > e.bottom;
  }
  function om(n, e) {
    return n.top < e.top;
  }
  function rm(n, e) {
    return n.left < e.left;
  }
  function am(n, e) {
    return n.right > e.right;
  }
  function cl(n) {
    return jo(n) ? n.startContainer.ownerDocument.defaultView : n.ownerDocument.defaultView;
  }
  function Hc(n) {
    if (jo(n)) {
      let e = n.commonAncestorContainer;
      return ce(e) && (e = e.parentNode), e;
    } else
      return n.parentNode;
  }
  function $c(n, e) {
    const t = cl(n), i = new O(n);
    if (t === e)
      return i;
    {
      let s = t;
      for (; s != e; ) {
        const o = s.frameElement, r = new O(o).excludeScrollbarsAndBorders();
        i.moveBy(r.left, r.top), s = s.parent;
      }
    }
    return i;
  }
  function hC(n) {
    return typeof n == "number" ? {
      top: n,
      bottom: n,
      left: n,
      right: n
    } : n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const fC = {
    ctrl: "⌃",
    cmd: "⌘",
    alt: "⌥",
    shift: "⇧"
  }, mC = {
    ctrl: "Ctrl+",
    alt: "Alt+",
    shift: "Shift+"
  }, Wc = {
    37: "←",
    38: "↑",
    39: "→",
    40: "↓",
    9: "⇥",
    33: "Page Up",
    34: "Page Down"
  }, F = _C(), gC = Object.fromEntries(Object.entries(F).map(([n, e]) => {
    let t;
    return e in Wc ? t = Wc[e] : t = n.charAt(0).toUpperCase() + n.slice(1), [e, t];
  }));
  function Ji(n) {
    let e;
    if (typeof n == "string") {
      if (e = F[n.toLowerCase()], !e)
        throw new g("keyboard-unknown-key", null, { key: n });
    } else
      e = n.keyCode + (n.altKey ? F.alt : 0) + (n.ctrlKey ? F.ctrl : 0) + (n.shiftKey ? F.shift : 0) + (n.metaKey ? F.cmd : 0);
    return e;
  }
  function gs(n) {
    return typeof n == "string" && (n = vC(n)), n.map((e) => typeof e == "string" ? wC(e) : e).reduce((e, t) => t + e, 0);
  }
  function ko(n) {
    let e = gs(n);
    return Object.entries(B.isMac || B.isiOS ? fC : mC).reduce((s, [o, r]) => (e & F[o] && (e &= ~F[o], s += r), s), "") + (e ? gC[e] : "");
  }
  function pC(n) {
    return n == F.arrowright || n == F.arrowleft || n == F.arrowup || n == F.arrowdown;
  }
  function ul(n, e) {
    const t = e === "ltr";
    switch (n) {
      case F.arrowleft:
        return t ? "left" : "right";
      case F.arrowright:
        return t ? "right" : "left";
      case F.arrowup:
        return "up";
      case F.arrowdown:
        return "down";
    }
  }
  function wC(n) {
    if (n.endsWith("!"))
      return Ji(n.slice(0, -1));
    const e = Ji(n);
    return (B.isMac || B.isiOS) && e == F.ctrl ? F.cmd : e;
  }
  function bC(n, e) {
    const t = ul(n, e);
    return t === "down" || t === "right";
  }
  function _C() {
    const n = {
      pageup: 33,
      pagedown: 34,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      backspace: 8,
      delete: 46,
      enter: 13,
      space: 32,
      esc: 27,
      tab: 9,
      // The idea about these numbers is that they do not collide with any real key codes, so we can use them
      // like bit masks.
      ctrl: 1114112,
      shift: 2228224,
      alt: 4456448,
      cmd: 8912896
    };
    for (let e = 65; e <= 90; e++) {
      const t = String.fromCharCode(e);
      n[t.toLowerCase()] = e;
    }
    for (let e = 48; e <= 57; e++)
      n[e - 48] = e;
    for (let e = 112; e <= 123; e++)
      n["f" + (e - 111)] = e;
    return Object.assign(n, {
      "'": 222,
      ",": 108,
      "-": 109,
      ".": 110,
      "/": 111,
      ";": 186,
      "=": 187,
      "[": 219,
      "\\": 220,
      "]": 221,
      "`": 223
    }), n;
  }
  function vC(n) {
    return n.split("+").map((e) => e.trim());
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const yC = [
    "ar",
    "ara",
    "dv",
    "div",
    "fa",
    "per",
    "fas",
    "he",
    "heb",
    "ku",
    "kur",
    "ug",
    "uig"
    // Uighur, Uyghur
  ];
  function qc(n) {
    return yC.includes(n) ? "rtl" : "ltr";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Z(n) {
    return Array.isArray(n) ? n : [n];
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  /* istanbul ignore else -- @preserve */
  E.window.CKEDITOR_TRANSLATIONS || (E.window.CKEDITOR_TRANSLATIONS = {});
  function CC(n, e, t = 1, i) {
    if (typeof t != "number")
      throw new g("translation-service-quantity-not-a-number", null, { quantity: t });
    const s = i || E.window.CKEDITOR_TRANSLATIONS, o = EC(s);
    o === 1 && (n = Object.keys(s)[0]);
    const r = e.id || e.string;
    if (o === 0 || !TC(n, r, s))
      return t !== 1 ? e.plural : e.string;
    const a = s[n].dictionary, l = s[n].getPluralForm || ((d) => d === 1 ? 0 : 1), c = a[r];
    if (typeof c == "string")
      return c;
    const u = Number(l(t));
    return c[u];
  }
  function kC(n) {
    return Array.isArray(n) ? n.reduce((e, t) => ll(e, t)) : n;
  }
  function TC(n, e, t) {
    return !!t[n] && !!t[n].dictionary[e];
  }
  function EC(n) {
    return Object.keys(n).length;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class AC {
    /**
     * Creates a new instance of the locale class. Learn more about
     * {@glink features/ui-language configuring the language of the editor}.
     *
     * @param options Locale configuration.
     * @param options.uiLanguage The editor UI language code in the
     * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. See {@link #uiLanguage}.
     * @param options.contentLanguage The editor content language code in the
     * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. If not specified, the same as `options.language`.
     * See {@link #contentLanguage}.
     * @param translations Translations passed as a editor config parameter.
     */
    constructor({ uiLanguage: e = "en", contentLanguage: t, translations: i } = {}) {
      this.uiLanguage = e, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = qc(this.uiLanguage), this.contentLanguageDirection = qc(this.contentLanguage), this.translations = kC(i), this.t = (s, o) => this._t(s, o);
    }
    /**
     * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
     *
     * **Note**: This property was deprecated. Please use {@link #uiLanguage} and {@link #contentLanguage}
     * properties instead.
     *
     * @deprecated
     */
    get language() {
      return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
    }
    /**
     * An unbound version of the {@link #t} method.
     */
    _t(e, t = []) {
      t = Z(t), typeof e == "string" && (e = { string: e });
      const s = !!e.plural ? t[0] : 1, o = CC(this.uiLanguage, e, s, this.translations);
      return xC(o, t);
    }
  }
  function xC(n, e) {
    return n.replace(/%(\d+)/g, (t, i) => i < e.length ? e[i] : t);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ce extends G() {
    constructor(e = {}, t = {}) {
      super();
      const i = We(e);
      if (i || (t = e), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = t.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], i)
        for (const s of e)
          this._items.push(s), this._itemMap.set(this._getItemIdBeforeAdding(s), s);
    }
    /**
     * The number of items available in the collection.
     */
    get length() {
      return this._items.length;
    }
    /**
     * Returns the first item from the collection or null when collection is empty.
     */
    get first() {
      return this._items[0] || null;
    }
    /**
     * Returns the last item from the collection or null when collection is empty.
     */
    get last() {
      return this._items[this.length - 1] || null;
    }
    /**
     * Adds an item into the collection.
     *
     * If the item does not have an id, then it will be automatically generated and set on the item.
     *
     * @param item
     * @param index The position of the item in the collection. The item
     * is pushed to the collection when `index` not specified.
     * @fires add
     * @fires change
     */
    add(e, t) {
      return this.addMany([e], t);
    }
    /**
     * Adds multiple items into the collection.
     *
     * Any item not containing an id will get an automatically generated one.
     *
     * @param items
     * @param index The position of the insertion. Items will be appended if no `index` is specified.
     * @fires add
     * @fires change
     */
    addMany(e, t) {
      if (t === void 0)
        t = this._items.length;
      else if (t > this._items.length || t < 0)
        throw new g("collection-add-item-invalid-index", this);
      let i = 0;
      for (const s of e) {
        const o = this._getItemIdBeforeAdding(s), r = t + i;
        this._items.splice(r, 0, s), this._itemMap.set(o, s), this.fire("add", s, r), i++;
      }
      return this.fire("change", {
        added: e,
        removed: [],
        index: t
      }), this;
    }
    /**
     * Gets an item by its ID or index.
     *
     * @param idOrIndex The item ID or index in the collection.
     * @returns The requested item or `null` if such item does not exist.
     */
    get(e) {
      let t;
      if (typeof e == "string")
        t = this._itemMap.get(e);
      else if (typeof e == "number")
        t = this._items[e];
      else
        throw new g("collection-get-invalid-arg", this);
      return t || null;
    }
    /**
     * Returns a Boolean indicating whether the collection contains an item.
     *
     * @param itemOrId The item or its ID in the collection.
     * @returns `true` if the collection contains the item, `false` otherwise.
     */
    has(e) {
      if (typeof e == "string")
        return this._itemMap.has(e);
      {
        const t = this._idProperty, i = e[t];
        return i && this._itemMap.has(i);
      }
    }
    /**
     * Gets an index of an item in the collection.
     * When an item is not defined in the collection, the index will equal -1.
     *
     * @param itemOrId The item or its ID in the collection.
     * @returns The index of a given item.
     */
    getIndex(e) {
      let t;
      return typeof e == "string" ? t = this._itemMap.get(e) : t = e, t ? this._items.indexOf(t) : -1;
    }
    /**
     * Removes an item from the collection.
     *
     * @param subject The item to remove, its ID or index in the collection.
     * @returns The removed item.
     * @fires remove
     * @fires change
     */
    remove(e) {
      const [t, i] = this._remove(e);
      return this.fire("change", {
        added: [],
        removed: [t],
        index: i
      }), t;
    }
    /**
     * Executes the callback for each item in the collection and composes an array or values returned by this callback.
     *
     * @typeParam U The result type of the callback.
     * @param callback
     * @param ctx Context in which the `callback` will be called.
     * @returns The result of mapping.
     */
    map(e, t) {
      return this._items.map(e, t);
    }
    /**
     * Performs the specified action for each item in the collection.
     *
     * @param ctx Context in which the `callback` will be called.
     */
    forEach(e, t) {
      this._items.forEach(e, t);
    }
    /**
     * Finds the first item in the collection for which the `callback` returns a true value.
     *
     * @param callback
     * @param ctx Context in which the `callback` will be called.
     * @returns The item for which `callback` returned a true value.
     */
    find(e, t) {
      return this._items.find(e, t);
    }
    /**
     * Returns an array with items for which the `callback` returned a true value.
     *
     * @param callback
     * @param ctx Context in which the `callback` will be called.
     * @returns The array with matching items.
     */
    filter(e, t) {
      return this._items.filter(e, t);
    }
    /**
     * Removes all items from the collection and destroys the binding created using
     * {@link #bindTo}.
     *
     * @fires remove
     * @fires change
     */
    clear() {
      this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
      const e = Array.from(this._items);
      for (; this.length; )
        this._remove(0);
      this.fire("change", {
        added: [],
        removed: e,
        index: 0
      });
    }
    /**
     * Binds and synchronizes the collection with another one.
     *
     * The binding can be a simple factory:
     *
     * ```ts
     * class FactoryClass {
     * 	public label: string;
     *
     * 	constructor( data: { label: string } ) {
     * 		this.label = data.label;
     * 	}
     * }
     *
     * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
     * const target = new Collection<FactoryClass>();
     *
     * target.bindTo( source ).as( FactoryClass );
     *
     * source.add( { label: 'foo' } );
     * source.add( { label: 'bar' } );
     *
     * console.log( target.length ); // 2
     * console.log( target.get( 1 ).label ); // 'bar'
     *
     * source.remove( 0 );
     * console.log( target.length ); // 1
     * console.log( target.get( 0 ).label ); // 'bar'
     * ```
     *
     * or the factory driven by a custom callback:
     *
     * ```ts
     * class FooClass {
     * 	public label: string;
     *
     * 	constructor( data: { label: string } ) {
     * 		this.label = data.label;
     * 	}
     * }
     *
     * class BarClass {
     * 	public label: string;
     *
     * 	constructor( data: { label: string } ) {
     * 		this.label = data.label;
     * 	}
     * }
     *
     * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
     * const target = new Collection<FooClass | BarClass>();
     *
     * target.bindTo( source ).using( ( item ) => {
     * 	if ( item.label == 'foo' ) {
     * 		return new FooClass( item );
     * 	} else {
     * 		return new BarClass( item );
     * 	}
     * } );
     *
     * source.add( { label: 'foo' } );
     * source.add( { label: 'bar' } );
     *
     * console.log( target.length ); // 2
     * console.log( target.get( 0 ) instanceof FooClass ); // true
     * console.log( target.get( 1 ) instanceof BarClass ); // true
     * ```
     *
     * or the factory out of property name:
     *
     * ```ts
     * const source = new Collection<{ nested: { value: string } }>();
     * const target = new Collection<{ value: string }>();
     *
     * target.bindTo( source ).using( 'nested' );
     *
     * source.add( { nested: { value: 'foo' } } );
     * source.add( { nested: { value: 'bar' } } );
     *
     * console.log( target.length ); // 2
     * console.log( target.get( 0 ).value ); // 'foo'
     * console.log( target.get( 1 ).value ); // 'bar'
     * ```
     *
     * It's possible to skip specified items by returning null value:
     *
     * ```ts
     * const source = new Collection<{ hidden: boolean }>();
     * const target = new Collection<{ hidden: boolean }>();
     *
     * target.bindTo( source ).using( item => {
     * 	if ( item.hidden ) {
     * 		return null;
     * 	}
     *
     * 	return item;
     * } );
     *
     * source.add( { hidden: true } );
     * source.add( { hidden: false } );
     *
     * console.log( source.length ); // 2
     * console.log( target.length ); // 1
     * ```
     *
     * **Note**: {@link #clear} can be used to break the binding.
     *
     * @typeParam S The type of `externalCollection` element.
     * @param externalCollection A collection to be bound.
     * @returns The binding chain object.
     */
    bindTo(e) {
      if (this._bindToCollection)
        throw new g("collection-bind-to-rebind", this);
      return this._bindToCollection = e, {
        as: (t) => {
          this._setUpBindToBinding((i) => new t(i));
        },
        using: (t) => {
          typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding((i) => i[t]);
        }
      };
    }
    /**
     * Finalizes and activates a binding initiated by {@link #bindTo}.
     *
     * @param factory A function which produces collection items.
     */
    _setUpBindToBinding(e) {
      const t = this._bindToCollection, i = (s, o, r) => {
        const a = t._bindToCollection == this, l = t._bindToInternalToExternalMap.get(o);
        if (a && l)
          this._bindToExternalToInternalMap.set(o, l), this._bindToInternalToExternalMap.set(l, o);
        else {
          const c = e(o);
          if (!c) {
            this._skippedIndexesFromExternal.push(r);
            return;
          }
          let u = r;
          for (const d of this._skippedIndexesFromExternal)
            r > d && u--;
          for (const d of t._skippedIndexesFromExternal)
            u >= d && u++;
          this._bindToExternalToInternalMap.set(o, c), this._bindToInternalToExternalMap.set(c, o), this.add(c, u);
          for (let d = 0; d < t._skippedIndexesFromExternal.length; d++)
            u <= t._skippedIndexesFromExternal[d] && t._skippedIndexesFromExternal[d]++;
        }
      };
      for (const s of t)
        i(null, s, t.getIndex(s));
      this.listenTo(t, "add", i), this.listenTo(t, "remove", (s, o, r) => {
        const a = this._bindToExternalToInternalMap.get(o);
        a && this.remove(a), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((l, c) => (r < c && l.push(c - 1), r > c && l.push(c), l), []);
      });
    }
    /**
     * Returns an unique id property for a given `item`.
     *
     * The method will generate new id and assign it to the `item` if it doesn't have any.
     *
     * @param item Item to be added.
     */
    _getItemIdBeforeAdding(e) {
      const t = this._idProperty;
      let i;
      if (t in e) {
        if (i = e[t], typeof i != "string")
          throw new g("collection-add-invalid-id", this);
        if (this.get(i))
          throw new g("collection-add-item-already-exists", this);
      } else
        e[t] = i = Ze();
      return i;
    }
    /**
     * Core {@link #remove} method implementation shared in other functions.
     *
     * In contrast this method **does not** fire the {@link #event:change} event.
     *
     * @param subject The item to remove, its id or index in the collection.
     * @returns Returns an array with the removed item and its index.
     * @fires remove
     */
    _remove(e) {
      let t, i, s, o = !1;
      const r = this._idProperty;
      if (typeof e == "string" ? (i = e, s = this._itemMap.get(i), o = !s, s && (t = this._items.indexOf(s))) : typeof e == "number" ? (t = e, s = this._items[t], o = !s, s && (i = s[r])) : (s = e, i = s[r], t = this._items.indexOf(s), o = t == -1 || !this._itemMap.get(i)), o)
        throw new g("collection-remove-404", this);
      this._items.splice(t, 1), this._itemMap.delete(i);
      const a = this._bindToInternalToExternalMap.get(s);
      return this._bindToInternalToExternalMap.delete(s), this._bindToExternalToInternalMap.delete(a), this.fire("remove", s, t), [s, t];
    }
    /**
     * Iterable interface.
     */
    [Symbol.iterator]() {
      return this._items[Symbol.iterator]();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function me(n) {
    const e = n.next();
    return e.done ? null : e.value;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Q extends Me($()) {
    constructor() {
      super(), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null);
    }
    /**
     * Starts tracking the specified element.
     */
    add(e) {
      if (this._elements.has(e))
        throw new g("focustracker-add-element-already-exist", this);
      this.listenTo(e, "focus", () => this._focus(e), { useCapture: !0 }), this.listenTo(e, "blur", () => this._blur(), { useCapture: !0 }), this._elements.add(e);
    }
    /**
     * Stops tracking the specified element and stops listening on this element.
     */
    remove(e) {
      e === this.focusedElement && this._blur(), this._elements.has(e) && (this.stopListening(e), this._elements.delete(e));
    }
    /**
     * Destroys the focus tracker by:
     * - Disabling all event listeners attached to tracked elements.
     * - Removing all tracked elements that were previously added.
     */
    destroy() {
      this.stopListening();
    }
    /**
     * Stores currently focused element and set {@link #isFocused} as `true`.
     */
    _focus(e) {
      clearTimeout(this._nextEventLoopTimeout), this.focusedElement = e, this.isFocused = !0;
    }
    /**
     * Clears currently focused element and set {@link #isFocused} as `false`.
     * This method uses `setTimeout` to change order of fires `blur` and `focus` events.
     */
    _blur() {
      clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
        this.focusedElement = null, this.isFocused = !1;
      }, 0);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ne {
    /**
     * Creates an instance of the keystroke handler.
     */
    constructor() {
      this._listener = new (Me())();
    }
    /**
     * Starts listening for `keydown` events from a given emitter.
     */
    listenTo(e) {
      this._listener.listenTo(e, "keydown", (t, i) => {
        this._listener.fire("_keydown:" + Ji(i), i);
      });
    }
    /**
     * Registers a handler for the specified keystroke.
     *
     * @param keystroke Keystroke defined in a format accepted by
     * the {@link module:utils/keyboard~parseKeystroke} function.
     * @param callback A function called with the
     * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
     * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.
     * @param options Additional options.
     * @param options.priority The priority of the keystroke
     * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority
     * are called in the order they were added.
     */
    set(e, t, i = {}) {
      const s = gs(e), o = i.priority;
      this._listener.listenTo(this._listener, "_keydown:" + s, (r, a) => {
        t(a, () => {
          a.preventDefault(), a.stopPropagation(), r.stop();
        }), r.return = !0;
      }, { priority: o });
    }
    /**
     * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
     *
     * @param keyEvtData Key event data.
     * @returns Whether the keystroke was handled.
     */
    press(e) {
      return !!this._listener.fire("_keydown:" + Ji(e), e);
    }
    /**
     * Stops listening to `keydown` events from the given emitter.
     */
    stopListening(e) {
      this._listener.stopListening(e);
    }
    /**
     * Destroys the keystroke handler.
     */
    destroy() {
      this.stopListening();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function SC(n) {
    const e = /* @__PURE__ */ new Map();
    for (const t in n)
      e.set(t, n[t]);
    return e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function wt(n) {
    return We(n) ? new Map(n) : SC(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const IC = 1e4;
  function PC(n, e, t, i) {
    if (Math.max(e.length, n.length) > IC)
      return n.slice(0, t).concat(e).concat(n.slice(t + i, n.length));
    {
      const s = Array.from(n);
      return s.splice(t, i, ...e), s;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function dl(n, e) {
    let t;
    function i(...s) {
      i.cancel(), t = setTimeout(() => n(...s), e);
    }
    return i.cancel = () => {
      clearTimeout(t);
    }, i;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function RC(n) {
    function e(d) {
      return d.length >= 40 && d.length <= 255 ? "VALID" : "INVALID";
    }
    if (!n)
      return "INVALID";
    let t = "";
    try {
      t = atob(n);
    } catch (d) {
      return "INVALID";
    }
    const i = t.split("-"), s = i[0], o = i[1];
    if (!o)
      return e(n);
    try {
      atob(o);
    } catch (d) {
      try {
        if (atob(s), !atob(s).length)
          return e(n);
      } catch (h) {
        return e(n);
      }
    }
    if (s.length < 40 || s.length > 255)
      return "INVALID";
    let r = "";
    try {
      atob(s), r = atob(o);
    } catch (d) {
      return "INVALID";
    }
    if (r.length !== 8)
      return "INVALID";
    const a = Number(r.substring(0, 4)), l = Number(r.substring(4, 6)) - 1, c = Number(r.substring(6, 8)), u = new Date(a, l, c);
    return u < Xw || isNaN(Number(u)) ? "INVALID" : "VALID";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function LC(n) {
    return !!n && n.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n);
  }
  function VC(n) {
    return !!n && n.length == 1 && /[\ud800-\udbff]/.test(n);
  }
  function MC(n) {
    return !!n && n.length == 1 && /[\udc00-\udfff]/.test(n);
  }
  function hl(n, e) {
    return VC(n.charAt(e - 1)) && MC(n.charAt(e));
  }
  function fl(n, e) {
    return LC(n.charAt(e));
  }
  const BC = OC();
  function lm(n, e) {
    const t = String(n).matchAll(BC);
    return Array.from(t).some((i) => i.index < e && e < i.index + i[0].length);
  }
  function OC() {
    const n = [
      // Emoji Tag Sequence (ETS)
      /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
      // Emoji Keycap Sequence
      /\p{Emoji}\u{FE0F}?\u{20E3}/u,
      // Emoji Presentation Sequence
      /\p{Emoji}\u{FE0F}/u,
      // Single-Character Emoji / Emoji Modifier Sequence
      /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u
    ], e = /\p{Regional_Indicator}{2}/u.source, t = "(?:" + n.map((s) => s.source).join("|") + ")", i = `${e}|${t}(?:‍${t})*`;
    return new RegExp(i, "ug");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class w extends $() {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(), this._disableStack = /* @__PURE__ */ new Set(), this.editor = e, this.set("isEnabled", !0);
    }
    /**
     * Disables the plugin.
     *
     * Plugin may be disabled by multiple features or algorithms (at once). When disabling a plugin, unique id should be passed
     * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the plugin.
     * The plugin becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
     *
     * Disabling and enabling a plugin:
     *
     * ```ts
     * plugin.isEnabled; // -> true
     * plugin.forceDisabled( 'MyFeature' );
     * plugin.isEnabled; // -> false
     * plugin.clearForceDisabled( 'MyFeature' );
     * plugin.isEnabled; // -> true
     * ```
     *
     * Plugin disabled by multiple features:
     *
     * ```ts
     * plugin.forceDisabled( 'MyFeature' );
     * plugin.forceDisabled( 'OtherFeature' );
     * plugin.clearForceDisabled( 'MyFeature' );
     * plugin.isEnabled; // -> false
     * plugin.clearForceDisabled( 'OtherFeature' );
     * plugin.isEnabled; // -> true
     * ```
     *
     * Multiple disabling with the same identifier is redundant:
     *
     * ```ts
     * plugin.forceDisabled( 'MyFeature' );
     * plugin.forceDisabled( 'MyFeature' );
     * plugin.clearForceDisabled( 'MyFeature' );
     * plugin.isEnabled; // -> true
     * ```
     *
     * **Note:** some plugins or algorithms may have more complex logic when it comes to enabling or disabling certain plugins,
     * so the plugin might be still disabled after {@link #clearForceDisabled} was used.
     *
     * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the plugin.
     */
    forceDisabled(e) {
      this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", Gc, { priority: "highest" }), this.isEnabled = !1);
    }
    /**
     * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
     *
     * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
     */
    clearForceDisabled(e) {
      this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", Gc), this.isEnabled = !0);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      this.stopListening();
    }
    /**
     * @inheritDoc
     */
    static get isContextPlugin() {
      return !1;
    }
  }
  function Gc(n) {
    n.return = !1, n.stop();
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class V extends $() {
    /**
     * Creates a new `Command` instance.
     *
     * @param editor The editor on which this command will be used.
     */
    constructor(e) {
      super(), this.editor = e, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
        this.refresh();
      }), this.listenTo(e, "change:isReadOnly", () => {
        this.refresh();
      }), this.on("set:isEnabled", (t) => {
        if (!this.affectsData)
          return;
        const i = e.model.document.selection, o = !(i.getFirstPosition().root.rootName == "$graveyard") && e.model.canEditAt(i);
        (e.isReadOnly || this._isEnabledBasedOnSelection && !o) && (t.return = !1, t.stop());
      }, { priority: "highest" }), this.on("execute", (t) => {
        this.isEnabled || t.stop();
      }, { priority: "high" });
    }
    /**
     * A flag indicating whether a command execution changes the editor data or not.
     *
     * Commands with `affectsData` set to `false` will not be automatically disabled in
     * the {@link module:core/editor/editor~Editor#isReadOnly read-only mode} and
     * {@glink features/read-only#related-features other editor modes} with restricted user write permissions.
     *
     * **Note:** You do not have to set it for your every command. It is `true` by default.
     *
     * @default true
     */
    get affectsData() {
      return this._affectsData;
    }
    set affectsData(e) {
      this._affectsData = e;
    }
    /**
     * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
     * in this method.
     *
     * This method is automatically called when
     * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.
     */
    refresh() {
      this.isEnabled = !0;
    }
    /**
     * Disables the command.
     *
     * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
     * (e.g. the feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
     * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
     *
     * Disabling and enabling a command:
     *
     * ```ts
     * command.isEnabled; // -> true
     * command.forceDisabled( 'MyFeature' );
     * command.isEnabled; // -> false
     * command.clearForceDisabled( 'MyFeature' );
     * command.isEnabled; // -> true
     * ```
     *
     * Command disabled by multiple features:
     *
     * ```ts
     * command.forceDisabled( 'MyFeature' );
     * command.forceDisabled( 'OtherFeature' );
     * command.clearForceDisabled( 'MyFeature' );
     * command.isEnabled; // -> false
     * command.clearForceDisabled( 'OtherFeature' );
     * command.isEnabled; // -> true
     * ```
     *
     * Multiple disabling with the same identifier is redundant:
     *
     * ```ts
     * command.forceDisabled( 'MyFeature' );
     * command.forceDisabled( 'MyFeature' );
     * command.clearForceDisabled( 'MyFeature' );
     * command.isEnabled; // -> true
     * ```
     *
     * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
     * so the command might be still disabled after {@link #clearForceDisabled} was used.
     *
     * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
     */
    forceDisabled(e) {
      this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", jc, { priority: "highest" }), this.isEnabled = !1);
    }
    /**
     * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
     *
     * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
     */
    clearForceDisabled(e) {
      this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", jc), this.refresh());
    }
    /**
     * Executes the command.
     *
     * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
     * to the command.
     *
     * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
     * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
     *
     * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
     *
     * This method may return a value, which would be forwarded all the way down to the
     * {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
     *
     * @fires execute
     */
    execute(...e) {
    }
    // eslint-disable-line @typescript-eslint/no-unused-vars
    /**
     * Destroys the command.
     */
    destroy() {
      this.stopListening();
    }
  }
  function jc(n) {
    n.return = !1, n.stop();
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Kc extends V {
    constructor() {
      super(...arguments), this._childCommandsDefinitions = [];
    }
    /**
     * @inheritDoc
     */
    refresh() {
    }
    /**
     * Executes the first enabled command which has the highest priority of all registered child commands.
     *
     * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
     */
    execute(...e) {
      const t = this._getFirstEnabledCommand();
      return !!t && t.execute(e);
    }
    /**
     * Registers a child command.
     *
     * @param options An object with configuration options.
     * @param options.priority Priority of a command to register.
     */
    registerChildCommand(e, t = {}) {
      nf(this._childCommandsDefinitions, { command: e, priority: t.priority || "normal" }), e.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
    }
    /**
     * Checks if any of child commands is enabled.
     */
    _checkEnabled() {
      this.isEnabled = !!this._getFirstEnabledCommand();
    }
    /**
     * Returns a first enabled command with the highest priority or `undefined` if none of them is enabled.
     */
    _getFirstEnabledCommand() {
      const e = this._childCommandsDefinitions.find(({ command: t }) => t.isEnabled);
      return e && e.command;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class cm extends G() {
    /**
     * Creates an instance of the plugin collection class.
     * Allows loading and initializing plugins and their dependencies.
     * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.
     *
     * @param availablePlugins Plugins (constructors) which the collection will be able to use
     * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).
     * Usually, the editor will pass its built-in plugins to the collection so they can later be
     * used in `config.plugins` or `config.removePlugins` by names.
     * @param contextPlugins A list of already initialized plugins represented by a `[ PluginConstructor, pluginInstance ]` pair.
     */
    constructor(e, t = [], i = []) {
      super(), this._plugins = /* @__PURE__ */ new Map(), this._context = e, this._availablePlugins = /* @__PURE__ */ new Map();
      for (const s of t)
        s.pluginName && this._availablePlugins.set(s.pluginName, s);
      this._contextPlugins = /* @__PURE__ */ new Map();
      for (const [s, o] of i)
        this._contextPlugins.set(s, o), this._contextPlugins.set(o, s), s.pluginName && this._availablePlugins.set(s.pluginName, s);
    }
    /**
     * Iterable interface.
     *
     * Returns `[ PluginConstructor, pluginInstance ]` pairs.
     */
    *[Symbol.iterator]() {
      for (const e of this._plugins)
        typeof e[0] == "function" && (yield e);
    }
    /**
     * Gets the plugin instance by its constructor or name.
     *
     * ```ts
     * // Check if 'Clipboard' plugin was loaded.
     * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
     * 	// Get clipboard plugin instance
     * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
     *
     * 	this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
     * 		// Do something on clipboard input.
     * 	} );
     * }
     * ```
     *
     * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`
     * to check if a plugin is available.
     *
     * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
     */
    get(e) {
      const t = this._plugins.get(e);
      if (!t) {
        let i = e;
        throw typeof e == "function" && (i = e.pluginName || e.name), new g("plugincollection-plugin-not-loaded", this._context, { plugin: i });
      }
      return t;
    }
    /**
     * Checks if a plugin is loaded.
     *
     * ```ts
     * // Check if the 'Clipboard' plugin was loaded.
     * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
     * 	// Now use the clipboard plugin instance:
     * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
     *
     * 	// ...
     * }
     * ```
     *
     * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
     */
    has(e) {
      return this._plugins.has(e);
    }
    /**
     * Initializes a set of plugins and adds them to the collection.
     *
     * @param plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
     * or {@link module:core/plugin~PluginStaticMembers#pluginName plugin names}.
     * @param pluginsToRemove Names of the plugins or plugin constructors
     * that should not be loaded (despite being specified in the `plugins` array).
     * @param pluginsSubstitutions An array of {@link module:core/plugin~PluginInterface plugin constructors}
     * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.
     * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced
     * must follow these rules:
     *   * The new plugin must be a class.
     *   * The new plugin must be named.
     *   * Both plugins must not depend on other plugins.
     * @returns A promise which gets resolved once all plugins are loaded and available in the collection.
     */
    init(e, t = [], i = []) {
      const s = this, o = this._context;
      f(e), p(e);
      const r = e.filter((A) => !d(A, t)), a = [...m(r)];
      D(a, i);
      const l = L(a);
      return M(l, "init").then(() => M(l, "afterInit")).then(() => l);
      function c(A) {
        return typeof A == "function";
      }
      function u(A) {
        return c(A) && !!A.isContextPlugin;
      }
      function d(A, R) {
        return R.some((S) => S === A || h(A) === S || h(S) === A);
      }
      function h(A) {
        return c(A) ? A.pluginName || A.name : A;
      }
      function f(A, R = /* @__PURE__ */ new Set()) {
        A.forEach((S) => {
          c(S) && (R.has(S) || (R.add(S), S.pluginName && !s._availablePlugins.has(S.pluginName) && s._availablePlugins.set(S.pluginName, S), S.requires && f(S.requires, R)));
        });
      }
      function m(A, R = /* @__PURE__ */ new Set()) {
        return A.map((S) => c(S) ? S : s._availablePlugins.get(S)).reduce((S, ee) => R.has(ee) ? S : (R.add(ee), ee.requires && (p(ee.requires, ee), m(ee.requires, R).forEach((Zt) => S.add(Zt))), S.add(ee)), /* @__PURE__ */ new Set());
      }
      function p(A, R = null) {
        A.map((S) => c(S) ? S : s._availablePlugins.get(S) || S).forEach((S) => {
          b(S, R), v(S, R), y(S, R);
        });
      }
      function b(A, R) {
        if (!c(A))
          throw R ? new g("plugincollection-soft-required", o, { missingPlugin: A, requiredBy: h(R) }) : new g("plugincollection-plugin-not-found", o, { plugin: A });
      }
      function v(A, R) {
        if (u(R) && !u(A))
          throw new g("plugincollection-context-required", o, { plugin: h(A), requiredBy: h(R) });
      }
      function y(A, R) {
        if (R && d(A, t))
          throw new g("plugincollection-required", o, { plugin: h(A), requiredBy: h(R) });
      }
      function L(A) {
        return A.map((R) => {
          let S = s._contextPlugins.get(R);
          return S = S || new R(o), s._add(R, S), S;
        });
      }
      function M(A, R) {
        return A.reduce((S, ee) => !ee[R] || s._contextPlugins.has(ee) ? S : S.then(ee[R].bind(ee)), Promise.resolve());
      }
      function D(A, R) {
        for (const S of R) {
          if (typeof S != "function")
            throw new g("plugincollection-replace-plugin-invalid-type", null, { pluginItem: S });
          const ee = S.pluginName;
          if (!ee)
            throw new g("plugincollection-replace-plugin-missing-name", null, { pluginItem: S });
          if (S.requires && S.requires.length)
            throw new g("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: ee });
          const Zt = s._availablePlugins.get(ee);
          if (!Zt)
            throw new g("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: ee });
          const Ql = A.indexOf(Zt);
          if (Ql === -1) {
            if (s._contextPlugins.has(Zt))
              return;
            throw new g("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: ee });
          }
          if (Zt.requires && Zt.requires.length)
            throw new g("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: ee });
          A.splice(Ql, 1, S), s._availablePlugins.set(ee, S);
        }
      }
    }
    /**
     * Destroys all loaded plugins.
     */
    destroy() {
      const e = [];
      for (const [, t] of this)
        typeof t.destroy == "function" && !this._contextPlugins.has(t) && e.push(t.destroy());
      return Promise.all(e);
    }
    /**
     * Adds the plugin to the collection. Exposed mainly for testing purposes.
     *
     * @param PluginConstructor The plugin constructor.
     * @param plugin The instance of the plugin.
     */
    _add(e, t) {
      this._plugins.set(e, t);
      const i = e.pluginName;
      if (i) {
        if (this._plugins.has(i))
          throw new g("plugincollection-plugin-name-conflict", null, { pluginName: i, plugin1: this._plugins.get(i).constructor, plugin2: e });
        this._plugins.set(i, t);
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class um {
    /**
     * Creates a context instance with a given configuration.
     *
     * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
     *
     * @param config The context configuration.
     */
    constructor(e) {
      this._contextOwner = null;
      const { translations: t, ...i } = e || {};
      this.config = new Jf(i, this.constructor.defaultConfig);
      const s = this.constructor.builtinPlugins;
      this.config.define("plugins", s), this.plugins = new cm(this, s);
      const o = this.config.get("language") || {};
      this.locale = new AC({
        uiLanguage: typeof o == "string" ? o : o.ui,
        contentLanguage: this.config.get("language.content"),
        translations: t
      }), this.t = this.locale.t, this.editors = new Ce();
    }
    /**
     * Loads and initializes plugins specified in the configuration.
     *
     * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
     */
    initPlugins() {
      const e = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
      for (const i of e.concat(t)) {
        if (typeof i != "function")
          throw new g("context-initplugins-constructor-only", null, { Plugin: i });
        if (i.isContextPlugin !== !0)
          throw new g("context-initplugins-invalid-plugin", null, { Plugin: i });
      }
      return this.plugins.init(e, [], t);
    }
    /**
     * Destroys the context instance and all editors used with the context,
     * releasing all resources used by the context.
     *
     * @returns A promise that resolves once the context instance is fully destroyed.
     */
    destroy() {
      return Promise.all(Array.from(this.editors, (e) => e.destroy())).then(() => this.plugins.destroy());
    }
    /**
     * Adds a reference to the editor which is used with this context.
     *
     * When the given editor has created the context, the reference to this editor will be stored
     * as a {@link ~Context#_contextOwner}.
     *
     * This method should only be used by the editor.
     *
     * @internal
     * @param isContextOwner Stores the given editor as a context owner.
     */
    _addEditor(e, t) {
      if (this._contextOwner)
        throw new g("context-addeditor-private-context");
      this.editors.add(e), t && (this._contextOwner = e);
    }
    /**
     * Removes a reference to the editor which was used with this context.
     * When the context was created by the given editor, the context will be destroyed.
     *
     * This method should only be used by the editor.
     *
     * @internal
     * @return A promise that resolves once the editor is removed from the context or when the context was destroyed.
     */
    _removeEditor(e) {
      return this.editors.has(e) && this.editors.remove(e), this._contextOwner === e ? this.destroy() : Promise.resolve();
    }
    /**
     * Returns the context configuration which will be copied to the editors created using this context.
     *
     * The configuration returned by this method has the plugins configuration removed &ndash; plugins are shared with all editors
     * through another mechanism.
     *
     * This method should only be used by the editor.
     *
     * @internal
     * @returns Configuration as a plain object.
     */
    _getEditorConfig() {
      const e = {};
      for (const t of this.config.names())
        ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
      return e;
    }
    /**
     * Creates and initializes a new context instance.
     *
     * ```ts
     * const commonConfig = { ... }; // Configuration for all the plugins and editors.
     * const editorPlugins = [ ... ]; // Regular plugins here.
     *
     * Context
     * 	.create( {
     * 		// Only context plugins here.
     * 		plugins: [ ... ],
     *
     * 		// Configure the language for all the editors (it cannot be overwritten).
     * 		language: { ... },
     *
     * 		// Configuration for context plugins.
     * 		comments: { ... },
     * 		...
     *
     * 		// Default configuration for editor plugins.
     * 		toolbar: { ... },
     * 		image: { ... },
     * 		...
     * 	} )
     * 	.then( context => {
     * 		const promises = [];
     *
     * 		promises.push( ClassicEditor.create(
     * 			document.getElementById( 'editor1' ),
     * 			{
     * 				editorPlugins,
     * 				context
     * 			}
     * 		) );
     *
     * 		promises.push( ClassicEditor.create(
     * 			document.getElementById( 'editor2' ),
     * 			{
     * 				editorPlugins,
     * 				context,
     * 				toolbar: { ... } // You can overwrite the configuration of the context.
     * 			}
     * 		) );
     *
     * 		return Promise.all( promises );
     * 	} );
     * ```
     *
     * @param config The context configuration.
     * @returns A promise resolved once the context is ready. The promise resolves with the created context instance.
     */
    static create(e) {
      return new Promise((t) => {
        const i = new this(e);
        t(i.initPlugins().then(() => i));
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Zo extends $() {
    /**
     * Creates a new plugin instance.
     */
    constructor(e) {
      super(), this.context = e;
    }
    /**
     * @inheritDoc
     */
    destroy() {
      this.stopListening();
    }
    /**
     * @inheritDoc
     */
    static get isContextPlugin() {
      return !0;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const oo = /* @__PURE__ */ new WeakMap();
  let Zc = !1;
  function ml({ view: n, element: e, text: t, isDirectHost: i = !0, keepOnFocus: s = !1 }) {
    const o = n.document;
    oo.has(o) || (oo.set(o, /* @__PURE__ */ new Map()), o.registerPostFixer((a) => yr(o, a)), o.on("change:isComposing", () => {
      n.change((a) => yr(o, a));
    }, { priority: "high" })), e.is("editableElement") && e.on("change:placeholder", (a, l, c) => {
      r(c);
    }), e.placeholder ? r(e.placeholder) : t && r(t), t && UC();
    function r(a) {
      oo.get(o).set(e, {
        text: a,
        isDirectHost: i,
        keepOnFocus: s,
        hostElement: i ? e : null
      }), n.change((l) => yr(o, l));
    }
  }
  function NC(n, e) {
    return e.hasClass("ck-placeholder") ? !1 : (n.addClass("ck-placeholder", e), !0);
  }
  function DC(n, e) {
    return e.hasClass("ck-placeholder") ? (n.removeClass("ck-placeholder", e), !0) : !1;
  }
  function FC(n, e) {
    if (!n.isAttached() || Array.from(n.getChildren()).some((r) => !r.is("uiElement")))
      return !1;
    const i = n.document, o = i.selection.anchor;
    return i.isComposing && o && o.parent === n ? !1 : e || !i.isFocused ? !0 : !!o && o.parent !== n;
  }
  function yr(n, e) {
    const t = oo.get(n), i = [];
    let s = !1;
    for (const [o, r] of t)
      r.isDirectHost && (i.push(o), Jc(e, o, r) && (s = !0));
    for (const [o, r] of t) {
      if (r.isDirectHost)
        continue;
      const a = zC(o);
      a && (i.includes(a) || (r.hostElement = a, Jc(e, o, r) && (s = !0)));
    }
    return s;
  }
  function Jc(n, e, t) {
    const { text: i, isDirectHost: s, hostElement: o } = t;
    let r = !1;
    return o.getAttribute("data-placeholder") !== i && (n.setAttribute("data-placeholder", i, o), r = !0), (s || e.childCount == 1) && FC(o, t.keepOnFocus) ? NC(n, o) && (r = !0) : DC(n, o) && (r = !0), r;
  }
  function zC(n) {
    if (n.childCount) {
      const e = n.getChild(0);
      if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement"))
        return e;
    }
    return null;
  }
  function UC() {
    Zc || z("enableplaceholder-deprecated-text-option"), Zc = !0;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let bi = class {
    /* istanbul ignore next -- @preserve */
    is() {
      throw new Error("is() method is abstract");
    }
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let _i = class extends G(bi) {
    /**
     * Creates a tree view node.
     *
     * @param document The document instance to which this node belongs.
     */
    constructor(e) {
      super(), this.document = e, this.parent = null;
    }
    /**
     * Index of the node in the parent element or null if the node has no parent.
     *
     * Accessing this property throws an error if this node's parent element does not contain it.
     * This means that view tree got broken.
     */
    get index() {
      let e;
      if (!this.parent)
        return null;
      if ((e = this.parent.getChildIndex(this)) == -1)
        throw new g("view-node-not-found-in-parent", this);
      return e;
    }
    /**
     * Node's next sibling, or `null` if it is the last child.
     */
    get nextSibling() {
      const e = this.index;
      return e !== null && this.parent.getChild(e + 1) || null;
    }
    /**
     * Node's previous sibling, or `null` if it is the first child.
     */
    get previousSibling() {
      const e = this.index;
      return e !== null && this.parent.getChild(e - 1) || null;
    }
    /**
     * Top-most ancestor of the node. If the node has no parent it is the root itself.
     */
    get root() {
      let e = this;
      for (; e.parent; )
        e = e.parent;
      return e;
    }
    /**
     * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
     */
    isAttached() {
      return this.root.is("rootElement");
    }
    /**
     * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
     * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.
     *
     * ```ts
     * const abc = downcastWriter.createText( 'abc' );
     * const foo = downcastWriter.createText( 'foo' );
     * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
     * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
     * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
     * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
     * h1.getPath(); // Returns [ 0 ].
     * div.getPath(); // Returns [].
     * ```
     *
     * @returns The path.
     */
    getPath() {
      const e = [];
      let t = this;
      for (; t.parent; )
        e.unshift(t.index), t = t.parent;
      return e;
    }
    /**
     * Returns ancestors array of this node.
     *
     * @param options Options object.
     * @param options.includeSelf When set to `true` this node will be also included in parent's array.
     * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
     * otherwise root element will be the first item in the array.
     * @returns Array with ancestors.
     */
    getAncestors(e = {}) {
      const t = [];
      let i = e.includeSelf ? this : this.parent;
      for (; i; )
        t[e.parentFirst ? "push" : "unshift"](i), i = i.parent;
      return t;
    }
    /**
     * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
     * which is a common ancestor of both nodes.
     *
     * @param node The second node.
     * @param options Options object.
     * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
     * Which means that if e.g. node A is inside B, then their common ancestor will be B.
     */
    getCommonAncestor(e, t = {}) {
      const i = this.getAncestors(t), s = e.getAncestors(t);
      let o = 0;
      for (; i[o] == s[o] && i[o]; )
        o++;
      return o === 0 ? null : i[o - 1];
    }
    /**
     * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
     * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
     *
     * @param node Node to compare with.
     */
    isBefore(e) {
      if (this == e || this.root !== e.root)
        return !1;
      const t = this.getPath(), i = e.getPath(), s = Ee(t, i);
      switch (s) {
        case "prefix":
          return !0;
        case "extension":
          return !1;
        default:
          return t[s] < i[s];
      }
    }
    /**
     * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
     * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
     *
     * @param node Node to compare with.
     */
    isAfter(e) {
      return this == e || this.root !== e.root ? !1 : !this.isBefore(e);
    }
    /**
     * Removes node from parent.
     *
     * @internal
     */
    _remove() {
      this.parent._removeChildren(this.index);
    }
    /**
     * @internal
     * @param type Type of the change.
     * @param node Changed node.
     * @fires change
     */
    _fireChange(e, t) {
      this.fire(`change:${e}`, t), this.parent && this.parent._fireChange(e, t);
    }
    /**
     * Custom toJSON method to solve child-parent circular dependencies.
     *
     * @returns Clone of this object with the parent property removed.
     */
    toJSON() {
      const e = zf(this);
      return delete e.parent, e;
    }
  };
  _i.prototype.is = function(n) {
    return n === "node" || n === "view:node";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let ie = class la extends _i {
    /**
     * Creates a tree view text node.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#createText
     * @internal
     * @param document The document instance to which this text node belongs.
     * @param data The text's data.
     */
    constructor(e, t) {
      super(e), this._textData = t;
    }
    /**
     * The text content.
     */
    get data() {
      return this._textData;
    }
    /**
     * The `_data` property is controlled by a getter and a setter.
     *
     * The getter is required when using the addition assignment operator on protected property:
     *
     * ```ts
     * const foo = downcastWriter.createText( 'foo' );
     * const bar = downcastWriter.createText( 'bar' );
     *
     * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
     * console.log( foo.data ); // prints: 'foobar'
     * ```
     *
     * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
     *
     * The setter sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.
     *
     * @internal
     */
    get _data() {
      return this.data;
    }
    set _data(e) {
      this._fireChange("text", this), this._textData = e;
    }
    /**
     * Checks if this text node is similar to other text node.
     * Both nodes should have the same data to be considered as similar.
     *
     * @param otherNode Node to check if it is same as this node.
     */
    isSimilar(e) {
      return e instanceof la ? this === e || this.data === e.data : !1;
    }
    /**
     * Clones this node.
     *
     * @internal
     * @returns Text node that is a clone of this node.
     */
    _clone() {
      return new la(this.document, this.data);
    }
  };
  ie.prototype.is = function(n) {
    return n === "$text" || n === "view:$text" || // This are legacy values kept for backward compatibility.
    n === "text" || n === "view:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "node" || n === "view:node";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let ft = class extends bi {
    /**
     * Creates a text proxy.
     *
     * @internal
     * @param textNode Text node which part is represented by this text proxy.
     * @param offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
     * from which the text proxy starts.
     * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
     * @constructor
     */
    constructor(e, t, i) {
      if (super(), this.textNode = e, t < 0 || t > e.data.length)
        throw new g("view-textproxy-wrong-offsetintext", this);
      if (i < 0 || t + i > e.data.length)
        throw new g("view-textproxy-wrong-length", this);
      this.data = e.data.substring(t, t + i), this.offsetInText = t;
    }
    /**
     * Offset size of this node.
     */
    get offsetSize() {
      return this.data.length;
    }
    /**
     * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
     * (`true`) or the whole text node (`false`).
     *
     * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
     * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
     * text node size.
     */
    get isPartial() {
      return this.data.length !== this.textNode.data.length;
    }
    /**
     * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
     */
    get parent() {
      return this.textNode.parent;
    }
    /**
     * Root of this text proxy, which is same as root of text node represented by this text proxy.
     */
    get root() {
      return this.textNode.root;
    }
    /**
     * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
     * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
     */
    get document() {
      return this.textNode.document;
    }
    /**
     * Returns ancestors array of this text proxy.
     *
     * @param options Options object.
     * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
     * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
     * root element, otherwise root element will be the first item in the array.
     * @returns Array with ancestors.
     */
    getAncestors(e = {}) {
      const t = [];
      let i = e.includeSelf ? this.textNode : this.parent;
      for (; i !== null; )
        t[e.parentFirst ? "push" : "unshift"](i), i = i.parent;
      return t;
    }
  };
  ft.prototype.is = function(n) {
    return n === "$textProxy" || n === "view:$textProxy" || // This are legacy values kept for backward compatibility.
    n === "textProxy" || n === "view:textProxy";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class rt {
    /**
     * Creates new instance of Matcher.
     *
     * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
     */
    constructor(...e) {
      this._patterns = [], this.add(...e);
    }
    /**
     * Adds pattern or patterns to matcher instance.
     *
     * ```ts
     * // String.
     * matcher.add( 'div' );
     *
     * // Regular expression.
     * matcher.add( /^\w/ );
     *
     * // Single class.
     * matcher.add( {
     * 	classes: 'foobar'
     * } );
     * ```
     *
     * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
     *
     * Multiple patterns can be added in one call:
     *
     * ```ts
     * matcher.add( 'div', { classes: 'foobar' } );
     * ```
     *
     * @param pattern Object describing pattern details. If string or regular expression
     * is provided it will be used to match element's name. Pattern can be also provided in a form
     * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
     * Function's return value will be stored under `match` key of the object returned from
     * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
     */
    add(...e) {
      for (let t of e)
        (typeof t == "string" || t instanceof RegExp) && (t = { name: t }), this._patterns.push(t);
    }
    /**
     * Matches elements for currently stored patterns. Returns match information about first found
     * {@link module:engine/view/element~Element element}, otherwise returns `null`.
     *
     * Example of returned object:
     *
     * ```ts
     * {
     * 	element: <instance of found element>,
     * 	pattern: <pattern used to match found element>,
     * 	match: {
     * 		name: true,
     * 		attributes: [ 'title', 'href' ],
     * 		classes: [ 'foo' ],
     * 		styles: [ 'color', 'position' ]
     * 	}
     * }
     * ```
     *
     * @see module:engine/view/matcher~Matcher#add
     * @see module:engine/view/matcher~Matcher#matchAll
     * @param element View element to match against stored patterns.
     */
    match(...e) {
      for (const t of e)
        for (const i of this._patterns) {
          const s = Xc(t, i);
          if (s)
            return {
              element: t,
              pattern: i,
              match: s
            };
        }
      return null;
    }
    /**
     * Matches elements for currently stored patterns. Returns array of match information with all found
     * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
     *
     * @see module:engine/view/matcher~Matcher#add
     * @see module:engine/view/matcher~Matcher#match
     * @param element View element to match against stored patterns.
     * @returns Array with match information about found elements or `null`. For more information
     * see {@link module:engine/view/matcher~Matcher#match match method} description.
     */
    matchAll(...e) {
      const t = [];
      for (const i of e)
        for (const s of this._patterns) {
          const o = Xc(i, s);
          o && t.push({
            element: i,
            pattern: s,
            match: o
          });
        }
      return t.length > 0 ? t : null;
    }
    /**
     * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
     * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
     *
     * @returns Element name trying to match.
     */
    getElementName() {
      if (this._patterns.length !== 1)
        return null;
      const e = this._patterns[0], t = e.name;
      return typeof e != "function" && t && !(t instanceof RegExp) ? t : null;
    }
  }
  function Xc(n, e) {
    if (typeof e == "function")
      return e(n);
    const t = {};
    return e.name && (t.name = HC(e.name, n.name), !t.name) || e.attributes && (t.attributes = GC(e.attributes, n), !t.attributes) || e.classes && (t.classes = jC(e.classes, n), !t.classes) || e.styles && (t.styles = KC(e.styles, n), !t.styles) ? null : t;
  }
  function HC(n, e) {
    return n instanceof RegExp ? !!e.match(n) : n === e;
  }
  function gl(n, e, t) {
    const i = $C(n), s = Array.from(e), o = [];
    if (i.forEach(([r, a]) => {
      s.forEach((l) => {
        WC(r, l) && qC(a, l, t) && o.push(l);
      });
    }), !(!i.length || o.length < i.length))
      return o;
  }
  function $C(n) {
    return Array.isArray(n) ? n.map((e) => Ne(e) ? ((e.key === void 0 || e.value === void 0) && z("matcher-pattern-missing-key-or-value", e), [e.key, e.value]) : [e, !0]) : Ne(n) ? Object.entries(n) : [[n, !0]];
  }
  function WC(n, e) {
    return n === !0 || n === e || n instanceof RegExp && e.match(n);
  }
  function qC(n, e, t) {
    if (n === !0)
      return !0;
    const i = t(e);
    return n === i || n instanceof RegExp && !!String(i).match(n);
  }
  function GC(n, e) {
    const t = new Set(e.getAttributeKeys());
    return Ne(n) ? (n.style !== void 0 && z("matcher-pattern-deprecated-attributes-style-key", n), n.class !== void 0 && z("matcher-pattern-deprecated-attributes-class-key", n)) : (t.delete("style"), t.delete("class")), gl(n, t, (i) => e.getAttribute(i));
  }
  function jC(n, e) {
    return gl(
      n,
      e.getClassNames(),
      /* istanbul ignore next -- @preserve */
      () => {
      }
    );
  }
  function KC(n, e) {
    return gl(n, e.getStyleNames(!0), (t) => e.getStyle(t));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ca {
    /**
     * Creates Styles instance.
     */
    constructor(e) {
      this._styles = {}, this._styleProcessor = e;
    }
    /**
     * Returns true if style map has no styles set.
     */
    get isEmpty() {
      return !Object.entries(this._styles).length;
    }
    /**
     * Number of styles defined.
     */
    get size() {
      return this.isEmpty ? 0 : this.getStyleNames().length;
    }
    /**
     * Set styles map to a new value.
     *
     * ```ts
     * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
     * ```
     */
    setTo(e) {
      this.clear();
      const t = JC(e);
      for (const [i, s] of t)
        this._styleProcessor.toNormalizedForm(i, s, this._styles);
    }
    /**
     * Checks if a given style is set.
     *
     * ```ts
     * styles.setTo( 'margin-left:1px;' );
     *
     * styles.has( 'margin-left' );    // -> true
     * styles.has( 'padding' );        // -> false
     * ```
     *
     * **Note**: This check supports normalized style names.
     *
     * ```ts
     * // Enable 'margin' shorthand processing:
     * editor.data.addStyleProcessorRules( addMarginRules );
     *
     * styles.setTo( 'margin:2px;' );
     *
     * styles.has( 'margin' );         // -> true
     * styles.has( 'margin-top' );     // -> true
     * styles.has( 'margin-left' );    // -> true
     *
     * styles.remove( 'margin-top' );
     *
     * styles.has( 'margin' );         // -> false
     * styles.has( 'margin-top' );     // -> false
     * styles.has( 'margin-left' );    // -> true
     * ```
     *
     * @param name Style name.
     */
    has(e) {
      if (this.isEmpty)
        return !1;
      const i = this._styleProcessor.getReducedForm(e, this._styles).find(([s]) => s === e);
      return Array.isArray(i);
    }
    set(e, t) {
      if (J(e))
        for (const [i, s] of Object.entries(e))
          this._styleProcessor.toNormalizedForm(i, s, this._styles);
      else
        this._styleProcessor.toNormalizedForm(e, t, this._styles);
    }
    /**
     * Removes given style.
     *
     * ```ts
     * styles.setTo( 'background:#f00;margin-right:2px;' );
     *
     * styles.remove( 'background' );
     *
     * styles.toString();   // -> 'margin-right:2px;'
     * ```
     *
     * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
     * enabled style processor rules} to normalize passed values.
     *
     * ```ts
     * // Enable 'margin' shorthand processing:
     * editor.data.addStyleProcessorRules( addMarginRules );
     *
     * styles.setTo( 'margin:1px' );
     *
     * styles.remove( 'margin-top' );
     * styles.remove( 'margin-right' );
     *
     * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
     * ```
     *
     * @param name Style name.
     */
    remove(e) {
      const t = ua(e);
      Wy(this._styles, t), delete this._styles[e], this._cleanEmptyObjectsOnPath(t);
    }
    /**
     * Returns a normalized style object or a single value.
     *
     * ```ts
     * // Enable 'margin' shorthand processing:
     * editor.data.addStyleProcessorRules( addMarginRules );
     *
     * const styles = new Styles();
     * styles.setTo( 'margin:1px 2px 3em;' );
     *
     * styles.getNormalized( 'margin' );
     * // will log:
     * // {
     * //     top: '1px',
     * //     right: '2px',
     * //     bottom: '3em',
     * //     left: '2px'     // normalized value from margin shorthand
     * // }
     *
     * styles.getNormalized( 'margin-left' ); // -> '2px'
     * ```
     *
     * **Note**: This method will only return normalized styles if a style processor was defined.
     *
     * @param name Style name.
     */
    getNormalized(e) {
      return this._styleProcessor.getNormalized(e, this._styles);
    }
    /**
     * Returns a normalized style string. Styles are sorted by name.
     *
     * ```ts
     * styles.set( 'margin' , '1px' );
     * styles.set( 'background', '#f00' );
     *
     * styles.toString(); // -> 'background:#f00;margin:1px;'
     * ```
     *
     * **Note**: This method supports normalized styles if defined.
     *
     * ```ts
     * // Enable 'margin' shorthand processing:
     * editor.data.addStyleProcessorRules( addMarginRules );
     *
     * styles.set( 'margin' , '1px' );
     * styles.set( 'background', '#f00' );
     * styles.remove( 'margin-top' );
     * styles.remove( 'margin-right' );
     *
     * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
     * ```
     */
    toString() {
      return this.isEmpty ? "" : this.getStylesEntries().map((e) => e.join(":")).sort().join(";") + ";";
    }
    /**
     * Returns property as a value string or undefined if property is not set.
     *
     * ```ts
     * // Enable 'margin' shorthand processing:
     * editor.data.addStyleProcessorRules( addMarginRules );
     *
     * const styles = new Styles();
     * styles.setTo( 'margin:1px;' );
     * styles.set( 'margin-bottom', '3em' );
     *
     * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
     * ```
     *
     * Note, however, that all sub-values must be set for the longhand property name to return a value:
     *
     * ```ts
     * const styles = new Styles();
     * styles.setTo( 'margin:1px;' );
     * styles.remove( 'margin-bottom' );
     *
     * styles.getAsString( 'margin' ); // -> undefined
     * ```
     *
     * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
     * Instead, you should use:
     *
     * ```ts
     * const styles = new Styles();
     * styles.setTo( 'margin:1px;' );
     * styles.remove( 'margin-bottom' );
     *
     * for ( const styleName of styles.getStyleNames() ) {
     * 	console.log( styleName, styles.getAsString( styleName ) );
     * }
     * // 'margin-top', '1px'
     * // 'margin-right', '1px'
     * // 'margin-left', '1px'
     * ```
     *
     * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
     * the currently set style values. So, if all the 4 margin values would be set
     * the for-of loop above would yield only `'margin'`, `'1px'`:
     *
     * ```ts
     * const styles = new Styles();
     * styles.setTo( 'margin:1px;' );
     *
     * for ( const styleName of styles.getStyleNames() ) {
     * 	console.log( styleName, styles.getAsString( styleName ) );
     * }
     * // 'margin', '1px'
     * ```
     *
     * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
     */
    getAsString(e) {
      if (this.isEmpty)
        return;
      if (this._styles[e] && !J(this._styles[e]))
        return this._styles[e];
      const i = this._styleProcessor.getReducedForm(e, this._styles).find(([s]) => s === e);
      if (Array.isArray(i))
        return i[1];
    }
    /**
     * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
     *
     * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
     *
     * ```ts
     * stylesMap.setTo( 'margin: 1em' )
     * ```
     *
     * will be expanded to:
     *
     * ```ts
     * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
     * ```
     *
     * @param expand Expand shorthand style properties and all return equivalent style representations.
     */
    getStyleNames(e = !1) {
      return this.isEmpty ? [] : e ? this._styleProcessor.getStyleNames(this._styles) : this.getStylesEntries().map(([i]) => i);
    }
    /**
     * Removes all styles.
     */
    clear() {
      this._styles = {};
    }
    /**
     * Returns normalized styles entries for further processing.
     */
    getStylesEntries() {
      const e = [], t = Object.keys(this._styles);
      for (const i of t)
        e.push(...this._styleProcessor.getReducedForm(i, this._styles));
      return e;
    }
    /**
     * Removes empty objects upon removing an entry from internal object.
     */
    _cleanEmptyObjectsOnPath(e) {
      const t = e.split(".");
      if (!(t.length > 1))
        return;
      const s = t.splice(0, t.length - 1).join("."), o = Kn(this._styles, s);
      if (!o)
        return;
      !Object.keys(o).length && this.remove(s);
    }
  }
  class ZC {
    /**
     * Creates StylesProcessor instance.
     *
     * @internal
     */
    constructor() {
      this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
    }
    /**
     * Parse style string value to a normalized object and appends it to styles object.
     *
     * ```ts
     * const styles = {};
     *
     * stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
     *
     * // styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
     * ```
     *
     * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
     *
     * @param name Name of style property.
     * @param propertyValue Value of style property.
     * @param styles Object holding normalized styles.
     */
    toNormalizedForm(e, t, i) {
      if (J(t)) {
        Cr(i, ua(e), t);
        return;
      }
      if (this._normalizers.has(e)) {
        const s = this._normalizers.get(e), { path: o, value: r } = s(t);
        Cr(i, o, r);
      } else
        Cr(i, e, t);
    }
    /**
     * Returns a normalized version of a style property.
     *
     * ```ts
     * const styles = {
     * 	margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
     * 	background: { color: '#f00' }
     * };
     *
     * stylesProcessor.getNormalized( 'background' );
     * // will return: { color: '#f00' }
     *
     * stylesProcessor.getNormalized( 'margin-top' );
     * // will return: '1px'
     * ```
     *
     * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
     *
     * @param name Name of style property.
     * @param styles Object holding normalized styles.
     */
    getNormalized(e, t) {
      if (!e)
        return ll({}, t);
      if (t[e] !== void 0)
        return t[e];
      if (this._extractors.has(e)) {
        const i = this._extractors.get(e);
        if (typeof i == "string")
          return Kn(t, i);
        const s = i(e, t);
        if (s)
          return s;
      }
      return Kn(t, ua(e));
    }
    /**
     * Returns a reduced form of style property form normalized object.
     *
     * For default margin reducer, the below code:
     *
     * ```ts
     * stylesProcessor.getReducedForm( 'margin', {
     * 	margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
     * } );
     * ```
     *
     * will return:
     *
     * ```ts
     * [
     * 	[ 'margin', '1px 1px 2px' ]
     * ]
     * ```
     *
     * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
     *
     * ```ts
     * [
     * 	[ 'margin-top', '1px' ],
     * 	[ 'margin-right', '1px' ],
     * 	[ 'margin-bottom', '2px' ]
     * 	// the 'left' value is missing - cannot use 'margin' shorthand.
     * ]
     * ```
     *
     * **Note**: To define reducer callbacks use {@link #setReducer}.
     *
     * @param name Name of style property.
     */
    getReducedForm(e, t) {
      const i = this.getNormalized(e, t);
      return i === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(i) : [[e, i]];
    }
    /**
     * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.
     *
     * @param styles Object holding normalized styles.
     */
    getStyleNames(e) {
      const t = Array.from(this._consumables.keys()).filter((s) => {
        const o = this.getNormalized(s, e);
        return o && typeof o == "object" ? Object.keys(o).length : o;
      }), i = /* @__PURE__ */ new Set([
        ...t,
        ...Object.keys(e)
      ]);
      return Array.from(i);
    }
    /**
     * Returns related style names.
     *
     * ```ts
     * stylesProcessor.getRelatedStyles( 'margin' );
     * // will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
     *
     * stylesProcessor.getRelatedStyles( 'margin-top' );
     * // will return: [ 'margin' ];
     * ```
     *
     * **Note**: To define new style relations load an existing style processor or use
     * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
     */
    getRelatedStyles(e) {
      return this._consumables.get(e) || [];
    }
    /**
     * Adds a normalizer method for a style property.
     *
     * A normalizer returns describing how the value should be normalized.
     *
     * For instance 'margin' style is a shorthand for four margin values:
     *
     * - 'margin-top'
     * - 'margin-right'
     * - 'margin-bottom'
     * - 'margin-left'
     *
     * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
     * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
     *
     * A normalizer should parse various margin notations as a single object:
     *
     * ```ts
     * const styles = {
     * 	margin: {
     * 		top: '1px',
     * 		right: '2em',
     * 		bottom: '1px',
     * 		left: '2em'
     * 	}
     * };
     * ```
     *
     * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
     *
     * ```ts
     * const returnValue = {
     * 	path: 'margin',
     * 	value: {
     * 		top: '1px',
     * 		right: '2em',
     * 		bottom: '1px',
     * 		left: '2em'
     * 	}
     * };
     * ```
     *
     * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
     * is an example for 'margin-top' style property normalizer:
     *
     * ```ts
     * stylesProcessor.setNormalizer( 'margin-top', valueString => {
     * 	return {
     * 		path: 'margin.top',
     * 		value: valueString
     * 	}
     * } );
     * ```
     */
    setNormalizer(e, t) {
      this._normalizers.set(e, t);
    }
    /**
     * Adds a extractor callback for a style property.
     *
     * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
     *
     * ```ts
     * const styles = {
     * 	margin: {
     * 		top: 'value'
     * 	}
     * }
     * ```
     *
     * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
     * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
     * shorthands. The default border styles processors stores styles as:
     *
     * ```ts
     * const styles = {
     * 	border: {
     * 		style: {
     * 			top: 'solid'
     * 		}
     * 	}
     * }
     * ```
     *
     * as it is better to modify border style independently from other values. On the other part the output of the border might be
     * desired as `border-top`, `border-left`, etc notation.
     *
     * In the above example an extractor should return a side border value that combines style, color and width:
     *
     * ```ts
     * styleProcessor.setExtractor( 'border-top', styles => {
     * 	return {
     * 		color: styles.border.color.top,
     * 		style: styles.border.style.top,
     * 		width: styles.border.width.top
     * 	}
     * } );
     * ```
     *
     * @param callbackOrPath Callback that return a requested value or path string for single values.
     */
    setExtractor(e, t) {
      this._extractors.set(e, t);
    }
    /**
     * Adds a reducer callback for a style property.
     *
     * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
     * by default the direct value from style path is taken.
     *
     * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
     * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
     *
     * ```ts
     * const marginShortHandTuple = [
     * 	[ 'margin', '1px 1px 2px' ]
     * ];
     * ```
     *
     * or a longhand tuples for defined values:
     *
     * ```ts
     * // Considering margin.bottom and margin.left are undefined.
     * const marginLonghandsTuples = [
     * 	[ 'margin-top', '1px' ],
     * 	[ 'margin-right', '1px' ]
     * ];
     * ```
     *
     * A reducer obtains a normalized style value:
     *
     * ```ts
     * // Simplified reducer that always outputs 4 values which are always present:
     * stylesProcessor.setReducer( 'margin', margin => {
     * 	return [
     * 		[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
     * 	]
     * } );
     * ```
     */
    setReducer(e, t) {
      this._reducers.set(e, t);
    }
    /**
     * Defines a style shorthand relation to other style notations.
     *
     * ```ts
     * stylesProcessor.setStyleRelation( 'margin', [
     * 	'margin-top',
     * 	'margin-right',
     * 	'margin-bottom',
     * 	'margin-left'
     * ] );
     * ```
     *
     * This enables expanding of style names for shorthands. For instance, if defined,
     * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
     * for long-hand margin style notation alongside the `'margin'` item.
     *
     * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
     * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
     * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
     * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
     */
    setStyleRelation(e, t) {
      this._mapStyleNames(e, t);
      for (const i of t)
        this._mapStyleNames(i, [e]);
    }
    /**
     * Set two-way binding of style names.
     */
    _mapStyleNames(e, t) {
      this._consumables.has(e) || this._consumables.set(e, []), this._consumables.get(e).push(...t);
    }
  }
  function JC(n) {
    let e = null, t = 0, i = 0, s = null;
    const o = /* @__PURE__ */ new Map();
    if (n === "")
      return o;
    n.charAt(n.length - 1) != ";" && (n = n + ";");
    for (let r = 0; r < n.length; r++) {
      const a = n.charAt(r);
      if (e === null)
        switch (a) {
          case ":":
            s || (s = n.substr(t, r - t), i = r + 1);
            break;
          case '"':
          case "'":
            e = a;
            break;
          case ";": {
            const l = n.substr(i, r - i);
            s && o.set(s.trim(), l.trim()), s = null, t = r + 1;
            break;
          }
        }
      else
        a === e && (e = null);
    }
    return o;
  }
  function ua(n) {
    return n.replace("-", ".");
  }
  function Cr(n, e, t) {
    let i = t;
    J(t) && (i = ll({}, Kn(n, e), t)), Hy(n, e, i);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let at = class dm extends _i {
    /**
     * Creates a view element.
     *
     * Attributes can be passed in various formats:
     *
     * ```ts
     * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
     * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
     * new Element( viewDocument, 'div', mapOfAttributes ); // map
     * ```
     *
     * @internal
     * @param document The document instance to which this element belongs.
     * @param name Node name.
     * @param attrs Collection of attributes.
     * @param children A list of nodes to be inserted into created element.
     */
    constructor(e, t, i, s) {
      if (super(e), this._unsafeAttributesToRender = [], this._customProperties = /* @__PURE__ */ new Map(), this.name = t, this._attrs = XC(i), this._children = [], s && this._insertChild(0, s), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
        const o = this._attrs.get("class");
        Yc(this._classes, o), this._attrs.delete("class");
      }
      this._styles = new ca(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"));
    }
    /**
     * Number of element's children.
     */
    get childCount() {
      return this._children.length;
    }
    /**
     * Is `true` if there are no nodes inside this element, `false` otherwise.
     */
    get isEmpty() {
      return this._children.length === 0;
    }
    /**
     * Gets child at the given index.
     *
     * @param index Index of child.
     * @returns Child node.
     */
    getChild(e) {
      return this._children[e];
    }
    /**
     * Gets index of the given child node. Returns `-1` if child node is not found.
     *
     * @param node Child node.
     * @returns Index of the child node.
     */
    getChildIndex(e) {
      return this._children.indexOf(e);
    }
    /**
     * Gets child nodes iterator.
     *
     * @returns Child nodes iterator.
     */
    getChildren() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
     *
     * @returns Keys for attributes.
     */
    *getAttributeKeys() {
      this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
    }
    /**
     * Returns iterator that iterates over this element's attributes.
     *
     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     */
    *getAttributes() {
      yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
    }
    /**
     * Gets attribute by key. If attribute is not present - returns undefined.
     *
     * @param key Attribute key.
     * @returns Attribute value.
     */
    getAttribute(e) {
      if (e == "class")
        return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
      if (e == "style") {
        const t = this._styles.toString();
        return t == "" ? void 0 : t;
      }
      return this._attrs.get(e);
    }
    /**
     * Returns a boolean indicating whether an attribute with the specified key exists in the element.
     *
     * @param key Attribute key.
     * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
     */
    hasAttribute(e) {
      return e == "class" ? this._classes.size > 0 : e == "style" ? !this._styles.isEmpty : this._attrs.has(e);
    }
    /**
     * Checks if this element is similar to other element.
     * Both elements should have the same name and attributes to be considered as similar. Two similar elements
     * can contain different set of children nodes.
     */
    isSimilar(e) {
      if (!(e instanceof dm))
        return !1;
      if (this === e)
        return !0;
      if (this.name != e.name || this._attrs.size !== e._attrs.size || this._classes.size !== e._classes.size || this._styles.size !== e._styles.size)
        return !1;
      for (const [t, i] of this._attrs)
        if (!e._attrs.has(t) || e._attrs.get(t) !== i)
          return !1;
      for (const t of this._classes)
        if (!e._classes.has(t))
          return !1;
      for (const t of this._styles.getStyleNames())
        if (!e._styles.has(t) || e._styles.getAsString(t) !== this._styles.getAsString(t))
          return !1;
      return !0;
    }
    /**
     * Returns true if class is present.
     * If more then one class is provided - returns true only when all classes are present.
     *
     * ```ts
     * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
     * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
     * ```
     */
    hasClass(...e) {
      for (const t of e)
        if (!this._classes.has(t))
          return !1;
      return !0;
    }
    /**
     * Returns iterator that contains all class names.
     */
    getClassNames() {
      return this._classes.keys();
    }
    /**
     * Returns style value for the given property mae.
     * If the style does not exist `undefined` is returned.
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
     *
     * For an element with style set to `'margin:1px'`:
     *
     * ```ts
     * // Enable 'margin' shorthand processing:
     * editor.data.addStyleProcessorRules( addMarginRules );
     *
     * const element = view.change( writer => {
     * 	const element = writer.createElement();
     * 	writer.setStyle( 'margin', '1px' );
     * 	writer.setStyle( 'margin-bottom', '3em' );
     *
     * 	return element;
     * } );
     *
     * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
     * ```
     */
    getStyle(e) {
      return this._styles.getAsString(e);
    }
    /**
     * Returns a normalized style object or single style value.
     *
     * For an element with style set to: margin:1px 2px 3em;
     *
     * ```ts
     * element.getNormalizedStyle( 'margin' ) );
     * ```
     *
     * will return:
     *
     * ```ts
     * {
     * 	top: '1px',
     * 	right: '2px',
     * 	bottom: '3em',
     * 	left: '2px'    // a normalized value from margin shorthand
     * }
     * ```
     *
     * and reading for single style value:
     *
     * ```ts
     * styles.getNormalizedStyle( 'margin-left' );
     * ```
     *
     * Will return a `2px` string.
     *
     * **Note**: This method will return normalized values only if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
     *
     * @param property Name of CSS property
     */
    getNormalizedStyle(e) {
      return this._styles.getNormalized(e);
    }
    /**
     * Returns iterator that contains all style names.
     *
     * @param expand Expand shorthand style properties and return all equivalent style representations.
     */
    getStyleNames(e) {
      return this._styles.getStyleNames(e);
    }
    /**
     * Returns true if style keys are present.
     * If more then one style property is provided - returns true only when all properties are present.
     *
     * ```ts
     * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
     * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
     * ```
     */
    hasStyle(...e) {
      for (const t of e)
        if (!this._styles.has(t))
          return !1;
      return !0;
    }
    /**
     * Returns ancestor element that match specified pattern.
     * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
     *
     * @see module:engine/view/matcher~Matcher
     * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
     * @returns Found element or `null` if no matching ancestor was found.
     */
    findAncestor(...e) {
      const t = new rt(...e);
      let i = this.parent;
      for (; i && !i.is("documentFragment"); ) {
        if (t.match(i))
          return i;
        i = i.parent;
      }
      return null;
    }
    /**
     * Returns the custom property value for the given key.
     */
    getCustomProperty(e) {
      return this._customProperties.get(e);
    }
    /**
     * Returns an iterator which iterates over this element's custom properties.
     * Iterator provides `[ key, value ]` pairs for each stored property.
     */
    *getCustomProperties() {
      yield* this._customProperties.entries();
    }
    /**
     * Returns identity string based on element's name, styles, classes and other attributes.
     * Two elements that {@link #isSimilar are similar} will have same identity string.
     * It has the following format:
     *
     * ```ts
     * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
     * ```
     *
     * For example:
     *
     * ```ts
     * const element = writer.createContainerElement( 'foo', {
     * 	banana: '10',
     * 	apple: '20',
     * 	style: 'color: red; border-color: white;',
     * 	class: 'baz'
     * } );
     *
     * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
     * element.getIdentity();
     * ```
     *
     * **Note**: Classes, styles and other attributes are sorted alphabetically.
     */
    getIdentity() {
      const e = Array.from(this._classes).sort().join(","), t = this._styles.toString(), i = Array.from(this._attrs).map((s) => `${s[0]}="${s[1]}"`).sort().join(" ");
      return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (i == "" ? "" : ` ${i}`);
    }
    /**
     * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
     * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.
     *
     * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.
     *
     * @param attributeName The name of the attribute to be checked.
     */
    shouldRenderUnsafeAttribute(e) {
      return this._unsafeAttributesToRender.includes(e);
    }
    /**
     * Clones provided element.
     *
     * @internal
     * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any children.
     * @returns Clone of this element.
     */
    _clone(e = !1) {
      const t = [];
      if (e)
        for (const s of this.getChildren())
          t.push(s._clone(e));
      const i = new this.constructor(this.document, this.name, this._attrs, t);
      return i._classes = new Set(this._classes), i._styles.set(this._styles.getNormalized()), i._customProperties = new Map(this._customProperties), i.getFillerOffset = this.getFillerOffset, i._unsafeAttributesToRender = this._unsafeAttributesToRender, i;
    }
    /**
     * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node
     * and sets the parent of these nodes to this element.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#insert
     * @internal
     * @param items Items to be inserted.
     * @fires change
     * @returns Number of appended nodes.
     */
    _appendChild(e) {
      return this._insertChild(this.childCount, e);
    }
    /**
     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
     * this element.
     *
     * @internal
     * @see module:engine/view/downcastwriter~DowncastWriter#insert
     * @param index Position where nodes should be inserted.
     * @param items Items to be inserted.
     * @fires change
     * @returns Number of inserted nodes.
     */
    _insertChild(e, t) {
      this._fireChange("children", this);
      let i = 0;
      const s = YC(this.document, t);
      for (const o of s)
        o.parent !== null && o._remove(), o.parent = this, o.document = this.document, this._children.splice(e, 0, o), e++, i++;
      return i;
    }
    /**
     * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#remove
     * @internal
     * @param index Number of the first node to remove.
     * @param howMany Number of nodes to remove.
     * @fires change
     * @returns The array of removed nodes.
     */
    _removeChildren(e, t = 1) {
      this._fireChange("children", this);
      for (let i = e; i < e + t; i++)
        this._children[i].parent = null;
      return this._children.splice(e, t);
    }
    /**
     * Adds or overwrite attribute with a specified key and value.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute
     * @internal
     * @param key Attribute key.
     * @param value Attribute value.
     * @fires change
     */
    _setAttribute(e, t) {
      const i = String(t);
      this._fireChange("attributes", this), e == "class" ? Yc(this._classes, i) : e == "style" ? this._styles.setTo(i) : this._attrs.set(e, i);
    }
    /**
     * Removes attribute from the element.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute
     * @internal
     * @param key Attribute key.
     * @returns Returns true if an attribute existed and has been removed.
     * @fires change
     */
    _removeAttribute(e) {
      return this._fireChange("attributes", this), e == "class" ? this._classes.size > 0 ? (this._classes.clear(), !0) : !1 : e == "style" ? this._styles.isEmpty ? !1 : (this._styles.clear(), !0) : this._attrs.delete(e);
    }
    /**
     * Adds specified class.
     *
     * ```ts
     * element._addClass( 'foo' ); // Adds 'foo' class.
     * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
     * ```
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#addClass
     * @internal
     * @fires change
     */
    _addClass(e) {
      this._fireChange("attributes", this);
      for (const t of Z(e))
        this._classes.add(t);
    }
    /**
     * Removes specified class.
     *
     * ```ts
     * element._removeClass( 'foo' );  // Removes 'foo' class.
     * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
     * ```
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeClass
     * @internal
     * @fires change
     */
    _removeClass(e) {
      this._fireChange("attributes", this);
      for (const t of Z(e))
        this._classes.delete(t);
    }
    _setStyle(e, t) {
      this._fireChange("attributes", this), typeof e != "string" ? this._styles.set(e) : this._styles.set(e, t);
    }
    /**
     * Removes specified style.
     *
     * ```ts
     * element._removeStyle( 'color' );  // Removes 'color' style.
     * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
     * ```
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle
     * @internal
     * @fires change
     */
    _removeStyle(e) {
      this._fireChange("attributes", this);
      for (const t of Z(e))
        this._styles.remove(t);
    }
    /**
     * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
     * so they can be used to add special data to elements.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
     * @internal
     */
    _setCustomProperty(e, t) {
      this._customProperties.set(e, t);
    }
    /**
     * Removes the custom property stored under the given key.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
     * @internal
     * @returns Returns true if property was removed.
     */
    _removeCustomProperty(e) {
      return this._customProperties.delete(e);
    }
  };
  at.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "element" || n === "view:element") : n === "element" || n === "view:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "node" || n === "view:node";
  };
  function XC(n) {
    const e = wt(n);
    for (const [t, i] of e)
      i === null ? e.delete(t) : typeof i != "string" && e.set(t, String(i));
    return e;
  }
  function Yc(n, e) {
    const t = e.split(/\s+/);
    n.clear(), t.forEach((i) => n.add(i));
  }
  function YC(n, e) {
    return typeof e == "string" ? [new ie(n, e)] : (We(e) || (e = [e]), Array.from(e).map((t) => typeof t == "string" ? new ie(n, t) : t instanceof ft ? new ie(n, t.data) : t));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Jn extends at {
    /**
     * Creates a container element.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement
     * @see module:engine/view/element~Element
     * @internal
     * @param document The document instance to which this element belongs.
     * @param name Node name.
     * @param attrs Collection of attributes.
     * @param children A list of nodes to be inserted into created element.
     */
    constructor(e, t, i, s) {
      super(e, t, i, s), this.getFillerOffset = QC;
    }
  }
  Jn.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "containerElement" || n === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "element" || n === "view:element") : n === "containerElement" || n === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "element" || n === "view:element" || n === "node" || n === "view:node";
  };
  function QC() {
    const n = [...this.getChildren()], e = n[this.childCount - 1];
    if (e && e.is("element", "br"))
      return this.childCount;
    for (const t of n)
      if (!t.is("uiElement"))
        return null;
    return this.childCount;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Jo extends $(Jn) {
    /**
     * Creates an editable element.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement
     * @internal
     * @param document The document instance to which this element belongs.
     * @param name Node name.
     * @param attrs Collection of attributes.
     * @param children A list of nodes to be inserted into created element.
     */
    constructor(e, t, i, s) {
      super(e, t, i, s), this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("placeholder", void 0), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", (o) => o && e.selection.editableElement == this), this.listenTo(e.selection, "change", () => {
        this.isFocused = e.isFocused && e.selection.editableElement == this;
      });
    }
    destroy() {
      this.stopListening();
    }
  }
  Jo.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "editableElement" || n === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "containerElement" || n === "view:containerElement" || n === "element" || n === "view:element") : n === "editableElement" || n === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "containerElement" || n === "view:containerElement" || n === "element" || n === "view:element" || n === "node" || n === "view:node";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Qc = Symbol("rootName");
  class hm extends Jo {
    /**
     * Creates root editable element.
     *
     * @param document The document instance to which this element belongs.
     * @param name Node name.
     */
    constructor(e, t) {
      super(e, t), this.rootName = "main";
    }
    /**
     * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no
     * other name is set, `main` name is used.
     *
     * @readonly
     */
    get rootName() {
      return this.getCustomProperty(Qc);
    }
    set rootName(e) {
      this._setCustomProperty(Qc, e);
    }
    /**
     * Overrides old element name and sets new one.
     * This is needed because view roots are created before they are attached to the DOM.
     * The name of the root element is temporary at this stage. It has to be changed when the
     * view root element is attached to the DOM element.
     *
     * @internal
     * @param name The new name of element.
     */
    set _name(e) {
      this.name = e;
    }
  }
  hm.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "rootElement" || n === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "editableElement" || n === "view:editableElement" || n === "containerElement" || n === "view:containerElement" || n === "element" || n === "view:element") : n === "rootElement" || n === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "editableElement" || n === "view:editableElement" || n === "containerElement" || n === "view:containerElement" || n === "element" || n === "view:element" || n === "node" || n === "view:node";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let si = class {
    /**
     * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
     *
     * @param options Object with configuration.
     */
    constructor(e = {}) {
      if (!e.boundaries && !e.startPosition)
        throw new g("view-tree-walker-no-start-position", null);
      if (e.direction && e.direction != "forward" && e.direction != "backward")
        throw new g("view-tree-walker-unknown-direction", e.startPosition, { direction: e.direction });
      this.boundaries = e.boundaries || null, e.startPosition ? this._position = k._createAt(e.startPosition) : this._position = k._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]), this.direction = e.direction || "forward", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
    }
    /**
     * Iterable interface.
     */
    [Symbol.iterator]() {
      return this;
    }
    /**
     * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
     * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
     */
    get position() {
      return this._position;
    }
    /**
     * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
     *
     * For example:
     *
     * ```ts
     * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
     * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
     * walker.skip( value => false ); // Do not move the position.
     * ```
     *
     * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
     * return `true` if the value should be skipped or `false` if not.
     */
    skip(e) {
      let t, i;
      do
        i = this.position, t = this.next();
      while (!t.done && e(t.value));
      t.done || (this._position = i);
    }
    /**
     * Gets the next tree walker's value.
     *
     * @returns Object implementing iterator interface, returning
     * information about taken step.
     */
    next() {
      return this.direction == "forward" ? this._next() : this._previous();
    }
    /**
     * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
     */
    _next() {
      let e = this.position.clone();
      const t = this.position, i = e.parent;
      if (i.parent === null && e.offset === i.childCount)
        return { done: !0, value: void 0 };
      if (i === this._boundaryEndParent && e.offset == this.boundaries.end.offset)
        return { done: !0, value: void 0 };
      let s;
      if (i instanceof ie) {
        if (e.isAtEnd)
          return this._position = k._createAfter(i), this._next();
        s = i.data[e.offset];
      } else
        s = i.getChild(e.offset);
      if (s instanceof at) {
        if (!this.shallow)
          e = new k(s, 0);
        else {
          if (this.boundaries && this.boundaries.end.isBefore(e))
            return { done: !0, value: void 0 };
          e.offset++;
        }
        return this._position = e, this._formatReturnValue("elementStart", s, t, e, 1);
      }
      if (s instanceof ie) {
        if (this.singleCharacters)
          return e = new k(s, 0), this._position = e, this._next();
        let o = s.data.length, r;
        return s == this._boundaryEndParent ? (o = this.boundaries.end.offset, r = new ft(s, 0, o), e = k._createAfter(r)) : (r = new ft(s, 0, s.data.length), e.offset++), this._position = e, this._formatReturnValue("text", r, t, e, o);
      }
      if (typeof s == "string") {
        let o;
        this.singleCharacters ? o = 1 : o = (i === this._boundaryEndParent ? this.boundaries.end.offset : i.data.length) - e.offset;
        const r = new ft(i, e.offset, o);
        return e.offset += o, this._position = e, this._formatReturnValue("text", r, t, e, o);
      }
      return e = k._createAfter(i), this._position = e, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", i, t, e);
    }
    /**
     * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
     */
    _previous() {
      let e = this.position.clone();
      const t = this.position, i = e.parent;
      if (i.parent === null && e.offset === 0)
        return { done: !0, value: void 0 };
      if (i == this._boundaryStartParent && e.offset == this.boundaries.start.offset)
        return { done: !0, value: void 0 };
      let s;
      if (i instanceof ie) {
        if (e.isAtStart)
          return this._position = k._createBefore(i), this._previous();
        s = i.data[e.offset - 1];
      } else
        s = i.getChild(e.offset - 1);
      if (s instanceof at)
        return this.shallow ? (e.offset--, this._position = e, this._formatReturnValue("elementStart", s, t, e, 1)) : (e = new k(s, s.childCount), this._position = e, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", s, t, e));
      if (s instanceof ie) {
        if (this.singleCharacters)
          return e = new k(s, s.data.length), this._position = e, this._previous();
        let o = s.data.length, r;
        if (s == this._boundaryStartParent) {
          const a = this.boundaries.start.offset;
          r = new ft(s, a, s.data.length - a), o = r.data.length, e = k._createBefore(r);
        } else
          r = new ft(s, 0, s.data.length), e.offset--;
        return this._position = e, this._formatReturnValue("text", r, t, e, o);
      }
      if (typeof s == "string") {
        let o;
        if (this.singleCharacters)
          o = 1;
        else {
          const a = i === this._boundaryStartParent ? this.boundaries.start.offset : 0;
          o = e.offset - a;
        }
        e.offset -= o;
        const r = new ft(i, e.offset, o);
        return this._position = e, this._formatReturnValue("text", r, t, e, o);
      }
      return e = k._createBefore(i), this._position = e, this._formatReturnValue("elementStart", i, t, e, 1);
    }
    /**
     * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
     *
     * @param type Type of step.
     * @param item Item between old and new position.
     * @param previousPosition Previous position of iterator.
     * @param nextPosition Next position of iterator.
     * @param length Length of the item.
     */
    _formatReturnValue(e, t, i, s, o) {
      return t instanceof ft && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position)) ? (s = k._createAfter(t.textNode), this._position = s) : i = k._createAfter(t.textNode)), t.offsetInText === 0 && (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position)) ? (s = k._createBefore(t.textNode), this._position = s) : i = k._createBefore(t.textNode))), {
        done: !1,
        value: {
          type: e,
          item: t,
          previousPosition: i,
          nextPosition: s,
          length: o
        }
      };
    }
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let k = class Ct extends bi {
    /**
     * Creates a position.
     *
     * @param parent Position parent.
     * @param offset Position offset.
     */
    constructor(e, t) {
      super(), this.parent = e, this.offset = t;
    }
    /**
     * Node directly after the position. Equals `null` when there is no node after position or position is located
     * inside text node.
     */
    get nodeAfter() {
      return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
    }
    /**
     * Node directly before the position. Equals `null` when there is no node before position or position is located
     * inside text node.
     */
    get nodeBefore() {
      return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
    }
    /**
     * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
     */
    get isAtStart() {
      return this.offset === 0;
    }
    /**
     * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
     */
    get isAtEnd() {
      const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
      return this.offset === e;
    }
    /**
     * Position's root, that is the root of the position's parent element.
     */
    get root() {
      return this.parent.root;
    }
    /**
     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
     * position is not inside an editable element.
     */
    get editableElement() {
      let e = this.parent;
      for (; !(e instanceof Jo); )
        if (e.parent)
          e = e.parent;
        else
          return null;
      return e;
    }
    /**
     * Returns a new instance of Position with offset incremented by `shift` value.
     *
     * @param shift How position offset should get changed. Accepts negative values.
     * @returns Shifted position.
     */
    getShiftedBy(e) {
      const t = Ct._createAt(this), i = t.offset + e;
      return t.offset = i < 0 ? 0 : i, t;
    }
    /**
     * Gets the farthest position which matches the callback using
     * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
     *
     * For example:
     *
     * ```ts
     * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
     * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
     * getLastMatchingPosition( value => false ); // Do not move the position.
     * ```
     *
     * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
     * return `true` if the value should be skipped or `false` if not.
     * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
     * @returns The position after the last item which matches the `skip` callback test.
     */
    getLastMatchingPosition(e, t = {}) {
      t.startPosition = this;
      const i = new si(t);
      return i.skip(e), i.position;
    }
    /**
     * Returns ancestors array of this position, that is this position's parent and it's ancestors.
     *
     * @returns Array with ancestors.
     */
    getAncestors() {
      return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
    }
    /**
     * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
     * which is a common ancestor of both positions.
     */
    getCommonAncestor(e) {
      const t = this.getAncestors(), i = e.getAncestors();
      let s = 0;
      for (; t[s] == i[s] && t[s]; )
        s++;
      return s === 0 ? null : t[s - 1];
    }
    /**
     * Checks whether this position equals given position.
     *
     * @param otherPosition Position to compare with.
     * @returns True if positions are same.
     */
    isEqual(e) {
      return this.parent == e.parent && this.offset == e.offset;
    }
    /**
     * Checks whether this position is located before given position. When method returns `false` it does not mean that
     * this position is after give one. Two positions may be located inside separate roots and in that situation this
     * method will still return `false`.
     *
     * @see module:engine/view/position~Position#isAfter
     * @see module:engine/view/position~Position#compareWith
     * @param otherPosition Position to compare with.
     * @returns Returns `true` if this position is before given position.
     */
    isBefore(e) {
      return this.compareWith(e) == "before";
    }
    /**
     * Checks whether this position is located after given position. When method returns `false` it does not mean that
     * this position is before give one. Two positions may be located inside separate roots and in that situation this
     * method will still return `false`.
     *
     * @see module:engine/view/position~Position#isBefore
     * @see module:engine/view/position~Position#compareWith
     * @param otherPosition Position to compare with.
     * @returns Returns `true` if this position is after given position.
     */
    isAfter(e) {
      return this.compareWith(e) == "after";
    }
    /**
     * Checks whether this position is before, after or in same position that other position. Two positions may be also
     * different when they are located in separate roots.
     *
     * @param otherPosition Position to compare with.
     */
    compareWith(e) {
      if (this.root !== e.root)
        return "different";
      if (this.isEqual(e))
        return "same";
      const t = this.parent.is("node") ? this.parent.getPath() : [], i = e.parent.is("node") ? e.parent.getPath() : [];
      t.push(this.offset), i.push(e.offset);
      const s = Ee(t, i);
      switch (s) {
        case "prefix":
          return "before";
        case "extension":
          return "after";
        default:
          return t[s] < i[s] ? "before" : "after";
      }
    }
    /**
     * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.
     *
     * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}
     */
    getWalker(e = {}) {
      return e.startPosition = this, new si(e);
    }
    /**
     * Clones this position.
     */
    clone() {
      return new Ct(this.parent, this.offset);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/view/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
     *
     * This method is a shortcut to other constructors such as:
     *
     * * {@link module:engine/view/position~Position._createBefore},
     * * {@link module:engine/view/position~Position._createAfter}.
     *
     * @internal
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
     */
    static _createAt(e, t) {
      if (e instanceof Ct)
        return new this(e.parent, e.offset);
      {
        const i = e;
        if (t == "end")
          t = i.is("$text") ? i.data.length : i.childCount;
        else {
          if (t == "before")
            return this._createBefore(i);
          if (t == "after")
            return this._createAfter(i);
          if (t !== 0 && !t)
            throw new g("view-createpositionat-offset-required", i);
        }
        return new Ct(i, t);
      }
    }
    /**
     * Creates a new position after given view item.
     *
     * @internal
     * @param item View item after which the position should be located.
     */
    static _createAfter(e) {
      if (e.is("$textProxy"))
        return new Ct(e.textNode, e.offsetInText + e.data.length);
      if (!e.parent)
        throw new g("view-position-after-root", e, { root: e });
      return new Ct(e.parent, e.index + 1);
    }
    /**
     * Creates a new position before given view item.
     *
     * @internal
     * @param item View item before which the position should be located.
     */
    static _createBefore(e) {
      if (e.is("$textProxy"))
        return new Ct(e.textNode, e.offsetInText);
      if (!e.parent)
        throw new g("view-position-before-root", e, { root: e });
      return new Ct(e.parent, e.index);
    }
  };
  k.prototype.is = function(n) {
    return n === "position" || n === "view:position";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let N = class Nt extends bi {
    /**
     * Creates a range spanning from `start` position to `end` position.
     *
     * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
     *
     * @param start Start position.
     * @param end End position. If not set, range will be collapsed at the `start` position.
     */
    constructor(e, t = null) {
      super(), this.start = e.clone(), this.end = t ? t.clone() : e.clone();
    }
    /**
     * Iterable interface.
     *
     * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
     * them together with additional information like length or {@link module:engine/view/position~Position positions},
     * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
     *
     * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
     * `ignoreElementEnd` option
     * set to `true`.
     */
    *[Symbol.iterator]() {
      yield* new si({ boundaries: this, ignoreElementEnd: !0 });
    }
    /**
     * Returns whether the range is collapsed, that is it start and end positions are equal.
     */
    get isCollapsed() {
      return this.start.isEqual(this.end);
    }
    /**
     * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
     * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
     */
    get isFlat() {
      return this.start.parent === this.end.parent;
    }
    /**
     * Range root element.
     */
    get root() {
      return this.start.root;
    }
    /**
     * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
     * and at the end).
     *
     * For example:
     *
     * ```html
     * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
     * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
     * ```
     *
     * Note that in the sample above:
     *
     * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
     * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
     * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
     *
     * @returns Enlarged range.
     */
    getEnlarged() {
      let e = this.start.getLastMatchingPosition(Ps, { direction: "backward" }), t = this.end.getLastMatchingPosition(Ps);
      return e.parent.is("$text") && e.isAtStart && (e = k._createBefore(e.parent)), t.parent.is("$text") && t.isAtEnd && (t = k._createAfter(t.parent)), new Nt(e, t);
    }
    /**
     * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
     * and at the end).
     *
     * For example:
     *
     * ```html
     * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
     * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
     * ```
     *
     * Note that in the sample above:
     *
     * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
     * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
     * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
     *
     * @returns Shrunk range.
     */
    getTrimmed() {
      let e = this.start.getLastMatchingPosition(Ps);
      if (e.isAfter(this.end) || e.isEqual(this.end))
        return new Nt(e, e);
      let t = this.end.getLastMatchingPosition(Ps, { direction: "backward" });
      const i = e.nodeAfter, s = t.nodeBefore;
      return i && i.is("$text") && (e = new k(i, 0)), s && s.is("$text") && (t = new k(s, s.data.length)), new Nt(e, t);
    }
    /**
     * Two ranges are equal if their start and end positions are equal.
     *
     * @param otherRange Range to compare with.
     * @returns `true` if ranges are equal, `false` otherwise
     */
    isEqual(e) {
      return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end);
    }
    /**
     * Checks whether this range contains given {@link module:engine/view/position~Position position}.
     *
     * @param position Position to check.
     * @returns `true` if given {@link module:engine/view/position~Position position} is contained in this range, `false` otherwise.
     */
    containsPosition(e) {
      return e.isAfter(this.start) && e.isBefore(this.end);
    }
    /**
     * Checks whether this range contains given {@link module:engine/view/range~Range range}.
     *
     * @param otherRange Range to check.
     * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
     * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
     * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
     * @returns `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
     * otherwise.
     */
    containsRange(e, t = !1) {
      e.isCollapsed && (t = !1);
      const i = this.containsPosition(e.start) || t && this.start.isEqual(e.start), s = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
      return i && s;
    }
    /**
     * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
     * {@link module:engine/view/range~Range range}.
     * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
     *
     * Examples:
     *
     * ```ts
     * let foo = downcastWriter.createText( 'foo' );
     * let img = downcastWriter.createContainerElement( 'img' );
     * let bar = downcastWriter.createText( 'bar' );
     * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
     *
     * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
     * let otherRange = view.createRange( // "oo", img, "ba" are in range.
     * 	view.createPositionAt( foo, 1 ),
     * 	view.createPositionAt( bar, 2 )
     * );
     * let transformed = range.getDifference( otherRange );
     * // transformed array has no ranges because `otherRange` contains `range`
     *
     * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
     * transformed = range.getDifference( otherRange );
     * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
     *
     * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
     * transformed = range.getDifference( otherRange );
     * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
     * ```
     *
     * @param otherRange Range to differentiate against.
     * @returns The difference between ranges.
     */
    getDifference(e) {
      const t = [];
      return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new Nt(this.start, e.start)), this.containsPosition(e.end) && t.push(new Nt(e.end, this.end))) : t.push(this.clone()), t;
    }
    /**
     * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
     * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
     *
     * Examples:
     *
     * ```ts
     * let foo = downcastWriter.createText( 'foo' );
     * let img = downcastWriter.createContainerElement( 'img' );
     * let bar = downcastWriter.createText( 'bar' );
     * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
     *
     * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
     * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
     * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
     *
     * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
     * transformed = range.getIntersection( otherRange ); // null - no common part.
     * ```
     *
     * @param otherRange Range to check for intersection.
     * @returns A common part of given ranges or `null` if ranges have no common part.
     */
    getIntersection(e) {
      if (this.isIntersecting(e)) {
        let t = this.start, i = this.end;
        return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (i = e.end), new Nt(t, i);
      }
      return null;
    }
    /**
     * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
     *
     * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
     */
    getWalker(e = {}) {
      return e.boundaries = this, new si(e);
    }
    /**
     * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
     * which is a common ancestor of range's both ends (in which the entire range is contained).
     */
    getCommonAncestor() {
      return this.start.getCommonAncestor(this.end);
    }
    /**
     * Returns an {@link module:engine/view/element~Element Element} contained by the range.
     * The element will be returned when it is the **only** node within the range and **fully–contained**
     * at the same time.
     */
    getContainedElement() {
      if (this.isCollapsed)
        return null;
      let e = this.start.nodeAfter, t = this.end.nodeBefore;
      return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling), e && e.is("element") && e === t ? e : null;
    }
    /**
     * Clones this range.
     */
    clone() {
      return new Nt(this.start, this.end);
    }
    /**
     * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
     * them.
     *
     * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
     * set to `true`. However it returns only {@link module:engine/view/item~Item items},
     * not {@link module:engine/view/treewalker~TreeWalkerValue}.
     *
     * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
     * a full list of available options.
     *
     * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
     */
    *getItems(e = {}) {
      e.boundaries = this, e.ignoreElementEnd = !0;
      const t = new si(e);
      for (const i of t)
        yield i.item;
    }
    /**
     * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
     * contained in this range.
     *
     * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
     * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
     *
     * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
     * a full list of available options.
     *
     * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
     */
    *getPositions(e = {}) {
      e.boundaries = this;
      const t = new si(e);
      yield t.position;
      for (const i of t)
        yield i.nextPosition;
    }
    /**
     * Checks and returns whether this range intersects with the given range.
     *
     * @param otherRange Range to compare with.
     * @returns True if ranges intersect.
     */
    isIntersecting(e) {
      return this.start.isBefore(e.end) && this.end.isAfter(e.start);
    }
    /**
     * Creates a range from the given parents and offsets.
     *
     * @internal
     * @param startElement Start position parent element.
     * @param startOffset Start position offset.
     * @param endElement End position parent element.
     * @param endOffset End position offset.
     * @returns Created range.
     */
    static _createFromParentsAndOffsets(e, t, i, s) {
      return new this(new k(e, t), new k(i, s));
    }
    /**
     * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
     * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
     *
     * @internal
     * @param position Beginning of the range.
     * @param shift How long the range should be.
     */
    static _createFromPositionAndShift(e, t) {
      const i = e, s = e.getShiftedBy(t);
      return t > 0 ? new this(i, s) : new this(s, i);
    }
    /**
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @internal
     * @param element Element which is a parent for the range.
     */
    static _createIn(e) {
      return this._createFromParentsAndOffsets(e, 0, e, e.childCount);
    }
    /**
     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
     *
     * @internal
     */
    static _createOn(e) {
      const t = e.is("$textProxy") ? e.offsetSize : 1;
      return this._createFromPositionAndShift(k._createBefore(e), t);
    }
  };
  N.prototype.is = function(n) {
    return n === "range" || n === "view:range";
  };
  function Ps(n) {
    return !!(n.item.is("attributeElement") || n.item.is("uiElement"));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let St = class fm extends G(bi) {
    /**
     * Creates new selection instance.
     *
     * **Note**: The selection constructor is available as a factory method:
     *
     * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
     * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
     *
     * ```ts
     * // Creates empty selection without ranges.
     * const selection = writer.createSelection();
     *
     * // Creates selection at the given range.
     * const range = writer.createRange( start, end );
     * const selection = writer.createSelection( range );
     *
     * // Creates selection at the given ranges
     * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     * const selection = writer.createSelection( ranges );
     *
     * // Creates selection from the other selection.
     * const otherSelection = writer.createSelection();
     * const selection = writer.createSelection( otherSelection );
     *
     * // Creates selection from the document selection.
     * const selection = writer.createSelection( editor.editing.view.document.selection );
     *
     * // Creates selection at the given position.
     * const position = writer.createPositionFromPath( root, path );
     * const selection = writer.createSelection( position );
     *
     * // Creates collapsed selection at the position of given item and offset.
     * const paragraph = writer.createContainerElement( 'paragraph' );
     * const selection = writer.createSelection( paragraph, offset );
     *
     * // Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
     * // first child of that element and ends after the last child of that element.
     * const selection = writer.createSelection( paragraph, 'in' );
     *
     * // Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
     * // just after the item.
     * const selection = writer.createSelection( paragraph, 'on' );
     * ```
     *
     * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
     *
     * ```ts
     * // Creates backward selection.
     * const selection = writer.createSelection( range, { backward: true } );
     * ```
     *
     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
     * represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
     * (and be  properly handled by screen readers).
     *
     * ```ts
     * // Creates fake selection with label.
     * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
     * ```
     *
     * @internal
     */
    constructor(...e) {
      super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", e.length && this.setTo(...e);
    }
    /**
     * Returns true if selection instance is marked as `fake`.
     *
     * @see #setTo
     */
    get isFake() {
      return this._isFake;
    }
    /**
     * Returns fake selection label.
     *
     * @see #setTo
     */
    get fakeSelectionLabel() {
      return this._fakeSelectionLabel;
    }
    /**
     * Selection anchor. Anchor may be described as a position where the selection starts. Together with
     * {@link #focus focus} they define the direction of selection, which is important
     * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
     * It may be a bit unintuitive when there are multiple ranges in selection.
     *
     * @see #focus
     */
    get anchor() {
      if (!this._ranges.length)
        return null;
      const e = this._ranges[this._ranges.length - 1];
      return (this._lastRangeBackward ? e.end : e.start).clone();
    }
    /**
     * Selection focus. Focus is a position where the selection ends.
     *
     * @see #anchor
     */
    get focus() {
      if (!this._ranges.length)
        return null;
      const e = this._ranges[this._ranges.length - 1];
      return (this._lastRangeBackward ? e.start : e.end).clone();
    }
    /**
     * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
     * collapsed.
     */
    get isCollapsed() {
      return this.rangeCount === 1 && this._ranges[0].isCollapsed;
    }
    /**
     * Returns number of ranges in selection.
     */
    get rangeCount() {
      return this._ranges.length;
    }
    /**
     * Specifies whether the {@link #focus} precedes {@link #anchor}.
     */
    get isBackward() {
      return !this.isCollapsed && this._lastRangeBackward;
    }
    /**
     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
     * if the selection is not inside an editable element.
     */
    get editableElement() {
      return this.anchor ? this.anchor.editableElement : null;
    }
    /**
     * Returns an iterable that contains copies of all ranges added to the selection.
     */
    *getRanges() {
      for (const e of this._ranges)
        yield e.clone();
    }
    /**
     * Returns copy of the first range in the selection. First range is the one which
     * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
     * position of all other ranges (not to confuse with the first range added to the selection).
     * Returns `null` if no ranges are added to selection.
     */
    getFirstRange() {
      let e = null;
      for (const t of this._ranges)
        (!e || t.start.isBefore(e.start)) && (e = t);
      return e ? e.clone() : null;
    }
    /**
     * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
     * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
     * with the last range added to the selection). Returns `null` if no ranges are added to selection.
     */
    getLastRange() {
      let e = null;
      for (const t of this._ranges)
        (!e || t.end.isAfter(e.end)) && (e = t);
      return e ? e.clone() : null;
    }
    /**
     * Returns copy of the first position in the selection. First position is the position that
     * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
     * Returns `null` if no ranges are added to selection.
     */
    getFirstPosition() {
      const e = this.getFirstRange();
      return e ? e.start.clone() : null;
    }
    /**
     * Returns copy of the last position in the selection. Last position is the position that
     * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
     * Returns `null` if no ranges are added to selection.
     */
    getLastPosition() {
      const e = this.getLastRange();
      return e ? e.end.clone() : null;
    }
    /**
     * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
     * same number of ranges and all ranges from one selection equal to a range from other selection.
     *
     * @param otherSelection Selection to compare with.
     * @returns `true` if selections are equal, `false` otherwise.
     */
    isEqual(e) {
      if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount)
        return !1;
      if (this.rangeCount === 0)
        return !0;
      if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
        return !1;
      for (const t of this._ranges) {
        let i = !1;
        for (const s of e._ranges)
          if (t.isEqual(s)) {
            i = !0;
            break;
          }
        if (!i)
          return !1;
      }
      return !0;
    }
    /**
     * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
     * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
     * equal to any trimmed range from other selection.
     *
     * @param otherSelection Selection to compare with.
     * @returns `true` if selections are similar, `false` otherwise.
     */
    isSimilar(e) {
      if (this.isBackward != e.isBackward)
        return !1;
      const t = oa(this.getRanges()), i = oa(e.getRanges());
      if (t != i)
        return !1;
      if (t == 0)
        return !0;
      for (let s of this.getRanges()) {
        s = s.getTrimmed();
        let o = !1;
        for (let r of e.getRanges())
          if (r = r.getTrimmed(), s.start.isEqual(r.start) && s.end.isEqual(r.end)) {
            o = !0;
            break;
          }
        if (!o)
          return !1;
      }
      return !0;
    }
    /**
     * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
     * one range in the selection, and that range contains exactly one element.
     * Returns `null` if there is no selected element.
     */
    getSelectedElement() {
      return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
    }
    /**
     * Sets this selection's ranges and direction to the specified location based on the given
     * {@link module:engine/view/selection~Selectable selectable}.
     *
     * ```ts
     * // Sets selection to the given range.
     * const range = writer.createRange( start, end );
     * selection.setTo( range );
     *
     * // Sets selection to given ranges.
     * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     * selection.setTo( range );
     *
     * // Sets selection to the other selection.
     * const otherSelection = writer.createSelection();
     * selection.setTo( otherSelection );
     *
     * // Sets selection to contents of DocumentSelection.
     * selection.setTo( editor.editing.view.document.selection );
     *
     * // Sets collapsed selection at the given position.
     * const position = writer.createPositionAt( root, path );
     * selection.setTo( position );
     *
     * // Sets collapsed selection at the position of given item and offset.
     * selection.setTo( paragraph, offset );
     * ```
     *
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * ```ts
     * selection.setTo( paragraph, 'in' );
     * ```
     *
     * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
     *
     * ```ts
     * selection.setTo( paragraph, 'on' );
     *
     * // Clears selection. Removes all ranges.
     * selection.setTo( null );
     * ```
     *
     * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
     *
     * ```ts
     * // Sets selection as backward.
     * selection.setTo( range, { backward: true } );
     * ```
     *
     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
     * represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
     * (and be  properly handled by screen readers).
     *
     * ```ts
     * // Creates fake selection with label.
     * selection.setTo( range, { fake: true, label: 'foo' } );
     * ```
     *
     * @fires change
     */
    setTo(...e) {
      let [t, i, s] = e;
      if (typeof i == "object" && (s = i, i = void 0), t === null)
        this._setRanges([]), this._setFakeOptions(s);
      else if (t instanceof fm || t instanceof pl)
        this._setRanges(t.getRanges(), t.isBackward), this._setFakeOptions({ fake: t.isFake, label: t.fakeSelectionLabel });
      else if (t instanceof N)
        this._setRanges([t], s && s.backward), this._setFakeOptions(s);
      else if (t instanceof k)
        this._setRanges([new N(t)]), this._setFakeOptions(s);
      else if (t instanceof _i) {
        const o = !!s && !!s.backward;
        let r;
        if (i === void 0)
          throw new g("view-selection-setto-required-second-parameter", this);
        i == "in" ? r = N._createIn(t) : i == "on" ? r = N._createOn(t) : r = new N(k._createAt(t, i)), this._setRanges([r], o), this._setFakeOptions(s);
      } else if (We(t))
        this._setRanges(t, s && s.backward), this._setFakeOptions(s);
      else
        throw new g("view-selection-setto-not-selectable", this);
      this.fire("change");
    }
    /**
     * Moves {@link #focus} to the specified location.
     *
     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
     * parameters.
     *
     * @fires change
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
     */
    setFocus(e, t) {
      if (this.anchor === null)
        throw new g("view-selection-setfocus-no-ranges", this);
      const i = k._createAt(e, t);
      if (i.compareWith(this.focus) == "same")
        return;
      const s = this.anchor;
      this._ranges.pop(), i.compareWith(s) == "before" ? this._addRange(new N(i, s), !0) : this._addRange(new N(s, i)), this.fire("change");
    }
    /**
     * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
     * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
     * Accepts a flag describing in which way the selection is made.
     *
     * @param newRanges Iterable object of ranges to set.
     * @param isLastBackward Flag describing if last added range was selected forward - from start to end
     * (`false`) or backward - from end to start (`true`). Defaults to `false`.
     */
    _setRanges(e, t = !1) {
      e = Array.from(e), this._ranges = [];
      for (const i of e)
        this._addRange(i);
      this._lastRangeBackward = !!t;
    }
    /**
     * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
     * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
     * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
     * properly handled by screen readers).
     */
    _setFakeOptions(e = {}) {
      this._isFake = !!e.fake, this._fakeSelectionLabel = e.fake && e.label || "";
    }
    /**
     * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
     * selection instance and you can safely operate on it.
     *
     * Accepts a flag describing in which way the selection is made - passed range might be selected from
     * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
     * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
     * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
     * with ranges already stored in Selection instance.
     */
    _addRange(e, t = !1) {
      if (!(e instanceof N))
        throw new g("view-selection-add-range-not-range", this);
      this._pushRange(e), this._lastRangeBackward = !!t;
    }
    /**
     * Adds range to selection - creates copy of given range so it can be safely used and modified.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
     * with ranges already stored in selection instance.
     */
    _pushRange(e) {
      for (const t of this._ranges)
        if (e.isIntersecting(t))
          throw new g("view-selection-range-intersects", this, { addedRange: e, intersectingRange: t });
      this._ranges.push(new N(e.start, e.end));
    }
  };
  St.prototype.is = function(n) {
    return n === "selection" || n === "view:selection";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let pl = class extends G(bi) {
    constructor(...e) {
      super(), this._selection = new St(), this._selection.delegate("change").to(this), e.length && this._selection.setTo(...e);
    }
    /**
     * Returns true if selection instance is marked as `fake`.
     *
     * @see #_setTo
     */
    get isFake() {
      return this._selection.isFake;
    }
    /**
     * Returns fake selection label.
     *
     * @see #_setTo
     */
    get fakeSelectionLabel() {
      return this._selection.fakeSelectionLabel;
    }
    /**
     * Selection anchor. Anchor may be described as a position where the selection starts. Together with
     * {@link #focus focus} they define the direction of selection, which is important
     * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
     * It may be a bit unintuitive when there are multiple ranges in selection.
     *
     * @see #focus
     */
    get anchor() {
      return this._selection.anchor;
    }
    /**
     * Selection focus. Focus is a position where the selection ends.
     *
     * @see #anchor
     */
    get focus() {
      return this._selection.focus;
    }
    /**
     * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
     * collapsed.
     */
    get isCollapsed() {
      return this._selection.isCollapsed;
    }
    /**
     * Returns number of ranges in selection.
     */
    get rangeCount() {
      return this._selection.rangeCount;
    }
    /**
     * Specifies whether the {@link #focus} precedes {@link #anchor}.
     */
    get isBackward() {
      return this._selection.isBackward;
    }
    /**
     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
     * if the selection is not inside an editable element.
     */
    get editableElement() {
      return this._selection.editableElement;
    }
    /**
     * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.
     *
     * @internal
     */
    get _ranges() {
      return this._selection._ranges;
    }
    /**
     * Returns an iterable that contains copies of all ranges added to the selection.
     */
    *getRanges() {
      yield* this._selection.getRanges();
    }
    /**
     * Returns copy of the first range in the selection. First range is the one which
     * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
     * position of all other ranges (not to confuse with the first range added to the selection).
     * Returns `null` if no ranges are added to selection.
     */
    getFirstRange() {
      return this._selection.getFirstRange();
    }
    /**
     * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
     * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
     * with the last range added to the selection). Returns `null` if no ranges are added to selection.
     */
    getLastRange() {
      return this._selection.getLastRange();
    }
    /**
     * Returns copy of the first position in the selection. First position is the position that
     * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
     * Returns `null` if no ranges are added to selection.
     */
    getFirstPosition() {
      return this._selection.getFirstPosition();
    }
    /**
     * Returns copy of the last position in the selection. Last position is the position that
     * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
     * Returns `null` if no ranges are added to selection.
     */
    getLastPosition() {
      return this._selection.getLastPosition();
    }
    /**
     * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
     * one range in the selection, and that range contains exactly one element.
     * Returns `null` if there is no selected element.
     */
    getSelectedElement() {
      return this._selection.getSelectedElement();
    }
    /**
     * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
     * same number of ranges and all ranges from one selection equal to a range from other selection.
     *
     * @param otherSelection Selection to compare with.
     * @returns `true` if selections are equal, `false` otherwise.
     */
    isEqual(e) {
      return this._selection.isEqual(e);
    }
    /**
     * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
     * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
     * equal to any trimmed range from other selection.
     *
     * @param otherSelection Selection to compare with.
     * @returns `true` if selections are similar, `false` otherwise.
     */
    isSimilar(e) {
      return this._selection.isSimilar(e);
    }
    /**
     * Sets this selection's ranges and direction to the specified location based on the given
     * {@link module:engine/view/selection~Selectable selectable}.
     *
     * ```ts
     * // Sets selection to the given range.
     * const range = writer.createRange( start, end );
     * documentSelection._setTo( range );
     *
     * // Sets selection to given ranges.
     * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
     * documentSelection._setTo( range );
     *
     * // Sets selection to the other selection.
     * const otherSelection = writer.createSelection();
     * documentSelection._setTo( otherSelection );
     *
     * // Sets collapsed selection at the given position.
     * const position = writer.createPositionAt( root, offset );
     * documentSelection._setTo( position );
     *
     * // Sets collapsed selection at the position of given item and offset.
     * documentSelection._setTo( paragraph, offset );
     * ```
     *
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * ```ts
     * documentSelection._setTo( paragraph, 'in' );
     * ```
     *
     * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
     *
     * ```ts
     * documentSelection._setTo( paragraph, 'on' );
     *
     * // Clears selection. Removes all ranges.
     * documentSelection._setTo( null );
     * ```
     *
     * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
     *
     * ```ts
     * // Sets selection as backward.
     * documentSelection._setTo( range, { backward: true } );
     * ```
     *
     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
     * represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
     * (and be  properly handled by screen readers).
     *
     * ```ts
     * // Creates fake selection with label.
     * documentSelection._setTo( range, { fake: true, label: 'foo' } );
     * ```
     *
     * @internal
     * @fires change
     */
    _setTo(...e) {
      this._selection.setTo(...e);
    }
    /**
     * Moves {@link #focus} to the specified location.
     *
     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
     * parameters.
     *
     * @internal
     * @fires change
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
     */
    _setFocus(e, t) {
      this._selection.setFocus(e, t);
    }
  };
  pl.prototype.is = function(n) {
    return n === "selection" || n == "documentSelection" || n == "view:selection" || n == "view:documentSelection";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class hn extends Pt {
    /**
     * @param source The emitter.
     * @param name The event name.
     * @param startRange The view range that the bubbling should start from.
     */
    constructor(e, t, i) {
      super(e, t), this.startRange = i, this._eventPhase = "none", this._currentTarget = null;
    }
    /**
     * The current event phase.
     */
    get eventPhase() {
      return this._eventPhase;
    }
    /**
     * The current bubbling target.
     */
    get currentTarget() {
      return this._currentTarget;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const kr = Symbol("bubbling contexts");
  function da(n) {
    class e extends n {
      fire(i, ...s) {
        try {
          const o = i instanceof Pt ? i : new Pt(this, i), r = Tr(this);
          if (!r.size)
            return;
          if (wn(o, "capturing", this), Ri(r, "$capture", o, ...s))
            return o.return;
          const a = o.startRange || this.selection.getFirstRange(), l = a ? a.getContainedElement() : null, c = l ? !!mm(r, l) : !1;
          let u = l || ek(a);
          if (wn(o, "atTarget", u), !c) {
            if (Ri(r, "$text", o, ...s))
              return o.return;
            wn(o, "bubbling", u);
          }
          for (; u; ) {
            if (u.is("rootElement")) {
              if (Ri(r, "$root", o, ...s))
                return o.return;
            } else if (u.is("element") && Ri(r, u.name, o, ...s))
              return o.return;
            if (Ri(r, u, o, ...s))
              return o.return;
            u = u.parent, wn(o, "bubbling", u);
          }
          return wn(o, "bubbling", this), Ri(r, "$document", o, ...s), o.return;
        } catch (o) {
          /* istanbul ignore next -- @preserve */
          g.rethrowUnexpectedError(o, this);
        }
      }
      _addEventListener(i, s, o) {
        const r = Z(o.context || "$document"), a = Tr(this);
        for (const l of r) {
          let c = a.get(l);
          c || (c = new (G())(), a.set(l, c)), this.listenTo(c, i, s, o);
        }
      }
      _removeEventListener(i, s) {
        const o = Tr(this);
        for (const r of o.values())
          this.stopListening(r, i, s);
      }
    }
    return e;
  }
  {
    const n = da(Object);
    ["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
      da[e] = n.prototype[e];
    });
  }
  function wn(n, e, t) {
    n instanceof hn && (n._eventPhase = e, n._currentTarget = t);
  }
  function Ri(n, e, t, ...i) {
    const s = typeof e == "string" ? n.get(e) : mm(n, e);
    return s ? (s.fire(t, ...i), t.stop.called) : !1;
  }
  function mm(n, e) {
    for (const [t, i] of n)
      if (typeof t == "function" && t(e))
        return i;
    return null;
  }
  function Tr(n) {
    return n[kr] || (n[kr] = /* @__PURE__ */ new Map()), n[kr];
  }
  function ek(n) {
    if (!n)
      return null;
    const e = n.start.parent, t = n.end.parent, i = e.getPath(), s = t.getPath();
    return i.length > s.length ? e : t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let Xo = class extends da($()) {
    /**
     * Creates a Document instance.
     *
     * @param stylesProcessor The styles processor instance.
     */
    constructor(e) {
      super(), this._postFixers = /* @__PURE__ */ new Set(), this.selection = new pl(), this.roots = new Ce({ idProperty: "rootName" }), this.stylesProcessor = e, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1);
    }
    /**
     * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not
     * specific "main" root is returned.
     *
     * @param name Name of the root.
     * @returns The view root element with the specified name or null when there is no root of given name.
     */
    getRoot(e = "main") {
      return this.roots.get(e);
    }
    /**
     * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
     * to the DOM.
     *
     * Post-fixers are executed right after all changes from the outermost change block were applied but
     * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made
     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
     * not be fixed in the new document tree state.
     *
     * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
     * changes executed in a view post-fixer should not break model-view mapping.
     *
     * The types of changes which should be safe:
     *
     * * adding or removing attribute from elements,
     * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},
     * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be
     * re-converted}.
     *
     * Try to avoid changes which touch view structure:
     *
     * * you should not add or remove nor wrap or unwrap any view elements,
     * * you should not change the editor data model in a view post-fixer.
     *
     * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.
     *
     * Typically, a post-fixer will look like this:
     *
     * ```ts
     * editor.editing.view.document.registerPostFixer( writer => {
     * 	if ( checkSomeCondition() ) {
     * 		writer.doSomething();
     *
     * 		// Let other post-fixers know that something changed.
     * 		return true;
     * 	}
     *
     * 	return false;
     * } );
     * ```
     *
     * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
     * That is because adding a post-fixer does not execute it.
     * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
     * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
     * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.
     *
     * If you need to register a callback which is executed when DOM elements are already updated,
     * use {@link module:engine/view/view~View#event:render render event}.
     */
    registerPostFixer(e) {
      this._postFixers.add(e);
    }
    /**
     * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
     */
    destroy() {
      this.roots.forEach((e) => e.destroy()), this.stopListening();
    }
    /**
     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
     *
     * @internal
     */
    _callPostFixers(e) {
      let t = !1;
      do
        for (const i of this._postFixers)
          if (t = i(e), t)
            break;
      while (t);
    }
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const gm = 10;
  class oi extends at {
    /**
     * Creates an attribute element.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#createAttributeElement
     * @see module:engine/view/element~Element
     * @protected
     * @param document The document instance to which this element belongs.
     * @param name Node name.
     * @param attrs Collection of attributes.
     * @param children A list of nodes to be inserted into created element.
     */
    constructor(e, t, i, s) {
      super(e, t, i, s), this._priority = gm, this._id = null, this._clonesGroup = null, this.getFillerOffset = tk;
    }
    /**
     * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
     */
    get priority() {
      return this._priority;
    }
    /**
     * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
     * and then two elements are considered similar if, and only if they have the same `id`.
     */
    get id() {
      return this._id;
    }
    /**
     * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the
     * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).
     *
     * Note: If this element has been removed from the tree, returned set will not include it.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
     * if this element has no `id`.
     *
     * @returns Set containing all the attribute elements
     * with the same `id` that were added and not removed from the view tree.
     */
    getElementsWithSameId() {
      if (this.id === null)
        throw new g("attribute-element-get-elements-with-same-id-no-id", this);
      return new Set(this._clonesGroup);
    }
    /**
     * Checks if this element is similar to other element.
     *
     * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements
     * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
     * different set of children nodes.
     *
     * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both
     * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be
     * considered similar.
     *
     * Similarity is important for {@link module:engine/view/downcastwriter~DowncastWriter}. For example:
     *
     * * two following similar elements can be merged together into one, longer element,
     * * {@link module:engine/view/downcastwriter~DowncastWriter#unwrap} checks similarity of passed element and processed element to
     * decide whether processed element should be unwrapped,
     * * etc.
     */
    isSimilar(e) {
      return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority;
    }
    /**
     * Clones provided element with priority.
     *
     * @internal
     * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any children.
     * @returns Clone of this element.
     */
    _clone(e = !1) {
      const t = super._clone(e);
      return t._priority = this._priority, t._id = this._id, t;
    }
  }
  oi.DEFAULT_PRIORITY = gm;
  oi.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "attributeElement" || n === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "element" || n === "view:element") : n === "attributeElement" || n === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "element" || n === "view:element" || n === "node" || n === "view:node";
  };
  function tk() {
    if (Er(this))
      return null;
    let n = this.parent;
    for (; n && n.is("attributeElement"); ) {
      if (Er(n) > 1)
        return null;
      n = n.parent;
    }
    return !n || Er(n) > 1 ? null : this.childCount;
  }
  function Er(n) {
    return Array.from(n.getChildren()).filter((e) => !e.is("uiElement")).length;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class wl extends at {
    /**
     * Creates new instance of EmptyElement.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
     * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#createEmptyElement
     * @internal
     * @param document The document instance to which this element belongs.
     * @param name Node name.
     * @param attrs Collection of attributes.
     * @param children A list of nodes to be inserted into created element.
     */
    constructor(e, t, i, s) {
      super(e, t, i, s), this.getFillerOffset = ik;
    }
    /**
     * Overrides {@link module:engine/view/element~Element#_insertChild} method.
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
     * adding any child nodes to EmptyElement.
     *
     * @internal
     */
    _insertChild(e, t) {
      if (t && (t instanceof _i || Array.from(t).length > 0))
        throw new g("view-emptyelement-cannot-add", [this, t]);
      return 0;
    }
  }
  wl.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "emptyElement" || n === "view:emptyElement" || n === "element" || n === "view:element") : n === "emptyElement" || n === "view:emptyElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "element" || n === "view:element" || n === "node" || n === "view:node";
  };
  function ik() {
    return null;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Yo extends at {
    /**
     * Creates new instance of UIElement.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
     * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement
     * @internal
     * @param document The document instance to which this element belongs.
     * @param name Node name.
     * @param attrs Collection of attributes.
     * @param children A list of nodes to be inserted into created element.
     */
    constructor(e, t, i, s) {
      super(e, t, i, s), this.getFillerOffset = sk;
    }
    /**
     * Overrides {@link module:engine/view/element~Element#_insertChild} method.
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
     * to UIElement.
     *
     * @internal
     */
    _insertChild(e, t) {
      if (t && (t instanceof _i || Array.from(t).length > 0))
        throw new g("view-uielement-cannot-add", [this, t]);
      return 0;
    }
    /**
     * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
     * {@link module:engine/view/domconverter~DomConverter}.
     * Do not use inheritance to create custom rendering method, replace `render()` method instead:
     *
     * ```ts
     * const myUIElement = downcastWriter.createUIElement( 'span' );
     * myUIElement.render = function( domDocument, domConverter ) {
     * 	const domElement = this.toDomElement( domDocument );
     *
     * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
     *
     * 	return domElement;
     * };
     * ```
     *
     * If changes in your UI element should trigger some editor UI update you should call
     * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
     * after rendering your UI element.
     *
     * @param domConverter Instance of the DomConverter used to optimize the output.
     */
    render(e, t) {
      return this.toDomElement(e);
    }
    /**
     * Creates DOM element based on this view UIElement.
     * Note that each time this method is called new DOM element is created.
     */
    toDomElement(e) {
      const t = e.createElement(this.name);
      for (const i of this.getAttributeKeys())
        t.setAttribute(i, this.getAttribute(i));
      return t;
    }
  }
  Yo.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "uiElement" || n === "view:uiElement" || n === "element" || n === "view:element") : n === "uiElement" || n === "view:uiElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "element" || n === "view:element" || n === "node" || n === "view:node";
  };
  function nk(n) {
    n.document.on("arrowKey", (e, t) => ok(e, t, n.domConverter), { priority: "low" });
  }
  function sk() {
    return null;
  }
  function ok(n, e, t) {
    if (e.keyCode == F.arrowright) {
      const i = e.domTarget.ownerDocument.defaultView.getSelection(), s = i.rangeCount == 1 && i.getRangeAt(0).collapsed;
      if (s || e.shiftKey) {
        const o = i.focusNode, r = i.focusOffset, a = t.domPositionToView(o, r);
        if (a === null)
          return;
        let l = !1;
        const c = a.getLastMatchingPosition((u) => (u.item.is("uiElement") && (l = !0), !!(u.item.is("uiElement") || u.item.is("attributeElement"))));
        if (l) {
          const u = t.viewPositionToDom(c);
          s ? i.collapse(u.parent, u.offset) : i.extend(u.parent, u.offset);
        }
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class bl extends at {
    /**
     * Creates a new instance of a raw element.
     *
     * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} when the `children`
     * parameter is passed to inform that the usage of `RawElement` is incorrect (adding child nodes to `RawElement` is forbidden).
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#createRawElement
     * @internal
     * @param document The document instance to which this element belongs.
     * @param name Node name.
     * @param attrs Collection of attributes.
     * @param children A list of nodes to be inserted into created element.
     */
    constructor(e, t, i, s) {
      super(e, t, i, s), this.getFillerOffset = rk;
    }
    /**
     * Overrides the {@link module:engine/view/element~Element#_insertChild} method.
     * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} to prevent
     * adding any child nodes to a raw element.
     *
     * @internal
     */
    _insertChild(e, t) {
      if (t && (t instanceof _i || Array.from(t).length > 0))
        throw new g("view-rawelement-cannot-add", [this, t]);
      return 0;
    }
    /**
     * This allows rendering the children of a {@link module:engine/view/rawelement~RawElement} on the DOM level.
     * This method is called by the {@link module:engine/view/domconverter~DomConverter} with the raw DOM element
     * passed as an argument, leaving the number and shape of the children up to the integrator.
     *
     * This method **must be defined** for the raw element to work:
     *
     * ```ts
     * const myRawElement = downcastWriter.createRawElement( 'div' );
     *
     * myRawElement.render = function( domElement, domConverter ) {
     * 	domConverter.setContentOf( domElement, '<b>This is the raw content of myRawElement.</b>' );
     * };
     * ```
     *
     * @param domElement The native DOM element representing the raw view element.
     * @param domConverter Instance of the DomConverter used to optimize the output.
     */
    render(e, t) {
    }
  }
  bl.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "rawElement" || n === "view:rawElement" || n === "element" || n === "view:element") : n === "rawElement" || n === "view:rawElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === this.name || n === "view:" + this.name || n === "element" || n === "view:element" || n === "node" || n === "view:node";
  };
  function rk() {
    return null;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let ri = class extends G(bi) {
    /**
     * Creates new DocumentFragment instance.
     *
     * @internal
     * @param document The document to which this document fragment belongs.
     * @param children A list of nodes to be inserted into the created document fragment.
     */
    constructor(e, t) {
      super(), this._children = [], this._customProperties = /* @__PURE__ */ new Map(), this.document = e, t && this._insertChild(0, t);
    }
    /**
     * Iterable interface.
     *
     * Iterates over nodes added to this document fragment.
     */
    [Symbol.iterator]() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Number of child nodes in this document fragment.
     */
    get childCount() {
      return this._children.length;
    }
    /**
     * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
     */
    get isEmpty() {
      return this.childCount === 0;
    }
    /**
     * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
     */
    get root() {
      return this;
    }
    /**
     * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
     */
    get parent() {
      return null;
    }
    /**
     * Artificial element name. Returns `undefined`. Added for compatibility reasons.
     */
    get name() {
    }
    /**
     * Artificial element getFillerOffset. Returns `undefined`. Added for compatibility reasons.
     */
    get getFillerOffset() {
    }
    /**
     * Returns the custom property value for the given key.
     */
    getCustomProperty(e) {
      return this._customProperties.get(e);
    }
    /**
     * Returns an iterator which iterates over this document fragment's custom properties.
     * Iterator provides `[ key, value ]` pairs for each stored property.
     */
    *getCustomProperties() {
      yield* this._customProperties.entries();
    }
    /**
     * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
     * and sets the parent of these nodes to this fragment.
     *
     * @internal
     * @param items Items to be inserted.
     * @returns Number of appended nodes.
     */
    _appendChild(e) {
      return this._insertChild(this.childCount, e);
    }
    /**
     * Gets child at the given index.
     *
     * @param index Index of child.
     * @returns Child node.
     */
    getChild(e) {
      return this._children[e];
    }
    /**
     * Gets index of the given child node. Returns `-1` if child node is not found.
     *
     * @param node Child node.
     * @returns Index of the child node.
     */
    getChildIndex(e) {
      return this._children.indexOf(e);
    }
    /**
     * Gets child nodes iterator.
     *
     * @returns Child nodes iterator.
     */
    getChildren() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
     * this fragment.
     *
     * @internal
     * @param index Position where nodes should be inserted.
     * @param items Items to be inserted.
     * @returns Number of inserted nodes.
     */
    _insertChild(e, t) {
      this._fireChange("children", this);
      let i = 0;
      const s = ak(this.document, t);
      for (const o of s)
        o.parent !== null && o._remove(), o.parent = this, this._children.splice(e, 0, o), e++, i++;
      return i;
    }
    /**
     * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
     *
     * @internal
     * @param index Number of the first node to remove.
     * @param howMany Number of nodes to remove.
     * @returns The array of removed nodes.
     */
    _removeChildren(e, t = 1) {
      this._fireChange("children", this);
      for (let i = e; i < e + t; i++)
        this._children[i].parent = null;
      return this._children.splice(e, t);
    }
    /**
     * Fires `change` event with given type of the change.
     *
     * @internal
     * @param type Type of the change.
     * @param node Changed node.
     */
    _fireChange(e, t) {
      this.fire("change:" + e, t);
    }
    /**
     * Sets a custom property. They can be used to add special data to elements.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
     * @internal
     */
    _setCustomProperty(e, t) {
      this._customProperties.set(e, t);
    }
    /**
     * Removes the custom property stored under the given key.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
     * @internal
     * @returns Returns true if property was removed.
     */
    _removeCustomProperty(e) {
      return this._customProperties.delete(e);
    }
  };
  ri.prototype.is = function(n) {
    return n === "documentFragment" || n === "view:documentFragment";
  };
  function ak(n, e) {
    return typeof e == "string" ? [new ie(n, e)] : (We(e) || (e = [e]), Array.from(e).map((t) => typeof t == "string" ? new ie(n, t) : t instanceof ft ? new ie(n, t.data) : t));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class pm {
    /**
     * @param document The view document instance.
     */
    constructor(e) {
      this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null, this.document = e;
    }
    setSelection(...e) {
      this.document.selection._setTo(...e);
    }
    /**
     * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.
     *
     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
     * parameters.
     *
     * @param Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
     */
    setSelectionFocus(e, t) {
      this.document.selection._setFocus(e, t);
    }
    /**
     * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
     *
     * @param children A list of nodes to be inserted into the created document fragment.
     * @returns The created document fragment.
     */
    createDocumentFragment(e) {
      return new ri(this.document, e);
    }
    /**
     * Creates a new {@link module:engine/view/text~Text text node}.
     *
     * ```ts
     * writer.createText( 'foo' );
     * ```
     *
     * @param data The text's data.
     * @returns The created text node.
     */
    createText(e) {
      return new ie(this.document, e);
    }
    /**
     * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.
     *
     * ```ts
     * writer.createAttributeElement( 'strong' );
     * writer.createAttributeElement( 'a', { href: 'foo.bar' } );
     *
     * // Make `<a>` element contain other attributes element so the `<a>` element is not broken.
     * writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
     *
     * // Set `id` of a marker element so it is not joined or merged with "normal" elements.
     * writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
     * ```
     *
     * @param name Name of the element.
     * @param attributes Element's attributes.
     * @param options Element's options.
     * @param options.priority Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.
     * @param options.id Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.
     * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
     * @returns Created element.
     */
    createAttributeElement(e, t, i = {}) {
      const s = new oi(this.document, e, t);
      return typeof i.priority == "number" && (s._priority = i.priority), i.id && (s._id = i.id), i.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), s;
    }
    createContainerElement(e, t, i = {}, s = {}) {
      let o = null;
      Ne(i) ? s = i : o = i;
      const r = new Jn(this.document, e, t, o);
      return s.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...s.renderUnsafeAttributes), r;
    }
    /**
     * Creates a new {@link module:engine/view/editableelement~EditableElement}.
     *
     * ```ts
     * writer.createEditableElement( 'div' );
     * writer.createEditableElement( 'div', { id: 'foo-1234' } );
     * ```
     *
     * Note: The editable element is to be used in the editing pipeline. Usually, together with
     * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.
     *
     * @param name Name of the element.
     * @param attributes Elements attributes.
     * @param options Element's options.
     * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
     * @returns Created element.
     */
    createEditableElement(e, t, i = {}) {
      const s = new Jo(this.document, e, t);
      return i.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), s;
    }
    /**
     * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.
     *
     * ```ts
     * writer.createEmptyElement( 'img' );
     * writer.createEmptyElement( 'img', { id: 'foo-1234' } );
     * ```
     *
     * @param name Name of the element.
     * @param attributes Elements attributes.
     * @param options Element's options.
     * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
     * @returns Created element.
     */
    createEmptyElement(e, t, i = {}) {
      const s = new wl(this.document, e, t);
      return i.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), s;
    }
    /**
     * Creates a new {@link module:engine/view/uielement~UIElement}.
     *
     * ```ts
     * writer.createUIElement( 'span' );
     * writer.createUIElement( 'span', { id: 'foo-1234' } );
     * ```
     *
     * A custom render function can be provided as the third parameter:
     *
     * ```ts
     * writer.createUIElement( 'span', null, function( domDocument ) {
     * 	const domElement = this.toDomElement( domDocument );
     * 	domElement.innerHTML = '<b>this is ui element</b>';
     *
     * 	return domElement;
     * } );
     * ```
     *
     * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,
     * they are ignored by the editor selection system.
     *
     * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.
     *
     * @param name The name of the element.
     * @param attributes Element attributes.
     * @param renderFunction A custom render function.
     * @returns The created element.
     */
    createUIElement(e, t, i) {
      const s = new Yo(this.document, e, t);
      return i && (s.render = i), s;
    }
    /**
     * Creates a new {@link module:engine/view/rawelement~RawElement}.
     *
     * ```ts
     * writer.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {
     * 	domElement.innerHTML = '<b>This is the raw content of the raw element.</b>';
     * } );
     * ```
     *
     * Raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
     * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
     * in the editor content without, for instance, worrying about compatibility with other editor features.
     * Raw elements are a perfect tool for integration with external frameworks and data sources.
     *
     * Unlike {@link #createUIElement UI elements}, raw elements act like "real" editor content (similar to
     * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),
     * and they are considered by the editor selection.
     *
     * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}
     * instead.
     *
     * @param name The name of the element.
     * @param attributes Element attributes.
     * @param renderFunction A custom render function.
     * @param options Element's options.
     * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
     * @returns The created element.
     */
    createRawElement(e, t, i, s = {}) {
      const o = new bl(this.document, e, t);
      return i && (o.render = i), s.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...s.renderUnsafeAttributes), o;
    }
    /**
     * Adds or overwrites the element's attribute with a specified key and value.
     *
     * ```ts
     * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
     * ```
     *
     * @param key The attribute key.
     * @param value The attribute value.
     */
    setAttribute(e, t, i) {
      i._setAttribute(e, t);
    }
    /**
     * Removes attribute from the element.
     *
     * ```ts
     * writer.removeAttribute( 'href', linkElement );
     * ```
     *
     * @param key Attribute key.
     */
    removeAttribute(e, t) {
      t._removeAttribute(e);
    }
    /**
     * Adds specified class to the element.
     *
     * ```ts
     * writer.addClass( 'foo', linkElement );
     * writer.addClass( [ 'foo', 'bar' ], linkElement );
     * ```
     */
    addClass(e, t) {
      t._addClass(e);
    }
    /**
     * Removes specified class from the element.
     *
     * ```ts
     * writer.removeClass( 'foo', linkElement );
     * writer.removeClass( [ 'foo', 'bar' ], linkElement );
     * ```
     */
    removeClass(e, t) {
      t._removeClass(e);
    }
    setStyle(e, t, i) {
      Ne(e) && i === void 0 ? t._setStyle(e) : i._setStyle(e, t);
    }
    /**
     * Removes specified style from the element.
     *
     * ```ts
     * writer.removeStyle( 'color', element ); // Removes 'color' style.
     * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
     * ```
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
     */
    removeStyle(e, t) {
      t._removeStyle(e);
    }
    /**
     * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
     * so they can be used to add special data to elements.
     */
    setCustomProperty(e, t, i) {
      i._setCustomProperty(e, t);
    }
    /**
     * Removes a custom property stored under the given key.
     *
     * @returns Returns true if property was removed.
     */
    removeCustomProperty(e, t) {
      return t._removeCustomProperty(e);
    }
    /**
     * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements
     * up to their first ancestor that is a container element.
     *
     * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:
     *
     * ```html
     * <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
     * <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
     * <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
     * <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
     * ```
     *
     * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
     *
     * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
     * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
     * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
     * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.
     *
     * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
     * when the {@link module:engine/view/range~Range#start start}
     * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.
     *
     * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
     * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
     *
     * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
     * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.
     *
     * @see module:engine/view/attributeelement~AttributeElement
     * @see module:engine/view/containerelement~ContainerElement
     * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer
     * @param positionOrRange The position where to break attribute elements.
     * @returns The new position or range, after breaking the attribute elements.
     */
    breakAttributes(e) {
      return e instanceof k ? this._breakAttributes(e) : this._breakAttributesRange(e);
    }
    /**
     * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.
     * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element
     * if the position is at the beginning or at the end of its parent element.
     *
     * ```html
     * <p>foo^bar</p> -> <p>foo</p><p>bar</p>
     * <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
     * <p>^foobar</p> -> ^<p>foobar</p>
     * <p>foobar^</p> -> <p>foobar</p>^
     * ```
     *
     * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
     * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
     * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
     * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.
     *
     * @see module:engine/view/attributeelement~AttributeElement
     * @see module:engine/view/containerelement~ContainerElement
     * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes
     * @param position The position where to break the element.
     * @returns The position between broken elements. If an element has not been broken,
     * the returned position is placed either before or after it.
     */
    breakContainer(e) {
      const t = e.parent;
      if (!t.is("containerElement"))
        throw new g("view-writer-break-non-container-element", this.document);
      if (!t.parent)
        throw new g("view-writer-break-root", this.document);
      if (e.isAtStart)
        return k._createBefore(t);
      if (!e.isAtEnd) {
        const i = t._clone(!1);
        this.insert(k._createAfter(t), i);
        const s = new N(e, k._createAt(t, "end")), o = new k(i, 0);
        this.move(s, o);
      }
      return k._createAfter(t);
    }
    /**
     * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.
     * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.
     *
     * In following examples `<p>` is a container and `<b>` is an attribute element:
     *
     * ```html
     * <p>foo[]bar</p> -> <p>foo{}bar</p>
     * <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
     * <p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
     * ```
     *
     * It will also take care about empty attributes when merging:
     *
     * ```html
     * <p><b>[]</b></p> -> <p>[]</p>
     * <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
     * ```
     *
     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
     * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
     * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
     *
     * @see module:engine/view/attributeelement~AttributeElement
     * @see module:engine/view/containerelement~ContainerElement
     * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers
     * @param position Merge position.
     * @returns Position after merge.
     */
    mergeAttributes(e) {
      const t = e.offset, i = e.parent;
      if (i.is("$text"))
        return e;
      if (i.is("attributeElement") && i.childCount === 0) {
        const r = i.parent, a = i.index;
        return i._remove(), this._removeFromClonedElementsGroup(i), this.mergeAttributes(new k(r, a));
      }
      const s = i.getChild(t - 1), o = i.getChild(t);
      if (!s || !o)
        return e;
      if (s.is("$text") && o.is("$text"))
        return tu(s, o);
      if (s.is("attributeElement") && o.is("attributeElement") && s.isSimilar(o)) {
        const r = s.childCount;
        return s._appendChild(o.getChildren()), o._remove(), this._removeFromClonedElementsGroup(o), this.mergeAttributes(new k(s, r));
      }
      return e;
    }
    /**
     * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.
     * Precisely, the element after the position is removed and it's contents are moved to element before the position.
     *
     * ```html
     * <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
     * <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
     * ```
     *
     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
     * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
     * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
     *
     * @see module:engine/view/attributeelement~AttributeElement
     * @see module:engine/view/containerelement~ContainerElement
     * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes
     * @param position Merge position.
     * @returns Position after merge.
     */
    mergeContainers(e) {
      const t = e.nodeBefore, i = e.nodeAfter;
      if (!t || !i || !t.is("containerElement") || !i.is("containerElement"))
        throw new g("view-writer-merge-containers-invalid-position", this.document);
      const s = t.getChild(t.childCount - 1), o = s instanceof ie ? k._createAt(s, "end") : k._createAt(t, "end");
      return this.move(N._createIn(i), k._createAt(t, "end")), this.remove(N._createOn(i)), o;
    }
    /**
     * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion
     * and merging them afterwards.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
     * contains instances that are not {@link module:engine/view/text~Text Texts},
     * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},
     * {@link module:engine/view/containerelement~ContainerElement ContainerElements},
     * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},
     * {@link module:engine/view/rawelement~RawElement RawElements} or
     * {@link module:engine/view/uielement~UIElement UIElements}.
     *
     * @param position Insertion position.
     * @param nodes Node or nodes to insert.
     * @returns Range around inserted nodes.
     */
    insert(e, t) {
      t = We(t) ? [...t] : [t], wm(t, this.document);
      const i = t.reduce((r, a) => {
        const l = r[r.length - 1], c = !a.is("uiElement");
        return !l || l.breakAttributes != c ? r.push({
          breakAttributes: c,
          nodes: [a]
        }) : l.nodes.push(a), r;
      }, []);
      let s = null, o = e;
      for (const { nodes: r, breakAttributes: a } of i) {
        const l = this._insertNodes(o, r, a);
        s || (s = l.start), o = l.end;
      }
      return s ? new N(s, o) : new N(e);
    }
    /**
     * Removes provided range from the container.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
     * same parent container.
     *
     * @param rangeOrItem Range to remove from container
     * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated
     * to a collapsed range showing the new position.
     * @returns Document fragment containing removed nodes.
     */
    remove(e) {
      const t = e instanceof N ? e : N._createOn(e);
      if (bn(t, this.document), t.isCollapsed)
        return new ri(this.document);
      const { start: i, end: s } = this._breakAttributesRange(t, !0), o = i.parent, r = s.offset - i.offset, a = o._removeChildren(i.offset, r);
      for (const c of a)
        this._removeFromClonedElementsGroup(c);
      const l = this.mergeAttributes(i);
      return t.start = l, t.end = l.clone(), new ri(this.document, a);
    }
    /**
     * Removes matching elements from given range.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
     * same parent container.
     *
     * @param range Range to clear.
     * @param element Element to remove.
     */
    clear(e, t) {
      bn(e, this.document);
      const i = e.getWalker({
        direction: "backward",
        ignoreElementEnd: !0
      });
      for (const s of i) {
        const o = s.item;
        let r;
        if (o.is("element") && t.isSimilar(o))
          r = N._createOn(o);
        else if (!s.nextPosition.isAfter(e.start) && o.is("$textProxy")) {
          const a = o.getAncestors().find((l) => l.is("element") && t.isSimilar(l));
          a && (r = N._createIn(a));
        }
        r && (r.end.isAfter(e.end) && (r.end = e.end), r.start.isBefore(e.start) && (r.start = e.start), this.remove(r));
      }
    }
    /**
     * Moves nodes from provided range to target position.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
     * same parent container.
     *
     * @param sourceRange Range containing nodes to move.
     * @param targetPosition Position to insert.
     * @returns Range in target container. Inserted nodes are placed between
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.
     */
    move(e, t) {
      let i;
      if (t.isAfter(e.end)) {
        t = this._breakAttributes(t, !0);
        const s = t.parent, o = s.childCount;
        e = this._breakAttributesRange(e, !0), i = this.remove(e), t.offset += s.childCount - o;
      } else
        i = this.remove(e);
      return this.insert(t, i);
    }
    /**
     * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
     * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
     *
     * If a collapsed range was passed and is same as selection, the selection
     * will be moved to the inside of the wrapped attribute element.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
     * when {@link module:engine/view/range~Range#start}
     * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
     * is collapsed and different than view selection.
     *
     * @param range Range to wrap.
     * @param attribute Attribute element to use as wrapper.
     * @returns range Range after wrapping, spanning over wrapping attribute element.
     */
    wrap(e, t) {
      if (!(t instanceof oi))
        throw new g("view-writer-wrap-invalid-attribute", this.document);
      if (bn(e, this.document), e.isCollapsed) {
        let i = e.start;
        i.parent.is("element") && !lk(i.parent) && (i = i.getLastMatchingPosition((o) => o.item.is("uiElement"))), i = this._wrapPosition(i, t);
        const s = this.document.selection;
        return s.isCollapsed && s.getFirstPosition().isEqual(e.start) && this.setSelection(i), new N(i);
      } else
        return this._wrapRange(e, t);
    }
    /**
     * Unwraps nodes within provided range from attribute element.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
     * same parent container.
     */
    unwrap(e, t) {
      if (!(t instanceof oi))
        throw new g("view-writer-unwrap-invalid-attribute", this.document);
      if (bn(e, this.document), e.isCollapsed)
        return e;
      const { start: i, end: s } = this._breakAttributesRange(e, !0), o = i.parent, r = this._unwrapChildren(o, i.offset, s.offset, t), a = this.mergeAttributes(r.start);
      a.isEqual(r.start) || r.end.offset--;
      const l = this.mergeAttributes(r.end);
      return new N(a, l);
    }
    /**
     * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
     * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which
     * has renamed element as {@link module:engine/view/position~Position#parent a parent}.
     *
     * New element has to be created because `Element#tagName` property in DOM is readonly.
     *
     * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
     *
     * @param newName New name for element.
     * @param viewElement Element to be renamed.
     * @returns Element created due to rename.
     */
    rename(e, t) {
      const i = new Jn(this.document, e, t.getAttributes());
      return this.insert(k._createAfter(t), i), this.move(N._createIn(t), k._createAt(i, 0)), this.remove(N._createOn(t)), i;
    }
    /**
     * Cleans up memory by removing obsolete cloned elements group from the writer.
     *
     * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}
     * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and
     * the group will no longer be needed.
     *
     * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
     * were removed from the view.
     *
     * Keep in mind that group names are equal to the `id` property of the attribute element.
     *
     * @param groupName Name of the group to clear.
     */
    clearClonedElementsGroup(e) {
      this._cloneGroups.delete(e);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/view/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
     *
     * This method is a shortcut to other constructors such as:
     *
     * * {@link #createPositionBefore},
     * * {@link #createPositionAfter},
     *
     * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
     */
    createPositionAt(e, t) {
      return k._createAt(e, t);
    }
    /**
     * Creates a new position after given view item.
     *
     * @param item View item after which the position should be located.
     */
    createPositionAfter(e) {
      return k._createAfter(e);
    }
    /**
     * Creates a new position before given view item.
     *
     * @param item View item before which the position should be located.
     */
    createPositionBefore(e) {
      return k._createBefore(e);
    }
    /**
     * Creates a range spanning from `start` position to `end` position.
     *
     * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.
     *
     * @param start Start position.
     * @param end End position. If not set, range will be collapsed at `start` position.
     */
    createRange(e, t) {
      return new N(e, t);
    }
    /**
     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
     */
    createRangeOn(e) {
      return N._createOn(e);
    }
    /**
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @param element Element which is a parent for the range.
     */
    createRangeIn(e) {
      return N._createIn(e);
    }
    createSelection(...e) {
      return new St(...e);
    }
    /**
     * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
     * `elementToStructure()`} conversion helper.
     *
     * ```ts
     * const viewSlot = conversionApi.writer.createSlot();
     * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
     *
     * conversionApi.writer.insert( viewPosition, viewSlot );
     * ```
     *
     * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):
     *
     * ```ts
     * const viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );
     * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
     *
     * conversionApi.writer.insert( viewPosition, viewSlot );
     * ```
     *
     * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into
     * multiple slots.
     *
     * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.
     *
     * @param modeOrFilter The filter for child nodes.
     * @returns The slot element to be placed in to the view structure while processing
     * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.
     */
    createSlot(e = "children") {
      if (!this._slotFactory)
        throw new g("view-writer-invalid-create-slot-context", this.document);
      return this._slotFactory(this, e);
    }
    /**
     * Registers a slot factory.
     *
     * @internal
     * @param slotFactory The slot factory.
     */
    _registerSlotFactory(e) {
      this._slotFactory = e;
    }
    /**
     * Clears the registered slot factory.
     *
     * @internal
     */
    _clearSlotFactory() {
      this._slotFactory = null;
    }
    /**
     * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion
     * and merging them afterwards if requested by the breakAttributes param.
     *
     * @param position Insertion position.
     * @param nodes Node or nodes to insert.
     * @param breakAttributes Whether attributes should be broken.
     * @returns Range around inserted nodes.
     */
    _insertNodes(e, t, i) {
      let s;
      if (i ? s = ha(e) : s = e.parent.is("$text") ? e.parent.parent : e.parent, !s)
        throw new g("view-writer-invalid-position-container", this.document);
      let o;
      i ? o = this._breakAttributes(e, !0) : o = e.parent.is("$text") ? Ar(e) : e;
      const r = s._insertChild(o.offset, t);
      for (const u of t)
        this._addToClonedElementsGroup(u);
      const a = o.getShiftedBy(r), l = this.mergeAttributes(o);
      l.isEqual(o) || a.offset--;
      const c = this.mergeAttributes(a);
      return new N(l, c);
    }
    /**
     * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
     * `startOffset` and `endOffset` will be wrapped.
     */
    _wrapChildren(e, t, i, s) {
      let o = t;
      const r = [];
      for (; o < i; ) {
        const l = e.getChild(o), c = l.is("$text"), u = l.is("attributeElement");
        if (u && this._wrapAttributeElement(s, l))
          r.push(new k(e, o));
        else if (c || !u || ck(s, l)) {
          const d = s._clone();
          l._remove(), d._appendChild(l), e._insertChild(o, d), this._addToClonedElementsGroup(d), r.push(new k(e, o));
        } else
          this._wrapChildren(l, 0, l.childCount, s);
        o++;
      }
      let a = 0;
      for (const l of r) {
        if (l.offset -= a, l.offset == t)
          continue;
        this.mergeAttributes(l).isEqual(l) || (a++, i--);
      }
      return N._createFromParentsAndOffsets(e, t, e, i);
    }
    /**
     * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
     * `startOffset` and `endOffset` will be unwrapped.
     */
    _unwrapChildren(e, t, i, s) {
      let o = t;
      const r = [];
      for (; o < i; ) {
        const l = e.getChild(o);
        if (!l.is("attributeElement")) {
          o++;
          continue;
        }
        if (l.isSimilar(s)) {
          const c = l.getChildren(), u = l.childCount;
          l._remove(), e._insertChild(o, c), this._removeFromClonedElementsGroup(l), r.push(new k(e, o), new k(e, o + u)), o += u, i += u - 1;
          continue;
        }
        if (this._unwrapAttributeElement(s, l)) {
          r.push(new k(e, o), new k(e, o + 1)), o++;
          continue;
        }
        this._unwrapChildren(l, 0, l.childCount, s), o++;
      }
      let a = 0;
      for (const l of r) {
        if (l.offset -= a, l.offset == t || l.offset == i)
          continue;
        this.mergeAttributes(l).isEqual(l) || (a++, i--);
      }
      return N._createFromParentsAndOffsets(e, t, e, i);
    }
    /**
     * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
     * This method will also merge newly added attribute element with its siblings whenever possible.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
     *
     * @returns New range after wrapping, spanning over wrapping attribute element.
     */
    _wrapRange(e, t) {
      const { start: i, end: s } = this._breakAttributesRange(e, !0), o = i.parent, r = this._wrapChildren(o, i.offset, s.offset, t), a = this.mergeAttributes(r.start);
      a.isEqual(r.start) || r.end.offset--;
      const l = this.mergeAttributes(r.end);
      return new N(a, l);
    }
    /**
     * Helper function for {@link #wrap}. Wraps position with provided attribute element.
     * This method will also merge newly added attribute element with its siblings whenever possible.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
     *
     * @returns New position after wrapping.
     */
    _wrapPosition(e, t) {
      if (t.isSimilar(e.parent))
        return eu(e.clone());
      e.parent.is("$text") && (e = Ar(e));
      const i = this.createAttributeElement("_wrapPosition-fake-element");
      i._priority = Number.POSITIVE_INFINITY, i.isSimilar = () => !1, e.parent._insertChild(e.offset, i);
      const s = new N(e, e.getShiftedBy(1));
      this.wrap(s, t);
      const o = new k(i.parent, i.index);
      i._remove();
      const r = o.nodeBefore, a = o.nodeAfter;
      return r instanceof ie && a instanceof ie ? tu(r, a) : eu(o);
    }
    /**
     * Wraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by
     * merging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper
     * element to element being wrapped.
     *
     * @param wrapper Wrapper AttributeElement.
     * @param toWrap AttributeElement to wrap using wrapper element.
     * @returns Returns `true` if elements are merged.
     */
    _wrapAttributeElement(e, t) {
      if (!iu(e, t) || e.name !== t.name || e.priority !== t.priority)
        return !1;
      for (const i of e.getAttributeKeys())
        if (!(i === "class" || i === "style") && t.hasAttribute(i) && t.getAttribute(i) !== e.getAttribute(i))
          return !1;
      for (const i of e.getStyleNames())
        if (t.hasStyle(i) && t.getStyle(i) !== e.getStyle(i))
          return !1;
      for (const i of e.getAttributeKeys())
        i === "class" || i === "style" || t.hasAttribute(i) || this.setAttribute(i, e.getAttribute(i), t);
      for (const i of e.getStyleNames())
        t.hasStyle(i) || this.setStyle(i, e.getStyle(i), t);
      for (const i of e.getClassNames())
        t.hasClass(i) || this.addClass(i, t);
      return !0;
    }
    /**
     * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing
     * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present
     * inside element being unwrapped.
     *
     * @param wrapper Wrapper AttributeElement.
     * @param toUnwrap AttributeElement to unwrap using wrapper element.
     * @returns Returns `true` if elements are unwrapped.
     **/
    _unwrapAttributeElement(e, t) {
      if (!iu(e, t) || e.name !== t.name || e.priority !== t.priority)
        return !1;
      for (const i of e.getAttributeKeys())
        if (!(i === "class" || i === "style") && (!t.hasAttribute(i) || t.getAttribute(i) !== e.getAttribute(i)))
          return !1;
      if (!t.hasClass(...e.getClassNames()))
        return !1;
      for (const i of e.getStyleNames())
        if (!t.hasStyle(i) || t.getStyle(i) !== e.getStyle(i))
          return !1;
      for (const i of e.getAttributeKeys())
        i === "class" || i === "style" || this.removeAttribute(i, t);
      return this.removeClass(Array.from(e.getClassNames()), t), this.removeStyle(Array.from(e.getStyleNames()), t), !0;
    }
    /**
     * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
     *
     * @param range Range which `start` and `end` positions will be used to break attributes.
     * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
     * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
     * @returns New range with located at break positions.
     */
    _breakAttributesRange(e, t = !1) {
      const i = e.start, s = e.end;
      if (bn(e, this.document), e.isCollapsed) {
        const l = this._breakAttributes(e.start, t);
        return new N(l, l);
      }
      const o = this._breakAttributes(s, t), r = o.parent.childCount, a = this._breakAttributes(i, t);
      return o.offset += o.parent.childCount - r, new N(a, o);
    }
    /**
     * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
     * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
     * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.
     *
     * @param position Position where to break attributes.
     * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
     * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
     * @returns New position after breaking the attributes.
     */
    _breakAttributes(e, t = !1) {
      const i = e.offset, s = e.parent;
      if (e.parent.is("emptyElement"))
        throw new g("view-writer-cannot-break-empty-element", this.document);
      if (e.parent.is("uiElement"))
        throw new g("view-writer-cannot-break-ui-element", this.document);
      if (e.parent.is("rawElement"))
        throw new g("view-writer-cannot-break-raw-element", this.document);
      if (!t && s.is("$text") && fa(s.parent) || fa(s))
        return e.clone();
      if (s.is("$text"))
        return this._breakAttributes(Ar(e), t);
      const o = s.childCount;
      if (i == o) {
        const r = new k(s.parent, s.index + 1);
        return this._breakAttributes(r, t);
      } else if (i === 0) {
        const r = new k(s.parent, s.index);
        return this._breakAttributes(r, t);
      } else {
        const r = s.index + 1, a = s._clone();
        s.parent._insertChild(r, a), this._addToClonedElementsGroup(a);
        const l = s.childCount - i, c = s._removeChildren(i, l);
        a._appendChild(c);
        const u = new k(s.parent, r);
        return this._breakAttributes(u, t);
      }
    }
    /**
     * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was
     * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
     * from the group now keep a reference to the given attribute element.
     *
     * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.
     *
     * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
     *
     * @param element Attribute element to save.
     */
    _addToClonedElementsGroup(e) {
      if (!e.root.is("rootElement"))
        return;
      if (e.is("element"))
        for (const s of e.getChildren())
          this._addToClonedElementsGroup(s);
      const t = e.id;
      if (!t)
        return;
      let i = this._cloneGroups.get(t);
      i || (i = /* @__PURE__ */ new Set(), this._cloneGroups.set(t, i)), i.add(e), e._clonesGroup = i;
    }
    /**
     * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}
     * from its clones group.
     *
     * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
     * This allows to reference the whole group even if the element was already removed from the tree.
     *
     * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
     *
     * @param element Attribute element to remove.
     */
    _removeFromClonedElementsGroup(e) {
      if (e.is("element"))
        for (const s of e.getChildren())
          this._removeFromClonedElementsGroup(s);
      const t = e.id;
      if (!t)
        return;
      const i = this._cloneGroups.get(t);
      i && i.delete(e);
    }
  }
  function lk(n) {
    return Array.from(n.getChildren()).some((e) => !e.is("uiElement"));
  }
  function ha(n) {
    let e = n.parent;
    for (; !fa(e); ) {
      if (!e)
        return;
      e = e.parent;
    }
    return e;
  }
  function ck(n, e) {
    return n.priority < e.priority ? !0 : n.priority > e.priority ? !1 : n.getIdentity() < e.getIdentity();
  }
  function eu(n) {
    const e = n.nodeBefore;
    if (e && e.is("$text"))
      return new k(e, e.data.length);
    const t = n.nodeAfter;
    return t && t.is("$text") ? new k(t, 0) : n;
  }
  function Ar(n) {
    if (n.offset == n.parent.data.length)
      return new k(n.parent.parent, n.parent.index + 1);
    if (n.offset === 0)
      return new k(n.parent.parent, n.parent.index);
    const e = n.parent.data.slice(n.offset);
    return n.parent._data = n.parent.data.slice(0, n.offset), n.parent.parent._insertChild(n.parent.index + 1, new ie(n.root.document, e)), new k(n.parent.parent, n.parent.index + 1);
  }
  function tu(n, e) {
    const t = n.data.length;
    return n._data += e.data, e._remove(), new k(n, t);
  }
  const uk = [ie, oi, Jn, wl, bl, Yo];
  function wm(n, e) {
    for (const t of n) {
      if (!uk.some((i) => t instanceof i))
        throw new g("view-writer-insert-invalid-node-type", e);
      t.is("$text") || wm(t.getChildren(), e);
    }
  }
  function fa(n) {
    return n && (n.is("containerElement") || n.is("documentFragment"));
  }
  function bn(n, e) {
    const t = ha(n.start), i = ha(n.end);
    if (!t || !i || t !== i)
      throw new g("view-writer-invalid-range-container", e);
  }
  function iu(n, e) {
    return n.id === null && e.id === null;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const bm = (n) => n.createTextNode(" "), _m = (n) => {
    const e = n.createElement("span");
    return e.dataset.ckeFiller = "true", e.innerText = " ", e;
  }, vm = (n) => {
    const e = n.createElement("br");
    return e.dataset.ckeFiller = "true", e;
  }, nt = 7, Xn = "⁠".repeat(nt);
  function Oe(n) {
    return typeof n == "string" ? n.substr(0, nt) === Xn : ce(n) && n.data.substr(0, nt) === Xn;
  }
  function In(n) {
    return n.data.length == nt && Oe(n);
  }
  function nu(n) {
    const e = typeof n == "string" ? n : n.data;
    return Oe(n) ? e.slice(nt) : e;
  }
  function dk(n) {
    n.document.on("arrowKey", hk, { priority: "low" });
  }
  function hk(n, e) {
    if (e.keyCode == F.arrowleft) {
      const t = e.domTarget.ownerDocument.defaultView.getSelection();
      if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
        const i = t.getRangeAt(0).startContainer, s = t.getRangeAt(0).startOffset;
        Oe(i) && s <= nt && t.collapse(i, 0);
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class fk extends $() {
    /**
     * Creates a renderer instance.
     *
     * @param domConverter Converter instance.
     * @param selection View selection.
     */
    constructor(e, t) {
      super(), this.domDocuments = /* @__PURE__ */ new Set(), this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = e, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), B.isBlink && !B.isAndroid && this.on("change:isSelecting", () => {
        this.isSelecting || this.render();
      }), this.set("isComposing", !1), this.on("change:isComposing", () => {
        this.isComposing || this.render();
      });
    }
    /**
     * Marks a view node to be updated in the DOM by {@link #render `render()`}.
     *
     * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.
     *
     * @see #markedAttributes
     * @see #markedChildren
     * @see #markedTexts
     *
     * @param type Type of the change.
     * @param node ViewNode to be marked.
     */
    markToSync(e, t) {
      if (e === "text")
        this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t);
      else {
        if (!this.domConverter.mapViewToDom(t))
          return;
        if (e === "attributes")
          this.markedAttributes.add(t);
        else if (e === "children")
          this.markedChildren.add(t);
        else
          throw new g("view-renderer-unknown-type", this);
      }
    }
    /**
     * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and
     * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.
     *
     * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,
     * so it does as little as it is needed to update the DOM.
     *
     * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
     * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be
     * removed as long as the selection is in the text node which needed it at first.
     */
    render() {
      if (this.isComposing && !B.isAndroid)
        return;
      let e = null;
      const t = B.isBlink && !B.isAndroid ? !this.isSelecting : !0;
      for (const i of this.markedChildren)
        this._updateChildrenMappings(i);
      t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(), this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller), e && e.parent.is("$text") && (e = k._createBefore(e.parent)));
      for (const i of this.markedAttributes)
        this._updateAttrs(i);
      for (const i of this.markedChildren)
        this._updateChildren(i, { inlineFillerPosition: e });
      for (const i of this.markedTexts)
        !this.markedChildren.has(i.parent) && this.domConverter.mapViewToDom(i.parent) && this._updateText(i, { inlineFillerPosition: e });
      if (t)
        if (e) {
          const i = this.domConverter.viewPositionToDom(e), s = i.parent.ownerDocument;
          Oe(i.parent) ? this._inlineFiller = i.parent : this._inlineFiller = su(s, i.parent, i.offset);
        } else
          this._inlineFiller = null;
      this._updateFocus(), this._updateSelection(), this.domConverter._clearTemporaryCustomProperties(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
    }
    /**
     * Updates mappings of view element's children.
     *
     * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.
     * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.
     * Thanks to that these elements do not need to be re-rendered completely.
     *
     * @param viewElement The view element whose children mappings will be updated.
     */
    _updateChildrenMappings(e) {
      const t = this.domConverter.mapViewToDom(e);
      if (!t)
        return;
      const i = Array.from(t.childNodes), s = Array.from(this.domConverter.viewChildrenToDom(e, { withChildren: !1 })), o = this._diffNodeLists(i, s), r = this._findUpdateActions(o, i, s, gk);
      if (r.indexOf("update") !== -1) {
        const a = { equal: 0, insert: 0, delete: 0 };
        for (const l of r)
          if (l === "update") {
            const c = a.equal + a.insert, u = a.equal + a.delete, d = e.getChild(c);
            d && !d.is("uiElement") && !d.is("rawElement") && this._updateElementMappings(d, i[u]), Uc(s[c]), a.equal++;
          } else
            a[l]++;
      }
    }
    /**
     * Updates mappings of a given view element.
     *
     * @param viewElement The view element whose mappings will be updated.
     * @param domElement The DOM element representing the given view element.
     */
    _updateElementMappings(e, t) {
      this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, e), this.markedChildren.add(e), this.markedAttributes.add(e);
    }
    /**
     * Gets the position of the inline filler based on the current selection.
     * Here, we assume that we know that the filler is needed and
     * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,
     * it is somewhere at the selection position.
     *
     * Note: The filler position cannot be restored based on the filler's DOM text node, because
     * when this method is called (before rendering), the bindings will often be broken. View-to-DOM
     * bindings are only dependable after rendering.
     */
    _getInlineFillerPosition() {
      const e = this.selection.getFirstPosition();
      return e.parent.is("$text") ? k._createBefore(e.parent) : e;
    }
    /**
     * Returns `true` if the selection has not left the inline filler's text node.
     * If it is `true`, it means that the filler had been added for a reason and the selection did not
     * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.
     *
     * @returns `true` if the inline filler and selection are in the same place.
     */
    _isSelectionInInlineFiller() {
      if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
        return !1;
      const e = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(e);
      return !!(t && ce(t.parent) && Oe(t.parent));
    }
    /**
     * Removes the inline filler.
     */
    _removeInlineFiller() {
      const e = this._inlineFiller;
      if (!Oe(e))
        throw new g("view-renderer-filler-was-lost", this);
      In(e) ? e.remove() : e.data = e.data.substr(nt), this._inlineFiller = null;
    }
    /**
     * Checks if the inline {@link module:engine/view/filler filler} should be added.
     *
     * @returns `true` if the inline filler should be added.
     */
    _needsInlineFillerAtSelection() {
      if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
        return !1;
      const e = this.selection.getFirstPosition(), t = e.parent, i = e.offset;
      if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !mk(t) || i === t.getFillerOffset())
        return !1;
      const s = e.nodeBefore, o = e.nodeAfter;
      return !(s instanceof ie || o instanceof ie || B.isAndroid && (s || o));
    }
    /**
     * Checks if text needs to be updated and possibly updates it.
     *
     * @param viewText View text to update.
     * @param options.inlineFillerPosition The position where the inline filler should be rendered.
     */
    _updateText(e, t) {
      const i = this.domConverter.findCorrespondingDomText(e);
      let o = this.domConverter.viewToDom(e).data;
      const r = t.inlineFillerPosition;
      r && r.parent == e.parent && r.offset == e.index && (o = Xn + o), ou(i, o);
    }
    /**
     * Checks if attribute list needs to be updated and possibly updates it.
     *
     * @param viewElement The view element to update.
     */
    _updateAttrs(e) {
      const t = this.domConverter.mapViewToDom(e);
      if (!t)
        return;
      const i = Array.from(t.attributes).map((o) => o.name), s = e.getAttributeKeys();
      for (const o of s)
        this.domConverter.setDomElementAttribute(t, o, e.getAttribute(o), e);
      for (const o of i)
        e.hasAttribute(o) || this.domConverter.removeDomElementAttribute(t, o);
    }
    /**
     * Checks if elements child list needs to be updated and possibly updates it.
     *
     * Note that on Android, to reduce the risk of composition breaks, it tries to update data of an existing
     * child text nodes instead of replacing them completely.
     *
     * @param viewElement View element to update.
     * @param options.inlineFillerPosition The position where the inline filler should be rendered.
     */
    _updateChildren(e, t) {
      const i = this.domConverter.mapViewToDom(e);
      if (!i)
        return;
      if (B.isAndroid) {
        let d = null;
        for (const h of Array.from(i.childNodes)) {
          if (d && ce(d) && ce(h)) {
            i.normalize();
            break;
          }
          d = h;
        }
      }
      const s = t.inlineFillerPosition, o = i.childNodes, r = Array.from(this.domConverter.viewChildrenToDom(e, { bind: !0 }));
      s && s.parent === e && su(i.ownerDocument, r, s.offset);
      const a = this._diffNodeLists(o, r), l = this._findUpdateActions(a, o, r, pk);
      let c = 0;
      const u = /* @__PURE__ */ new Set();
      for (const d of l)
        d === "delete" ? (u.add(o[c]), Uc(o[c])) : (d === "equal" || d === "update") && c++;
      c = 0;
      for (const d of l)
        d === "insert" ? (im(i, c, r[c]), c++) : d === "update" ? (ou(o[c], r[c].data), c++) : d === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(r[c])), c++);
      for (const d of u)
        d.parentNode || this.domConverter.unbindDomElement(d);
    }
    /**
     * Shorthand for diffing two arrays or node lists of DOM nodes.
     *
     * @param actualDomChildren Actual DOM children
     * @param expectedDomChildren Expected DOM children.
     * @returns The list of actions based on the {@link module:utils/diff~diff} function.
     */
    _diffNodeLists(e, t) {
      return e = _k(e, this._fakeSelectionContainer), Vn(e, t, wk.bind(null, this.domConverter));
    }
    /**
     * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared
     * within one `insert`/`delete` action group, for example:
     *
     * ```
     * Actual DOM:		<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>
     * Expected DOM:	<p>Bar<b>123</b><i>Baz</i><b>456</b></p>
     * Input actions:	[ insert, insert, delete, delete, equal, insert, delete ]
     * Output actions:	[ insert, replace, delete, equal, replace ]
     * ```
     *
     * @param actions Actions array which is a result of the {@link module:utils/diff~diff} function.
     * @param actualDom Actual DOM children
     * @param expectedDom Expected DOM children.
     * @param comparator A comparator function that should return `true` if the given node should be reused
     * (either by the update of a text node data or an element children list for similar elements).
     * @returns Actions array modified with the `update` actions.
     */
    _findUpdateActions(e, t, i, s) {
      if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1)
        return e;
      let o = [], r = [], a = [];
      const l = { equal: 0, insert: 0, delete: 0 };
      for (const c of e)
        c === "insert" ? a.push(i[l.equal + l.insert]) : c === "delete" ? r.push(t[l.equal + l.delete]) : (o = o.concat(Vn(r, a, s).map((u) => u === "equal" ? "update" : u)), o.push("equal"), r = [], a = []), l[c]++;
      return o.concat(Vn(r, a, s).map((c) => c === "equal" ? "update" : c));
    }
    /**
     * Marks text nodes to be synchronized.
     *
     * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.
     *
     * @param viewNode View node to sync.
     */
    _markDescendantTextToSync(e) {
      if (e) {
        if (e.is("$text"))
          this.markedTexts.add(e);
        else if (e.is("element"))
          for (const t of e.getChildren())
            this._markDescendantTextToSync(t);
      }
    }
    /**
     * Checks if the selection needs to be updated and possibly updates it.
     */
    _updateSelection() {
      if (B.isBlink && !B.isAndroid && this.isSelecting && !this.markedChildren.size)
        return;
      if (this.selection.rangeCount === 0) {
        this._removeDomSelection(), this._removeFakeSelection();
        return;
      }
      const e = this.domConverter.mapViewToDom(this.selection.editableElement);
      !this.isFocused || !e || (this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(e)) : this.isComposing && B.isAndroid || this._updateDomSelection(e));
    }
    /**
     * Updates the fake selection.
     *
     * @param domRoot A valid DOM root where the fake selection container should be added.
     */
    _updateFakeSelection(e) {
      const t = e.ownerDocument;
      this._fakeSelectionContainer || (this._fakeSelectionContainer = vk(t));
      const i = this._fakeSelectionContainer;
      if (this.domConverter.bindFakeSelection(i, this.selection), !this._fakeSelectionNeedsUpdate(e))
        return;
      (!i.parentElement || i.parentElement != e) && e.appendChild(i), i.textContent = this.selection.fakeSelectionLabel || " ";
      const s = t.getSelection(), o = t.createRange();
      s.removeAllRanges(), o.selectNodeContents(i), s.addRange(o);
    }
    /**
     * Updates the DOM selection.
     *
     * @param domRoot A valid DOM root where the DOM selection should be rendered.
     */
    _updateDomSelection(e) {
      const t = e.ownerDocument.defaultView.getSelection();
      if (!this._domSelectionNeedsUpdate(t))
        return;
      const i = this.domConverter.viewPositionToDom(this.selection.anchor), s = this.domConverter.viewPositionToDom(this.selection.focus);
      t.setBaseAndExtent(i.parent, i.offset, s.parent, s.offset), B.isGecko && bk(s, t);
    }
    /**
     * Checks whether a given DOM selection needs to be updated.
     *
     * @param domSelection The DOM selection to check.
     */
    _domSelectionNeedsUpdate(e) {
      if (!this.domConverter.isDomSelectionCorrect(e))
        return !0;
      const t = e && this.domConverter.domSelectionToView(e);
      return !(t && this.selection.isEqual(t) || !this.selection.isCollapsed && this.selection.isSimilar(t));
    }
    /**
     * Checks whether the fake selection needs to be updated.
     *
     * @param domRoot A valid DOM root where a new fake selection container should be added.
     */
    _fakeSelectionNeedsUpdate(e) {
      const t = this._fakeSelectionContainer, i = e.ownerDocument.getSelection();
      return !t || t.parentElement !== e || i.anchorNode !== t && !t.contains(i.anchorNode) ? !0 : t.textContent !== this.selection.fakeSelectionLabel;
    }
    /**
     * Removes the DOM selection.
     */
    _removeDomSelection() {
      for (const e of this.domDocuments) {
        const t = e.getSelection();
        if (t.rangeCount) {
          const i = e.activeElement, s = this.domConverter.mapDomToView(i);
          i && s && t.removeAllRanges();
        }
      }
    }
    /**
     * Removes the fake selection.
     */
    _removeFakeSelection() {
      const e = this._fakeSelectionContainer;
      e && e.remove();
    }
    /**
     * Checks if focus needs to be updated and possibly updates it.
     */
    _updateFocus() {
      if (this.isFocused) {
        const e = this.selection.editableElement;
        e && this.domConverter.focus(e);
      }
    }
  }
  function mk(n) {
    if (n.getAttribute("contenteditable") == "false")
      return !1;
    const e = n.findAncestor((t) => t.hasAttribute("contenteditable"));
    return !e || e.getAttribute("contenteditable") == "true";
  }
  function su(n, e, t) {
    const i = e instanceof Array ? e : e.childNodes, s = i[t];
    if (ce(s))
      return s.data = Xn + s.data, s;
    {
      const o = n.createTextNode(Xn);
      return Array.isArray(e) ? i.splice(t, 0, o) : im(e, t, o), o;
    }
  }
  function gk(n, e) {
    return Ht(n) && Ht(e) && !ce(n) && !ce(e) && !Bn(n) && !Bn(e) && n.tagName.toLowerCase() === e.tagName.toLowerCase();
  }
  function pk(n, e) {
    return Ht(n) && Ht(e) && ce(n) && ce(e);
  }
  function wk(n, e, t) {
    return e === t ? !0 : ce(e) && ce(t) ? e.data === t.data : !!(n.isBlockFiller(e) && n.isBlockFiller(t));
  }
  function bk(n, e) {
    const t = n.parent;
    if (t.nodeType != Node.ELEMENT_NODE || n.offset != t.childNodes.length - 1)
      return;
    const i = t.childNodes[n.offset];
    i && i.tagName == "BR" && e.addRange(e.getRangeAt(0));
  }
  function _k(n, e) {
    const t = Array.from(n);
    return t.length == 0 || !e || t[t.length - 1] == e && t.pop(), t;
  }
  function vk(n) {
    const e = n.createElement("div");
    return e.className = "ck-fake-selection-container", Object.assign(e.style, {
      position: "fixed",
      top: 0,
      left: "-9999px",
      // See https://github.com/ckeditor/ckeditor5/issues/752.
      width: "42px"
    }), e.textContent = " ", e;
  }
  function ou(n, e) {
    const t = n.data;
    if (t == e)
      return;
    const i = tf(t, e);
    for (const s of i)
      s.type === "insert" ? n.insertData(s.index, s.values.join("")) : n.deleteData(s.index, s.howMany);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const yk = vm(E.document), Ck = bm(E.document), kk = _m(E.document), Rs = "data-ck-unsafe-attribute-", ru = "data-ck-unsafe-element";
  class Qo {
    /**
     * Creates a DOM converter.
     *
     * @param document The view document instance.
     * @param options An object with configuration options.
     * @param options.blockFillerMode The type of the block filler to use.
     * Default value depends on the options.renderingMode:
     *  'nbsp' when options.renderingMode == 'data',
     *  'br' when options.renderingMode == 'editing'.
     * @param options.renderingMode Whether to leave the View-to-DOM conversion result unchanged
     * or improve editing experience by filtering out interactive data.
     */
    constructor(e, { blockFillerMode: t, renderingMode: i = "editing" } = {}) {
      this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new rt(), this._inlineObjectElementMatcher = new rt(), this._elementsWithTemporaryCustomProperties = /* @__PURE__ */ new Set(), this.document = e, this.renderingMode = i, this.blockFillerMode = t || (i === "editing" ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = [
        "address",
        "article",
        "aside",
        "blockquote",
        "caption",
        "center",
        "dd",
        "details",
        "dir",
        "div",
        "dl",
        "dt",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "legend",
        "li",
        "main",
        "menu",
        "nav",
        "ol",
        "p",
        "pre",
        "section",
        "summary",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr",
        "ul"
      ], this.inlineObjectElements = [
        "object",
        "iframe",
        "input",
        "button",
        "textarea",
        "select",
        "option",
        "video",
        "embed",
        "audio",
        "img",
        "canvas"
      ], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? E.document : E.document.implementation.createHTMLDocument("");
    }
    /**
     * Binds a given DOM element that represents fake selection to a **position** of a
     * {@link module:engine/view/documentselection~DocumentSelection document selection}.
     * Document selection copy is stored and can be retrieved by the
     * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.
     */
    bindFakeSelection(e, t) {
      this._fakeSelectionMapping.set(e, new St(t));
    }
    /**
     * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given
     * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.
     */
    fakeSelectionToView(e) {
      return this._fakeSelectionMapping.get(e);
    }
    /**
     * Binds DOM and view elements, so it will be possible to get corresponding elements using
     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
     *
     * @param domElement The DOM element to bind.
     * @param viewElement The view element to bind.
     */
    bindElements(e, t) {
      this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
    }
    /**
     * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of
     * the DOM element will be unbound too.
     *
     * @param domElement The DOM element to unbind.
     */
    unbindDomElement(e) {
      const t = this._domToViewMapping.get(e);
      if (t) {
        this._domToViewMapping.delete(e), this._viewToDomMapping.delete(t);
        for (const i of Array.from(e.children))
          this.unbindDomElement(i);
      }
    }
    /**
     * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using
     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
     *
     * @param domFragment The DOM document fragment to bind.
     * @param viewFragment The view document fragment to bind.
     */
    bindDocumentFragments(e, t) {
      this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
    }
    /**
     * Decides whether a given pair of attribute key and value should be passed further down the pipeline.
     *
     * @param elementName Element name in lower case.
     */
    shouldRenderAttribute(e, t, i) {
      return this.renderingMode === "data" ? !0 : (e = e.toLowerCase(), e.startsWith("on") || e === "srcdoc" && t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i) ? !1 : i === "img" && (e === "src" || e === "srcset") || i === "source" && e === "srcset" ? !0 : !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i));
    }
    /**
     * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.
     *
     * @param domElement DOM element that should have `html` set as its content.
     * @param html Textual representation of the HTML that will be set on `domElement`.
     */
    setContentOf(e, t) {
      if (this.renderingMode === "data") {
        e.innerHTML = t;
        return;
      }
      const i = new DOMParser().parseFromString(t, "text/html"), s = i.createDocumentFragment(), o = i.body.childNodes;
      for (; o.length > 0; )
        s.appendChild(o[0]);
      const r = i.createTreeWalker(s, NodeFilter.SHOW_ELEMENT), a = [];
      let l;
      for (; l = r.nextNode(); )
        a.push(l);
      for (const c of a) {
        for (const d of c.getAttributeNames())
          this.setDomElementAttribute(c, d, c.getAttribute(d));
        const u = c.tagName.toLowerCase();
        this._shouldRenameElement(u) && (lu(u), c.replaceWith(this._createReplacementDomElement(u, c)));
      }
      for (; e.firstChild; )
        e.firstChild.remove();
      e.append(s);
    }
    /**
     * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will
     * be created. For bound elements and document fragments the method will return corresponding items.
     *
     * @param viewNode View node or document fragment to transform.
     * @param options Conversion options.
     * @param options.bind Determines whether new elements will be bound.
     * @param options.withChildren If `false`, node's and document fragment's children will not be converted.
     * @returns Converted node or DocumentFragment.
     */
    viewToDom(e, t = {}) {
      if (e.is("$text")) {
        const i = this._processDataFromViewText(e);
        return this._domDocument.createTextNode(i);
      } else {
        const i = e;
        if (this.mapViewToDom(i))
          if (i.getCustomProperty("editingPipeline:doNotReuseOnce"))
            this._elementsWithTemporaryCustomProperties.add(i);
          else
            return this.mapViewToDom(i);
        let s;
        if (i.is("documentFragment"))
          s = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(s, i);
        else {
          if (i.is("uiElement"))
            return i.name === "$comment" ? s = this._domDocument.createComment(i.getCustomProperty("$rawContent")) : s = i.render(this._domDocument, this), t.bind && this.bindElements(s, i), s;
          this._shouldRenameElement(i.name) ? (lu(i.name), s = this._createReplacementDomElement(i.name)) : i.hasAttribute("xmlns") ? s = this._domDocument.createElementNS(i.getAttribute("xmlns"), i.name) : s = this._domDocument.createElement(i.name), i.is("rawElement") && i.render(s, this), t.bind && this.bindElements(s, i);
          for (const o of i.getAttributeKeys())
            this.setDomElementAttribute(s, o, i.getAttribute(o), i);
        }
        if (t.withChildren !== !1)
          for (const o of this.viewChildrenToDom(i, t))
            s.appendChild(o);
        return s;
      }
    }
    /**
     * Sets the attribute on a DOM element.
     *
     * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.
     *
     * @param domElement The DOM element the attribute should be set on.
     * @param key The name of the attribute.
     * @param value The value of the attribute.
     * @param relatedViewElement The view element related to the `domElement` (if there is any).
     * It helps decide whether the attribute set is unsafe. For instance, view elements created via the
     * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.
     */
    setDomElementAttribute(e, t, i, s) {
      const o = this.shouldRenderAttribute(t, i, e.tagName.toLowerCase()) || s && s.shouldRenderUnsafeAttribute(t);
      if (o || z("domconverter-unsafe-attribute-detected", { domElement: e, key: t, value: i }), !rC(t)) {
        z("domconverter-invalid-attribute-detected", { domElement: e, key: t, value: i });
        return;
      }
      e.hasAttribute(t) && !o ? e.removeAttribute(t) : e.hasAttribute(Rs + t) && o && e.removeAttribute(Rs + t), e.setAttribute(o ? t : Rs + t, i);
    }
    /**
     * Removes an attribute from a DOM element.
     *
     * **Note**: To set the attribute, use {@link #setDomElementAttribute}.
     *
     * @param domElement The DOM element the attribute should be removed from.
     * @param key The name of the attribute.
     */
    removeDomElementAttribute(e, t) {
      t != ru && (e.removeAttribute(t), e.removeAttribute(Rs + t));
    }
    /**
     * Converts children of the view element to DOM using the
     * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
     * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
     *
     * @param viewElement Parent view element.
     * @param options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
     * @returns DOM nodes.
     */
    *viewChildrenToDom(e, t = {}) {
      const i = e.getFillerOffset && e.getFillerOffset();
      let s = 0;
      for (const o of e.getChildren()) {
        i === s && (yield this._getBlockFiller());
        const r = o.is("element") && !!o.getCustomProperty("dataPipeline:transparentRendering") && !me(o.getAttributes());
        r && this.renderingMode == "data" ? yield* this.viewChildrenToDom(o, t) : (r && z("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: o }), yield this.viewToDom(o, t)), s++;
      }
      i === s && (yield this._getBlockFiller());
    }
    /**
     * Converts view {@link module:engine/view/range~Range} to DOM range.
     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
     *
     * @param viewRange View range.
     * @returns DOM range.
     */
    viewRangeToDom(e) {
      const t = this.viewPositionToDom(e.start), i = this.viewPositionToDom(e.end), s = this._domDocument.createRange();
      return s.setStart(t.parent, t.offset), s.setEnd(i.parent, i.offset), s;
    }
    /**
     * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
     *
     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
     * If the converted position is directly before inline filler it is moved inside the filler.
     *
     * @param viewPosition View position.
     * @returns DOM position or `null` if view position could not be converted to DOM.
     * DOM position has two properties:
     * * `parent` - DOM position parent.
     * * `offset` - DOM position offset.
     */
    viewPositionToDom(e) {
      const t = e.parent;
      if (t.is("$text")) {
        const i = this.findCorrespondingDomText(t);
        if (!i)
          return null;
        let s = e.offset;
        return Oe(i) && (s += nt), { parent: i, offset: s };
      } else {
        let i, s, o;
        if (e.offset === 0) {
          if (i = this.mapViewToDom(t), !i)
            return null;
          o = i.childNodes[0];
        } else {
          const a = e.nodeBefore;
          if (s = a.is("$text") ? this.findCorrespondingDomText(a) : this.mapViewToDom(a), !s)
            return null;
          i = s.parentNode, o = s.nextSibling;
        }
        if (ce(o) && Oe(o))
          return { parent: o, offset: nt };
        const r = s ? Is(s) + 1 : 0;
        return { parent: i, offset: r };
      }
    }
    /**
     * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
     * be created. For bound elements and document fragments function will return corresponding items. For
     * {@link module:engine/view/filler fillers} `null` will be returned.
     * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
     *
     * @param domNode DOM node or document fragment to transform.
     * @param options Conversion options.
     * @param options.bind Determines whether new elements will be bound. False by default.
     * @param options.withChildren If `true`, node's and document fragment's children will be converted too. True by default.
     * @param options.keepOriginalCase If `false`, node's tag name will be converted to lower case. False by default.
     * @param options.skipComments If `false`, comment nodes will be converted to `$comment`
     * {@link module:engine/view/uielement~UIElement view UI elements}. False by default.
     * @returns Converted node or document fragment or `null` if DOM node is a {@link module:engine/view/filler filler}
     * or the given node is an empty text node.
     */
    domToView(e, t = {}) {
      const i = [], s = this._domToView(e, t, i), o = s.next().value;
      return !o || (s.next(), this._processDomInlineNodes(null, i, t), o.is("$text") && o.data.length == 0) ? null : o;
    }
    /**
     * Converts children of the DOM element to view nodes using
     * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
     * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
     *
     * @param domElement Parent DOM element.
     * @param options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
     * @param inlineNodes An array that will be populated with inline nodes. It's used internally for whitespace processing.
     * @returns View nodes.
     */
    *domChildrenToView(e, t = {}, i = []) {
      for (let s = 0; s < e.childNodes.length; s++) {
        const o = e.childNodes[s], r = this._domToView(o, t, i), a = r.next().value;
        a !== null && (this._isBlockViewElement(a) && this._processDomInlineNodes(e, i, t), yield a, r.next());
      }
      this._processDomInlineNodes(e, i, t);
    }
    /**
     * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
     * Ranges which cannot be converted will be omitted.
     *
     * @param domSelection DOM selection.
     * @returns View selection.
     */
    domSelectionToView(e) {
      if (Ak(e))
        return new St([]);
      if (e.rangeCount === 1) {
        let s = e.getRangeAt(0).startContainer;
        ce(s) && (s = s.parentNode);
        const o = this.fakeSelectionToView(s);
        if (o)
          return o;
      }
      const t = this.isDomSelectionBackward(e), i = [];
      for (let s = 0; s < e.rangeCount; s++) {
        const o = e.getRangeAt(s), r = this.domRangeToView(o);
        r && i.push(r);
      }
      return new St(i, { backward: t });
    }
    /**
     * Converts DOM Range to view {@link module:engine/view/range~Range}.
     * If the start or end position can not be converted `null` is returned.
     *
     * @param domRange DOM range.
     * @returns View range.
     */
    domRangeToView(e) {
      const t = this.domPositionToView(e.startContainer, e.startOffset), i = this.domPositionToView(e.endContainer, e.endOffset);
      return t && i ? new N(t, i) : null;
    }
    /**
     * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
     *
     * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
     * position of the filler will be converted and returned.
     *
     * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
     * that position will be converted to view position before that UIElement.
     *
     * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
     *
     * @param domParent DOM position parent.
     * @param domOffset DOM position offset. You can skip it when converting the inline filler node.
     * @returns View position.
     */
    domPositionToView(e, t = 0) {
      if (this.isBlockFiller(e))
        return this.domPositionToView(e.parentNode, Is(e));
      const i = this.mapDomToView(e);
      if (i && (i.is("uiElement") || i.is("rawElement")))
        return k._createBefore(i);
      if (ce(e)) {
        if (In(e))
          return this.domPositionToView(e.parentNode, Is(e));
        const s = this.findCorrespondingViewText(e);
        let o = t;
        return s ? (Oe(e) && (o -= nt, o = o < 0 ? 0 : o), new k(s, o)) : null;
      } else {
        if (t === 0) {
          const s = this.mapDomToView(e);
          if (s)
            return new k(s, 0);
        } else {
          const s = e.childNodes[t - 1];
          if (ce(s) && In(s) || s && this.isBlockFiller(s))
            return this.domPositionToView(s.parentNode, Is(s));
          const o = ce(s) ? this.findCorrespondingViewText(s) : this.mapDomToView(s);
          if (o && o.parent)
            return new k(o.parent, o.index + 1);
        }
        return null;
      }
    }
    /**
     * Returns corresponding view {@link module:engine/view/element~Element Element} or
     * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
     * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
     * to the given DOM - `undefined` is returned.
     *
     * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or
     * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
     *
     * @param domElementOrDocumentFragment DOM element or document fragment.
     * @returns Corresponding view element, document fragment or `undefined` if no element was bound.
     */
    mapDomToView(e) {
      return this.getHostViewElement(e) || this._domToViewMapping.get(e);
    }
    /**
     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
     * corresponding text node is returned based on the sibling or parent.
     *
     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
     * to find the corresponding text node.
     *
     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
     * element, it is used to find the corresponding text node.
     *
     * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or
     * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
     *
     * Otherwise `null` is returned.
     *
     * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
     *
     * @param domText DOM text node.
     * @returns Corresponding view text node or `null`, if it was not possible to find a corresponding node.
     */
    findCorrespondingViewText(e) {
      if (In(e))
        return null;
      const t = this.getHostViewElement(e);
      if (t)
        return t;
      const i = e.previousSibling;
      if (i) {
        if (!this.isElement(i))
          return null;
        const s = this.mapDomToView(i);
        if (s) {
          const o = s.nextSibling;
          return o instanceof ie ? o : null;
        }
      } else {
        const s = this.mapDomToView(e.parentNode);
        if (s) {
          const o = s.getChild(0);
          return o instanceof ie ? o : null;
        }
      }
      return null;
    }
    mapViewToDom(e) {
      return this._viewToDomMapping.get(e);
    }
    /**
     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
     * corresponding text node is returned based on the sibling or parent.
     *
     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
     * to find the corresponding text node.
     *
     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
     * element, it is used to find the corresponding text node.
     *
     * Otherwise `null` is returned.
     *
     * @param viewText View text node.
     * @returns Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
     */
    findCorrespondingDomText(e) {
      const t = e.previousSibling;
      return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null;
    }
    /**
     * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
     */
    focus(e) {
      const t = this.mapViewToDom(e);
      if (t && t.ownerDocument.activeElement !== t) {
        const { scrollX: i, scrollY: s } = E.window, o = [];
        au(t, (r) => {
          const { scrollLeft: a, scrollTop: l } = r;
          o.push([a, l]);
        }), t.focus(), au(t, (r) => {
          const [a, l] = o.shift();
          r.scrollLeft = a, r.scrollTop = l;
        }), E.window.scrollTo(i, s);
      }
    }
    /**
     * Remove DOM selection from blurred editable, so it won't interfere with clicking on dropdowns (especially on iOS).
     *
     * @internal
     */
    _clearDomSelection() {
      const e = this.mapViewToDom(this.document.selection.editableElement);
      if (!e)
        return;
      const t = e.ownerDocument.defaultView.getSelection(), i = this.domSelectionToView(t);
      i && i.rangeCount > 0 && t.removeAllRanges();
    }
    /**
     * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
     *
     * @param node Node to check.
     */
    isElement(e) {
      return e && e.nodeType == Node.ELEMENT_NODE;
    }
    /**
     * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
     *
     * @param node Node to check.
     */
    isDocumentFragment(e) {
      return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
    }
    /**
     * Checks if the node is an instance of the block filler for this DOM converter.
     *
     * ```ts
     * const converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );
     *
     * converter.isBlockFiller( BR_FILLER( document ) ); // true
     * converter.isBlockFiller( NBSP_FILLER( document ) ); // false
     * ```
     *
     * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
     *
     * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
     *
     * @param domNode DOM node to check.
     * @returns True if a node is considered a block filler for given mode.
     */
    isBlockFiller(e) {
      return this.blockFillerMode == "br" ? e.isEqualNode(yk) : e.tagName === "BR" && ym(e, this.blockElements) && e.parentNode.childNodes.length === 1 ? !0 : e.isEqualNode(kk) || Ek(e, this.blockElements);
    }
    /**
     * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
     *
     * @param DOM Selection instance to check.
     */
    isDomSelectionBackward(e) {
      if (e.isCollapsed)
        return !1;
      const t = this._domDocument.createRange();
      try {
        t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset);
      } catch (s) {
        return !1;
      }
      const i = t.collapsed;
      return t.detach(), i;
    }
    /**
     * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}
     * that hosts the provided DOM node. Returns `null` if there is no such parent.
     */
    getHostViewElement(e) {
      const t = iC(e);
      for (t.pop(); t.length; ) {
        const i = t.pop(), s = this._domToViewMapping.get(i);
        if (s && (s.is("uiElement") || s.is("rawElement")))
          return s;
      }
      return null;
    }
    /**
     * Checks if the given selection's boundaries are at correct places.
     *
     * The following places are considered as incorrect for selection boundaries:
     *
     * * before or in the middle of an inline filler sequence,
     * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},
     * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.
     *
     * @param domSelection The DOM selection object to be checked.
     * @returns `true` if the given selection is at a correct place, `false` otherwise.
     */
    isDomSelectionCorrect(e) {
      return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset);
    }
    /**
     * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
     * and not processed during the conversion from DOM nodes to view elements.
     *
     * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
     * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
     *
     * The raw data can be later accessed by a
     * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
     *
     * @param pattern Pattern matching a view element whose content should
     * be treated as raw data.
     */
    registerRawContentMatcher(e) {
      this._rawContentElementMatcher.add(e);
    }
    /**
     * Registers a {@link module:engine/view/matcher~MatcherPattern} for inline object view elements.
     *
     * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
     * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
     *
     * This is an extension of a simple {@link #inlineObjectElements} array of element names.
     *
     * @param pattern Pattern matching a view element which should be treated as an inline object.
     */
    registerInlineObjectMatcher(e) {
      this._inlineObjectElementMatcher.add(e);
    }
    /**
     * Clear temporary custom properties.
     *
     * @internal
     */
    _clearTemporaryCustomProperties() {
      for (const e of this._elementsWithTemporaryCustomProperties)
        e._removeCustomProperty("editingPipeline:doNotReuseOnce");
      this._elementsWithTemporaryCustomProperties.clear();
    }
    /**
     * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.
     */
    _getBlockFiller() {
      switch (this.blockFillerMode) {
        case "nbsp":
          return bm(this._domDocument);
        case "markedNbsp":
          return _m(this._domDocument);
        case "br":
          return vm(this._domDocument);
      }
    }
    /**
     * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
     *
     * @param domParent Position parent.
     * @param offset Position offset.
     * @returns `true` if given position is at a correct place for selection boundary, `false` otherwise.
     */
    _isDomSelectionPositionCorrect(e, t) {
      if (ce(e) && Oe(e) && t < nt || this.isElement(e) && Oe(e.childNodes[t]))
        return !1;
      const i = this.mapDomToView(e);
      return !(i && (i.is("uiElement") || i.is("rawElement")));
    }
    /**
     * Internal generator for {@link #domToView}. Also used by {@link #domChildrenToView}.
     * Separates DOM nodes conversion from whitespaces processing.
     *
     * @param domNode DOM node or document fragment to transform.
     * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
     * Used later to process whitespaces.
     */
    *_domToView(e, t, i) {
      if (this.isBlockFiller(e))
        return null;
      const s = this.getHostViewElement(e);
      if (s)
        return s;
      if (Bn(e) && t.skipComments)
        return null;
      if (ce(e)) {
        if (In(e))
          return null;
        {
          const o = e.data;
          if (o === "")
            return null;
          const r = new ie(this.document, o);
          return i.push(r), r;
        }
      } else {
        let o = this.mapDomToView(e);
        if (o)
          return this._isInlineObjectElement(o) && i.push(o), o;
        if (this.isDocumentFragment(e))
          o = new ri(this.document), t.bind && this.bindDocumentFragments(e, o);
        else {
          o = this._createViewElement(e, t), t.bind && this.bindElements(e, o);
          const a = e.attributes;
          if (a)
            for (let l = a.length, c = 0; c < l; c++)
              o._setAttribute(a[c].name, a[c].value);
          if (this._isViewElementWithRawContent(o, t))
            return o._setCustomProperty("$rawContent", e.innerHTML), this._isBlockViewElement(o) || i.push(o), o;
          if (Bn(e))
            return o._setCustomProperty("$rawContent", e.data), o;
        }
        yield o;
        const r = [];
        if (t.withChildren !== !1)
          for (const a of this.domChildrenToView(e, t, r))
            o._appendChild(a);
        if (this._isInlineObjectElement(o))
          i.push(o);
        else
          for (const a of r)
            i.push(a);
      }
    }
    /**
     * Internal helper that walks the list of inline view nodes already generated from DOM nodes
     * and handles whitespaces and NBSPs.
     *
     * @param domParent The DOM parent of the given inline nodes. This should be a document fragment or
     * a block element to whitespace processing start cleaning.
     * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
     */
    _processDomInlineNodes(e, t, i) {
      if (!t.length || e && !this.isDocumentFragment(e) && !this._isBlockDomElement(e))
        return;
      let s = !1;
      for (let o = 0; o < t.length; o++) {
        const r = t[o];
        if (!r.is("$text")) {
          s = !1;
          continue;
        }
        let a, l = !1;
        if (Tk(r, this.preElements))
          a = nu(r.data);
        else {
          a = r.data.replace(/[ \n\t\r]{1,}/g, " "), l = /[^\S\u00A0]/.test(a.charAt(a.length - 1));
          const c = o > 0 ? t[o - 1] : null, u = o + 1 < t.length ? t[o + 1] : null, d = !c || c.is("element") && c.name == "br" || s, h = u ? !1 : !Oe(r.data);
          i.withChildren !== !1 && (d && (a = a.replace(/^ /, "")), h && (a = a.replace(/ $/, ""))), a = nu(a), a = a.replace(/ \u00A0/g, "  ");
          const f = u && u.is("element") && u.name != "br", m = u && u.is("$text") && u.data.charAt(0) == " ";
          (/[ \u00A0]\u00A0$/.test(a) || !u || f || m) && (a = a.replace(/\u00A0$/, " ")), (d || c && c.is("element") && c.name != "br") && (a = a.replace(/^\u00A0/, " "));
        }
        a.length == 0 && r.parent ? (r._remove(), t.splice(o, 1), o--) : (r._data = a, s = l);
      }
      t.length = 0;
    }
    /**
     * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
     * it is correctly displayed in the DOM.
     *
     * Following changes are done:
     *
     * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
     * element or if a previous text node ends with a space character,
     * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
     * starts with a space or if it is the last text node in its container,
     * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
     *
     * Content of {@link #preElements} is not processed.
     *
     * @param node View text node to process.
     * @returns Processed text data.
     */
    _processDataFromViewText(e) {
      let t = e.data;
      if (e.getAncestors().some((i) => this.preElements.includes(i.name)))
        return t;
      if (t.charAt(0) == " ") {
        const i = this._getTouchingInlineViewNode(e, !1);
        (i && i.is("$textProxy") && this._nodeEndsWithSpace(i) || !i) && (t = " " + t.substr(1));
      }
      if (t.charAt(t.length - 1) == " ") {
        const i = this._getTouchingInlineViewNode(e, !0), s = i && i.is("$textProxy") && i.data.charAt(0) == " ";
        (t.charAt(t.length - 2) == " " || !i || s) && (t = t.substr(0, t.length - 1) + " ");
      }
      return t.replace(/ {2}/g, "  ");
    }
    /**
     * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
     *
     * @param  node Node to check.
     * @returns `true` if given `node` ends with space, `false` otherwise.
     */
    _nodeEndsWithSpace(e) {
      if (e.getAncestors().some((i) => this.preElements.includes(i.name)))
        return !1;
      const t = this._processDataFromViewText(e);
      return t.charAt(t.length - 1) == " ";
    }
    /**
     * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
     * that is contained in the same container element. If there is no such sibling, `null` is returned.
     *
     * @param node Reference node.
     * @returns Touching text node, an inline object
     * or `null` if there is no next or previous touching text node.
     */
    _getTouchingInlineViewNode(e, t) {
      const i = new si({
        startPosition: t ? k._createAfter(e) : k._createBefore(e),
        direction: t ? "forward" : "backward"
      });
      for (const s of i) {
        if (s.item.is("element", "br"))
          return null;
        if (this._isInlineObjectElement(s.item))
          return s.item;
        if (s.item.is("containerElement"))
          return null;
        if (s.item.is("$textProxy"))
          return s.item;
      }
      return null;
    }
    /**
     * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.
     */
    _isBlockDomElement(e) {
      return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase());
    }
    /**
     * Returns `true` if a view node belongs to {@link #blockElements}. `false` otherwise.
     */
    _isBlockViewElement(e) {
      return e.is("element") && this.blockElements.includes(e.name);
    }
    /**
     * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.
     */
    _isInlineObjectElement(e) {
      return e.is("element") ? e.name == "br" || this.inlineObjectElements.includes(e.name) || !!this._inlineObjectElementMatcher.match(e) : !1;
    }
    /**
     * Creates view element basing on the node type.
     *
     * @param node DOM node to check.
     * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
     */
    _createViewElement(e, t) {
      if (Bn(e))
        return new Yo(this.document, "$comment");
      const i = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
      return new at(this.document, i);
    }
    /**
     * Checks if view element's content should be treated as a raw data.
     *
     * @param viewElement View element to check.
     * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
     */
    _isViewElementWithRawContent(e, t) {
      return t.withChildren !== !1 && e.is("element") && !!this._rawContentElementMatcher.match(e);
    }
    /**
     * Checks whether a given element name should be renamed in a current rendering mode.
     *
     * @param elementName The name of view element.
     */
    _shouldRenameElement(e) {
      const t = e.toLowerCase();
      return this.renderingMode === "editing" && this.unsafeElements.includes(t);
    }
    /**
     * Return a <span> element with a special attribute holding the name of the original element.
     * Optionally, copy all the attributes of the original element if that element is provided.
     *
     * @param elementName The name of view element.
     * @param originalDomElement The original DOM element to copy attributes and content from.
     */
    _createReplacementDomElement(e, t) {
      const i = this._domDocument.createElement("span");
      if (i.setAttribute(ru, e), t) {
        for (; t.firstChild; )
          i.appendChild(t.firstChild);
        for (const s of t.getAttributeNames())
          i.setAttribute(s, t.getAttribute(s));
      }
      return i;
    }
  }
  function Tk(n, e) {
    return n.getAncestors().some((t) => t.is("element") && e.includes(t.name));
  }
  function au(n, e) {
    let t = n;
    for (; t; )
      e(t), t = t.parentElement;
  }
  function Ek(n, e) {
    return n.isEqualNode(Ck) && ym(n, e) && n.parentNode.childNodes.length === 1;
  }
  function ym(n, e) {
    const t = n.parentNode;
    return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase());
  }
  function lu(n) {
    n === "script" && z("domconverter-unsafe-script-element-detected"), n === "style" && z("domconverter-unsafe-style-element-detected");
  }
  function Ak(n) {
    if (!B.isGecko || !n.rangeCount)
      return !1;
    const e = n.getRangeAt(0).startContainer;
    try {
      Object.prototype.toString.call(e);
    } catch (t) {
      return !0;
    }
    return !1;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class _t extends Me() {
    /**
     * Creates an instance of the observer.
     */
    constructor(e) {
      super(), this._isEnabled = !1, this.view = e, this.document = e.document;
    }
    /**
     * The state of the observer. If it is disabled, no events will be fired.
     */
    get isEnabled() {
      return this._isEnabled;
    }
    /**
     * Enables the observer. This method is called when the observer is registered to the
     * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
     * (all observers are {@link #disable disabled} before rendering).
     *
     * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
     * However, a child class may not need to be disabled, so it can implement an empty method.
     *
     * @see module:engine/view/observer/observer~Observer#disable
     */
    enable() {
      this._isEnabled = !0;
    }
    /**
     * Disables the observer. This method is called before
     * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
     *
     * @see module:engine/view/observer/observer~Observer#enable
     */
    disable() {
      this._isEnabled = !1;
    }
    /**
     * Disables and destroys the observer, among others removes event listeners created by the observer.
     */
    destroy() {
      this.disable(), this.stopListening();
    }
    /**
     * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
     *
     * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
     * This attribute can be used inside the structures generated by
     * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `DowncastWriter#createUIElement()`} to ignore events
     * fired within a UI that should be excluded from CKEditor 5's realms.
     *
     * @param domTarget The DOM event target to check (usually an element, sometimes a text node and
     * potentially sometimes a document, too).
     * @returns Whether this event should be ignored by the observer.
     */
    checkShouldIgnoreEventFromTarget(e) {
      return e && e.nodeType === 3 && (e = e.parentNode), !e || e.nodeType !== 1 ? !1 : e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Xi {
    /**
     * @param view The instance of the view controller.
     * @param domEvent The DOM event.
     * @param additionalData Additional properties that the instance should contain.
     */
    constructor(e, t, i) {
      this.view = e, this.document = e.document, this.domEvent = t, this.domTarget = t.target, _f(this, i);
    }
    /**
     * The tree view element representing the target.
     */
    get target() {
      return this.view.domConverter.mapDomToView(this.domTarget);
    }
    /**
     * Prevents the native's event default action.
     */
    preventDefault() {
      this.domEvent.preventDefault();
    }
    /**
     * Stops native event propagation.
     */
    stopPropagation() {
      this.domEvent.stopPropagation();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Gt extends _t {
    constructor() {
      super(...arguments), this.useCapture = !1;
    }
    /**
     * @inheritDoc
     */
    observe(e) {
      (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach((i) => {
        this.listenTo(e, i, (s, o) => {
          this.isEnabled && !this.checkShouldIgnoreEventFromTarget(o.target) && this.onDomEvent(o);
        }, { useCapture: this.useCapture });
      });
    }
    /**
     * @inheritDoc
     */
    stopObserving(e) {
      this.stopListening(e);
    }
    /**
     * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
     *
     * @see module:utils/emittermixin~Emitter#fire
     * @param eventType The event type (name).
     * @param domEvent The DOM event.
     * @param additionalData The additional data which should extend the
     * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
     */
    fire(e, t, i) {
      this.isEnabled && this.document.fire(e, new Xi(this.view, t, i));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class xk extends Gt {
    constructor() {
      super(...arguments), this.domEventType = ["keydown", "keyup"];
    }
    /**
     * @inheritDoc
     */
    onDomEvent(e) {
      const t = {
        keyCode: e.keyCode,
        altKey: e.altKey,
        ctrlKey: e.ctrlKey,
        shiftKey: e.shiftKey,
        metaKey: e.metaKey,
        get keystroke() {
          return Ji(this);
        }
      };
      this.fire(e.type, e, t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Sk extends _t {
    /**
     * Creates new FakeSelectionObserver instance.
     */
    constructor(e) {
      super(e), this._fireSelectionChangeDoneDebounced = Rt((t) => {
        this.document.fire("selectionChangeDone", t);
      }, 200);
    }
    /**
     * @inheritDoc
     */
    observe() {
      const e = this.document;
      e.on("arrowKey", (t, i) => {
        e.selection.isFake && this.isEnabled && i.preventDefault();
      }, { context: "$capture" }), e.on("arrowKey", (t, i) => {
        e.selection.isFake && this.isEnabled && this._handleSelectionMove(i.keyCode);
      }, { priority: "lowest" });
    }
    /**
     * @inheritDoc
     */
    stopObserving() {
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
    }
    /**
     * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
     * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
     *
     * This method fires {@link module:engine/view/document~Document#event:selectionChange} and
     * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of
     * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
     */
    _handleSelectionMove(e) {
      const t = this.document.selection, i = new St(t.getRanges(), { backward: t.isBackward, fake: !1 });
      (e == F.arrowleft || e == F.arrowup) && i.setTo(i.getFirstPosition()), (e == F.arrowright || e == F.arrowdown) && i.setTo(i.getLastPosition());
      const s = {
        oldSelection: t,
        newSelection: i,
        domSelection: null
      };
      this.document.fire("selectionChange", s), this._fireSelectionChangeDoneDebounced(s);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let Cm = class extends _t {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._config = {
        childList: !0,
        characterData: !0,
        subtree: !0
      }, this.domConverter = e.domConverter, this.renderer = e._renderer, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
    }
    /**
     * Synchronously handles mutations and empties the queue.
     */
    flush() {
      this._onMutations(this._mutationObserver.takeRecords());
    }
    /**
     * @inheritDoc
     */
    observe(e) {
      this._domElements.add(e), this.isEnabled && this._mutationObserver.observe(e, this._config);
    }
    /**
     * @inheritDoc
     */
    stopObserving(e) {
      if (this._domElements.delete(e), this.isEnabled) {
        this._mutationObserver.disconnect();
        for (const t of this._domElements)
          this._mutationObserver.observe(t, this._config);
      }
    }
    /**
     * @inheritDoc
     */
    enable() {
      super.enable();
      for (const e of this._domElements)
        this._mutationObserver.observe(e, this._config);
    }
    /**
     * @inheritDoc
     */
    disable() {
      super.disable(), this._mutationObserver.disconnect();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this._mutationObserver.disconnect();
    }
    /**
     * Handles mutations. Mark view elements to sync and call render.
     *
     * @param domMutations Array of native mutations.
     */
    _onMutations(e) {
      if (e.length === 0)
        return;
      const t = this.domConverter, i = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
      for (const r of e) {
        const a = t.mapDomToView(r.target);
        a && (a.is("uiElement") || a.is("rawElement") || r.type === "childList" && !this._isBogusBrMutation(r) && s.add(a));
      }
      for (const r of e) {
        const a = t.mapDomToView(r.target);
        if (!(a && (a.is("uiElement") || a.is("rawElement"))) && r.type === "characterData") {
          const l = t.findCorrespondingViewText(r.target);
          l && !s.has(l.parent) ? i.add(l) : !l && Oe(r.target) && s.add(t.mapDomToView(r.target.parentNode));
        }
      }
      let o = !1;
      for (const r of i)
        o = !0, this.renderer.markToSync("text", r);
      for (const r of s) {
        const a = t.mapViewToDom(r), l = Array.from(r.getChildren()), c = Array.from(t.domChildrenToView(a, { withChildren: !1 }));
        Dy(l, c, Ik) || (o = !0, this.renderer.markToSync("children", r));
      }
      o && this.view.forceRender();
    }
    /**
     * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
     * Such mutations are generated while pressing space or performing native spellchecker correction
     * on the end of the block element in Firefox browser.
     *
     * @param mutation Native mutation object.
     */
    _isBogusBrMutation(e) {
      let t = null;
      return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], {
        withChildren: !1
      })), t && t.is("element", "br");
    }
  };
  function Ik(n, e) {
    if (!Array.isArray(n))
      return n === e ? !0 : n.is("$text") && e.is("$text") ? n.data === e.data : !1;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class To extends Gt {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
      const t = this.document;
      t.on("focus", () => {
        this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
          this.flush(), e.change(() => {
          });
        }, 50);
      }), t.on("blur", (i, s) => {
        const o = t.selection.editableElement;
        (o === null || o === s.target) && (t.isFocused = !1, this._isFocusChanging = !1, e.change(() => {
        }));
      });
    }
    /**
     * Finishes setting the document focus state.
     */
    flush() {
      this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0);
    }
    /**
     * @inheritDoc
     */
    onDomEvent(e) {
      this.fire(e.type, e);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Pk extends _t {
    constructor(e) {
      super(e), this.mutationObserver = e.getObserver(Cm), this.focusObserver = e.getObserver(To), this.selection = this.document.selection, this.domConverter = e.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = Rt((t) => {
        this.document.fire("selectionChangeDone", t);
      }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = Rt(() => this.document.isSelecting = !1, 5e3), this._loopbackCounter = 0;
    }
    /**
     * @inheritDoc
     */
    observe(e) {
      const t = e.ownerDocument, i = () => {
        this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced();
      }, s = () => {
        this.document.isSelecting && (this._handleSelectionChange(null, t), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
      };
      this.listenTo(e, "selectstart", i, { priority: "highest" }), this.listenTo(e, "keydown", s, { priority: "highest", useCapture: !0 }), this.listenTo(e, "keyup", s, { priority: "highest", useCapture: !0 }), !this._documents.has(t) && (this.listenTo(t, "mouseup", s, { priority: "highest", useCapture: !0 }), this.listenTo(t, "selectionchange", (o, r) => {
        this.document.isComposing && !B.isAndroid || (this._handleSelectionChange(r, t), this._documentIsSelectingInactivityTimeoutDebounced());
      }), this._documents.add(t));
    }
    /**
     * @inheritDoc
     */
    stopObserving(e) {
      this.stopListening(e);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
    }
    /* istanbul ignore next -- @preserve */
    _reportInfiniteLoop() {
    }
    /**
     * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
     * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change
     * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.
     *
     * @param domEvent DOM event.
     * @param domDocument DOM document.
     */
    _handleSelectionChange(e, t) {
      if (!this.isEnabled)
        return;
      const i = t.defaultView.getSelection();
      if (this.checkShouldIgnoreEventFromTarget(i.anchorNode))
        return;
      this.mutationObserver.flush();
      const s = this.domConverter.domSelectionToView(i);
      if (s.rangeCount == 0) {
        this.view.hasDomSelection = !1;
        return;
      }
      if (this.view.hasDomSelection = !0, this.focusObserver.flush(), !(this.selection.isEqual(s) && this.domConverter.isDomSelectionCorrect(i))) {
        if (++this._loopbackCounter > 60) {
          this._reportInfiniteLoop();
          return;
        }
        if (this.selection.isSimilar(s))
          this.view.forceRender();
        else {
          const o = {
            oldSelection: this.selection,
            newSelection: s,
            domSelection: i
          };
          this.document.fire("selectionChange", o), this._fireSelectionChangeDoneDebounced(o);
        }
      }
    }
    /**
     * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
     */
    _clearInfiniteLoop() {
      this._loopbackCounter = 0;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Rk extends Gt {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
      const t = this.document;
      t.on("compositionstart", () => {
        t.isComposing = !0;
      }, { priority: "low" }), t.on("compositionend", () => {
        t.isComposing = !1;
      }, { priority: "low" });
    }
    /**
     * @inheritDoc
     */
    onDomEvent(e) {
      this.fire(e.type, e, {
        data: e.data
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class km {
    /**
     * @param nativeDataTransfer The native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
     * @param options.cacheFiles Whether `files` list should be initialized in the constructor.
     */
    constructor(e, t = {}) {
      this._files = t.cacheFiles ? cu(e) : null, this._native = e;
    }
    /**
     * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
     */
    get files() {
      return this._files || (this._files = cu(this._native)), this._files;
    }
    /**
     * Returns an array of available native content types.
     */
    get types() {
      return this._native.types;
    }
    /**
     * Gets the data from the data transfer by its MIME type.
     *
     * ```ts
     * dataTransfer.getData( 'text/plain' );
     * ```
     *
     * @param type The MIME type. E.g. `text/html` or `text/plain`.
     */
    getData(e) {
      return this._native.getData(e);
    }
    /**
     * Sets the data in the data transfer.
     *
     * @param type The MIME type. E.g. `text/html` or `text/plain`.
     */
    setData(e, t) {
      this._native.setData(e, t);
    }
    /**
     * The effect that is allowed for a drag operation.
     */
    set effectAllowed(e) {
      this._native.effectAllowed = e;
    }
    get effectAllowed() {
      return this._native.effectAllowed;
    }
    /**
     * The actual drop effect.
     */
    set dropEffect(e) {
      this._native.dropEffect = e;
    }
    get dropEffect() {
      return this._native.dropEffect;
    }
    /**
     * Set a preview image of the dragged content.
     */
    setDragImage(e, t, i) {
      this._native.setDragImage(e, t, i);
    }
    /**
     * Whether the dragging operation was canceled.
     */
    get isCanceled() {
      return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
    }
  }
  function cu(n) {
    const e = Array.from(n.files || []), t = Array.from(n.items || []);
    return e.length ? e : t.filter((i) => i.kind === "file").map((i) => i.getAsFile());
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Lk extends Gt {
    constructor() {
      super(...arguments), this.domEventType = "beforeinput";
    }
    /**
     * @inheritDoc
     */
    onDomEvent(e) {
      const t = e.getTargetRanges(), i = this.view, s = i.document;
      let o = null, r = null, a = [];
      if (e.dataTransfer && (o = new km(e.dataTransfer)), e.data !== null ? r = e.data : o && (r = o.getData("text/plain")), s.selection.isFake)
        a = Array.from(s.selection.getRanges());
      else if (t.length)
        a = t.map((l) => {
          const c = i.domConverter.domPositionToView(l.startContainer, l.startOffset), u = i.domConverter.domPositionToView(l.endContainer, l.endOffset);
          if (c)
            return i.createRange(c, u);
          if (u)
            return i.createRange(u);
        }).filter((l) => !!l);
      else if (B.isAndroid) {
        const l = e.target.ownerDocument.defaultView.getSelection();
        a = Array.from(i.domConverter.domSelectionToView(l).getRanges());
      }
      if (B.isAndroid && e.inputType == "insertCompositionText" && r && r.endsWith(`
`)) {
        this.fire(e.type, e, {
          inputType: "insertParagraph",
          targetRanges: [i.createRange(a[0].end)]
        });
        return;
      }
      if (e.inputType == "insertText" && r && r.includes(`
`)) {
        const l = r.split(/\n{1,2}/g);
        let c = a;
        for (let u = 0; u < l.length; u++) {
          const d = l[u];
          d != "" && (this.fire(e.type, e, {
            data: d,
            dataTransfer: o,
            targetRanges: c,
            inputType: e.inputType,
            isComposing: e.isComposing
          }), c = [s.selection.getFirstRange()]), u + 1 < l.length && (this.fire(e.type, e, {
            inputType: "insertParagraph",
            targetRanges: c
          }), c = [s.selection.getFirstRange()]);
        }
        return;
      }
      this.fire(e.type, e, {
        data: r,
        dataTransfer: o,
        targetRanges: a,
        inputType: e.inputType,
        isComposing: e.isComposing
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Vk extends _t {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.document.on("keydown", (t, i) => {
        if (this.isEnabled && pC(i.keyCode)) {
          const s = new hn(this.document, "arrowKey", this.document.selection.getFirstRange());
          this.document.fire(s, i), s.stop.called && t.stop();
        }
      });
    }
    /**
     * @inheritDoc
     */
    observe() {
    }
    /**
     * @inheritDoc
     */
    stopObserving() {
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Mk extends _t {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = this.document;
      t.on("keydown", (i, s) => {
        if (!this.isEnabled || s.keyCode != F.tab || s.ctrlKey)
          return;
        const o = new hn(t, "tab", t.selection.getFirstRange());
        t.fire(o, s), o.stop.called && i.stop();
      });
    }
    /**
     * @inheritDoc
     */
    observe() {
    }
    /**
     * @inheritDoc
     */
    stopObserving() {
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let Bk = class extends $() {
    /**
     * @param stylesProcessor The styles processor instance.
     */
    constructor(e) {
      super(), this.domRoots = /* @__PURE__ */ new Map(), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this.document = new Xo(e), this.domConverter = new Qo(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new fk(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new pm(this.document), this.addObserver(Cm), this.addObserver(To), this.addObserver(Pk), this.addObserver(xk), this.addObserver(Sk), this.addObserver(Rk), this.addObserver(Vk), this.addObserver(Lk), this.addObserver(Mk), dk(this), nk(this), this.on("render", () => {
        this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1;
      }), this.listenTo(this.document.selection, "change", () => {
        this._hasChangedSinceTheLastRendering = !0;
      }), this.listenTo(this.document, "change:isFocused", () => {
        this._hasChangedSinceTheLastRendering = !0;
      }), B.isiOS && this.listenTo(this.document, "blur", (t, i) => {
        this.domConverter.mapDomToView(i.domEvent.relatedTarget) || this.domConverter._clearDomSelection();
      });
    }
    /**
     * Attaches a DOM root element to the view element and enable all observers on that element.
     * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized
     * with the view what means that all child nodes will be removed and replaced with content of the view root.
     *
     * This method also will change view element name as the same as tag name of given dom root.
     * Name is always transformed to lower case.
     *
     * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.
     *
     * @param domRoot DOM root element.
     * @param name Name of the root.
     */
    attachDomRoot(e, t = "main") {
      const i = this.document.getRoot(t);
      i._name = e.tagName.toLowerCase();
      const s = {};
      for (const { name: r, value: a } of Array.from(e.attributes))
        s[r] = a, r === "class" ? this._writer.addClass(a.split(" "), i) : this._writer.setAttribute(r, a, i);
      this._initialDomRootAttributes.set(e, s);
      const o = () => {
        this._writer.setAttribute("contenteditable", (!i.isReadOnly).toString(), i), i.isReadOnly ? this._writer.addClass("ck-read-only", i) : this._writer.removeClass("ck-read-only", i);
      };
      o(), this.domRoots.set(t, e), this.domConverter.bindElements(e, i), this._renderer.markToSync("children", i), this._renderer.markToSync("attributes", i), this._renderer.domDocuments.add(e.ownerDocument), i.on("change:children", (r, a) => this._renderer.markToSync("children", a)), i.on("change:attributes", (r, a) => this._renderer.markToSync("attributes", a)), i.on("change:text", (r, a) => this._renderer.markToSync("text", a)), i.on("change:isReadOnly", () => this.change(o)), i.on("change", () => {
        this._hasChangedSinceTheLastRendering = !0;
      });
      for (const r of this._observers.values())
        r.observe(e, t);
    }
    /**
     * Detaches a DOM root element from the view element and restores its attributes to the state before
     * {@link #attachDomRoot `attachDomRoot()`}.
     *
     * @param name Name of the root to detach.
     */
    detachDomRoot(e) {
      const t = this.domRoots.get(e);
      Array.from(t.attributes).forEach(({ name: s }) => t.removeAttribute(s));
      const i = this._initialDomRootAttributes.get(t);
      for (const s in i)
        t.setAttribute(s, i[s]);
      this.domRoots.delete(e), this.domConverter.unbindDomElement(t);
      for (const s of this._observers.values())
        s.stopObserving(t);
    }
    /**
     * Gets DOM root element.
     *
     * @param name  Name of the root.
     * @returns DOM root element instance.
     */
    getDomRoot(e = "main") {
      return this.domRoots.get(e);
    }
    /**
     * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
     * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
     * {@link #domRoots DOM roots}.
     *
     * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
     * when registered for the first time. This means that features and other components can register a single observer
     * multiple times without caring whether it has been already added or not.
     *
     * @param ObserverConstructor The constructor of an observer to add.
     * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
     * @returns Added observer instance.
     */
    addObserver(e) {
      let t = this._observers.get(e);
      if (t)
        return t;
      t = new e(this), this._observers.set(e, t);
      for (const [i, s] of this.domRoots)
        t.observe(s, i);
      return t.enable(), t;
    }
    /**
     * Returns observer of the given type or `undefined` if such observer has not been added yet.
     *
     * @param ObserverConstructor The constructor of an observer to get.
     * @returns Observer instance or undefined.
     */
    getObserver(e) {
      return this._observers.get(e);
    }
    /**
     * Disables all added observers.
     */
    disableObservers() {
      for (const e of this._observers.values())
        e.disable();
    }
    /**
     * Enables all added observers.
     */
    enableObservers() {
      for (const e of this._observers.values())
        e.enable();
    }
    /**
     * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
     * caret, **if not already visible to the user**.
     *
     * **Note**: Calling this method fires the {@link module:engine/view/view~ViewScrollToTheSelectionEvent} event that
     * allows custom behaviors.
     *
     * @param options Additional configuration of the scrolling behavior.
     * @param options.viewportOffset A distance between the DOM selection and the viewport boundary to be maintained
     * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
     * the viewport boundary.
     * @param options.ancestorOffset A distance between the DOM selection and scrollable DOM root ancestor(s) to be maintained
     * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
     * the scrollable ancestor(s) boundary.
     * @param options.alignToTop When set `true`, the DOM selection will be aligned to the top of the viewport if not already visible
     * (see `forceScroll` to learn more).
     * @param options.forceScroll When set `true`, the DOM selection will be aligned to the top of the viewport and scrollable ancestors
     * whether it is already visible or not. This option will only work when `alignToTop` is `true`.
     */
    scrollToTheSelection({ alignToTop: e, forceScroll: t, viewportOffset: i = 20, ancestorOffset: s = 20 } = {}) {
      const o = this.document.selection.getFirstRange();
      if (!o)
        return;
      const r = ut({ alignToTop: e, forceScroll: t, viewportOffset: i, ancestorOffset: s });
      typeof i == "number" && (i = {
        top: i,
        bottom: i,
        left: i,
        right: i
      });
      const a = {
        target: this.domConverter.viewRangeToDom(o),
        viewportOffset: i,
        ancestorOffset: s,
        alignToTop: e,
        forceScroll: t
      };
      this.fire("scrollToTheSelection", a, r), cC(a);
    }
    /**
     * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}
     * that is currently having selection inside.
     */
    focus() {
      if (!this.document.isFocused) {
        const e = this.document.selection.editableElement;
        e && (this.domConverter.focus(e), this.forceRender());
      }
    }
    /**
     * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.
     * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed
     * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows
     * to nest calls one inside another and still performs a single rendering after all those changes are made.
     * It also returns the return value of its callback.
     *
     * ```ts
     * const text = view.change( writer => {
     * 	const newText = writer.createText( 'foo' );
     * 	writer.insert( position1, newText );
     *
     * 	view.change( writer => {
     * 		writer.insert( position2, writer.createText( 'bar' ) );
     * 	} );
     *
     * 	writer.remove( range );
     *
     * 	return newText;
     * } );
     * ```
     *
     * When the outermost change block is done and rendering to the DOM is over the
     * {@link module:engine/view/view~View#event:render `View#render`} event is fired.
     *
     * This method throws a `applying-view-changes-on-rendering` error when
     * the change block is used after rendering to the DOM has started.
     *
     * @param callback Callback function which may modify the view.
     * @returns Value returned by the callback.
     */
    change(e) {
      if (this.isRenderingInProgress || this._postFixersInProgress)
        throw new g("cannot-change-view-tree", this);
      try {
        if (this._ongoingChange)
          return e(this._writer);
        this._ongoingChange = !0;
        const t = e(this._writer);
        return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t;
      } catch (t) {
        /* istanbul ignore next -- @preserve */
        g.rethrowUnexpectedError(t, this);
      }
    }
    /**
     * Forces rendering {@link module:engine/view/document~Document view document} to DOM. If any view changes are
     * currently in progress, rendering will start after all {@link #change change blocks} are processed.
     *
     * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}
     * block and the view will automatically check whether it needs to render DOM or not.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when
     * trying to re-render when rendering to DOM has already started.
     */
    forceRender() {
      this._hasChangedSinceTheLastRendering = !0, this.getObserver(To).flush(), this.change(() => {
      });
    }
    /**
     * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
     */
    destroy() {
      for (const e of this._observers.values())
        e.destroy();
      this.document.destroy(), this.stopListening();
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/view/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
     *
     * This method is a shortcut to other constructors such as:
     *
     * * {@link #createPositionBefore},
     * * {@link #createPositionAfter},
     *
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
     */
    createPositionAt(e, t) {
      return k._createAt(e, t);
    }
    /**
     * Creates a new position after given view item.
     *
     * @param item View item after which the position should be located.
     */
    createPositionAfter(e) {
      return k._createAfter(e);
    }
    /**
     * Creates a new position before given view item.
     *
     * @param item View item before which the position should be located.
     */
    createPositionBefore(e) {
      return k._createBefore(e);
    }
    /**
     * Creates a range spanning from `start` position to `end` position.
     *
     * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
     *
     * @param start Start position.
     * @param end End position. If not set, range will be collapsed at `start` position.
     */
    createRange(e, t) {
      return new N(e, t);
    }
    /**
     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
     */
    createRangeOn(e) {
      return N._createOn(e);
    }
    /**
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @param element Element which is a parent for the range.
     */
    createRangeIn(e) {
      return N._createIn(e);
    }
    createSelection(...e) {
      return new St(...e);
    }
    /**
     * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.
     * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.
     *
     * @internal
     * @param flag A flag indicates whether the rendering should be disabled.
     */
    _disableRendering(e) {
      this._renderingDisabled = e, e == !1 && this.change(() => {
      });
    }
    /**
     * Renders all changes. In order to avoid triggering the observers (e.g. selection) all observers are disabled
     * before rendering and re-enabled after that.
     */
    _render() {
      this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1;
    }
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class jt {
    /* istanbul ignore next -- @preserve */
    is() {
      throw new Error("is() method is abstract");
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let vi = class extends jt {
    /**
     * Creates a model node.
     *
     * This is an abstract class, so this constructor should not be used directly.
     *
     * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
     */
    constructor(e) {
      super(), this.parent = null, this._attrs = wt(e);
    }
    /**
     * {@link module:engine/model/document~Document Document} that owns this root element.
     */
    get document() {
      return null;
    }
    /**
     * Index of this node in its parent or `null` if the node has no parent.
     *
     * Accessing this property throws an error if this node's parent element does not contain it.
     * This means that model tree got broken.
     */
    get index() {
      let e;
      if (!this.parent)
        return null;
      if ((e = this.parent.getChildIndex(this)) === null)
        throw new g("model-node-not-found-in-parent", this);
      return e;
    }
    /**
     * Offset at which this node starts in its parent. It is equal to the sum of {@link #offsetSize offsetSize}
     * of all its previous siblings. Equals to `null` if node has no parent.
     *
     * Accessing this property throws an error if this node's parent element does not contain it.
     * This means that model tree got broken.
     */
    get startOffset() {
      let e;
      if (!this.parent)
        return null;
      if ((e = this.parent.getChildStartOffset(this)) === null)
        throw new g("model-node-not-found-in-parent", this);
      return e;
    }
    /**
     * Offset size of this node. Represents how much "offset space" is occupied by the node in it's parent.
     * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position
     * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more
     * than one entity, i.e. {@link module:engine/model/text~Text text node}.
     */
    get offsetSize() {
      return 1;
    }
    /**
     * Offset at which this node ends in it's parent. It is equal to the sum of this node's
     * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.
     * Equals to `null` if the node has no parent.
     */
    get endOffset() {
      return this.parent ? this.startOffset + this.offsetSize : null;
    }
    /**
     * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
     */
    get nextSibling() {
      const e = this.index;
      return e !== null && this.parent.getChild(e + 1) || null;
    }
    /**
     * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
     */
    get previousSibling() {
      const e = this.index;
      return e !== null && this.parent.getChild(e - 1) || null;
    }
    /**
     * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
     * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
     */
    get root() {
      let e = this;
      for (; e.parent; )
        e = e.parent;
      return e;
    }
    /**
     * Returns `true` if the node is inside a document root that is attached to the document.
     */
    isAttached() {
      return this.parent === null ? !1 : this.root.isAttached();
    }
    /**
     * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
     * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to
     * create {@link module:engine/model/position~Position Position} instance.
     *
     * ```ts
     * const abc = new Text( 'abc' );
     * const foo = new Text( 'foo' );
     * const h1 = new Element( 'h1', null, new Text( 'header' ) );
     * const p = new Element( 'p', null, [ abc, foo ] );
     * const div = new Element( 'div', null, [ h1, p ] );
     * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
     * h1.getPath(); // Returns [ 0 ].
     * div.getPath(); // Returns [].
     * ```
     */
    getPath() {
      const e = [];
      let t = this;
      for (; t.parent; )
        e.unshift(t.startOffset), t = t.parent;
      return e;
    }
    /**
     * Returns ancestors array of this node.
     *
     * @param options Options object.
     * @param options.includeSelf When set to `true` this node will be also included in parent's array.
     * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
     * otherwise root element will be the first item in the array.
     * @returns Array with ancestors.
     */
    getAncestors(e = {}) {
      const t = [];
      let i = e.includeSelf ? this : this.parent;
      for (; i; )
        t[e.parentFirst ? "push" : "unshift"](i), i = i.parent;
      return t;
    }
    /**
     * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
     * which is a common ancestor of both nodes.
     *
     * @param node The second node.
     * @param options Options object.
     * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
     * Which means that if e.g. node A is inside B, then their common ancestor will be B.
     */
    getCommonAncestor(e, t = {}) {
      const i = this.getAncestors(t), s = e.getAncestors(t);
      let o = 0;
      for (; i[o] == s[o] && i[o]; )
        o++;
      return o === 0 ? null : i[o - 1];
    }
    /**
     * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
     * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
     *
     * @param node Node to compare with.
     */
    isBefore(e) {
      if (this == e || this.root !== e.root)
        return !1;
      const t = this.getPath(), i = e.getPath(), s = Ee(t, i);
      switch (s) {
        case "prefix":
          return !0;
        case "extension":
          return !1;
        default:
          return t[s] < i[s];
      }
    }
    /**
     * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
     * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
     *
     * @param node Node to compare with.
     */
    isAfter(e) {
      return this == e || this.root !== e.root ? !1 : !this.isBefore(e);
    }
    /**
     * Checks if the node has an attribute with given key.
     *
     * @param key Key of attribute to check.
     * @returns `true` if attribute with given key is set on node, `false` otherwise.
     */
    hasAttribute(e) {
      return this._attrs.has(e);
    }
    /**
     * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
     *
     * @param key Key of attribute to look for.
     * @returns Attribute value or `undefined`.
     */
    getAttribute(e) {
      return this._attrs.get(e);
    }
    /**
     * Returns iterator that iterates over this node's attributes.
     *
     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     */
    getAttributes() {
      return this._attrs.entries();
    }
    /**
     * Returns iterator that iterates over this node's attribute keys.
     */
    getAttributeKeys() {
      return this._attrs.keys();
    }
    /**
     * Converts `Node` to plain object and returns it.
     *
     * @returns `Node` converted to plain object.
     */
    toJSON() {
      const e = {};
      return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce((t, i) => (t[i[0]] = i[1], t), {})), e;
    }
    /**
     * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
     *
     * @internal
     * @returns Node with same attributes as this node.
     */
    _clone(e) {
      return new this.constructor(this._attrs);
    }
    /**
     * Removes this node from it's parent.
     *
     * @internal
     * @see module:engine/model/writer~Writer#remove
     */
    _remove() {
      this.parent._removeChildren(this.index);
    }
    /**
     * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
     *
     * @see module:engine/model/writer~Writer#setAttribute
     * @internal
     * @param key Key of attribute to set.
     * @param value Attribute value.
     */
    _setAttribute(e, t) {
      this._attrs.set(e, t);
    }
    /**
     * Removes all attributes from the node and sets given attributes.
     *
     * @see module:engine/model/writer~Writer#setAttributes
     * @internal
     * @param attrs Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
     */
    _setAttributesTo(e) {
      this._attrs = wt(e);
    }
    /**
     * Removes an attribute with given key from the node.
     *
     * @see module:engine/model/writer~Writer#removeAttribute
     * @internal
     * @param key Key of attribute to remove.
     * @returns `true` if the attribute was set on the element, `false` otherwise.
     */
    _removeAttribute(e) {
      return this._attrs.delete(e);
    }
    /**
     * Removes all attributes from the node.
     *
     * @see module:engine/model/writer~Writer#clearAttributes
     * @internal
     */
    _clearAttributes() {
      this._attrs.clear();
    }
  };
  vi.prototype.is = function(n) {
    return n === "node" || n === "model:node";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class On {
    /**
     * Creates an empty node list.
     *
     * @internal
     * @param nodes Nodes contained in this node list.
     */
    constructor(e) {
      this._nodes = [], e && this._insertNodes(0, e);
    }
    /**
     * Iterable interface.
     *
     * Iterates over all nodes contained inside this node list.
     */
    [Symbol.iterator]() {
      return this._nodes[Symbol.iterator]();
    }
    /**
     * Number of nodes contained inside this node list.
     */
    get length() {
      return this._nodes.length;
    }
    /**
     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.
     */
    get maxOffset() {
      return this._nodes.reduce((e, t) => e + t.offsetSize, 0);
    }
    /**
     * Gets the node at the given index. Returns `null` if incorrect index was passed.
     */
    getNode(e) {
      return this._nodes[e] || null;
    }
    /**
     * Returns an index of the given node. Returns `null` if given node is not inside this node list.
     */
    getNodeIndex(e) {
      const t = this._nodes.indexOf(e);
      return t == -1 ? null : t;
    }
    /**
     * Returns the starting offset of given node. Starting offset is equal to the sum of
     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.
     */
    getNodeStartOffset(e) {
      const t = this.getNodeIndex(e);
      return t === null ? null : this._nodes.slice(0, t).reduce((i, s) => i + s.offsetSize, 0);
    }
    /**
     * Converts index to offset in node list.
     *
     * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
     * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.
     */
    indexToOffset(e) {
      if (e == this._nodes.length)
        return this.maxOffset;
      const t = this._nodes[e];
      if (!t)
        throw new g("model-nodelist-index-out-of-bounds", this);
      return this.getNodeStartOffset(t);
    }
    /**
     * Converts offset in node list to index.
     *
     * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
     * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.
     */
    offsetToIndex(e) {
      let t = 0;
      for (const i of this._nodes) {
        if (e >= t && e < t + i.offsetSize)
          return this.getNodeIndex(i);
        t += i.offsetSize;
      }
      if (t != e)
        throw new g("model-nodelist-offset-out-of-bounds", this, {
          offset: e,
          nodeList: this
        });
      return this.length;
    }
    /**
     * Inserts given nodes at given index.
     *
     * @internal
     * @param index Index at which nodes should be inserted.
     * @param nodes Nodes to be inserted.
     */
    _insertNodes(e, t) {
      for (const i of t)
        if (!(i instanceof vi))
          throw new g("model-nodelist-insertnodes-not-node", this);
      this._nodes = PC(this._nodes, Array.from(t), e, 0);
    }
    /**
     * Removes one or more nodes starting at the given index.
     *
     * @internal
     * @param indexStart Index of the first node to remove.
     * @param howMany Number of nodes to remove.
     * @returns Array containing removed nodes.
     */
    _removeNodes(e, t = 1) {
      return this._nodes.splice(e, t);
    }
    /**
     * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
     * are also converted to their plain object representation.
     *
     * @returns `NodeList` instance converted to `Array`.
     */
    toJSON() {
      return this._nodes.map((e) => e.toJSON());
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class j extends vi {
    /**
     * Creates a text node.
     *
     * **Note:** Constructor of this class shouldn't be used directly in the code.
     * Use the {@link module:engine/model/writer~Writer#createText} method instead.
     *
     * @internal
     * @param data Node's text.
     * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
     */
    constructor(e, t) {
      super(t), this._data = e || "";
    }
    /**
     * @inheritDoc
     */
    get offsetSize() {
      return this.data.length;
    }
    /**
     * Returns a text data contained in the node.
     */
    get data() {
      return this._data;
    }
    /**
     * Converts `Text` instance to plain object and returns it.
     *
     * @returns`Text` instance converted to plain object.
     */
    toJSON() {
      const e = super.toJSON();
      return e.data = this.data, e;
    }
    /**
     * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
     *
     * @internal
     * @returns `Text` instance created using given plain object.
     */
    _clone() {
      return new j(this.data, this.getAttributes());
    }
    /**
     * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
     *
     * @param json Plain object to be converted to `Text`.
     * @returns `Text` instance created using given plain object.
     */
    static fromJSON(e) {
      return new j(e.data, e.attributes);
    }
  }
  j.prototype.is = function(n) {
    return n === "$text" || n === "model:$text" || // This are legacy values kept for backward compatibility.
    n === "text" || n === "model:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "node" || n === "model:node";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class st extends jt {
    /**
     * Creates a text proxy.
     *
     * @internal
     * @param textNode Text node which part is represented by this text proxy.
     * @param offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy
     * starts.
     * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
     */
    constructor(e, t, i) {
      if (super(), this.textNode = e, t < 0 || t > e.offsetSize)
        throw new g("model-textproxy-wrong-offsetintext", this);
      if (i < 0 || t + i > e.offsetSize)
        throw new g("model-textproxy-wrong-length", this);
      this.data = e.data.substring(t, t + i), this.offsetInText = t;
    }
    /**
     * Offset at which this text proxy starts in it's parent.
     *
     * @see module:engine/model/node~Node#startOffset
     */
    get startOffset() {
      return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
    }
    /**
     * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
     *
     * @see module:engine/model/node~Node#offsetSize
     */
    get offsetSize() {
      return this.data.length;
    }
    /**
     * Offset at which this text proxy ends in it's parent.
     *
     * @see module:engine/model/node~Node#endOffset
     */
    get endOffset() {
      return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
    }
    /**
     * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}
     * (`true`) or the whole text node (`false`).
     *
     * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}
     * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
     * text node size.
     */
    get isPartial() {
      return this.offsetSize !== this.textNode.offsetSize;
    }
    /**
     * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
     */
    get parent() {
      return this.textNode.parent;
    }
    /**
     * Root of this text proxy, which is same as root of text node represented by this text proxy.
     */
    get root() {
      return this.textNode.root;
    }
    /**
     * Gets path to this text proxy.
     *
     * @see module:engine/model/node~Node#getPath
     */
    getPath() {
      const e = this.textNode.getPath();
      return e.length > 0 && (e[e.length - 1] += this.offsetInText), e;
    }
    /**
     * Returns ancestors array of this text proxy.
     *
     * @param options Options object.
     * @param options.includeSelf When set to `true` this text proxy will be also included in parent's array.
     * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to root element,
     * otherwise root element will be the first item in the array.
     * @returns Array with ancestors.
     */
    getAncestors(e = {}) {
      const t = [];
      let i = e.includeSelf ? this : this.parent;
      for (; i; )
        t[e.parentFirst ? "push" : "unshift"](i), i = i.parent;
      return t;
    }
    /**
     * Checks if this text proxy has an attribute for given key.
     *
     * @param key Key of attribute to check.
     * @returns `true` if attribute with given key is set on text proxy, `false` otherwise.
     */
    hasAttribute(e) {
      return this.textNode.hasAttribute(e);
    }
    /**
     * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
     *
     * @param key Key of attribute to look for.
     * @returns Attribute value or `undefined`.
     */
    getAttribute(e) {
      return this.textNode.getAttribute(e);
    }
    /**
     * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
     * items. First one is attribute key and second is attribute value.
     *
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     */
    getAttributes() {
      return this.textNode.getAttributes();
    }
    /**
     * Returns iterator that iterates over this node's attribute keys.
     */
    getAttributeKeys() {
      return this.textNode.getAttributeKeys();
    }
  }
  st.prototype.is = function(n) {
    return n === "$textProxy" || n === "model:$textProxy" || // This are legacy values kept for backward compatibility.
    n === "textProxy" || n === "model:textProxy";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class W extends vi {
    /**
     * Creates a model element.
     *
     * **Note:** Constructor of this class shouldn't be used directly in the code.
     * Use the {@link module:engine/model/writer~Writer#createElement} method instead.
     *
     * @internal
     * @param name Element's name.
     * @param attrs Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
     * @param children One or more nodes to be inserted as children of created element.
     */
    constructor(e, t, i) {
      super(t), this._children = new On(), this.name = e, i && this._insertChild(0, i);
    }
    /**
     * Number of this element's children.
     */
    get childCount() {
      return this._children.length;
    }
    /**
     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.
     */
    get maxOffset() {
      return this._children.maxOffset;
    }
    /**
     * Is `true` if there are no nodes inside this element, `false` otherwise.
     */
    get isEmpty() {
      return this.childCount === 0;
    }
    /**
     * Gets the child at the given index.
     */
    getChild(e) {
      return this._children.getNode(e);
    }
    /**
     * Returns an iterator that iterates over all of this element's children.
     */
    getChildren() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
     *
     * @param node Child node to look for.
     * @returns Child node's index in this element.
     */
    getChildIndex(e) {
      return this._children.getNodeIndex(e);
    }
    /**
     * Returns the starting offset of given child. Starting offset is equal to the sum of
     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
     * given node is not a child of this element.
     *
     * @param node Child node to look for.
     * @returns Child node's starting offset.
     */
    getChildStartOffset(e) {
      return this._children.getNodeStartOffset(e);
    }
    /**
     * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
     * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.
     *
     * ```ts
     * const textNode = new Text( 'foo' );
     * const pElement = new Element( 'p' );
     * const divElement = new Element( [ textNode, pElement ] );
     * divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
     * divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
     * divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
     * divElement.offsetToIndex( 2 ); // Returns 0.
     * divElement.offsetToIndex( 3 ); // Returns 1.
     * divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
     * ```
     */
    offsetToIndex(e) {
      return this._children.offsetToIndex(e);
    }
    /**
     * Returns a descendant node by its path relative to this element.
     *
     * ```ts
     * // <this>a<b>c</b></this>
     * this.getNodeByPath( [ 0 ] );     // -> "a"
     * this.getNodeByPath( [ 1 ] );     // -> <b>
     * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
     * ```
     *
     * @param relativePath Path of the node to find, relative to this element.
     */
    getNodeByPath(e) {
      let t = this;
      for (const i of e)
        t = t.getChild(t.offsetToIndex(i));
      return t;
    }
    /**
     * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.
     *
     * @param parentName The name of the parent element to find.
     * @param options Options object.
     * @param options.includeSelf When set to `true` this node will be also included while searching.
     */
    findAncestor(e, t = {}) {
      let i = t.includeSelf ? this : this.parent;
      for (; i; ) {
        if (i.name === e)
          return i;
        i = i.parent;
      }
      return null;
    }
    /**
     * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
     *
     * @returns `Element` instance converted to plain object.
     */
    toJSON() {
      const e = super.toJSON();
      if (e.name = this.name, this._children.length > 0) {
        e.children = [];
        for (const t of this._children)
          e.children.push(t.toJSON());
      }
      return e;
    }
    /**
     * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
     * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
     *
     * @internal
     * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any child.
     */
    _clone(e = !1) {
      const t = e ? Array.from(this._children).map((i) => i._clone(!0)) : void 0;
      return new W(this.name, this.getAttributes(), t);
    }
    /**
     * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.
     *
     * @see module:engine/model/writer~Writer#append
     * @internal
     * @param nodes Nodes to be inserted.
     */
    _appendChild(e) {
      this._insertChild(this.childCount, e);
    }
    /**
     * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
     * to this element.
     *
     * @see module:engine/model/writer~Writer#insert
     * @internal
     * @param index Index at which nodes should be inserted.
     * @param items Items to be inserted.
     */
    _insertChild(e, t) {
      const i = Ok(t);
      for (const s of i)
        s.parent !== null && s._remove(), s.parent = this;
      this._children._insertNodes(e, i);
    }
    /**
     * Removes one or more nodes starting at the given index and sets
     * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
     *
     * @see module:engine/model/writer~Writer#remove
     * @internal
     * @param index Index of the first node to remove.
     * @param howMany Number of nodes to remove.
     * @returns Array containing removed nodes.
     */
    _removeChildren(e, t = 1) {
      const i = this._children._removeNodes(e, t);
      for (const s of i)
        s.parent = null;
      return i;
    }
    /**
     * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
     * Converts `Element` children to proper nodes.
     *
     * @param json Plain object to be converted to `Element`.
     * @returns `Element` instance created using given plain object.
     */
    static fromJSON(e) {
      let t;
      if (e.children) {
        t = [];
        for (const i of e.children)
          i.name ? t.push(W.fromJSON(i)) : t.push(j.fromJSON(i));
      }
      return new W(e.name, e.attributes, t);
    }
  }
  W.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "element" || n === "model:element") : n === "element" || n === "model:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "node" || n === "model:node";
  };
  function Ok(n) {
    return typeof n == "string" ? [new j(n)] : (We(n) || (n = [n]), Array.from(n).map((e) => typeof e == "string" ? new j(e) : e instanceof st ? new j(e.data, e.getAttributes()) : e));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class xt {
    /**
     * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
     *
     * @param options Object with configuration.
     */
    constructor(e) {
      if (!e || !e.boundaries && !e.startPosition)
        throw new g("model-tree-walker-no-start-position", null);
      const t = e.direction || "forward";
      if (t != "forward" && t != "backward")
        throw new g("model-tree-walker-unknown-direction", e, { direction: t });
      this.direction = t, this.boundaries = e.boundaries || null, e.startPosition ? this._position = e.startPosition.clone() : this._position = C._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
    }
    /**
     * Iterable interface.
     *
     * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
     */
    [Symbol.iterator]() {
      return this;
    }
    /**
     * Iterator position. This is always static position, even if the initial position was a
     * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
     * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
     * is `'backward'` position starts from the end.
     */
    get position() {
      return this._position;
    }
    /**
     * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
     *
     * For example:
     *
     * ```ts
     * walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
     * walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
     * walker.skip( () => false ); // Do not move the position.
     * ```
     *
     * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
     * return `true` if the value should be skipped or `false` if not.
     */
    skip(e) {
      let t, i, s, o;
      do
        s = this.position, o = this._visitedParent, { done: t, value: i } = this.next();
      while (!t && e(i));
      t || (this._position = s, this._visitedParent = o);
    }
    /**
     * Gets the next tree walker's value.
     */
    next() {
      return this.direction == "forward" ? this._next() : this._previous();
    }
    /**
     * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
     */
    _next() {
      const e = this.position, t = this.position.clone(), i = this._visitedParent;
      if (i.parent === null && t.offset === i.maxOffset)
        return { done: !0, value: void 0 };
      if (i === this._boundaryEndParent && t.offset == this.boundaries.end.offset)
        return { done: !0, value: void 0 };
      const s = Nn(t, i), o = s || Tm(t, i, s);
      if (o instanceof W) {
        if (!this.shallow)
          t.path.push(0), this._visitedParent = o;
        else {
          if (this.boundaries && this.boundaries.end.isBefore(t))
            return { done: !0, value: void 0 };
          t.offset++;
        }
        return this._position = t, Xt("elementStart", o, e, t, 1);
      }
      if (o instanceof j) {
        let r;
        if (this.singleCharacters)
          r = 1;
        else {
          let c = o.endOffset;
          this._boundaryEndParent == i && this.boundaries.end.offset < c && (c = this.boundaries.end.offset), r = c - t.offset;
        }
        const a = t.offset - o.startOffset, l = new st(o, a, r);
        return t.offset += r, this._position = t, Xt("text", l, e, t, r);
      }
      return t.path.pop(), t.offset++, this._position = t, this._visitedParent = i.parent, this.ignoreElementEnd ? this._next() : Xt("elementEnd", i, e, t);
    }
    /**
     * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
     */
    _previous() {
      const e = this.position, t = this.position.clone(), i = this._visitedParent;
      if (i.parent === null && t.offset === 0)
        return { done: !0, value: void 0 };
      if (i == this._boundaryStartParent && t.offset == this.boundaries.start.offset)
        return { done: !0, value: void 0 };
      const s = t.parent, o = Nn(t, s), r = o || Em(t, s, o);
      if (r instanceof W)
        return t.offset--, this.shallow ? (this._position = t, Xt("elementStart", r, e, t, 1)) : (t.path.push(r.maxOffset), this._position = t, this._visitedParent = r, this.ignoreElementEnd ? this._previous() : Xt("elementEnd", r, e, t));
      if (r instanceof j) {
        let a;
        if (this.singleCharacters)
          a = 1;
        else {
          let u = r.startOffset;
          this._boundaryStartParent == i && this.boundaries.start.offset > u && (u = this.boundaries.start.offset), a = t.offset - u;
        }
        const l = t.offset - r.startOffset, c = new st(r, l - a, a);
        return t.offset -= a, this._position = t, Xt("text", c, e, t, a);
      }
      return t.path.pop(), this._position = t, this._visitedParent = i.parent, Xt("elementStart", i, e, t, 1);
    }
  }
  function Xt(n, e, t, i, s) {
    return {
      done: !1,
      value: {
        type: n,
        item: e,
        previousPosition: t,
        nextPosition: i,
        length: s
      }
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class C extends jt {
    /**
     * Creates a position.
     *
     * @param root Root of the position.
     * @param path Position path. See {@link module:engine/model/position~Position#path}.
     * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
     */
    constructor(e, t, i = "toNone") {
      if (super(), !e.is("element") && !e.is("documentFragment"))
        throw new g("model-position-root-invalid", e);
      if (!(t instanceof Array) || t.length === 0)
        throw new g("model-position-path-incorrect-format", e, { path: t });
      e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t], e = e.root), this.root = e, this.path = t, this.stickiness = i;
    }
    /**
     * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal
     * to the last item in position {@link module:engine/model/position~Position#path path}.
     *
     * @type {Number}
     */
    get offset() {
      return this.path[this.path.length - 1];
    }
    set offset(e) {
      this.path[this.path.length - 1] = e;
    }
    /**
     * Parent element of this position.
     *
     * Keep in mind that `parent` value is calculated when the property is accessed.
     * If {@link module:engine/model/position~Position#path position path}
     * leads to a non-existing element, `parent` property will throw error.
     *
     * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
     */
    get parent() {
      let e = this.root;
      for (let t = 0; t < this.path.length - 1; t++)
        if (e = e.getChild(e.offsetToIndex(this.path[t])), !e)
          throw new g("model-position-path-incorrect", this, { position: this });
      if (e.is("$text"))
        throw new g("model-position-path-incorrect", this, { position: this });
      return e;
    }
    /**
     * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is
     * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed
     * in text node, position index is equal to the index of that text node.
     */
    get index() {
      return this.parent.offsetToIndex(this.offset);
    }
    /**
     * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this
     * position is not in a text node.
     */
    get textNode() {
      return Nn(this, this.parent);
    }
    /**
     * Node directly after this position or `null` if this position is in text node.
     */
    get nodeAfter() {
      const e = this.parent;
      return Tm(this, e, Nn(this, e));
    }
    /**
     * Node directly before this position or `null` if this position is in text node.
     */
    get nodeBefore() {
      const e = this.parent;
      return Em(this, e, Nn(this, e));
    }
    /**
     * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
     */
    get isAtStart() {
      return this.offset === 0;
    }
    /**
     * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
     */
    get isAtEnd() {
      return this.offset == this.parent.maxOffset;
    }
    /**
     * Checks whether this position is before or after given position.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     */
    compareWith(e) {
      if (this.root != e.root)
        return "different";
      const t = Ee(this.path, e.path);
      switch (t) {
        case "same":
          return "same";
        case "prefix":
          return "before";
        case "extension":
          return "after";
        default:
          return this.path[t] < e.path[t] ? "before" : "after";
      }
    }
    /**
     * Gets the farthest position which matches the callback using
     * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.
     *
     * For example:
     *
     * ```ts
     * getLastMatchingPosition( value => value.type == 'text' );
     * // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
     *
     * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
     * // <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
     *
     * getLastMatchingPosition( value => false );
     * // Do not move the position.
     * ```
     *
     * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
     * return `true` if the value should be skipped or `false` if not.
     * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
     *
     * @returns The position after the last item which matches the `skip` callback test.
     */
    getLastMatchingPosition(e, t = {}) {
      t.startPosition = this;
      const i = new xt(t);
      return i.skip(e), i.position;
    }
    /**
     * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}
     * but without the last item.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @returns Path to the parent.
     */
    getParentPath() {
      return this.path.slice(0, -1);
    }
    /**
     * Returns ancestors array of this position, that is this position's parent and its ancestors.
     *
     * @returns Array with ancestors.
     */
    getAncestors() {
      const e = this.parent;
      return e.is("documentFragment") ? [e] : e.getAncestors({ includeSelf: !0 });
    }
    /**
     * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.
     *
     * @param parentName The name of the parent element to find.
     */
    findAncestor(e) {
      const t = this.parent;
      return t.is("element") ? t.findAncestor(e, { includeSelf: !0 }) : null;
    }
    /**
     * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
     * of these two paths must be identical.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param position The second position.
     * @returns The common path.
     */
    getCommonPath(e) {
      if (this.root != e.root)
        return [];
      const t = Ee(this.path, e.path), i = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
      return this.path.slice(0, i);
    }
    /**
     * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
     * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
     *
     * @param position The second position.
     */
    getCommonAncestor(e) {
      const t = this.getAncestors(), i = e.getAncestors();
      let s = 0;
      for (; t[s] == i[s] && t[s]; )
        s++;
      return s === 0 ? null : t[s - 1];
    }
    /**
     * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
     * is shifted by `shift` value (can be a negative value).
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param shift Offset shift. Can be a negative value.
     * @returns Shifted position.
     */
    getShiftedBy(e) {
      const t = this.clone(), i = t.offset + e;
      return t.offset = i < 0 ? 0 : i, t;
    }
    /**
     * Checks whether this position is after given position.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @see module:engine/model/position~Position#isBefore
     * @param  otherPosition Position to compare with.
     * @returns True if this position is after given position.
     */
    isAfter(e) {
      return this.compareWith(e) == "after";
    }
    /**
     * Checks whether this position is before given position.
     *
     * **Note:** watch out when using negation of the value returned by this method, because the negation will also
     * be `true` if positions are in different roots and you might not expect this. You should probably use
     * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
     * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
     *
     * ```ts
     * if ( a.isBefore( b ) && c.isAfter( d ) ) {
     * 	// do A.
     * } else {
     * 	// do B.
     * }
     * ```
     *
     * or, if you have only one if-branch:
     *
     * ```ts
     * if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
     * 	// do B.
     * }
     * ```
     *
     * rather than:
     *
     * ```ts
     * if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
     * 	// do B.
     * } else {
     * 	// do A.
     * }
     * ```
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param otherPosition Position to compare with.
     * @returns True if this position is before given position.
     */
    isBefore(e) {
      return this.compareWith(e) == "before";
    }
    /**
     * Checks whether this position is equal to given position.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param otherPosition Position to compare with.
     * @returns True if positions are same.
     */
    isEqual(e) {
      return this.compareWith(e) == "same";
    }
    /**
     * Checks whether this position is touching given position. Positions touch when there are no text nodes
     * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
     * they are very similar or even indistinguishable.
     *
     * @param otherPosition Position to compare with.
     * @returns True if positions touch.
     */
    isTouching(e) {
      if (this.root !== e.root)
        return !1;
      const t = Math.min(this.path.length, e.path.length);
      for (let i = 0; i < t; i++) {
        const s = this.path[i] - e.path[i];
        if (s < -1 || s > 1)
          return !1;
        if (s === 1)
          return uu(e, this, i);
        if (s === -1)
          return uu(this, e, i);
      }
      return this.path.length === e.path.length ? !0 : this.path.length > e.path.length ? ma(this.path, t) : ma(e.path, t);
    }
    /**
     * Checks if two positions are in the same parent.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param position Position to compare with.
     * @returns `true` if positions have the same parent, `false` otherwise.
     */
    hasSameParentAs(e) {
      if (this.root !== e.root)
        return !1;
      const t = this.getParentPath(), i = e.getParentPath();
      return Ee(t, i) == "same";
    }
    /**
     * Returns a copy of this position that is transformed by given `operation`.
     *
     * The new position's parameters are updated accordingly to the effect of the `operation`.
     *
     * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be
     * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param operation Operation to transform by.
     * @returns Transformed position.
     */
    getTransformedByOperation(e) {
      let t;
      switch (e.type) {
        case "insert":
          t = this._getTransformedByInsertOperation(e);
          break;
        case "move":
        case "remove":
        case "reinsert":
          t = this._getTransformedByMoveOperation(e);
          break;
        case "split":
          t = this._getTransformedBySplitOperation(e);
          break;
        case "merge":
          t = this._getTransformedByMergeOperation(e);
          break;
        default:
          t = C._createAt(this);
          break;
      }
      return t;
    }
    /**
     * Returns a copy of this position transformed by an insert operation.
     *
     * @internal
     */
    _getTransformedByInsertOperation(e) {
      return this._getTransformedByInsertion(e.position, e.howMany);
    }
    /**
     * Returns a copy of this position transformed by a move operation.
     *
     * @internal
     */
    _getTransformedByMoveOperation(e) {
      return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
    }
    /**
     * Returns a copy of this position transformed by a split operation.
     *
     * @internal
     */
    _getTransformedBySplitOperation(e) {
      const t = e.movedRange;
      return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1);
    }
    /**
     * Returns a copy of this position transformed by merge operation.
     *
     * @internal
     */
    _getTransformedByMergeOperation(e) {
      const t = e.movedRange, i = t.containsPosition(this) || t.start.isEqual(this);
      let s;
      return i ? (s = this._getCombined(e.sourcePosition, e.targetPosition), e.sourcePosition.isBefore(e.targetPosition) && (s = s._getTransformedByDeletion(e.deletionPosition, 1))) : this.isEqual(e.deletionPosition) ? s = C._createAt(e.deletionPosition) : s = this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1), s;
    }
    /**
     * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
     * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
     *
     * @internal
     * @param deletePosition Position before the first removed node.
     * @param howMany How many nodes are removed.
     * @returns Transformed position or `null`.
     */
    _getTransformedByDeletion(e, t) {
      const i = C._createAt(this);
      if (this.root != e.root)
        return i;
      if (Ee(e.getParentPath(), this.getParentPath()) == "same") {
        if (e.offset < this.offset) {
          if (e.offset + t > this.offset)
            return null;
          i.offset -= t;
        }
      } else if (Ee(e.getParentPath(), this.getParentPath()) == "prefix") {
        const s = e.path.length - 1;
        if (e.offset <= this.path[s]) {
          if (e.offset + t > this.path[s])
            return null;
          i.path[s] -= t;
        }
      }
      return i;
    }
    /**
     * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
     *
     * @internal
     * @param insertPosition Position where nodes are inserted.
     * @param howMany How many nodes are inserted.
     * @returns Transformed position.
     */
    _getTransformedByInsertion(e, t) {
      const i = C._createAt(this);
      if (this.root != e.root)
        return i;
      if (Ee(e.getParentPath(), this.getParentPath()) == "same")
        (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (i.offset += t);
      else if (Ee(e.getParentPath(), this.getParentPath()) == "prefix") {
        const s = e.path.length - 1;
        e.offset <= this.path[s] && (i.path[s] += t);
      }
      return i;
    }
    /**
     * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
     *
     * @internal
     * @param sourcePosition Position before the first element to move.
     * @param targetPosition Position where moved elements will be inserted.
     * @param howMany How many consecutive nodes to move, starting from `sourcePosition`.
     * @returns Transformed position.
     */
    _getTransformedByMove(e, t, i) {
      if (t = t._getTransformedByDeletion(e, i), e.isEqual(t))
        return C._createAt(this);
      const s = this._getTransformedByDeletion(e, i);
      return s === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(i).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : s._getTransformedByInsertion(t, i);
    }
    /**
     * Returns a new position that is a combination of this position and given positions.
     *
     * The combined position is a copy of this position transformed by moving a range starting at `source` position
     * to the `target` position. It is expected that this position is inside the moved range.
     *
     * Example:
     *
     * ```ts
     * let original = model.createPositionFromPath( root, [ 2, 3, 1 ] );
     * let source = model.createPositionFromPath( root, [ 2, 2 ] );
     * let target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );
     * original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
     * ```
     *
     * Explanation:
     *
     * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
     * was inside moved nodes and now should point to the new place. The moved nodes will be after
     * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
     * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
     * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
     * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
     *
     * @internal
     * @param source Beginning of the moved range.
     * @param target Position where the range is moved.
     * @returns Combined position.
     */
    _getCombined(e, t) {
      const i = e.path.length - 1, s = C._createAt(t);
      return s.stickiness = this.stickiness, s.offset = s.offset + this.path[i] - e.offset, s.path = [...s.path, ...this.path.slice(i + 1)], s;
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      return {
        root: this.root.toJSON(),
        path: Array.from(this.path),
        stickiness: this.stickiness
      };
    }
    /**
     * Returns a new position that is equal to current position.
     */
    clone() {
      return new this.constructor(this.root, this.path, this.stickiness);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/model/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).
     *
     * This method is a shortcut to other factory methods such as:
     *
     * * {@link module:engine/model/position~Position._createBefore},
     * * {@link module:engine/model/position~Position._createAfter}.
     *
     * @internal
     * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
     * @param stickiness Position stickiness. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
     */
    static _createAt(e, t, i = "toNone") {
      if (e instanceof C)
        return new C(e.root, e.path, e.stickiness);
      {
        const s = e;
        if (t == "end")
          t = s.maxOffset;
        else {
          if (t == "before")
            return this._createBefore(s, i);
          if (t == "after")
            return this._createAfter(s, i);
          if (t !== 0 && !t)
            throw new g("model-createpositionat-offset-required", [this, e]);
        }
        if (!s.is("element") && !s.is("documentFragment"))
          throw new g("model-position-parent-incorrect", [this, e]);
        const o = s.getPath();
        return o.push(t), new this(s.root, o, i);
      }
    }
    /**
     * Creates a new position, after given {@link module:engine/model/item~Item model item}.
     *
     * @internal
     * @param item Item after which the position should be placed.
     * @param stickiness Position stickiness.
     */
    static _createAfter(e, t) {
      if (!e.parent)
        throw new g("model-position-after-root", [this, e], { root: e });
      return this._createAt(e.parent, e.endOffset, t);
    }
    /**
     * Creates a new position, before the given {@link module:engine/model/item~Item model item}.
     *
     * @internal
     * @param item Item before which the position should be placed.
     * @param stickiness Position stickiness.
     */
    static _createBefore(e, t) {
      if (!e.parent)
        throw new g("model-position-before-root", e, { root: e });
      return this._createAt(e.parent, e.startOffset, t);
    }
    /**
     * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
     *
     * @param json Plain object to be converted to `Position`.
     * @param doc Document object that will be position owner.
     * @returns `Position` instance created using given plain object.
     */
    static fromJSON(e, t) {
      if (e.root === "$graveyard") {
        const i = new C(t.graveyard, e.path);
        return i.stickiness = e.stickiness, i;
      }
      if (!t.getRoot(e.root))
        throw new g("model-position-fromjson-no-root", t, { rootName: e.root });
      return new C(t.getRoot(e.root), e.path, e.stickiness);
    }
  }
  C.prototype.is = function(n) {
    return n === "position" || n === "model:position";
  };
  function Nn(n, e) {
    const t = e.getChild(e.offsetToIndex(n.offset));
    return t && t.is("$text") && t.startOffset < n.offset ? t : null;
  }
  function Tm(n, e, t) {
    return t !== null ? null : e.getChild(e.offsetToIndex(n.offset));
  }
  function Em(n, e, t) {
    return t !== null ? null : e.getChild(e.offsetToIndex(n.offset) - 1);
  }
  function uu(n, e, t) {
    return !(t + 1 === n.path.length || !ma(e.path, t + 1) || !Nk(n, t + 1));
  }
  function ma(n, e) {
    for (; e < n.length; ) {
      if (n[e] !== 0)
        return !1;
      e++;
    }
    return !0;
  }
  function Nk(n, e) {
    let t = n.parent, i = n.path.length - 1, s = 0;
    for (; i >= e; ) {
      if (n.path[i] + s !== t.maxOffset)
        return !1;
      s = 1, i--, t = t.parent;
    }
    return !0;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class _ extends jt {
    /**
     * Creates a range spanning from `start` position to `end` position.
     *
     * @param start The start position.
     * @param end The end position. If not set, the range will be collapsed at the `start` position.
     */
    constructor(e, t) {
      super(), this.start = C._createAt(e), this.end = t ? C._createAt(t) : C._createAt(e), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
    }
    /**
     * Iterable interface.
     *
     * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
     * them together with additional information like length or {@link module:engine/model/position~Position positions},
     * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.
     * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range
     * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.
     *
     * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range
     * and `ignoreElementEnd` option set to `true`.
     */
    *[Symbol.iterator]() {
      yield* new xt({ boundaries: this, ignoreElementEnd: !0 });
    }
    /**
     * Describes whether the range is collapsed, that is if {@link #start} and
     * {@link #end} positions are equal.
     */
    get isCollapsed() {
      return this.start.isEqual(this.end);
    }
    /**
     * Describes whether this range is flat, that is if {@link #start} position and
     * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.
     */
    get isFlat() {
      const e = this.start.getParentPath(), t = this.end.getParentPath();
      return Ee(e, t) == "same";
    }
    /**
     * Range root element.
     */
    get root() {
      return this.start.root;
    }
    /**
     * Checks whether this range contains given {@link module:engine/model/position~Position position}.
     *
     * @param position Position to check.
     * @returns `true` if given {@link module:engine/model/position~Position position} is contained
     * in this range,`false` otherwise.
     */
    containsPosition(e) {
      return e.isAfter(this.start) && e.isBefore(this.end);
    }
    /**
     * Checks whether this range contains given {@link ~Range range}.
     *
     * @param otherRange Range to check.
     * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
     * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
     * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
     * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.
     */
    containsRange(e, t = !1) {
      e.isCollapsed && (t = !1);
      const i = this.containsPosition(e.start) || t && this.start.isEqual(e.start), s = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
      return i && s;
    }
    /**
     * Checks whether given {@link module:engine/model/item~Item} is inside this range.
     */
    containsItem(e) {
      const t = C._createBefore(e);
      return this.containsPosition(t) || this.start.isEqual(t);
    }
    /**
     * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
     *
     * @param otherRange Range to compare with.
     * @returns `true` if ranges are equal, `false` otherwise.
     */
    isEqual(e) {
      return this.start.isEqual(e.start) && this.end.isEqual(e.end);
    }
    /**
     * Checks and returns whether this range intersects with given range.
     *
     * @param otherRange Range to compare with.
     * @returns `true` if ranges intersect, `false` otherwise.
     */
    isIntersecting(e) {
      return this.start.isBefore(e.end) && this.end.isAfter(e.start);
    }
    /**
     * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.
     * Returned array contains zero, one or two {@link ~Range ranges}.
     *
     * Examples:
     *
     * ```ts
     * let range = model.createRange(
     * 	model.createPositionFromPath( root, [ 2, 7 ] ),
     * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
     * );
     * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );
     * let transformed = range.getDifference( otherRange );
     * // transformed array has no ranges because `otherRange` contains `range`
     *
     * otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );
     * transformed = range.getDifference( otherRange );
     * // transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
     *
     * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );
     * transformed = range.getDifference( otherRange );
     * // transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
     * ```
     *
     * @param otherRange Range to differentiate against.
     * @returns The difference between ranges.
     */
    getDifference(e) {
      const t = [];
      return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new _(this.start, e.start)), this.containsPosition(e.end) && t.push(new _(e.end, this.end))) : t.push(new _(this.start, this.end)), t;
    }
    /**
     * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.
     * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
     *
     * Examples:
     *
     * ```ts
     * let range = model.createRange(
     * 	model.createPositionFromPath( root, [ 2, 7 ] ),
     * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
     * );
     * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );
     * let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
     *
     * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );
     * transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
     * ```
     *
     * @param otherRange Range to check for intersection.
     * @returns A common part of given ranges or `null` if ranges have no common part.
     */
    getIntersection(e) {
      if (this.isIntersecting(e)) {
        let t = this.start, i = this.end;
        return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (i = e.end), new _(t, i);
      }
      return null;
    }
    /**
     * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.
     * If ranges have no common part, returns `null`.
     *
     * Examples:
     *
     * ```ts
     * let range = model.createRange(
     * 	model.createPositionFromPath( root, [ 2, 7 ] ),
     * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
     * );
     * let otherRange = model.createRange(
     * 	model.createPositionFromPath( root, [ 1 ] ),
     * 	model.createPositionFromPath( root, [ 2 ] )
     * );
     * let transformed = range.getJoined( otherRange ); // null - ranges have no common part
     *
     * otherRange = model.createRange(
     * 	model.createPositionFromPath( root, [ 3 ] ),
     * 	model.createPositionFromPath( root, [ 5 ] )
     * );
     * transformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]
     * ```
     *
     * @param otherRange Range to be joined.
     * @param loose Whether the intersection check is loose or strict. If the check is strict (`false`),
     * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),
     * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.
     * @returns A sum of given ranges or `null` if ranges have no common part.
     */
    getJoined(e, t = !1) {
      let i = this.isIntersecting(e);
      if (i || (this.start.isBefore(e.start) ? i = t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : i = t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)), !i)
        return null;
      let s = this.start, o = this.end;
      return e.start.isBefore(s) && (s = e.start), e.end.isAfter(o) && (o = e.end), new _(s, o);
    }
    /**
     * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
     *
     * See an example of a model structure (`[` and `]` are range boundaries):
     *
     * ```
     * root                                                            root
     *  |- element DIV                         DIV             P2              P3             DIV
     *  |   |- element H                   H        P1        f o o           b a r       H         P4
     *  |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
     *  |   |- element P1
     *  |   |   |- "lorem"                                              ||
     *  |- element P2                                                   ||
     *  |   |- "foo"                                                    VV
     *  |- element P3
     *  |   |- "bar"                                                   root
     *  |- element DIV                         DIV             [P2             P3]             DIV
     *  |   |- element H                   H       [P1]       f o o           b a r        H         P4
     *  |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
     *  |   |- element P4
     *  |   |   |- "ipsum"
     * ```
     *
     * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
     * We are looking for minimal set of flat ranges that contains the same nodes.
     *
     * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
     *
     * ```
     * ( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
     * ( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
     * ( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
     * ( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
     * ```
     *
     * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned
     * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
     * were omitted. Only their parts that were wholly in the range were returned.
     *
     * **Note:** this method is not returning flat ranges that contain no nodes.
     *
     * @returns Array of flat ranges covering this range.
     */
    getMinimalFlatRanges() {
      const e = [], t = this.start.getCommonPath(this.end).length, i = C._createAt(this.start);
      let s = i.parent;
      for (; i.path.length > t + 1; ) {
        const o = s.maxOffset - i.offset;
        o !== 0 && e.push(new _(i, i.getShiftedBy(o))), i.path = i.path.slice(0, -1), i.offset++, s = s.parent;
      }
      for (; i.path.length <= this.end.path.length; ) {
        const o = this.end.path[i.path.length - 1], r = o - i.offset;
        r !== 0 && e.push(new _(i, i.getShiftedBy(r))), i.offset = o, i.path.push(0);
      }
      return e;
    }
    /**
     * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
     *
     * For example, to iterate over all items in the entire document root:
     *
     * ```ts
     * // Create a range spanning over the entire root content:
     * const range = editor.model.createRangeIn( editor.model.document.getRoot() );
     *
     * // Iterate over all items in this range:
     * for ( const value of range.getWalker() ) {
     * 	console.log( value.item );
     * }
     * ```
     *
     * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
     */
    getWalker(e = {}) {
      return e.boundaries = this, new xt(e);
    }
    /**
     * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
     * them.
     *
     * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
     * set to `true`. However it returns only {@link module:engine/model/item~Item model items},
     * not {@link module:engine/model/treewalker~TreeWalkerValue}.
     *
     * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
     * a full list of available options.
     *
     * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
     */
    *getItems(e = {}) {
      e.boundaries = this, e.ignoreElementEnd = !0;
      const t = new xt(e);
      for (const i of t)
        yield i.item;
    }
    /**
     * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or
     * contained in this range.
     *
     * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
     * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.
     *
     * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
     * a full list of available options.
     *
     * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
     */
    *getPositions(e = {}) {
      e.boundaries = this;
      const t = new xt(e);
      yield t.position;
      for (const i of t)
        yield i.nextPosition;
    }
    /**
     * Returns a range that is a result of transforming this range by given `operation`.
     *
     * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is
     * moved to a different part of document tree). For this reason, an array is returned by this method and it
     * may contain one or more `Range` instances.
     *
     * @param operation Operation to transform range by.
     * @returns Range which is the result of transformation.
     */
    getTransformedByOperation(e) {
      switch (e.type) {
        case "insert":
          return this._getTransformedByInsertOperation(e);
        case "move":
        case "remove":
        case "reinsert":
          return this._getTransformedByMoveOperation(e);
        case "split":
          return [this._getTransformedBySplitOperation(e)];
        case "merge":
          return [this._getTransformedByMergeOperation(e)];
      }
      return [new _(this.start, this.end)];
    }
    /**
     * Returns a range that is a result of transforming this range by multiple `operations`.
     *
     * @see ~Range#getTransformedByOperation
     * @param operations Operations to transform the range by.
     * @returns Range which is the result of transformation.
     */
    getTransformedByOperations(e) {
      const t = [new _(this.start, this.end)];
      for (const i of e)
        for (let s = 0; s < t.length; s++) {
          const o = t[s].getTransformedByOperation(i);
          t.splice(s, 1, ...o), s += o.length - 1;
        }
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        for (let o = i + 1; o < t.length; o++) {
          const r = t[o];
          (s.containsRange(r) || r.containsRange(s) || s.isEqual(r)) && t.splice(o, 1);
        }
      }
      return t;
    }
    /**
     * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
     * which is a common ancestor of the range's both ends (in which the entire range is contained).
     */
    getCommonAncestor() {
      return this.start.getCommonAncestor(this.end);
    }
    /**
     * Returns an {@link module:engine/model/element~Element Element} contained by the range.
     * The element will be returned when it is the **only** node within the range and **fully–contained**
     * at the same time.
     */
    getContainedElement() {
      if (this.isCollapsed)
        return null;
      const e = this.start.nodeAfter, t = this.end.nodeBefore;
      return e && e.is("element") && e === t ? e : null;
    }
    /**
     * Converts `Range` to plain object and returns it.
     *
     * @returns `Node` converted to plain object.
     */
    toJSON() {
      return {
        start: this.start.toJSON(),
        end: this.end.toJSON()
      };
    }
    /**
     * Returns a new range that is equal to current range.
     */
    clone() {
      return new this.constructor(this.start, this.end);
    }
    /**
     * Returns a result of transforming a copy of this range by insert operation.
     *
     * One or more ranges may be returned as a result of this transformation.
     *
     * @internal
     */
    _getTransformedByInsertOperation(e, t = !1) {
      return this._getTransformedByInsertion(e.position, e.howMany, t);
    }
    /**
     * Returns a result of transforming a copy of this range by move operation.
     *
     * One or more ranges may be returned as a result of this transformation.
     *
     * @internal
     */
    _getTransformedByMoveOperation(e, t = !1) {
      const i = e.sourcePosition, s = e.howMany, o = e.targetPosition;
      return this._getTransformedByMove(i, o, s, t);
    }
    /**
     * Returns a result of transforming a copy of this range by split operation.
     *
     * Always one range is returned. The transformation is done in a way to not break the range.
     *
     * @internal
     */
    _getTransformedBySplitOperation(e) {
      const t = this.start._getTransformedBySplitOperation(e);
      let i = this.end._getTransformedBySplitOperation(e);
      return this.end.isEqual(e.insertionPosition) && (i = this.end.getShiftedBy(1)), t.root != i.root && (i = this.end.getShiftedBy(-1)), new _(t, i);
    }
    /**
     * Returns a result of transforming a copy of this range by merge operation.
     *
     * Always one range is returned. The transformation is done in a way to not break the range.
     *
     * @internal
     */
    _getTransformedByMergeOperation(e) {
      if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition))
        return new _(this.start);
      let t = this.start._getTransformedByMergeOperation(e), i = this.end._getTransformedByMergeOperation(e);
      return t.root != i.root && (i = this.end.getShiftedBy(-1)), t.isAfter(i) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = C._createAt(i), t.offset = 0) : (e.deletionPosition.isEqual(t) || (i = e.deletionPosition), t = e.targetPosition), new _(t, i)) : new _(t, i);
    }
    /**
     * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this
     * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are
     * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.
     *
     * Examples:
     *
     * ```ts
     * let range = model.createRange(
     * 	model.createPositionFromPath( root, [ 2, 7 ] ),
     * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
     * );
     * let transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );
     * // transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
     *
     * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );
     * // transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
     *
     * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );
     * // transformed array has one range, which is equal to original range
     *
     * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );
     * // transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
     * ```
     *
     * @internal
     * @param insertPosition Position where nodes are inserted.
     * @param howMany How many nodes are inserted.
     * @param spread Flag indicating whether this range should be spread if insertion
     * was inside the range. Defaults to `false`.
     * @returns Result of the transformation.
     */
    _getTransformedByInsertion(e, t, i = !1) {
      if (i && this.containsPosition(e))
        return [
          new _(this.start, e),
          new _(e.getShiftedBy(t), this.end._getTransformedByInsertion(e, t))
        ];
      {
        const s = new _(this.start, this.end);
        return s.start = s.start._getTransformedByInsertion(e, t), s.end = s.end._getTransformedByInsertion(e, t), [s];
      }
    }
    /**
     * Returns an array containing {@link ~Range ranges} that are a result of transforming this
     * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
     *
     * @internal
     * @param sourcePosition Position from which nodes are moved.
     * @param targetPosition Position to where nodes are moved.
     * @param howMany How many nodes are moved.
     * @param spread Whether the range should be spread if the move points inside the range.
     * @returns  Result of the transformation.
     */
    _getTransformedByMove(e, t, i, s = !1) {
      if (this.isCollapsed) {
        const d = this.start._getTransformedByMove(e, t, i);
        return [new _(d)];
      }
      const o = _._createFromPositionAndShift(e, i), r = t._getTransformedByDeletion(e, i);
      if (this.containsPosition(t) && !s && (o.containsPosition(this.start) || o.containsPosition(this.end))) {
        const d = this.start._getTransformedByMove(e, t, i), h = this.end._getTransformedByMove(e, t, i);
        return [new _(d, h)];
      }
      let a;
      const l = this.getDifference(o);
      let c = null;
      const u = this.getIntersection(o);
      if (l.length == 1 ? c = new _(l[0].start._getTransformedByDeletion(e, i), l[0].end._getTransformedByDeletion(e, i)) : l.length == 2 && (c = new _(this.start, this.end._getTransformedByDeletion(e, i))), c ? a = c._getTransformedByInsertion(r, i, u !== null || s) : a = [], u) {
        const d = new _(u.start._getCombined(o.start, r), u.end._getCombined(o.start, r));
        a.length == 2 ? a.splice(1, 0, d) : a.push(d);
      }
      return a;
    }
    /**
     * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.
     *
     * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.
     *
     * If the deleted range contains transformed range, `null` will be returned.
     *
     * @internal
     * @param deletionPosition Position from which nodes are removed.
     * @param howMany How many nodes are removed.
     * @returns Result of the transformation.
     */
    _getTransformedByDeletion(e, t) {
      let i = this.start._getTransformedByDeletion(e, t), s = this.end._getTransformedByDeletion(e, t);
      return i == null && s == null ? null : (i == null && (i = e), s == null && (s = e), new _(i, s));
    }
    /**
     * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by
     * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
     *
     * @internal
     * @param position Beginning of the range.
     * @param shift How long the range should be.
     */
    static _createFromPositionAndShift(e, t) {
      const i = e, s = e.getShiftedBy(t);
      return t > 0 ? new this(i, s) : new this(s, i);
    }
    /**
     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @internal
     * @param element Element which is a parent for the range.
     */
    static _createIn(e) {
      return new this(C._createAt(e, 0), C._createAt(e, e.maxOffset));
    }
    /**
     * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.
     *
     * @internal
     */
    static _createOn(e) {
      return this._createFromPositionAndShift(C._createBefore(e), e.offsetSize);
    }
    /**
     * Combines all ranges from the passed array into a one range. At least one range has to be passed.
     * Passed ranges must not have common parts.
     *
     * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
     * the reference range, they get combined into one range.
     *
     * ```
     * [  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
     * [    ]                                       // The result of the function if the first range was a reference range.
     *         [                           ]        // The result of the function if the third-to-seventh range was a reference range.
     *                                        [  ]  // The result of the function if the last range was a reference range.
     * ```
     *
     * @internal
     * @param ranges Ranges to combine.
     * @returns Combined range.
     */
    static _createFromRanges(e) {
      if (e.length === 0)
        throw new g("range-create-from-ranges-empty-array", null);
      if (e.length == 1)
        return e[0].clone();
      const t = e[0];
      e.sort((o, r) => o.start.isAfter(r.start) ? 1 : -1);
      const i = e.indexOf(t), s = new this(t.start, t.end);
      if (i > 0)
        for (let o = i - 1; e[o].end.isEqual(s.start); o++)
          s.start = C._createAt(e[o].start);
      for (let o = i + 1; o < e.length && e[o].start.isEqual(s.end); o++)
        s.end = C._createAt(e[o].end);
      return s;
    }
    /**
     * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
     *
     * @param json Plain object to be converted to `Range`.
     * @param doc Document object that will be range owner.
     * @returns `Range` instance created using given plain object.
     */
    static fromJSON(e, t) {
      return new this(C.fromJSON(e.start, t), C.fromJSON(e.end, t));
    }
  }
  _.prototype.is = function(n) {
    return n === "range" || n === "model:range";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Am extends G() {
    /**
     * Creates an instance of the mapper.
     */
    constructor() {
      super(), this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (e, t) => {
        if (t.viewPosition)
          return;
        const i = this._modelToViewMapping.get(t.modelPosition.parent);
        if (!i)
          throw new g("mapping-model-position-view-parent-not-found", this, { modelPosition: t.modelPosition });
        t.viewPosition = this.findPositionIn(i, t.modelPosition.offset);
      }, { priority: "low" }), this.on("viewToModelPosition", (e, t) => {
        if (t.modelPosition)
          return;
        const i = this.findMappedViewAncestor(t.viewPosition), s = this._viewToModelMapping.get(i), o = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, i);
        t.modelPosition = C._createAt(s, o);
      }, { priority: "low" });
    }
    /**
     * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
     * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
     * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
     * The information that elements are bound is also used to translate positions.
     *
     * @param modelElement Model element.
     * @param viewElement View element.
     */
    bindElements(e, t) {
      this._modelToViewMapping.set(e, t), this._viewToModelMapping.set(t, e);
    }
    /**
     * Unbinds the given {@link module:engine/view/element~Element view element} from the map.
     *
     * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding
     * will be removed only if model element is still bound to the passed `viewElement`.
     *
     * This behavior allows for re-binding model element to another view element without fear of losing the new binding
     * when the previously bound view element is unbound.
     *
     * @param viewElement View element to unbind.
     * @param options The options object.
     * @param options.defer Controls whether the binding should be removed immediately or deferred until a
     * {@link #flushDeferredBindings `flushDeferredBindings()`} call.
     */
    unbindViewElement(e, t = {}) {
      const i = this.toModelElement(e);
      if (this._elementToMarkerNames.has(e))
        for (const s of this._elementToMarkerNames.get(e))
          this._unboundMarkerNames.add(s);
      t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e), this._modelToViewMapping.get(i) == e && this._modelToViewMapping.delete(i));
    }
    /**
     * Unbinds the given {@link module:engine/model/element~Element model element} from the map.
     *
     * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding
     * will be removed only if the view element is still bound to the passed `modelElement`.
     *
     * This behavior lets for re-binding view element to another model element without fear of losing the new binding
     * when the previously bound model element is unbound.
     *
     * @param modelElement Model element to unbind.
     */
    unbindModelElement(e) {
      const t = this.toViewElement(e);
      this._modelToViewMapping.delete(e), this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t);
    }
    /**
     * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element
     * will be added to the current set of elements bound with the given marker name.
     *
     * @param element Element to bind.
     * @param name Marker name.
     */
    bindElementToMarker(e, t) {
      const i = this._markerNameToElements.get(t) || /* @__PURE__ */ new Set();
      i.add(e);
      const s = this._elementToMarkerNames.get(e) || /* @__PURE__ */ new Set();
      s.add(t), this._markerNameToElements.set(t, i), this._elementToMarkerNames.set(e, s);
    }
    /**
     * Unbinds an element from given marker name.
     *
     * @param element Element to unbind.
     * @param name Marker name.
     */
    unbindElementFromMarkerName(e, t) {
      const i = this._markerNameToElements.get(t);
      i && (i.delete(e), i.size == 0 && this._markerNameToElements.delete(t));
      const s = this._elementToMarkerNames.get(e);
      s && (s.delete(t), s.size == 0 && this._elementToMarkerNames.delete(e));
    }
    /**
     * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
     * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.
     */
    flushUnboundMarkerNames() {
      const e = Array.from(this._unboundMarkerNames);
      return this._unboundMarkerNames.clear(), e;
    }
    /**
     * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.
     *
     * See: {@link #unbindViewElement `unbindViewElement()`}.
     */
    flushDeferredBindings() {
      for (const [e, t] of this._deferredBindingRemovals)
        e.root == t && this.unbindViewElement(e);
      this._deferredBindingRemovals = /* @__PURE__ */ new Map();
    }
    /**
     * Removes all model to view and view to model bindings.
     */
    clearBindings() {
      this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
    }
    toModelElement(e) {
      return this._viewToModelMapping.get(e);
    }
    toViewElement(e) {
      return this._modelToViewMapping.get(e);
    }
    /**
     * Gets the corresponding model range.
     *
     * @param viewRange View range.
     * @returns Corresponding model range.
     */
    toModelRange(e) {
      return new _(this.toModelPosition(e.start), this.toModelPosition(e.end));
    }
    /**
     * Gets the corresponding view range.
     *
     * @param modelRange Model range.
     * @returns Corresponding view range.
     */
    toViewRange(e) {
      return new N(this.toViewPosition(e.start), this.toViewPosition(e.end));
    }
    /**
     * Gets the corresponding model position.
     *
     * @fires viewToModelPosition
     * @param viewPosition View position.
     * @returns Corresponding model position.
     */
    toModelPosition(e) {
      const t = {
        viewPosition: e,
        mapper: this
      };
      return this.fire("viewToModelPosition", t), t.modelPosition;
    }
    /**
     * Gets the corresponding view position.
     *
     * @fires modelToViewPosition
     * @param modelPosition Model position.
     * @param options Additional options for position mapping process.
     * @param options.isPhantom Should be set to `true` if the model position to map is pointing to a place
     * in model tree which no longer exists. For example, it could be an end of a removed model range.
     * @returns Corresponding view position.
     */
    toViewPosition(e, t = {}) {
      const i = {
        modelPosition: e,
        mapper: this,
        isPhantom: t.isPhantom
      };
      return this.fire("modelToViewPosition", i), i.viewPosition;
    }
    /**
     * Gets all view elements bound to the given marker name.
     *
     * @param name Marker name.
     * @returns View elements bound with the given marker name or `null`
     * if no elements are bound to the given marker name.
     */
    markerNameToElements(e) {
      const t = this._markerNameToElements.get(e);
      if (!t)
        return null;
      const i = /* @__PURE__ */ new Set();
      for (const s of t)
        if (s.is("attributeElement"))
          for (const o of s.getElementsWithSameId())
            i.add(o);
        else
          i.add(s);
      return i;
    }
    /**
     * Registers a callback that evaluates the length in the model of a view element with the given name.
     *
     * The callback is fired with one argument, which is a view element instance. The callback is expected to return
     * a number representing the length of the view element in the model.
     *
     * ```ts
     * // List item in view may contain nested list, which have other list items. In model though,
     * // the lists are represented by flat structure. Because of those differences, length of list view element
     * // may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
     *
     * function getViewListItemLength( element ) {
     * 	let length = 1;
     *
     * 	for ( let child of element.getChildren() ) {
     * 		if ( child.name == 'ul' || child.name == 'ol' ) {
     * 			for ( let item of child.getChildren() ) {
     * 				length += getViewListItemLength( item );
     * 			}
     * 		}
     * 	}
     *
     * 	return length;
     * }
     *
     * mapper.registerViewToModelLength( 'li', getViewListItemLength );
     * ```
     *
     * @param viewElementName Name of view element for which callback is registered.
     * @param lengthCallback Function return a length of view element instance in model.
     */
    registerViewToModelLength(e, t) {
      this._viewToModelLengthCallbacks.set(e, t);
    }
    /**
     * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to
     * the model.
     *
     * @param viewPosition Position for which a mapped ancestor should be found.
     */
    findMappedViewAncestor(e) {
      let t = e.parent;
      for (; !this._viewToModelMapping.has(t); )
        t = t.parent;
      return t;
    }
    /**
     * Calculates model offset based on the view position and the block element.
     *
     * Example:
     *
     * ```html
     * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
     * ```
     *
     * Is a sum of:
     *
     * ```html
     * <p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
     * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
     * ```
     *
     * @param viewParent Position parent.
     * @param viewOffset Position offset.
     * @param viewBlock Block used as a base to calculate offset.
     * @returns Offset in the model.
     */
    _toModelOffset(e, t, i) {
      if (i != e) {
        const o = this._toModelOffset(e.parent, e.index, i), r = this._toModelOffset(e, t, e);
        return o + r;
      }
      if (e.is("$text"))
        return t;
      let s = 0;
      for (let o = 0; o < t; o++)
        s += this.getModelLength(e.getChild(o));
      return s;
    }
    /**
     * Gets the length of the view element in the model.
     *
     * The length is calculated as follows:
     * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to
     * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),
     * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its
     * {@link module:engine/view/text~Text#data data},
     * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,
     * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,
     * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.
     *
     * Examples:
     *
     * ```
     * foo                          -> 3 // Text length is equal to its data length.
     * <p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
     * <b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
     * <div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
     * ```
     *
     * @param viewNode View node.
     * @returns Length of the node in the tree model.
     */
    getModelLength(e) {
      if (this._viewToModelLengthCallbacks.get(e.name))
        return this._viewToModelLengthCallbacks.get(e.name)(e);
      if (this._viewToModelMapping.has(e))
        return 1;
      if (e.is("$text"))
        return e.data.length;
      if (e.is("uiElement"))
        return 0;
      {
        let t = 0;
        for (const i of e.getChildren())
          t += this.getModelLength(i);
        return t;
      }
    }
    /**
     * Finds the position in the view node (or in its children) with the expected model offset.
     *
     * Example:
     *
     * ```
     * <p>fo<b>bar</b>bom</p> -> expected offset: 4
     *
     * findPositionIn( p, 4 ):
     * <p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
     * <p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
     * <p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
     *
     * findPositionIn( b, 4 - ( 5 - 3 ) ):
     * <p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
     * <p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
     *
     * findPositionIn( bar, 2 - ( 3 - 3 ) ):
     * We are in the text node so we can simple find the offset.
     * <p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
     * ```
     *
     * @param viewParent Tree view element in which we are looking for the position.
     * @param expectedOffset Expected offset.
     * @returns Found position.
     */
    findPositionIn(e, t) {
      let i, s = 0, o = 0, r = 0;
      if (e.is("$text"))
        return new k(e, t);
      for (; o < t; )
        i = e.getChild(r), s = this.getModelLength(i), o += s, r++;
      return o == t ? this._moveViewPositionToTextNode(new k(e, r)) : this.findPositionIn(i, t - (o - s));
    }
    /**
     * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,
     * it moves it into the text node instead.
     *
     * ```
     * <p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
     * <p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
     * <p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
     * ```
     *
     * @param viewPosition Position potentially next to the text node.
     * @returns Position in the text node if possible.
     */
    _moveViewPositionToTextNode(e) {
      const t = e.nodeBefore, i = e.nodeAfter;
      return t instanceof ie ? new k(t, t.data.length) : i instanceof ie ? new k(i, 0) : e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Dk {
    constructor() {
      this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
    }
    /**
     * Adds a consumable value to the consumables list and links it with a given model item.
     *
     * ```ts
     * modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
     * modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
     * modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
     * modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
     * modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
     * ```
     *
     * @param item Model item, range or selection that has the consumable.
     * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
     * Second colon and everything after will be cut. Passing event name is a safe and good practice.
     */
    add(e, t) {
      t = Ls(t), e instanceof st && (e = this._getSymbolForTextProxy(e)), this._consumable.has(e) || this._consumable.set(e, /* @__PURE__ */ new Map()), this._consumable.get(e).set(t, !0);
    }
    /**
     * Removes a given consumable value from a given model item.
     *
     * ```ts
     * modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
     * modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
     * modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
     * modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
     * modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
     * ```
     *
     * @param item Model item, range or selection from which consumable will be consumed.
     * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
     * Second colon and everything after will be cut. Passing event name is a safe and good practice.
     * @returns `true` if consumable value was available and was consumed, `false` otherwise.
     */
    consume(e, t) {
      return t = Ls(t), e instanceof st && (e = this._getSymbolForTextProxy(e)), this.test(e, t) ? (this._consumable.get(e).set(t, !1), !0) : !1;
    }
    /**
     * Tests whether there is a consumable value of a given type connected with a given model item.
     *
     * ```ts
     * modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
     * modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
     * modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
     * modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
     * modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
     * ```
     *
     * @param item Model item, range or selection to be tested.
     * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
     * Second colon and everything after will be cut. Passing event name is a safe and good practice.
     * @returns `null` if such consumable was never added, `false` if the consumable values was
     * already consumed or `true` if it was added and not consumed yet.
     */
    test(e, t) {
      t = Ls(t), e instanceof st && (e = this._getSymbolForTextProxy(e));
      const i = this._consumable.get(e);
      if (i === void 0)
        return null;
      const s = i.get(t);
      return s === void 0 ? null : s;
    }
    /**
     * Reverts consuming of a consumable value.
     *
     * ```ts
     * modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
     * modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
     * modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
     * modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
     * modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
     * ```
     *
     * @param item Model item, range or selection to be reverted.
     * @param type Consumable type.
     * @returns `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
     * never been added.
     */
    revert(e, t) {
      t = Ls(t), e instanceof st && (e = this._getSymbolForTextProxy(e));
      const i = this.test(e, t);
      return i === !1 ? (this._consumable.get(e).set(t, !0), !0) : i === !0 ? !1 : null;
    }
    /**
     * Verifies if all events from the specified group were consumed.
     *
     * @param eventGroup The events group to verify.
     */
    verifyAllConsumed(e) {
      const t = [];
      for (const [i, s] of this._consumable)
        for (const [o, r] of s) {
          const a = o.split(":")[0];
          r && e == a && t.push({
            event: o,
            item: i.name || i.description
          });
        }
      if (t.length)
        throw new g("conversion-model-consumable-not-consumed", null, { items: t });
    }
    /**
     * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that
     * have same parent, same start index and same end index will get the same symbol.
     *
     * Used internally to correctly consume `TextProxy` instances.
     *
     * @internal
     * @param textProxy `TextProxy` instance to get a symbol for.
     * @returns Symbol representing all equal instances of `TextProxy`.
     */
    _getSymbolForTextProxy(e) {
      let t = null;
      const i = this._textProxyRegistry.get(e.startOffset);
      if (i) {
        const s = i.get(e.endOffset);
        s && (t = s.get(e.parent));
      }
      return t || (t = this._addSymbolForTextProxy(e)), t;
    }
    /**
     * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.
     *
     * Used internally to correctly consume `TextProxy` instances.
     *
     * @param textProxy Text proxy instance.
     * @returns Symbol generated for given `TextProxy`.
     */
    _addSymbolForTextProxy(e) {
      const t = e.startOffset, i = e.endOffset, s = e.parent, o = Symbol("$textProxy:" + e.data);
      let r, a;
      return r = this._textProxyRegistry.get(t), r || (r = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(t, r)), a = r.get(i), a || (a = /* @__PURE__ */ new Map(), r.set(i, a)), a.set(s, o), o;
    }
  }
  function Ls(n) {
    const e = n.split(":");
    return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? n : e.length > 1 ? e[0] + ":" + e[1] : e[0];
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class xm extends G() {
    /**
     * Creates a downcast dispatcher instance.
     *
     * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi
     *
     * @param conversionApi Additional properties for an interface that will be passed to events fired
     * by the downcast dispatcher.
     */
    constructor(e) {
      super(), this._conversionApi = { dispatcher: this, ...e }, this._firedEventsMap = /* @__PURE__ */ new WeakMap();
    }
    /**
     * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}
     * and fires conversion events based on it.
     *
     * @fires insert
     * @fires remove
     * @fires attribute
     * @fires addMarker
     * @fires removeMarker
     * @fires reduceChanges
     * @param differ The differ object with buffered changes.
     * @param markers Markers related to the model fragment to convert.
     * @param writer The view writer that should be used to modify the view document.
     */
    convertChanges(e, t, i) {
      const s = this._createConversionApi(i, e.getRefreshedItems());
      for (const r of e.getMarkersToRemove())
        this._convertMarkerRemove(r.name, r.range, s);
      const o = this._reduceChanges(e.getChanges());
      for (const r of o)
        r.type === "insert" ? this._convertInsert(_._createFromPositionAndShift(r.position, r.length), s) : r.type === "reinsert" ? this._convertReinsert(_._createFromPositionAndShift(r.position, r.length), s) : r.type === "remove" ? this._convertRemove(r.position, r.length, r.name, s) : this._convertAttribute(r.range, r.attributeKey, r.attributeOldValue, r.attributeNewValue, s);
      s.mapper.flushDeferredBindings();
      for (const r of s.mapper.flushUnboundMarkerNames()) {
        const a = t.get(r).getRange();
        this._convertMarkerRemove(r, a, s), this._convertMarkerAdd(r, a, s);
      }
      for (const r of e.getMarkersToAdd())
        this._convertMarkerAdd(r.name, r.range, s);
      s.consumable.verifyAllConsumed("insert");
    }
    /**
     * Starts a conversion of a model range and the provided markers.
     *
     * @fires insert
     * @fires attribute
     * @fires addMarker
     * @param range The inserted range.
     * @param markers The map of markers that should be down-casted.
     * @param writer The view writer that should be used to modify the view document.
     * @param options Optional options object passed to `convertionApi.options`.
     */
    convert(e, t, i, s = {}) {
      const o = this._createConversionApi(i, void 0, s);
      this._convertInsert(e, o);
      for (const [r, a] of t)
        this._convertMarkerAdd(r, a, o);
      o.consumable.verifyAllConsumed("insert");
    }
    /**
     * Starts the model selection conversion.
     *
     * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.
     *
     * @fires selection
     * @fires addMarker
     * @fires attribute
     * @param selection The selection to convert.
     * @param markers Markers connected with the converted model.
     * @param writer View writer that should be used to modify the view document.
     */
    convertSelection(e, t, i) {
      const s = this._createConversionApi(i);
      this.fire("cleanSelection", { selection: e }, s);
      const o = e.getFirstPosition().root;
      if (!s.mapper.toViewElement(o))
        return;
      const r = Array.from(t.getMarkersAtPosition(e.getFirstPosition()));
      if (this._addConsumablesForSelection(s.consumable, e, r), this.fire("selection", { selection: e }, s), !!e.isCollapsed) {
        for (const a of r)
          if (s.consumable.test(e, "addMarker:" + a.name)) {
            const l = a.getRange();
            if (!Fk(e.getFirstPosition(), a, s.mapper))
              continue;
            const c = {
              item: e,
              markerName: a.name,
              markerRange: l
            };
            this.fire(`addMarker:${a.name}`, c, s);
          }
        for (const a of e.getAttributeKeys())
          if (s.consumable.test(e, "attribute:" + a)) {
            const l = {
              item: e,
              range: e.getFirstRange(),
              attributeKey: a,
              attributeOldValue: null,
              attributeNewValue: e.getAttribute(a)
            };
            this.fire(`attribute:${a}:$text`, l, s);
          }
      }
    }
    /**
     * Fires insertion conversion of a range of nodes.
     *
     * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,
     * {@link #event:attribute `attribute` event is fired}.
     *
     * @fires insert
     * @fires attribute
     * @param range The inserted range.
     * @param conversionApi The conversion API object.
     * @param options.doNotAddConsumables Whether the ModelConsumable should not get populated
     * for items in the provided range.
     */
    _convertInsert(e, t, i = {}) {
      i.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, e);
      for (const s of Array.from(e.getWalker({ shallow: !0 })).map(du))
        this._testAndFire("insert", s, t);
    }
    /**
     * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.
     *
     * @param position Position from which node was removed.
     * @param length Offset size of removed node.
     * @param name Name of removed node.
     * @param conversionApi The conversion API object.
     */
    _convertRemove(e, t, i, s) {
      this.fire(`remove:${i}`, { position: e, length: t }, s);
    }
    /**
     * Starts a conversion of an attribute change on a given `range`.
     *
     * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.
     *
     * @fires attribute
     * @param range Changed range.
     * @param key Key of the attribute that has changed.
     * @param oldValue Attribute value before the change or `null` if the attribute has not been set before.
     * @param newValue New attribute value or `null` if the attribute has been removed.
     * @param conversionApi The conversion API object.
     */
    _convertAttribute(e, t, i, s, o) {
      this._addConsumablesForRange(o.consumable, e, `attribute:${t}`);
      for (const r of e) {
        const a = {
          item: r.item,
          range: _._createFromPositionAndShift(r.previousPosition, r.length),
          attributeKey: t,
          attributeOldValue: i,
          attributeNewValue: s
        };
        this._testAndFire(`attribute:${t}`, a, o);
      }
    }
    /**
     * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)
     * of a range of elements (only elements on the range depth, without children).
     *
     * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.
     * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.
     *
     * @fires insert
     * @fires attribute
     * @param range The range to reinsert.
     * @param conversionApi The conversion API object.
     */
    _convertReinsert(e, t) {
      const i = Array.from(e.getWalker({ shallow: !0 }));
      this._addConsumablesForInsert(t.consumable, i);
      for (const s of i.map(du))
        this._testAndFire("insert", { ...s, reconversion: !0 }, t);
    }
    /**
     * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item
     * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.
     *
     * @fires addMarker
     * @param markerName Marker name.
     * @param markerRange The marker range.
     * @param conversionApi The conversion API object.
     */
    _convertMarkerAdd(e, t, i) {
      if (t.root.rootName == "$graveyard")
        return;
      const s = `addMarker:${e}`;
      if (i.consumable.add(t, s), this.fire(s, { markerName: e, markerRange: t }, i), !!i.consumable.consume(t, s)) {
        this._addConsumablesForRange(i.consumable, t, s);
        for (const o of t.getItems()) {
          if (!i.consumable.test(o, s))
            continue;
          const r = { item: o, range: _._createOn(o), markerName: e, markerRange: t };
          this.fire(s, r, i);
        }
      }
    }
    /**
     * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.
     *
     * @fires removeMarker
     * @param markerName Marker name.
     * @param markerRange The marker range.
     * @param conversionApi The conversion API object.
     */
    _convertMarkerRemove(e, t, i) {
      t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, { markerName: e, markerRange: t }, i);
    }
    /**
     * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.
     *
     * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger
     * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
     * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.
     *
     * @fires reduceChanges
     */
    _reduceChanges(e) {
      const t = { changes: e };
      return this.fire("reduceChanges", t), t.changes;
    }
    /**
     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,
     * assuming that the range has just been inserted to the model.
     *
     * @param consumable The consumable.
     * @param walkerValues The walker values for the inserted range.
     * @returns The values to consume.
     */
    _addConsumablesForInsert(e, t) {
      for (const i of t) {
        const s = i.item;
        if (e.test(s, "insert") === null) {
          e.add(s, "insert");
          for (const o of s.getAttributeKeys())
            e.add(s, "attribute:" + o);
        }
      }
      return e;
    }
    /**
     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.
     *
     * @param consumable The consumable.
     * @param range The affected range.
     * @param type Consumable type.
     * @returns The values to consume.
     */
    _addConsumablesForRange(e, t, i) {
      for (const s of t.getItems())
        e.add(s, i);
      return e;
    }
    /**
     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
     *
     * @param consumable The consumable.
     * @param selection The selection to create the consumable from.
     * @param markers Markers that contain the selection.
     * @returns The values to consume.
     */
    _addConsumablesForSelection(e, t, i) {
      e.add(t, "selection");
      for (const s of i)
        e.add(t, "addMarker:" + s.name);
      for (const s of t.getAttributeKeys())
        e.add(t, "attribute:" + s);
      return e;
    }
    /**
     * Tests whether given event wasn't already fired and if so, fires it.
     *
     * @fires insert
     * @fires attribute
     * @param type Event type.
     * @param data Event data.
     * @param conversionApi The conversion API object.
     */
    _testAndFire(e, t, i) {
      const s = zk(e, t), o = t.item.is("$textProxy") ? i.consumable._getSymbolForTextProxy(t.item) : t.item, r = this._firedEventsMap.get(i), a = r.get(o);
      if (!a)
        r.set(o, /* @__PURE__ */ new Set([s]));
      else if (!a.has(s))
        a.add(s);
      else
        return;
      this.fire(s, t, i);
    }
    /**
     * Fires not already fired events for setting attributes on just inserted item.
     *
     * @param item The model item to convert attributes for.
     * @param conversionApi The conversion API object.
     */
    _testAndFireAddAttributes(e, t) {
      const i = {
        item: e,
        range: _._createOn(e)
      };
      for (const s of i.item.getAttributeKeys())
        i.attributeKey = s, i.attributeOldValue = null, i.attributeNewValue = i.item.getAttribute(s), this._testAndFire(`attribute:${s}`, i, t);
    }
    /**
     * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given
     * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.
     *
     * @param writer View writer that should be used to modify the view document.
     * @param refreshedItems A set of model elements that should not reuse their
     * previous view representations.
     * @param options Optional options passed to `convertionApi.options`.
     * @return The conversion API object.
     */
    _createConversionApi(e, t = /* @__PURE__ */ new Set(), i = {}) {
      const s = {
        ...this._conversionApi,
        consumable: new Dk(),
        writer: e,
        options: i,
        convertItem: (o) => this._convertInsert(_._createOn(o), s),
        convertChildren: (o) => this._convertInsert(_._createIn(o), s, { doNotAddConsumables: !0 }),
        convertAttributes: (o) => this._testAndFireAddAttributes(o, s),
        canReuseView: (o) => !t.has(s.mapper.toModelElement(o))
      };
      return this._firedEventsMap.set(s, /* @__PURE__ */ new Map()), s;
    }
  }
  function Fk(n, e, t) {
    const i = e.getRange(), s = Array.from(n.getAncestors());
    return s.shift(), s.reverse(), !s.some((r) => {
      if (i.containsItem(r))
        return !!t.toViewElement(r).getCustomProperty("addHighlight");
    });
  }
  function zk(n, e) {
    const t = e.item.is("element") ? e.item.name : "$text";
    return `${n}:${t}`;
  }
  function du(n) {
    const e = n.item, t = _._createFromPositionAndShift(n.previousPosition, n.length);
    return {
      item: e,
      range: t
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class De extends G(jt) {
    /**
     * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}
     * or creates an empty selection if no arguments were passed.
     *
     * ```ts
     * // Creates empty selection without ranges.
     * const selection = writer.createSelection();
     *
     * // Creates selection at the given range.
     * const range = writer.createRange( start, end );
     * const selection = writer.createSelection( range );
     *
     * // Creates selection at the given ranges
     * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     * const selection = writer.createSelection( ranges );
     *
     * // Creates selection from the other selection.
     * // Note: It doesn't copy selection attributes.
     * const otherSelection = writer.createSelection();
     * const selection = writer.createSelection( otherSelection );
     *
     * // Creates selection from the given document selection.
     * // Note: It doesn't copy selection attributes.
     * const documentSelection = model.document.selection;
     * const selection = writer.createSelection( documentSelection );
     *
     * // Creates selection at the given position.
     * const position = writer.createPositionFromPath( root, path );
     * const selection = writer.createSelection( position );
     *
     * // Creates selection at the given offset in the given element.
     * const paragraph = writer.createElement( 'paragraph' );
     * const selection = writer.createSelection( paragraph, offset );
     *
     * // Creates a range inside an {@link module:engine/model/element~Element element} which starts before the
     * // first child of that element and ends after the last child of that element.
     * const selection = writer.createSelection( paragraph, 'in' );
     *
     * // Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends
     * // just after the item.
     * const selection = writer.createSelection( paragraph, 'on' );
     * ```
     *
     * Selection's constructor allow passing additional options (`'backward'`) as the last argument.
     *
     * ```ts
     * // Creates backward selection.
     * const selection = writer.createSelection( range, { backward: true } );
     * ```
     *
     * @internal
     */
    constructor(...e) {
      super(), this._lastRangeBackward = !1, this._attrs = /* @__PURE__ */ new Map(), this._ranges = [], e.length && this.setTo(...e);
    }
    /**
     * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection
     * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).
     *
     * Anchor and {@link #focus} define the direction of the selection, which is important
     * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.
     *
     * Anchor is always set to the {@link module:engine/model/range~Range#start start} or
     * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is
     * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.
     *
     * May be set to `null` if there are no ranges in the selection.
     *
     * @see #focus
     */
    get anchor() {
      if (this._ranges.length > 0) {
        const e = this._ranges[this._ranges.length - 1];
        return this._lastRangeBackward ? e.end : e.start;
      }
      return null;
    }
    /**
     * Selection focus. Focus is the position where the selection ends. If a user is making a selection
     * by dragging the mouse, the focus is where the mouse cursor is.
     *
     * May be set to `null` if there are no ranges in the selection.
     *
     * @see #anchor
     */
    get focus() {
      if (this._ranges.length > 0) {
        const e = this._ranges[this._ranges.length - 1];
        return this._lastRangeBackward ? e.start : e.end;
      }
      return null;
    }
    /**
     * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it
     * and it is collapsed.
     */
    get isCollapsed() {
      return this._ranges.length === 1 ? this._ranges[0].isCollapsed : !1;
    }
    /**
     * Returns the number of ranges in the selection.
     */
    get rangeCount() {
      return this._ranges.length;
    }
    /**
     * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.
     */
    get isBackward() {
      return !this.isCollapsed && this._lastRangeBackward;
    }
    /**
     * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,
     * the same number of ranges and all ranges from one selection equal to ranges from the another selection.
     *
     * @param otherSelection Selection to compare with.
     * @returns `true` if selections are equal, `false` otherwise.
     */
    isEqual(e) {
      if (this.rangeCount != e.rangeCount)
        return !1;
      if (this.rangeCount === 0)
        return !0;
      if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
        return !1;
      for (const t of this._ranges) {
        let i = !1;
        for (const s of e._ranges)
          if (t.isEqual(s)) {
            i = !0;
            break;
          }
        if (!i)
          return !1;
      }
      return !0;
    }
    /**
     * Returns an iterable object that iterates over copies of selection ranges.
     */
    *getRanges() {
      for (const e of this._ranges)
        yield new _(e.start, e.end);
    }
    /**
     * Returns a copy of the first range in the selection.
     * First range is the one which {@link module:engine/model/range~Range#start start} position
     * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
     * (not to confuse with the first range added to the selection).
     *
     * Returns `null` if there are no ranges in selection.
     */
    getFirstRange() {
      let e = null;
      for (const t of this._ranges)
        (!e || t.start.isBefore(e.start)) && (e = t);
      return e ? new _(e.start, e.end) : null;
    }
    /**
     * Returns a copy of the last range in the selection.
     * Last range is the one which {@link module:engine/model/range~Range#end end} position
     * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
     * recently added to the selection).
     *
     * Returns `null` if there are no ranges in selection.
     */
    getLastRange() {
      let e = null;
      for (const t of this._ranges)
        (!e || t.end.isAfter(e.end)) && (e = t);
      return e ? new _(e.start, e.end) : null;
    }
    /**
     * Returns the first position in the selection.
     * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
     * any other position in the selection.
     *
     * Returns `null` if there are no ranges in selection.
     */
    getFirstPosition() {
      const e = this.getFirstRange();
      return e ? e.start.clone() : null;
    }
    /**
     * Returns the last position in the selection.
     * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
     * any other position in the selection.
     *
     * Returns `null` if there are no ranges in selection.
     */
    getLastPosition() {
      const e = this.getLastRange();
      return e ? e.end.clone() : null;
    }
    /**
     * Sets this selection's ranges and direction to the specified location based on the given
     * {@link module:engine/model/selection~Selectable selectable}.
     *
     * ```ts
     * // Removes all selection's ranges.
     * selection.setTo( null );
     *
     * // Sets selection to the given range.
     * const range = writer.createRange( start, end );
     * selection.setTo( range );
     *
     * // Sets selection to given ranges.
     * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     * selection.setTo( ranges );
     *
     * // Sets selection to other selection.
     * // Note: It doesn't copy selection attributes.
     * const otherSelection = writer.createSelection();
     * selection.setTo( otherSelection );
     *
     * // Sets selection to the given document selection.
     * // Note: It doesn't copy selection attributes.
     * const documentSelection = new DocumentSelection( doc );
     * selection.setTo( documentSelection );
     *
     * // Sets collapsed selection at the given position.
     * const position = writer.createPositionFromPath( root, path );
     * selection.setTo( position );
     *
     * // Sets collapsed selection at the position of the given node and an offset.
     * selection.setTo( paragraph, offset );
     * ```
     *
     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * ```ts
     * selection.setTo( paragraph, 'in' );
     * ```
     *
     * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.
     *
     * ```ts
     * selection.setTo( paragraph, 'on' );
     * ```
     *
     * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.
     *
     * ```ts
     * // Sets backward selection.
     * const selection = writer.createSelection( range, { backward: true } );
     * ```
     */
    setTo(...e) {
      let [t, i, s] = e;
      if (typeof i == "object" && (s = i, i = void 0), t === null)
        this._setRanges([]);
      else if (t instanceof De)
        this._setRanges(t.getRanges(), t.isBackward);
      else if (t && typeof t.getRanges == "function")
        this._setRanges(t.getRanges(), t.isBackward);
      else if (t instanceof _)
        this._setRanges([t], !!s && !!s.backward);
      else if (t instanceof C)
        this._setRanges([new _(t)]);
      else if (t instanceof vi) {
        const o = !!s && !!s.backward;
        let r;
        if (i == "in")
          r = _._createIn(t);
        else if (i == "on")
          r = _._createOn(t);
        else if (i !== void 0)
          r = new _(C._createAt(t, i));
        else
          throw new g("model-selection-setto-required-second-parameter", [this, t]);
        this._setRanges([r], o);
      } else if (We(t))
        this._setRanges(t, s && !!s.backward);
      else
        throw new g("model-selection-setto-not-selectable", [this, t]);
    }
    /**
     * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
     * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and
     * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.
     *
     * @fires change:range
     * @param newRanges Ranges to set.
     * @param isLastBackward Flag describing if last added range was selected forward - from start to end (`false`)
     * or backward - from end to start (`true`).
     */
    _setRanges(e, t = !1) {
      const i = Array.from(e), s = i.some((o) => {
        if (!(o instanceof _))
          throw new g("model-selection-set-ranges-not-range", [this, e]);
        return this._ranges.every((r) => !r.isEqual(o));
      });
      i.length === this._ranges.length && !s || (this._replaceAllRanges(i), this._lastRangeBackward = !!t, this.fire("change:range", { directChange: !0 }));
    }
    /**
     * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.
     *
     * The location can be specified in the same form as
     * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
     *
     * @fires change:range
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
     */
    setFocus(e, t) {
      if (this.anchor === null)
        throw new g("model-selection-setfocus-no-ranges", [this, e]);
      const i = C._createAt(e, t);
      if (i.compareWith(this.focus) == "same")
        return;
      const s = this.anchor;
      this._ranges.length && this._popRange(), i.compareWith(s) == "before" ? (this._pushRange(new _(i, s)), this._lastRangeBackward = !0) : (this._pushRange(new _(s, i)), this._lastRangeBackward = !1), this.fire("change:range", { directChange: !0 });
    }
    /**
     * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
     *
     * @param key Key of attribute to look for.
     * @returns Attribute value or `undefined`.
     */
    getAttribute(e) {
      return this._attrs.get(e);
    }
    /**
     * Returns iterable that iterates over this selection's attributes.
     *
     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     */
    getAttributes() {
      return this._attrs.entries();
    }
    /**
     * Returns iterable that iterates over this selection's attribute keys.
     */
    getAttributeKeys() {
      return this._attrs.keys();
    }
    /**
     * Checks if the selection has an attribute for given key.
     *
     * @param key Key of attribute to check.
     * @returns `true` if attribute with given key is set on selection, `false` otherwise.
     */
    hasAttribute(e) {
      return this._attrs.has(e);
    }
    /**
     * Removes an attribute with given key from the selection.
     *
     * If given attribute was set on the selection, fires the {@link #event:change:range} event with
     * removed attribute key.
     *
     * @fires change:attribute
     * @param key Key of attribute to remove.
     */
    removeAttribute(e) {
      this.hasAttribute(e) && (this._attrs.delete(e), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
    }
    /**
     * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
     *
     * If the attribute value has changed, fires the {@link #event:change:range} event with
     * the attribute key.
     *
     * @fires change:attribute
     * @param key Key of attribute to set.
     * @param value Attribute value.
     */
    setAttribute(e, t) {
      this.getAttribute(e) !== t && (this._attrs.set(e, t), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
    }
    /**
     * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
     * one range in the selection, and that range contains exactly one element.
     * Returns `null` if there is no selected element.
     */
    getSelectedElement() {
      return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
    }
    /**
     * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
     *
     * This method's result can be used for example to apply block styling to all blocks covered by this selection.
     *
     * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
     * but will not return blocks nested in other blocks.
     *
     * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
     *
     * ```xml
     * <paragraph>[a</paragraph>
     * <blockQuote>
     * 	<paragraph>b</paragraph>
     * </blockQuote>
     * <paragraph>c]d</paragraph>
     * ```
     *
     * In this case the paragraph will also be returned, despite the collapsed selection:
     *
     * ```xml
     * <paragraph>[]a</paragraph>
     * ```
     *
     * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
     *
     * ```xml
     * [<blockA></blockA>
     * <blockB>
     * 	<blockC></blockC>
     * 	<blockD></blockD>
     * </blockB>
     * <blockE></blockE>]
     * ```
     *
     * If the selection is inside a block all the inner blocks (A & B) are returned:
     *
     * ```xml
     * <block>
     * 	<blockA>[a</blockA>
     * 	<blockB>b]</blockB>
     * </block>
     * ```
     *
     * **Special case**: Selection ignores first and/or last blocks if nothing (from user perspective) is selected in them.
     *
     * ```xml
     * // Selection ends and the beginning of the last block.
     * <paragraph>[a</paragraph>
     * <paragraph>b</paragraph>
     * <paragraph>]c</paragraph> // This block will not be returned
     *
     * // Selection begins at the end of the first block.
     * <paragraph>a[</paragraph> // This block will not be returned
     * <paragraph>b</paragraph>
     * <paragraph>c]</paragraph>
     *
     * // Selection begings at the end of the first block and ends at the beginning of the last block.
     * <paragraph>a[</paragraph> // This block will not be returned
     * <paragraph>b</paragraph>
     * <paragraph>]c</paragraph> // This block will not be returned
     * ```
     */
    *getSelectedBlocks() {
      const e = /* @__PURE__ */ new WeakSet();
      for (const t of this.getRanges()) {
        const i = hu(t.start, e);
        Hk(i, t) && (yield i);
        for (const o of t.getWalker()) {
          const r = o.item;
          o.type == "elementEnd" && Uk(r, e, t) && (yield r);
        }
        const s = hu(t.end, e);
        $k(s, t) && (yield s);
      }
    }
    /**
     * Checks whether the selection contains the entire content of the given element. This means that selection must start
     * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
     * touching the element's end.
     *
     * By default, this method will check whether the entire content of the selection's current root is selected.
     * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
     */
    containsEntireContent(e = this.anchor.root) {
      const t = C._createAt(e, 0), i = C._createAt(e, "end");
      return t.isTouching(this.getFirstPosition()) && i.isTouching(this.getLastPosition());
    }
    /**
     * Adds given range to internal {@link #_ranges ranges array}. Throws an error
     * if given range is intersecting with any range that is already stored in this selection.
     */
    _pushRange(e) {
      this._checkRange(e), this._ranges.push(new _(e.start, e.end));
    }
    /**
     * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
     */
    _checkRange(e) {
      for (let t = 0; t < this._ranges.length; t++)
        if (e.isIntersecting(this._ranges[t]))
          throw new g("model-selection-range-intersects", [this, e], { addedRange: e, intersectingRange: this._ranges[t] });
    }
    /**
     * Replaces all the ranges by the given ones.
     * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.
     */
    _replaceAllRanges(e) {
      this._removeAllRanges();
      for (const t of e)
        this._pushRange(t);
    }
    /**
     * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
     * ensure proper ranges removal.
     */
    _removeAllRanges() {
      for (; this._ranges.length > 0; )
        this._popRange();
    }
    /**
     * Removes most recently added range from the selection.
     */
    _popRange() {
      this._ranges.pop();
    }
  }
  De.prototype.is = function(n) {
    return n === "selection" || n === "model:selection";
  };
  function Sm(n, e) {
    return e.has(n) ? !1 : (e.add(n), n.root.document.model.schema.isBlock(n) && !!n.parent);
  }
  function Uk(n, e, t) {
    return Sm(n, e) && _l(n, t);
  }
  function hu(n, e) {
    const i = n.parent.root.document.model.schema, s = n.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
    let o = !1;
    const r = s.find((a) => o ? !1 : (o = i.isLimit(a), !o && Sm(a, e)));
    return s.forEach((a) => e.add(a)), r;
  }
  function _l(n, e) {
    const t = Wk(n);
    return t ? !e.containsRange(_._createOn(t), !0) : !0;
  }
  function Hk(n, e) {
    return n ? e.isCollapsed || n.isEmpty ? !0 : e.start.isTouching(C._createAt(n, n.maxOffset)) ? !1 : _l(n, e) : !1;
  }
  function $k(n, e) {
    return n ? e.isCollapsed || n.isEmpty ? !0 : e.end.isTouching(C._createAt(n, 0)) ? !1 : _l(n, e) : !1;
  }
  function Wk(n) {
    const e = n.root.document.model.schema;
    let t = n.parent;
    for (; t; ) {
      if (e.isBlock(t))
        return t;
      t = t.parent;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Pe extends G(_) {
    /**
     * Creates a live range.
     *
     * @see module:engine/model/range~Range
     */
    constructor(e, t) {
      super(e, t), qk.call(this);
    }
    /**
     * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
     * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
     * referring to it).
     */
    detach() {
      this.stopListening();
    }
    /**
     * Creates a {@link module:engine/model/range~Range range instance} that is equal to this live range.
     */
    toRange() {
      return new _(this.start, this.end);
    }
    /**
     * Creates a `LiveRange` instance that is equal to the given range.
     */
    static fromRange(e) {
      return new Pe(e.start, e.end);
    }
  }
  Pe.prototype.is = function(n) {
    return n === "liveRange" || n === "model:liveRange" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n == "range" || n === "model:range";
  };
  function qk() {
    this.listenTo(this.root.document.model, "applyOperation", (n, e) => {
      const t = e[0];
      t.isDocumentOperation && Gk.call(this, t);
    }, { priority: "low" });
  }
  function Gk(n) {
    const e = this.getTransformedByOperation(n), t = _._createFromRanges(e), i = !t.isEqual(this), s = jk(this, n);
    let o = null;
    if (i) {
      t.root.rootName == "$graveyard" && (n.type == "remove" ? o = n.sourcePosition : o = n.deletionPosition);
      const r = this.toRange();
      this.start = t.start, this.end = t.end, this.fire("change:range", r, { deletionPosition: o });
    } else
      s && this.fire("change:content", this.toRange(), { deletionPosition: o });
  }
  function jk(n, e) {
    switch (e.type) {
      case "insert":
        return n.containsPosition(e.position);
      case "move":
      case "remove":
      case "reinsert":
      case "merge":
        return n.containsPosition(e.sourcePosition) || n.start.isEqual(e.sourcePosition) || n.containsPosition(e.targetPosition);
      case "split":
        return n.containsPosition(e.splitPosition) || n.containsPosition(e.insertionPosition);
    }
    return !1;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Yn = "selection:";
  class lt extends G(jt) {
    /**
     * Creates an empty live selection for given {@link module:engine/model/document~Document}.
     *
     * @param doc Document which owns this selection.
     */
    constructor(e) {
      super(), this._selection = new Kk(e), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
    }
    /**
     * Describes whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
     * collapsed.
     */
    get isCollapsed() {
      return this._selection.isCollapsed;
    }
    /**
     * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
     * Together with {@link #focus} they define the direction of selection, which is important
     * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or
     * {@link module:engine/model/range~Range#end end} position of the most recently added range.
     *
     * Is set to `null` if there are no ranges in selection.
     *
     * @see #focus
     */
    get anchor() {
      return this._selection.anchor;
    }
    /**
     * Selection focus. Focus is a position where the selection ends.
     *
     * Is set to `null` if there are no ranges in selection.
     *
     * @see #anchor
     */
    get focus() {
      return this._selection.focus;
    }
    /**
     * Number of ranges in selection.
     */
    get rangeCount() {
      return this._selection.rangeCount;
    }
    /**
     * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to
     * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
     */
    get hasOwnRange() {
      return this._selection.hasOwnRange;
    }
    /**
     * Specifies whether the {@link #focus}
     * precedes {@link #anchor}.
     *
     * @readonly
     * @type {Boolean}
     */
    get isBackward() {
      return this._selection.isBackward;
    }
    /**
     * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.
     *
     * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.
     */
    get isGravityOverridden() {
      return this._selection.isGravityOverridden;
    }
    /**
     * A collection of selection {@link module:engine/model/markercollection~Marker markers}.
     * Marker is a selection marker when selection range is inside the marker range.
     *
     * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.
     */
    get markers() {
      return this._selection.markers;
    }
    /**
     * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.
     *
     * @internal
     */
    get _ranges() {
      return this._selection._ranges;
    }
    /**
     * Returns an iterable that iterates over copies of selection ranges.
     */
    getRanges() {
      return this._selection.getRanges();
    }
    /**
     * Returns the first position in the selection.
     * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
     * any other position in the selection.
     *
     * Returns `null` if there are no ranges in selection.
     */
    getFirstPosition() {
      return this._selection.getFirstPosition();
    }
    /**
     * Returns the last position in the selection.
     * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
     * any other position in the selection.
     *
     * Returns `null` if there are no ranges in selection.
     */
    getLastPosition() {
      return this._selection.getLastPosition();
    }
    /**
     * Returns a copy of the first range in the selection.
     * First range is the one which {@link module:engine/model/range~Range#start start} position
     * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
     * (not to confuse with the first range added to the selection).
     *
     * Returns `null` if there are no ranges in selection.
     */
    getFirstRange() {
      return this._selection.getFirstRange();
    }
    /**
     * Returns a copy of the last range in the selection.
     * Last range is the one which {@link module:engine/model/range~Range#end end} position
     * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
     * recently added to the selection).
     *
     * Returns `null` if there are no ranges in selection.
     */
    getLastRange() {
      return this._selection.getLastRange();
    }
    /**
     * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
     *
     * This method's result can be used for example to apply block styling to all blocks covered by this selection.
     *
     * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
     * but will not return blocks nested in other blocks.
     *
     * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
     *
     * ```
     * <paragraph>[a</paragraph>
     * <blockQuote>
     * 	<paragraph>b</paragraph>
     * </blockQuote>
     * <paragraph>c]d</paragraph>
     * ```
     *
     * In this case the paragraph will also be returned, despite the collapsed selection:
     *
     * ```
     * <paragraph>[]a</paragraph>
     * ```
     *
     * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
     *
     * ```
     * [<blockA></blockA>
     * <blockB>
     * 	<blockC></blockC>
     * 	<blockD></blockD>
     * </blockB>
     * <blockE></blockE>]
     * ```
     *
     * If the selection is inside a block all the inner blocks (A & B) are returned:
     *
     * ```
     * <block>
     * 	<blockA>[a</blockA>
     * 	<blockB>b]</blockB>
     * </block>
     * ```
     *
     * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
     * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
     *
     * ```
     * <paragraph>[a</paragraph>
     * <paragraph>b</paragraph>
     * <paragraph>]c</paragraph> // this block will not be returned
     * ```
     */
    getSelectedBlocks() {
      return this._selection.getSelectedBlocks();
    }
    /**
     * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
     * one range in the selection, and that range contains exactly one element.
     * Returns `null` if there is no selected element.
     */
    getSelectedElement() {
      return this._selection.getSelectedElement();
    }
    /**
     * Checks whether the selection contains the entire content of the given element. This means that selection must start
     * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
     * touching the element's end.
     *
     * By default, this method will check whether the entire content of the selection's current root is selected.
     * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
     */
    containsEntireContent(e) {
      return this._selection.containsEntireContent(e);
    }
    /**
     * Unbinds all events previously bound by document selection.
     */
    destroy() {
      this._selection.destroy();
    }
    /**
     * Returns iterable that iterates over this selection's attribute keys.
     */
    getAttributeKeys() {
      return this._selection.getAttributeKeys();
    }
    /**
     * Returns iterable that iterates over this selection's attributes.
     *
     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     */
    getAttributes() {
      return this._selection.getAttributes();
    }
    /**
     * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
     *
     * @param key Key of attribute to look for.
     * @returns Attribute value or `undefined`.
     */
    getAttribute(e) {
      return this._selection.getAttribute(e);
    }
    /**
     * Checks if the selection has an attribute for given key.
     *
     * @param key Key of attribute to check.
     * @returns `true` if attribute with given key is set on selection, `false` otherwise.
     */
    hasAttribute(e) {
      return this._selection.hasAttribute(e);
    }
    /**
     * Refreshes selection attributes and markers according to the current position in the model.
     */
    refresh() {
      this._selection.updateMarkers(), this._selection._updateAttributes(!1);
    }
    /**
     * Registers a marker group prefix or a marker name to be collected in the
     * {@link ~DocumentSelection#markers selection markers collection}.
     *
     * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.
     *
     * @param prefixOrName The marker group prefix or marker name.
     */
    observeMarkers(e) {
      this._selection.observeMarkers(e);
    }
    /**
     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
     * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.
     *
     * The location can be specified in the same form as
     * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
     *
     * @see module:engine/model/writer~Writer#setSelectionFocus
     * @internal
     * @param offset Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/model/item~Item model item}.
     */
    _setFocus(e, t) {
      this._selection.setFocus(e, t);
    }
    /**
     * Sets this selection's ranges and direction to the specified location based on the given
     * {@link module:engine/model/selection~Selectable selectable}.
     * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.
     *
     * @see module:engine/model/writer~Writer#setSelection
     * @internal
     */
    _setTo(...e) {
      this._selection.setTo(...e);
    }
    /**
     * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
     * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.
     *
     * @see module:engine/model/writer~Writer#setSelectionAttribute
     * @internal
     * @param key Key of the attribute to set.
     * @param value Attribute value.
     */
    _setAttribute(e, t) {
      this._selection.setAttribute(e, t);
    }
    /**
     * Removes an attribute with given key from the selection.
     * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}
     * event with removed attribute key.
     * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.
     *
     * @see module:engine/model/writer~Writer#removeSelectionAttribute
     * @internal
     * @param key Key of the attribute to remove.
     */
    _removeAttribute(e) {
      this._selection.removeAttribute(e);
    }
    /**
     * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
     *
     * @internal
     */
    _getStoredAttributes() {
      return this._selection.getStoredAttributes();
    }
    /**
     * Temporarily changes the gravity of the selection from the left to the right.
     *
     * The gravity defines from which direction the selection inherits its attributes. If it's the default left
     * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.
     * This method allows to temporarily override this behavior by forcing the gravity to the right.
     *
     * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
     * of the process.
     *
     * @see module:engine/model/writer~Writer#overrideSelectionGravity
     * @internal
     * @returns The unique id which allows restoring the gravity.
     */
    _overrideGravity() {
      return this._selection.overrideGravity();
    }
    /**
     * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.
     *
     * Restoring the gravity is only possible using the unique identifier returned by
     * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored
     * the same number of times it was overridden.
     *
     * @see module:engine/model/writer~Writer#restoreSelectionGravity
     * @internal
     * @param uid The unique id returned by {@link #_overrideGravity}.
     */
    _restoreGravity(e) {
      this._selection.restoreGravity(e);
    }
    /**
     * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
     *
     * @internal
     * @param key Attribute key to convert.
     * @returns Converted attribute key, applicable for selection store.
     */
    static _getStoreAttributeKey(e) {
      return Yn + e;
    }
    /**
     * Checks whether the given attribute key is an attribute stored on an element.
     *
     * @internal
     */
    static _isStoreAttributeKey(e) {
      return e.startsWith(Yn);
    }
  }
  lt.prototype.is = function(n) {
    return n === "selection" || n == "model:selection" || n == "documentSelection" || n == "model:documentSelection";
  };
  class Kk extends De {
    /**
     * Creates an empty live selection for given {@link module:engine/model/document~Document}.
     *
     * @param doc Document which owns this selection.
     */
    constructor(e) {
      super(), this.markers = new Ce({ idProperty: "name" }), this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this._model = e.model, this._document = e, this.listenTo(this._model, "applyOperation", (t, i) => {
        const s = i[0];
        !s.isDocumentOperation || s.type == "marker" || s.type == "rename" || s.type == "noop" || (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", { directChange: !1 })));
      }, { priority: "lowest" }), this.on("change:range", () => {
        this._validateSelectionRanges(this.getRanges());
      }), this.listenTo(this._model.markers, "update", (t, i, s, o) => {
        this._updateMarker(i, o);
      }), this.listenTo(this._document, "change", (t, i) => {
        Zk(this._model, i);
      });
    }
    get isCollapsed() {
      return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
    }
    get anchor() {
      return super.anchor || this._document._getDefaultRange().start;
    }
    get focus() {
      return super.focus || this._document._getDefaultRange().end;
    }
    get rangeCount() {
      return this._ranges.length ? this._ranges.length : 1;
    }
    /**
     * Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to
     * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
     */
    get hasOwnRange() {
      return this._ranges.length > 0;
    }
    /**
     * When set to `true` then selection attributes on node before the caret won't be taken
     * into consideration while updating selection attributes.
     */
    get isGravityOverridden() {
      return !!this._overriddenGravityRegister.size;
    }
    /**
     * Unbinds all events previously bound by live selection.
     */
    destroy() {
      for (let e = 0; e < this._ranges.length; e++)
        this._ranges[e].detach();
      this.stopListening();
    }
    *getRanges() {
      this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
    }
    getFirstRange() {
      return super.getFirstRange() || this._document._getDefaultRange();
    }
    getLastRange() {
      return super.getLastRange() || this._document._getDefaultRange();
    }
    setTo(...e) {
      super.setTo(...e), this._updateAttributes(!0), this.updateMarkers();
    }
    setFocus(e, t) {
      super.setFocus(e, t), this._updateAttributes(!0), this.updateMarkers();
    }
    setAttribute(e, t) {
      if (this._setAttribute(e, t)) {
        const i = [e];
        this.fire("change:attribute", { attributeKeys: i, directChange: !0 });
      }
    }
    removeAttribute(e) {
      if (this._removeAttribute(e)) {
        const t = [e];
        this.fire("change:attribute", { attributeKeys: t, directChange: !0 });
      }
    }
    overrideGravity() {
      const e = Ze();
      return this._overriddenGravityRegister.add(e), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), e;
    }
    restoreGravity(e) {
      if (!this._overriddenGravityRegister.has(e))
        throw new g("document-selection-gravity-wrong-restore", this, { uid: e });
      this._overriddenGravityRegister.delete(e), this.isGravityOverridden || this._updateAttributes(!0);
    }
    observeMarkers(e) {
      this._observedMarkers.add(e), this.updateMarkers();
    }
    _replaceAllRanges(e) {
      this._validateSelectionRanges(e), super._replaceAllRanges(e);
    }
    _popRange() {
      this._ranges.pop().detach();
    }
    _pushRange(e) {
      const t = this._prepareRange(e);
      t && this._ranges.push(t);
    }
    _validateSelectionRanges(e) {
      for (const t of e)
        if (!this._document._validateSelectionRange(t))
          throw new g("document-selection-wrong-position", this, { range: t });
    }
    /**
     * Prepares given range to be added to selection. Checks if it is correct,
     * converts it to {@link module:engine/model/liverange~LiveRange LiveRange}
     * and sets listeners listening to the range's change event.
     */
    _prepareRange(e) {
      if (this._checkRange(e), e.root == this._document.graveyard)
        return;
      const t = Pe.fromRange(e);
      return t.on("change:range", (i, s, o) => {
        if (this._hasChangedRange = !0, t.root == this._document.graveyard) {
          this._selectionRestorePosition = o.deletionPosition;
          const r = this._ranges.indexOf(t);
          this._ranges.splice(r, 1), t.detach();
        }
      }), t;
    }
    updateMarkers() {
      if (!this._observedMarkers.size)
        return;
      const e = [];
      let t = !1;
      for (const s of this._model.markers) {
        const o = s.name.split(":", 1)[0];
        if (!this._observedMarkers.has(o))
          continue;
        const r = s.getRange();
        for (const a of this.getRanges())
          r.containsRange(a, !a.isCollapsed) && e.push(s);
      }
      const i = Array.from(this.markers);
      for (const s of e)
        this.markers.has(s) || (this.markers.add(s), t = !0);
      for (const s of Array.from(this.markers))
        e.includes(s) || (this.markers.remove(s), t = !0);
      t && this.fire("change:marker", { oldMarkers: i, directChange: !1 });
    }
    _updateMarker(e, t) {
      const i = e.name.split(":", 1)[0];
      if (!this._observedMarkers.has(i))
        return;
      let s = !1;
      const o = Array.from(this.markers), r = this.markers.has(e);
      if (!t)
        r && (this.markers.remove(e), s = !0);
      else {
        let a = !1;
        for (const l of this.getRanges())
          if (t.containsRange(l, !l.isCollapsed)) {
            a = !0;
            break;
          }
        a && !r ? (this.markers.add(e), s = !0) : !a && r && (this.markers.remove(e), s = !0);
      }
      s && this.fire("change:marker", { oldMarkers: o, directChange: !1 });
    }
    /**
     * Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.
     */
    _updateAttributes(e) {
      const t = wt(this._getSurroundingAttributes()), i = wt(this.getAttributes());
      if (e)
        this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
      else
        for (const [o, r] of this._attributePriority)
          r == "low" && (this._attrs.delete(o), this._attributePriority.delete(o));
      this._setAttributesTo(t);
      const s = [];
      for (const [o, r] of this.getAttributes())
        (!i.has(o) || i.get(o) !== r) && s.push(o);
      for (const [o] of i)
        this.hasAttribute(o) || s.push(o);
      s.length > 0 && this.fire("change:attribute", { attributeKeys: s, directChange: !1 });
    }
    /**
     * Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
     * parameter).
     */
    _setAttribute(e, t, i = !0) {
      const s = i ? "normal" : "low";
      return s == "low" && this._attributePriority.get(e) == "normal" || super.getAttribute(e) === t ? !1 : (this._attrs.set(e, t), this._attributePriority.set(e, s), !0);
    }
    /**
     * Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
     * parameter).
     *
     * NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will
     * be changed according to `directChange` parameter.
     */
    _removeAttribute(e, t = !0) {
      const i = t ? "normal" : "low";
      return i == "low" && this._attributePriority.get(e) == "normal" || (this._attributePriority.set(e, i), !super.hasAttribute(e)) ? !1 : (this._attrs.delete(e), !0);
    }
    /**
     * Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
     * `directChange` parameter).
     */
    _setAttributesTo(e) {
      const t = /* @__PURE__ */ new Set();
      for (const [i, s] of this.getAttributes())
        e.get(i) !== s && this._removeAttribute(i, !1);
      for (const [i, s] of e)
        this._setAttribute(i, s, !1) && t.add(i);
      return t;
    }
    /**
     * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
     */
    *getStoredAttributes() {
      const e = this.getFirstPosition().parent;
      if (this.isCollapsed && e.isEmpty)
        for (const t of e.getAttributeKeys())
          t.startsWith(Yn) && (yield [t.substr(Yn.length), e.getAttribute(t)]);
    }
    /**
     * Checks model text nodes that are closest to the selection's first position and returns attributes of first
     * found element. If there are no text nodes in selection's first position parent, it returns selection
     * attributes stored in that parent.
     */
    _getSurroundingAttributes() {
      const e = this.getFirstPosition(), t = this._model.schema;
      if (e.root.rootName == "$graveyard")
        return null;
      let i = null;
      if (this.isCollapsed) {
        const s = e.textNode ? e.textNode : e.nodeBefore, o = e.textNode ? e.textNode : e.nodeAfter;
        if (this.isGravityOverridden || (i = _n(s, t)), i || (i = _n(o, t)), !this.isGravityOverridden && !i) {
          let r = s;
          for (; r && !i; )
            r = r.previousSibling, i = _n(r, t);
        }
        if (!i) {
          let r = o;
          for (; r && !i; )
            r = r.nextSibling, i = _n(r, t);
        }
        i || (i = this.getStoredAttributes());
      } else {
        const s = this.getFirstRange();
        for (const o of s) {
          if (o.item.is("element") && t.isObject(o.item)) {
            i = _n(o.item, t);
            break;
          }
          if (o.type == "text") {
            i = o.item.getAttributes();
            break;
          }
        }
      }
      return i;
    }
    /**
     * Fixes the selection after all its ranges got removed.
     * @param deletionPosition Position where the deletion happened.
     */
    _fixGraveyardSelection(e) {
      const t = this._model.schema.getNearestSelectionRange(e);
      t && this._pushRange(t);
    }
  }
  function _n(n, e) {
    if (!n)
      return null;
    if (n instanceof st || n instanceof j)
      return n.getAttributes();
    if (!e.isInline(n))
      return null;
    if (!e.isObject(n))
      return [];
    const t = [];
    for (const [i, s] of n.getAttributes())
      e.checkAttribute("$text", i) && e.getAttributeProperties(i).copyFromObject !== !1 && t.push([i, s]);
    return t;
  }
  function Zk(n, e) {
    const t = n.document.differ;
    for (const i of t.getChanges()) {
      if (i.type != "insert")
        continue;
      const s = i.position.parent;
      i.length === s.maxOffset && n.enqueueChange(e, (r) => {
        const a = Array.from(s.getAttributeKeys()).filter((l) => l.startsWith(Yn));
        for (const l of a)
          r.removeAttribute(l, s);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Im {
    /**
     * Creates a conversion helpers instance.
     */
    constructor(e) {
      this._dispatchers = e;
    }
    /**
     * Registers a conversion helper.
     *
     * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`
     * method description.
     *
     * @param conversionHelper The function to be called on event.
     */
    add(e) {
      for (const t of this._dispatchers)
        e(t);
      return this;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Jk extends Im {
    /**
     * Model element to view element conversion helper.
     *
     * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.
     *
     * ```ts
     * editor.conversion.for( 'downcast' ).elementToElement( {
     * 	model: 'paragraph',
     * 	view: 'p'
     * } );
     *
     * editor.conversion.for( 'downcast' ).elementToElement( {
     * 	model: 'paragraph',
     * 	view: 'div',
     * 	converterPriority: 'high'
     * } );
     *
     * editor.conversion.for( 'downcast' ).elementToElement( {
     * 	model: 'fancyParagraph',
     * 	view: {
     * 		name: 'p',
     * 		classes: 'fancy'
     * 	}
     * } );
     *
     * editor.conversion.for( 'downcast' ).elementToElement( {
     * 	model: 'heading',
     * 	view: ( modelElement, conversionApi ) => {
     * 		const { writer } = conversionApi;
     *
     * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
     * 	}
     * } );
     * ```
     *
     * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or
     * the `children` props on a model description. You will find a couple examples below.
     *
     * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`
     * description. For example, this model:
     *
     * ```xml
     * <box>
     * 	<paragraph>Some text.</paragraph>
     * </box>
     * ```
     *
     * will be converted into this structure in the view:
     *
     * ```html
     * <div class="box" data-type="single">
     * 	<p>Some text.</p>
     * </div>
     * ```
     *
     * But if more items were inserted in the model:
     *
     * ```xml
     * <box>
     * 	<paragraph>Some text.</paragraph>
     * 	<paragraph>Other item.</paragraph>
     * </box>
     * ```
     *
     * it will be converted into this structure in the view (note the element `data-type` change):
     *
     * ```html
     * <div class="box" data-type="multiple">
     * 	<p>Some text.</p>
     * 	<p>Other item.</p>
     * </div>
     * ```
     *
     * Such a converter would look like this (note that the `paragraph` elements are converted separately):
     *
     * ```ts
     * editor.conversion.for( 'downcast' ).elementToElement( {
     * 	model: {
     * 		name: 'box',
     * 		children: true
     * 	},
     * 	view: ( modelElement, conversionApi ) => {
     * 		const { writer } = conversionApi;
     *
     * 		return writer.createContainerElement( 'div', {
     * 			class: 'box',
     * 			'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'
     * 		} );
     * 	}
     * } );
     * ```
     *
     * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`
     * description. For example, this model:
     *
     * ```xml
     * <heading level="2">Some text.</heading>
     * ```
     *
     * will be converted into this structure in the view:
     *
     * ```html
     * <h2>Some text.</h2>
     * ```
     *
     * But if the `heading` element's `level` attribute has been updated to `3` for example, then
     * it will be converted into this structure in the view:
     *
     * ```html
     * <h3>Some text.</h3>
     * ```
     *
     * Such a converter would look as follows:
     *
     * ```ts
     * editor.conversion.for( 'downcast' ).elementToElement( {
     * 	model: {
     * 		name: 'heading',
     * 		attributes: 'level'
     * 	},
     * 	view: ( modelElement, conversionApi ) => {
     * 		const { writer } = conversionApi;
     *
     * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
     * 	}
     * } );
     * ```
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * You can read more about the element-to-element conversion in the
     * {@glink framework/deep-dive/conversion/downcast downcast conversion} guide.
     *
     * @param config Conversion configuration.
     * @param config.model The description or a name of the model element to convert.
     * @param config.model.attributes The list of attribute names that should be consumed while creating
     * the view element. Note that the view will be reconverted if any of the listed attributes changes.
     * @param config.model.children Specifies whether the view element requires reconversion if the list
     * of the model child nodes changed.
     * @param config.view A view element definition or a function that takes the model element and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
     * as parameters and returns a view container element.
     */
    elementToElement(e) {
      return this.add(mT(e));
    }
    /**
     * The model element to view structure (several elements) conversion helper.
     *
     * This conversion results in creating a view structure with one or more slots defined for the child nodes.
     * For example, a model `<table>` may become this structure in the view:
     *
     * ```html
     * <figure class="table">
     * 	<table>
     * 		<tbody>${ slot for table rows }</tbody>
     * 	</table>
     * </figure>
     * ```
     *
     * The children of the model's `<table>` element will be inserted into the `<tbody>` element.
     * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.
     *
     * Imagine a table feature where for this model structure:
     *
     * ```xml
     * <table headingRows="1">
     * 	<tableRow> ... table cells 1 ... </tableRow>
     * 	<tableRow> ... table cells 2 ... </tableRow>
     * 	<tableRow> ... table cells 3 ... </tableRow>
     * 	<caption>Caption text</caption>
     * </table>
     * ```
     *
     * we want to generate this view structure:
     *
     * ```html
     * <figure class="table">
     * 	<table>
     * 		<thead>
     * 			<tr> ... table cells 1 ... </tr>
     * 		</thead>
     * 		<tbody>
     * 			<tr> ... table cells 2 ... </tr>
     * 			<tr> ... table cells 3 ... </tr>
     * 		</tbody>
     * 	</table>
     * 	<figcaption>Caption text</figcaption>
     * </figure>
     * ```
     *
     * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements
     * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.
     *
     * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.
     * In the example above, this will handle the table caption.
     *
     * Such a converter would look like this:
     *
     * ```ts
     * editor.conversion.for( 'downcast' ).elementToStructure( {
     * 	model: {
     * 		name: 'table',
     * 		attributes: [ 'headingRows' ]
     * 	},
     * 	view: ( modelElement, conversionApi ) => {
     * 		const { writer } = conversionApi;
     *
     * 		const figureElement = writer.createContainerElement( 'figure', { class: 'table' } );
     * 		const tableElement = writer.createContainerElement( 'table' );
     *
     * 		writer.insert( writer.createPositionAt( figureElement, 0 ), tableElement );
     *
     * 		const headingRows = modelElement.getAttribute( 'headingRows' ) || 0;
     *
     * 		if ( headingRows > 0 ) {
     * 			const tableHead = writer.createContainerElement( 'thead' );
     *
     * 			const headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );
     *
     * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );
     * 			writer.insert( writer.createPositionAt( tableHead, 0 ), headSlot );
     * 		}
     *
     * 		if ( headingRows < tableUtils.getRows( table ) ) {
     * 			const tableBody = writer.createContainerElement( 'tbody' );
     *
     * 			const bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );
     *
     * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );
     * 			writer.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );
     * 		}
     *
     * 		const restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );
     *
     * 		writer.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );
     *
     * 		return figureElement;
     * 	}
     * } );
     * ```
     *
     * Note: The children of a model element that's being converted must be allocated in the same order in the view
     * in which they are placed in the model.
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.model The description or a name of the model element to convert.
     * @param config.model.name The name of the model element to convert.
     * @param config.model.attributes The list of attribute names that should be consumed while creating
     * the view structure. Note that the view will be reconverted if any of the listed attributes will change.
     * @param config.view A function that takes the model element and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters
     * and returns a view container element with slots for model child nodes to be converted into.
     */
    elementToStructure(e) {
      return this.add(gT(e));
    }
    /**
     * Model attribute to view element conversion helper.
     *
     * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with
     * `"Foo"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.
     *
     * ```ts
     * editor.conversion.for( 'downcast' ).attributeToElement( {
     * 	model: 'bold',
     * 	view: 'strong'
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToElement( {
     * 	model: 'bold',
     * 	view: 'b',
     * 	converterPriority: 'high'
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToElement( {
     * 	model: 'invert',
     * 	view: {
     * 		name: 'span',
     * 		classes: [ 'font-light', 'bg-dark' ]
     * 	}
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToElement( {
     * 	model: {
     * 		key: 'fontSize',
     * 		values: [ 'big', 'small' ]
     * 	},
     * 	view: {
     * 		big: {
     * 			name: 'span',
     * 			styles: {
     * 				'font-size': '1.2em'
     * 			}
     * 		},
     * 		small: {
     * 			name: 'span',
     * 			styles: {
     * 				'font-size': '0.8em'
     * 			}
     * 		}
     * 	}
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToElement( {
     * 	model: 'bold',
     * 	view: ( modelAttributeValue, conversionApi ) => {
     * 		const { writer } = conversionApi;
     *
     * 		return writer.createAttributeElement( 'span', {
     * 			style: 'font-weight:' + modelAttributeValue
     * 		} );
     * 	}
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToElement( {
     * 	model: {
     * 		key: 'color',
     * 		name: '$text'
     * 	},
     * 	view: ( modelAttributeValue, conversionApi ) => {
     * 		const { writer } = conversionApi;
     *
     * 		return writer.createAttributeElement( 'span', {
     * 			style: 'color:' + modelAttributeValue
     * 		} );
     * 	}
     * } );
     * ```
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
     * of `String`s with possible values if the model attribute is an enumerable.
     * @param config.view A view element definition or a function
     * that takes the model attribute value and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view
     * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`
     * to view element definitions or functions.
     * @param config.converterPriority Converter priority.
     */
    attributeToElement(e) {
      return this.add(pT(e));
    }
    /**
     * Model attribute to view attribute conversion helper.
     *
     * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,
     * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.
     *
     * ```ts
     * editor.conversion.for( 'downcast' ).attributeToAttribute( {
     * 	model: 'source',
     * 	view: 'src'
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToAttribute( {
     * 	model: 'source',
     * 	view: 'href',
     * 	converterPriority: 'high'
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToAttribute( {
     * 	model: {
     * 		name: 'imageInline',
     * 		key: 'source'
     * 	},
     * 	view: 'src'
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToAttribute( {
     * 	model: {
     * 		name: 'styled',
     * 		values: [ 'dark', 'light' ]
     * 	},
     * 	view: {
     * 		dark: {
     * 			key: 'class',
     * 			value: [ 'styled', 'styled-dark' ]
     * 		},
     * 		light: {
     * 			key: 'class',
     * 			value: [ 'styled', 'styled-light' ]
     * 		}
     * 	}
     * } );
     *
     * editor.conversion.for( 'downcast' ).attributeToAttribute( {
     * 	model: 'styled',
     * 	view: modelAttributeValue => ( {
     * 		key: 'class',
     * 		value: 'styled-' + modelAttributeValue
     * 	} )
     * } );
     * ```
     *
     * **Note**: Downcasting to a style property requires providing `value` as an object:
     *
     * ```ts
     * editor.conversion.for( 'downcast' ).attributeToAttribute( {
     * 	model: 'lineHeight',
     * 	view: modelAttributeValue => ( {
     * 		key: 'style',
     * 		value: {
     * 			'line-height': modelAttributeValue,
     * 			'border-bottom': '1px dotted #ba2'
     * 		}
     * 	} )
     * } );
     * ```
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
     * the attribute key, possible values and, optionally, an element name to convert from.
     * @param config.view A view attribute key, or a `{ key, value }` object or a function that takes the model attribute value and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
     * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an
     * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.
     * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
     * `{ key, value }` objects or a functions.
     * @param config.converterPriority Converter priority.
     */
    attributeToAttribute(e) {
      return this.add(wT(e));
    }
    /**
     * Model marker to view element conversion helper.
     *
     * **Note**: This method should be used mainly for editing the downcast and it is recommended
     * to use the {@link #markerToData `#markerToData()`} helper instead.
     *
     * This helper may produce invalid HTML code (e.g. a span between table cells).
     * It should only be used when you are sure that the produced HTML will be semantically correct.
     *
     * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker
     * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`
     * becomes `<p>F<span data-marker="search"></span>oo b<span data-marker="search"></span>ar</p>` in the view.
     *
     * ```ts
     * editor.conversion.for( 'editingDowncast' ).markerToElement( {
     * 	model: 'search',
     * 	view: 'marker-search'
     * } );
     *
     * editor.conversion.for( 'editingDowncast' ).markerToElement( {
     * 	model: 'search',
     * 	view: 'search-result',
     * 	converterPriority: 'high'
     * } );
     *
     * editor.conversion.for( 'editingDowncast' ).markerToElement( {
     * 	model: 'search',
     * 	view: {
     * 		name: 'span',
     * 		attributes: {
     * 			'data-marker': 'search'
     * 		}
     * 	}
     * } );
     *
     * editor.conversion.for( 'editingDowncast' ).markerToElement( {
     * 	model: 'search',
     * 	view: ( markerData, conversionApi ) => {
     * 		const { writer } = conversionApi;
     *
     * 		return writer.createUIElement( 'span', {
     * 			'data-marker': 'search',
     * 			'data-start': markerData.isOpening
     * 		} );
     * 	}
     * } );
     * ```
     *
     * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function
     * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
     * as a parameters and should return an instance of the
     * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from
     * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,
     * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for
     * the marker end boundary element.
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.model The name of the model marker (or model marker group) to convert.
     * @param config.view A view element definition or a function that takes the model marker data and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
     * and returns a view UI element.
     * @param config.converterPriority Converter priority.
     */
    markerToElement(e) {
      return this.add(bT(e));
    }
    /**
     * Model marker to highlight conversion helper.
     *
     * This conversion results in creating a highlight on view nodes. For this kind of conversion,
     * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.
     *
     * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes
     * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes
     * `<p>F<span class="comment">oo b</span>ar</p>` in the view.
     *
     * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,
     * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).
     * For example, a model marker set like this:
     * `[<imageInline src="foo.jpg"></imageInline>]` becomes `<img src="foo.jpg" class="comment"></img>` in the view.
     *
     * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it
     * to a container element, it is the container element instance itself that applies values from the highlight descriptor.
     * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.
     *
     * ```ts
     * editor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );
     *
     * editor.conversion.for( 'downcast' ).markerToHighlight( {
     * 	model: 'comment',
     * 	view: { classes: 'comment' },
     * 	converterPriority: 'high'
     * } );
     *
     * editor.conversion.for( 'downcast' ).markerToHighlight( {
     * 	model: 'comment',
     * 	view: ( data, conversionApi ) => {
     * 		// Assuming that the marker name is in a form of comment:commentType:commentId.
     * 		const [ , commentType, commentId ] = data.markerName.split( ':' );
     *
     * 		return {
     * 			classes: [ 'comment', 'comment-' + commentType ],
     * 			attributes: { 'data-comment-id': commentId }
     * 		};
     * 	}
     * } );
     * ```
     *
     * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function
     * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
     * as the parameters and should return a
     * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.
     * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.model The name of the model marker (or model marker group) to convert.
     * @param config.view A highlight descriptor that will be used for highlighting or a function that takes the model marker data and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
     * and returns a highlight descriptor.
     * @param config.converterPriority Converter priority.
     */
    markerToHighlight(e) {
      return this.add(vT(e));
    }
    /**
     * Model marker converter for data downcast.
     *
     * This conversion creates a representation for model marker boundaries in the view:
     *
     * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.
     * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.
     *
     * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.
     * The default configuration for this conversion is that the first part is the `group` part and the rest of
     * the marker name becomes the `name` part.
     *
     * Tag and attribute names and values are generated from the marker name:
     *
     * * The templates for attributes are `data-[group]-start-before="[name]"`, `data-[group]-start-after="[name]"`,
     * `data-[group]-end-before="[name]"` and `data-[group]-end-after="[name]"`.
     * * The templates for view elements are `<[group]-start name="[name]">` and `<[group]-end name="[name]">`.
     *
     * Attributes mark whether the given marker's start or end boundary is before or after the given element.
     * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.
     * The other two are used when the former two cannot be used.
     *
     * The conversion configuration can take a function that will generate different group and name parts.
     * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two
     * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.
     *
     * Basic usage:
     *
     * ```ts
     * // Using the default conversion.
     * // In this case, all markers with names starting with 'comment:' will be converted.
     * // The `group` parameter will be set to `comment`.
     * // The `name` parameter will be the rest of the marker name (without the `:`).
     * editor.conversion.for( 'dataDowncast' ).markerToData( {
     * 	model: 'comment'
     * } );
     * ```
     *
     * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked
     * by `[]`):
     *
     * ```
     * // Model:
     * <paragraph>Foo[bar</paragraph>
     * <imageBlock src="abc.jpg"></imageBlock>]
     *
     * // View:
     * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
     * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
     * ```
     *
     * In the example above, the comment starts before "bar" and ends after the image.
     *
     * If the `name` part is empty, the following view may be generated:
     *
     * ```html
     * <p>Foo <myMarker-start></myMarker-start>bar</p>
     * <figure data-myMarker-end-after="" class="image"><img src="abc.jpg" /></figure>
     * ```
     *
     * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.
     *
     * Examples where `data-group-start-after` and `data-group-end-before` are used:
     *
     * ```
     * // Model:
     * <blockQuote>[]<paragraph>Foo</paragraph></blockQuote>
     *
     * // View:
     * <blockquote><p data-group-end-before="name" data-group-start-before="name">Foo</p></blockquote>
     * ```
     *
     * Similarly, when a marker is collapsed after the last element:
     *
     * ```
     * // Model:
     * <blockQuote><paragraph>Foo</paragraph>[]</blockQuote>
     *
     * // View:
     * <blockquote><p data-group-end-after="name" data-group-start-after="name">Foo</p></blockquote>
     * ```
     *
     * When there are multiple markers from the same group stored in the same attribute of the same element, their
     * name parts are put together in the attribute value, for example: `data-group-start-before="name1,name2,name3"`.
     *
     * Other examples of usage:
     *
     * ```ts
     * // Using a custom function which is the same as the default conversion:
     * editor.conversion.for( 'dataDowncast' ).markerToData( {
     * 	model: 'comment',
     * 	view: markerName => ( {
     * 		group: 'comment',
     * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
     * 	} )
     * } );
     *
     * // Using the converter priority:
     * editor.conversion.for( 'dataDowncast' ).markerToData( {
     * 	model: 'comment',
     * 	view: markerName => ( {
     * 		group: 'comment',
     * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
     * 	} ),
     * 	converterPriority: 'high'
     * } );
     * ```
     *
     * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.
     *
     * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to
     * add a converter to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.model The name of the model marker (or the model marker group) to convert.
     * @param config.view A function that takes the model marker name and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters
     * and returns an object with the `group` and `name` properties.
     * @param config.converterPriority Converter priority.
     */
    markerToData(e) {
      return this.add(_T(e));
    }
  }
  function Pm() {
    return (n, e, t) => {
      if (!t.consumable.consume(e.item, n.name))
        return;
      const i = t.writer, s = t.mapper.toViewPosition(e.range.start), o = i.createText(e.item.data);
      i.insert(s, o);
    };
  }
  function Rm() {
    return (n, e, t) => {
      t.convertAttributes(e.item), !e.reconversion && e.item.is("element") && !e.item.isEmpty && t.convertChildren(e.item);
    };
  }
  function Xk() {
    return (n, e, t) => {
      const i = t.mapper.toViewPosition(e.position), s = e.position.getShiftedBy(e.length), o = t.mapper.toViewPosition(s, { isPhantom: !0 }), r = t.writer.createRange(i, o), a = t.writer.remove(r.getTrimmed());
      for (const l of t.writer.createRangeIn(a).getItems())
        t.mapper.unbindViewElement(l, { defer: !0 });
    };
  }
  function Lm(n, e) {
    const t = n.createAttributeElement("span", e.attributes);
    return e.classes && t._addClass(e.classes), typeof e.priority == "number" && (t._priority = e.priority), t._id = e.id, t;
  }
  function Yk() {
    return (n, e, t) => {
      const i = e.selection;
      if (i.isCollapsed || !t.consumable.consume(i, "selection"))
        return;
      const s = [];
      for (const o of i.getRanges())
        s.push(t.mapper.toViewRange(o));
      t.writer.setSelection(s, { backward: i.isBackward });
    };
  }
  function Qk() {
    return (n, e, t) => {
      const i = e.selection;
      if (!i.isCollapsed || !t.consumable.consume(i, "selection"))
        return;
      const s = t.writer, o = i.getFirstPosition(), r = t.mapper.toViewPosition(o), a = s.breakAttributes(r);
      s.setSelection(a);
    };
  }
  function eT() {
    return (n, e, t) => {
      const i = t.writer, s = i.document.selection;
      for (const o of s.getRanges())
        o.isCollapsed && o.end.parent.isAttached() && t.writer.mergeAttributes(o.start);
      i.setSelection(null);
    };
  }
  function tT(n) {
    return (e, t, i) => {
      if (!i.consumable.test(t.item, e.name))
        return;
      const s = n(t.attributeOldValue, i, t), o = n(t.attributeNewValue, i, t);
      if (!s && !o)
        return;
      i.consumable.consume(t.item, e.name);
      const r = i.writer, a = r.document.selection;
      if (t.item instanceof De || t.item instanceof lt)
        r.wrap(a.getFirstRange(), o);
      else {
        let l = i.mapper.toViewRange(t.range);
        t.attributeOldValue !== null && s && (l = r.unwrap(l, s)), t.attributeNewValue !== null && o && r.wrap(l, o);
      }
    };
  }
  function iT(n, e = xT) {
    return (t, i, s) => {
      if (!e(i.item, s.consumable, { preflight: !0 }))
        return;
      const o = n(i.item, s, i);
      if (!o)
        return;
      e(i.item, s.consumable);
      const r = s.mapper.toViewPosition(i.range.start);
      s.mapper.bindElements(i.item, o), s.writer.insert(r, o), s.convertAttributes(i.item), Nm(o, i.item.getChildren(), s, { reconversion: i.reconversion });
    };
  }
  function nT(n, e) {
    return (t, i, s) => {
      if (!e(i.item, s.consumable, { preflight: !0 }))
        return;
      const o = /* @__PURE__ */ new Map();
      s.writer._registerSlotFactory(kT(i.item, o, s));
      const r = n(i.item, s, i);
      if (s.writer._clearSlotFactory(), !r)
        return;
      TT(i.item, o, s), e(i.item, s.consumable);
      const a = s.mapper.toViewPosition(i.range.start);
      s.mapper.bindElements(i.item, r), s.writer.insert(a, r), s.convertAttributes(i.item), ET(r, o, s, { reconversion: i.reconversion });
    };
  }
  function sT(n) {
    return (e, t, i) => {
      t.isOpening = !0;
      const s = n(t, i);
      t.isOpening = !1;
      const o = n(t, i);
      if (!s || !o)
        return;
      const r = t.markerRange;
      if (r.isCollapsed && !i.consumable.consume(r, e.name))
        return;
      for (const c of r)
        if (!i.consumable.consume(c.item, e.name))
          return;
      const a = i.mapper, l = i.writer;
      l.insert(a.toViewPosition(r.start), s), i.mapper.bindElementToMarker(s, t.markerName), r.isCollapsed || (l.insert(a.toViewPosition(r.end), o), i.mapper.bindElementToMarker(o, t.markerName)), e.stop();
    };
  }
  function oT() {
    return (n, e, t) => {
      const i = t.mapper.markerNameToElements(e.markerName);
      if (i) {
        for (const s of i)
          t.mapper.unbindElementFromMarkerName(s, e.markerName), t.writer.clear(t.writer.createRangeOn(s), s);
        t.writer.clearClonedElementsGroup(e.markerName), n.stop();
      }
    };
  }
  function rT(n) {
    return (e, t, i) => {
      const s = n(t.markerName, i);
      if (!s)
        return;
      const o = t.markerRange;
      i.consumable.consume(o, e.name) && (fu(o, !1, i, t, s), fu(o, !0, i, t, s), e.stop());
    };
  }
  function fu(n, e, t, i, s) {
    const o = e ? n.start : n.end, r = o.nodeAfter && o.nodeAfter.is("element") ? o.nodeAfter : null, a = o.nodeBefore && o.nodeBefore.is("element") ? o.nodeBefore : null;
    if (r || a) {
      let c, u;
      e && r || !e && !a ? (c = r, u = !0) : (c = a, u = !1);
      const d = t.mapper.toViewElement(c);
      if (d) {
        aT(d, e, u, t, i, s);
        return;
      }
    }
    const l = t.mapper.toViewPosition(o);
    lT(l, e, t, i, s);
  }
  function aT(n, e, t, i, s, o) {
    const r = `data-${o.group}-${e ? "start" : "end"}-${t ? "before" : "after"}`, a = n.hasAttribute(r) ? n.getAttribute(r).split(",") : [];
    a.unshift(o.name), i.writer.setAttribute(r, a.join(","), n), i.mapper.bindElementToMarker(n, s.markerName);
  }
  function lT(n, e, t, i, s) {
    const o = `${s.group}-${e ? "start" : "end"}`, r = s.name ? { name: s.name } : null, a = t.writer.createUIElement(o, r);
    t.writer.insert(n, a), t.mapper.bindElementToMarker(a, i.markerName);
  }
  function cT(n) {
    return (e, t, i) => {
      const s = n(t.markerName, i);
      if (!s)
        return;
      const o = i.mapper.markerNameToElements(t.markerName);
      if (!o)
        return;
      for (const a of o)
        i.mapper.unbindElementFromMarkerName(a, t.markerName), a.is("containerElement") ? (r(`data-${s.group}-start-before`, a), r(`data-${s.group}-start-after`, a), r(`data-${s.group}-end-before`, a), r(`data-${s.group}-end-after`, a)) : i.writer.clear(i.writer.createRangeOn(a), a);
      i.writer.clearClonedElementsGroup(t.markerName), e.stop();
      function r(a, l) {
        if (l.hasAttribute(a)) {
          const c = new Set(l.getAttribute(a).split(","));
          c.delete(s.name), c.size == 0 ? i.writer.removeAttribute(a, l) : i.writer.setAttribute(a, Array.from(c).join(","), l);
        }
      }
    };
  }
  function uT(n) {
    return (e, t, i) => {
      if (!i.consumable.test(t.item, e.name))
        return;
      const s = n(t.attributeOldValue, i, t), o = n(t.attributeNewValue, i, t);
      if (!s && !o)
        return;
      i.consumable.consume(t.item, e.name);
      const r = i.mapper.toViewElement(t.item), a = i.writer;
      if (!r)
        throw new g("conversion-attribute-to-attribute-on-text", i.dispatcher, t);
      if (t.attributeOldValue !== null && s)
        if (s.key == "class") {
          const l = typeof s.value == "string" ? s.value.split(/\s+/) : s.value;
          for (const c of l)
            a.removeClass(c, r);
        } else if (s.key == "style")
          if (typeof s.value == "string") {
            const l = new ca(a.document.stylesProcessor);
            l.setTo(s.value);
            for (const [c] of l.getStylesEntries())
              a.removeStyle(c, r);
          } else {
            const l = Object.keys(s.value);
            for (const c of l)
              a.removeStyle(c, r);
          }
        else
          a.removeAttribute(s.key, r);
      if (t.attributeNewValue !== null && o)
        if (o.key == "class") {
          const l = typeof o.value == "string" ? o.value.split(/\s+/) : o.value;
          for (const c of l)
            a.addClass(c, r);
        } else if (o.key == "style")
          if (typeof o.value == "string") {
            const l = new ca(a.document.stylesProcessor);
            l.setTo(o.value);
            for (const [c, u] of l.getStylesEntries())
              a.setStyle(c, u, r);
          } else {
            const l = Object.keys(o.value);
            for (const c of l)
              a.setStyle(c, o.value[c], r);
          }
        else
          a.setAttribute(o.key, o.value, r);
    };
  }
  function dT(n) {
    return (e, t, i) => {
      if (!t.item || !(t.item instanceof De || t.item instanceof lt) && !t.item.is("$textProxy"))
        return;
      const s = vl(n, t, i);
      if (!s || !i.consumable.consume(t.item, e.name))
        return;
      const o = i.writer, r = Lm(o, s), a = o.document.selection;
      if (t.item instanceof De || t.item instanceof lt)
        o.wrap(a.getFirstRange(), r);
      else {
        const l = i.mapper.toViewRange(t.range), c = o.wrap(l, r);
        for (const u of c.getItems())
          if (u.is("attributeElement") && u.isSimilar(r)) {
            i.mapper.bindElementToMarker(u, t.markerName);
            break;
          }
      }
    };
  }
  function hT(n) {
    return (e, t, i) => {
      if (!t.item || !(t.item instanceof W))
        return;
      const s = vl(n, t, i);
      if (!s || !i.consumable.test(t.item, e.name))
        return;
      const o = i.mapper.toViewElement(t.item);
      if (o && o.getCustomProperty("addHighlight")) {
        i.consumable.consume(t.item, e.name);
        for (const a of _._createIn(t.item))
          i.consumable.consume(a.item, e.name);
        o.getCustomProperty("addHighlight")(o, s, i.writer), i.mapper.bindElementToMarker(o, t.markerName);
      }
    };
  }
  function fT(n) {
    return (e, t, i) => {
      if (t.markerRange.isCollapsed)
        return;
      const s = vl(n, t, i);
      if (!s)
        return;
      const o = Lm(i.writer, s), r = i.mapper.markerNameToElements(t.markerName);
      if (r) {
        for (const a of r)
          i.mapper.unbindElementFromMarkerName(a, t.markerName), a.is("attributeElement") ? i.writer.unwrap(i.writer.createRangeOn(a), o) : a.getCustomProperty("removeHighlight")(a, s.id, i.writer);
        i.writer.clearClonedElementsGroup(t.markerName), e.stop();
      }
    };
  }
  function mT(n) {
    const e = Vm(n.model), t = Qn(n.view, "container");
    return e.attributes.length && (e.children = !0), (i) => {
      i.on(`insert:${e.name}`, iT(t, Om(e)), { priority: n.converterPriority || "normal" }), (e.children || e.attributes.length) && i.on("reduceChanges", Bm(e), { priority: "low" });
    };
  }
  function gT(n) {
    const e = Vm(n.model), t = Qn(n.view, "container");
    return e.children = !0, (i) => {
      if (i._conversionApi.schema.checkChild(e.name, "$text"))
        throw new g("conversion-element-to-structure-disallowed-text", i, { elementName: e.name });
      i.on(`insert:${e.name}`, nT(t, Om(e)), { priority: n.converterPriority || "normal" }), i.on("reduceChanges", Bm(e), { priority: "low" });
    };
  }
  function pT(n) {
    n = ut(n);
    let e = n.model;
    typeof e == "string" && (e = { key: e });
    let t = `attribute:${e.key}`;
    if (e.name && (t += ":" + e.name), e.values)
      for (const s of e.values)
        n.view[s] = Qn(n.view[s], "attribute");
    else
      n.view = Qn(n.view, "attribute");
    const i = Mm(n);
    return (s) => {
      s.on(t, tT(i), { priority: n.converterPriority || "normal" });
    };
  }
  function wT(n) {
    n = ut(n);
    let e = n.model;
    typeof e == "string" && (e = { key: e });
    let t = `attribute:${e.key}`;
    if (e.name && (t += ":" + e.name), e.values)
      for (const s of e.values)
        n.view[s] = mu(n.view[s]);
    else
      n.view = mu(n.view);
    const i = Mm(n);
    return (s) => {
      s.on(t, uT(i), { priority: n.converterPriority || "normal" });
    };
  }
  function bT(n) {
    const e = Qn(n.view, "ui");
    return (t) => {
      t.on(`addMarker:${n.model}`, sT(e), { priority: n.converterPriority || "normal" }), t.on(`removeMarker:${n.model}`, oT(), { priority: n.converterPriority || "normal" });
    };
  }
  function _T(n) {
    n = ut(n);
    const e = n.model;
    let t = n.view;
    return t || (t = (i) => ({
      group: e,
      name: i.substr(n.model.length + 1)
    })), (i) => {
      i.on(`addMarker:${e}`, rT(t), { priority: n.converterPriority || "normal" }), i.on(`removeMarker:${e}`, cT(t), { priority: n.converterPriority || "normal" });
    };
  }
  function vT(n) {
    return (e) => {
      e.on(`addMarker:${n.model}`, dT(n.view), { priority: n.converterPriority || "normal" }), e.on(`addMarker:${n.model}`, hT(n.view), { priority: n.converterPriority || "normal" }), e.on(`removeMarker:${n.model}`, fT(n.view), { priority: n.converterPriority || "normal" });
    };
  }
  function Vm(n) {
    return typeof n == "string" && (n = { name: n }), {
      name: n.name,
      attributes: n.attributes ? Z(n.attributes) : [],
      children: !!n.children
    };
  }
  function Qn(n, e) {
    return typeof n == "function" ? n : (t, i) => yT(n, i, e);
  }
  function yT(n, e, t) {
    typeof n == "string" && (n = { name: n });
    let i;
    const s = e.writer, o = Object.assign({}, n.attributes);
    if (t == "container")
      i = s.createContainerElement(n.name, o);
    else if (t == "attribute") {
      const r = {
        priority: n.priority || oi.DEFAULT_PRIORITY
      };
      i = s.createAttributeElement(n.name, o, r);
    } else
      i = s.createUIElement(n.name, o);
    if (n.styles) {
      const r = Object.keys(n.styles);
      for (const a of r)
        s.setStyle(a, n.styles[a], i);
    }
    if (n.classes) {
      const r = n.classes;
      if (typeof r == "string")
        s.addClass(r, i);
      else
        for (const a of r)
          s.addClass(a, i);
    }
    return i;
  }
  function Mm(n) {
    return n.model.values ? (e, t, i) => {
      const s = n.view[e];
      return s ? s(e, t, i) : null;
    } : n.view;
  }
  function mu(n) {
    return typeof n == "string" ? (e) => ({ key: n, value: e }) : typeof n == "object" ? n.value ? () => n : (e) => ({ key: n.key, value: e }) : n;
  }
  function vl(n, e, t) {
    const i = typeof n == "function" ? n(e, t) : n;
    return i ? (i.priority || (i.priority = 10), i.id || (i.id = e.markerName), i) : null;
  }
  function CT(n) {
    return (e, t) => {
      if (!e.is("element", n.name))
        return !1;
      if (t.type == "attribute") {
        if (n.attributes.includes(t.attributeKey))
          return !0;
      } else {
        /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve */
        if (n.children)
          return !0;
      }
      return !1;
    };
  }
  function Bm(n) {
    const e = CT(n);
    return (t, i) => {
      const s = [];
      i.reconvertedElements || (i.reconvertedElements = /* @__PURE__ */ new Set());
      for (const o of i.changes) {
        const r = o.type == "attribute" ? o.range.start.nodeAfter : o.position.parent;
        if (!r || !e(r, o)) {
          s.push(o);
          continue;
        }
        if (!i.reconvertedElements.has(r)) {
          i.reconvertedElements.add(r);
          const a = C._createBefore(r);
          let l = s.length;
          for (let c = s.length - 1; c >= 0; c--) {
            const u = s[c], h = (u.type == "attribute" ? u.range.start : u.position).compareWith(a);
            if (h == "before" || u.type == "remove" && h == "same")
              break;
            l = c;
          }
          s.splice(l, 0, {
            type: "remove",
            name: r.name,
            position: a,
            length: 1
          }, {
            type: "reinsert",
            name: r.name,
            position: a,
            length: 1
          });
        }
      }
      i.changes = s;
    };
  }
  function Om(n) {
    return (e, t, i = {}) => {
      const s = ["insert"];
      for (const o of n.attributes)
        e.hasAttribute(o) && s.push(`attribute:${o}`);
      return s.every((o) => t.test(e, o)) ? (i.preflight || s.forEach((o) => t.consume(e, o)), !0) : !1;
    };
  }
  function kT(n, e, t) {
    return (i, s) => {
      const o = i.createContainerElement("$slot");
      let r = null;
      if (s === "children")
        r = Array.from(n.getChildren());
      else if (typeof s == "function")
        r = Array.from(n.getChildren()).filter((a) => s(a));
      else
        throw new g("conversion-slot-mode-unknown", t.dispatcher, { modeOrFilter: s });
      return e.set(o, r), o;
    };
  }
  function TT(n, e, t) {
    const i = Array.from(e.values()).flat(), s = new Set(i);
    if (s.size != i.length)
      throw new g("conversion-slot-filter-overlap", t.dispatcher, { element: n });
    if (s.size != n.childCount)
      throw new g("conversion-slot-filter-incomplete", t.dispatcher, { element: n });
  }
  function ET(n, e, t, i) {
    t.mapper.on("modelToViewPosition", r, { priority: "highest" });
    let s = null, o = null;
    for ([s, o] of e)
      Nm(n, o, t, i), t.writer.move(t.writer.createRangeIn(s), t.writer.createPositionBefore(s)), t.writer.remove(s);
    t.mapper.off("modelToViewPosition", r);
    function r(a, l) {
      const c = l.modelPosition.nodeAfter, u = o.indexOf(c);
      u < 0 || (l.viewPosition = l.mapper.findPositionIn(s, u));
    }
  }
  function Nm(n, e, t, i) {
    for (const s of e)
      AT(n.root, s, t, i) || t.convertItem(s);
  }
  function AT(n, e, t, i) {
    const { writer: s, mapper: o } = t;
    if (!i.reconversion)
      return !1;
    const r = o.toViewElement(e);
    return !r || r.root == n || !t.canReuseView(r) ? !1 : (s.move(s.createRangeOn(r), o.toViewPosition(C._createBefore(e))), !0);
  }
  function xT(n, e, { preflight: t } = {}) {
    return t ? e.test(n, "insert") : e.consume(n, "insert");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Dm(n) {
    const { schema: e, document: t } = n.model;
    for (const i of t.getRoots())
      if (i.isEmpty && !e.checkChild(i, "$text") && e.checkChild(i, "paragraph"))
        return n.insertElement("paragraph", i), !0;
    return !1;
  }
  function Fm(n, e, t) {
    const i = t.createContext(n);
    return !(!t.checkChild(i, "paragraph") || !t.checkChild(i.push("paragraph"), e));
  }
  function zm(n, e) {
    const t = e.createElement("paragraph");
    return e.insert(t, n), e.createPositionAt(t, 0);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ST extends Im {
    /**
     * View element to model element conversion helper.
     *
     * This conversion results in creating a model element. For example,
     * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.
     *
     * Keep in mind that the element will be inserted only if it is allowed
     * by {@link module:engine/model/schema~Schema schema} configuration.
     *
     * ```ts
     * editor.conversion.for( 'upcast' ).elementToElement( {
     * 	view: 'p',
     * 	model: 'paragraph'
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToElement( {
     * 	view: 'p',
     * 	model: 'paragraph',
     * 	converterPriority: 'high'
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToElement( {
     * 	view: {
     * 		name: 'p',
     * 		classes: 'fancy'
     * 	},
     * 	model: 'fancyParagraph'
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToElement( {
     * 	view: {
     * 		name: 'p',
     * 		classes: 'heading'
     * 	},
     * 	model: ( viewElement, conversionApi ) => {
     * 		const modelWriter = conversionApi.writer;
     *
     * 		return modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );
     * 	}
     * } );
     * ```
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.view Pattern matching all view elements which should be converted. If not set, the converter
     * will fire for every view element.
     * @param config.model Name of the model element, a model element instance or a function that takes a view element
     * and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}
     * and returns a model element. The model element will be inserted in the model.
     * @param config.converterPriority Converter priority.
     */
    elementToElement(e) {
      return this.add(Um(e));
    }
    /**
     * View element to model attribute conversion helper.
     *
     * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes
     * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.
     *
     * This helper is meant to set a model attribute on all the elements that are inside the converted element:
     *
     * ```
     * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
     * ```
     *
     * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
     * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text. See
     * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.
     *
     * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
     *
     * ```ts
     * editor.conversion.for( 'upcast' ).elementToAttribute( {
     * 	view: 'strong',
     * 	model: 'bold'
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToAttribute( {
     * 	view: 'strong',
     * 	model: 'bold',
     * 	converterPriority: 'high'
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToAttribute( {
     * 	view: {
     * 		name: 'span',
     * 		classes: 'bold'
     * 	},
     * 	model: 'bold'
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToAttribute( {
     * 	view: {
     * 		name: 'span',
     * 		classes: [ 'styled', 'styled-dark' ]
     * 	},
     * 	model: {
     * 		key: 'styled',
     * 		value: 'dark'
     * 	}
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToAttribute( {
     * 	view: {
     * 		name: 'span',
     * 		styles: {
     * 			'font-size': /[\s\S]+/
     * 		}
     * 	},
     * 	model: {
     * 		key: 'fontSize',
     * 		value: ( viewElement, conversionApi ) => {
     * 			const fontSize = viewElement.getStyle( 'font-size' );
     * 			const value = fontSize.substr( 0, fontSize.length - 2 );
     *
     * 			if ( value <= 10 ) {
     * 				return 'small';
     * 			} else if ( value > 12 ) {
     * 				return 'big';
     * 			}
     *
     * 			return null;
     * 		}
     * 	}
     * } );
     * ```
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.view Pattern matching all view elements which should be converted.
     * @param config.model Model attribute key or an object with `key` and `value` properties, describing
     * the model attribute. `value` property may be set as a function that takes a view element and
     * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
     * If `String` is given, the model attribute value will be set to `true`.
     * @param config.converterPriority Converter priority. Defaults to `low`.
     */
    elementToAttribute(e) {
      return this.add(RT(e));
    }
    /**
     * View attribute to model attribute conversion helper.
     *
     * This conversion results in setting an attribute on a model node. For example, view `<img src="foo.jpg"></img>` becomes
     * `<imageBlock source="foo.jpg"></imageBlock>` in the model.
     *
     * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute
     * is set only on the corresponding model node:
     *
     * ```
     * <div class="dark"><div>foo</div></div>    -->    <div dark="true"><div>foo</div></div>
     * ```
     *
     * Above, `class="dark"` attribute is added only to the `<div>` elements that has it. This is in contrast to
     * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for
     * all the children in the model:
     *
     * ```
     * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
     * ```
     *
     * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
     * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text.
     *
     * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
     *
     * ```ts
     * editor.conversion.for( 'upcast' ).attributeToAttribute( {
     * 	view: 'src',
     * 	model: 'source'
     * } );
     *
     * editor.conversion.for( 'upcast' ).attributeToAttribute( {
     * 	view: { key: 'src' },
     * 	model: 'source'
     * } );
     *
     * editor.conversion.for( 'upcast' ).attributeToAttribute( {
     * 	view: { key: 'src' },
     * 	model: 'source',
     * 	converterPriority: 'normal'
     * } );
     *
     * editor.conversion.for( 'upcast' ).attributeToAttribute( {
     * 	view: {
     * 		key: 'data-style',
     * 		value: /[\s\S]+/
     * 	},
     * 	model: 'styled'
     * } );
     *
     * editor.conversion.for( 'upcast' ).attributeToAttribute( {
     * 	view: {
     * 		name: 'img',
     * 		key: 'class',
     * 		value: 'styled-dark'
     * 	},
     * 	model: {
     * 		key: 'styled',
     * 		value: 'dark'
     * 	}
     * } );
     *
     * editor.conversion.for( 'upcast' ).attributeToAttribute( {
     * 	view: {
     * 		key: 'class',
     * 		value: /styled-[\S]+/
     * 	},
     * 	model: {
     * 		key: 'styled'
     * 		value: ( viewElement, conversionApi ) => {
     * 			const regexp = /styled-([\S]+)/;
     * 			const match = viewElement.getAttribute( 'class' ).match( regexp );
     *
     * 			return match[ 1 ];
     * 		}
     * 	}
     * } );
     * ```
     *
     * Converting styles works a bit differently as it requires `view.styles` to be an object and by default
     * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`
     * callback that returns the desired value.
     *
     * ```ts
     * // Default conversion of font-weight style will result in setting bold attribute to true.
     * editor.conversion.for( 'upcast' ).attributeToAttribute( {
     * 	view: {
     * 		styles: {
     * 			'font-weight': 'bold'
     * 		}
     * 	},
     * 	model: 'bold'
     * } );
     *
     * // This converter will pass any style value to the `lineHeight` model attribute.
     * editor.conversion.for( 'upcast' ).attributeToAttribute( {
     * 	view: {
     * 		styles: {
     * 			'line-height': /[\s\S]+/
     * 		}
     * 	},
     * 	model: {
     * 		key: 'lineHeight',
     * 		value: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )
     * 	}
     * } );
     * ```
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.view Specifies which view attribute will be converted. If a `String` is passed,
     * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
     * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
     * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
     * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
     * @param config.model Model attribute key or an object with `key` and `value` properties, describing
     * the model attribute. `value` property may be set as a function that takes a view element and
     * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
     * If `String` is given, the model attribute value will be same as view attribute value.
     * @param config.converterPriority Converter priority. Defaults to `low`.
     */
    attributeToAttribute(e) {
      return this.add(LT(e));
    }
    /**
     * View element to model marker conversion helper.
     *
     * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:
     * `<p>Fo<span data-marker="comment" data-comment-id="7"></span>o</p><p>B<span data-marker="comment" data-comment-id="7"></span>ar</p>`,
     * after the conversion is done, the marker will be available in
     * {@link module:engine/model/model~Model#markers model document markers}.
     *
     * **Note**: When this helper is used in the data upcast in combination with
     * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,
     * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.
     *
     * In most of the cases, the {@link #dataToMarker} should be used instead.
     *
     * ```ts
     * editor.conversion.for( 'upcast' ).elementToMarker( {
     * 	view: 'marker-search',
     * 	model: 'search'
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToMarker( {
     * 	view: 'marker-search',
     * 	model: 'search',
     * 	converterPriority: 'high'
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToMarker( {
     * 	view: 'marker-search',
     * 	model: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )
     * } );
     *
     * editor.conversion.for( 'upcast' ).elementToMarker( {
     * 	view: {
     * 		name: 'span',
     * 		attributes: {
     * 			'data-marker': 'search'
     * 		}
     * 	},
     * 	model: 'search'
     * } );
     * ```
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.view Pattern matching all view elements which should be converted.
     * @param config.model Name of the model marker, or a function that takes a view element and returns
     * a model marker name.
     * @param config.converterPriority Converter priority.
     */
    elementToMarker(e) {
      return this.add(VT(e));
    }
    /**
     * View-to-model marker conversion helper.
     *
     * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}
     * back to a model marker.
     *
     * This converter looks for specific view elements and view attributes that mark marker boundaries. See
     * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data
     * is expected by this converter.
     *
     * The `config.view` property is equal to the marker group name to convert.
     *
     * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).
     *
     * The conversion configuration can take a function that will generate a marker name.
     * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is
     * expected to return a string with the marker name.
     *
     * Basic usage:
     *
     * ```ts
     * // Using the default conversion.
     * // In this case, all markers from the `comment` group will be converted.
     * // The conversion will look for `<comment-start>` and `<comment-end>` tags and
     * // `data-comment-start-before`, `data-comment-start-after`,
     * // `data-comment-end-before` and `data-comment-end-after` attributes.
     * editor.conversion.for( 'upcast' ).dataToMarker( {
     * 	view: 'comment'
     * } );
     * ```
     *
     * An example of a model that may be generated by this conversion:
     *
     * ```
     * // View:
     * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
     * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
     *
     * // Model:
     * <paragraph>Foo[bar</paragraph>
     * <imageBlock src="abc.jpg"></imageBlock>]
     * ```
     *
     * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.
     *
     * Other examples of usage:
     *
     * ```ts
     * // Using a custom function which is the same as the default conversion:
     * editor.conversion.for( 'upcast' ).dataToMarker( {
     * 	view: 'comment',
     * 	model: ( name, conversionApi ) => 'comment:' + name,
     * } );
     *
     * // Using the converter priority:
     * editor.conversion.for( 'upcast' ).dataToMarker( {
     * 	view: 'comment',
     * 	model: ( name, conversionApi ) => 'comment:' + name,
     * 	converterPriority: 'high'
     * } );
     * ```
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @param config Conversion configuration.
     * @param config.view The marker group name to convert.
     * @param config.model A function that takes the `name` part from the view element or attribute and
     * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.
     * @param config.converterPriority Converter priority.
     */
    dataToMarker(e) {
      return this.add(MT(e));
    }
  }
  function gu() {
    return (n, e, t) => {
      if (!e.modelRange && t.consumable.consume(e.viewItem, { name: !0 })) {
        const { modelRange: i, modelCursor: s } = t.convertChildren(e.viewItem, e.modelCursor);
        e.modelRange = i, e.modelCursor = s;
      }
    };
  }
  function IT() {
    return (n, e, { schema: t, consumable: i, writer: s }) => {
      let o = e.modelCursor;
      if (!i.test(e.viewItem))
        return;
      if (!t.checkChild(o, "$text")) {
        if (!Fm(o, "$text", t) || e.viewItem.data.trim().length == 0)
          return;
        const a = o.nodeBefore;
        o = zm(o, s), a && a.is("element", "$marker") && (s.move(s.createRangeOn(a), o), o = s.createPositionAfter(a));
      }
      i.consume(e.viewItem);
      const r = s.createText(e.viewItem.data);
      s.insert(r, o), e.modelRange = s.createRange(o, o.getShiftedBy(r.offsetSize)), e.modelCursor = e.modelRange.end;
    };
  }
  function PT(n, e) {
    return (t, i) => {
      const s = i.newSelection, o = [];
      for (const a of s.getRanges())
        o.push(e.toModelRange(a));
      const r = n.createSelection(o, { backward: s.isBackward });
      r.isEqual(n.document.selection) || n.change((a) => {
        a.setSelection(r);
      });
    };
  }
  function Um(n) {
    n = ut(n);
    const e = ga(n), t = yl(n.view), i = t ? `element:${t}` : "element";
    return (s) => {
      s.on(i, e, { priority: n.converterPriority || "normal" });
    };
  }
  function RT(n) {
    n = ut(n), Hm(n);
    const e = $m(n, !1), t = yl(n.view), i = t ? `element:${t}` : "element";
    return (s) => {
      s.on(i, e, { priority: n.converterPriority || "low" });
    };
  }
  function LT(n) {
    n = ut(n);
    let e = null;
    (typeof n.view == "string" || n.view.key) && (e = NT(n)), Hm(n, e);
    const t = $m(n, !0);
    return (i) => {
      i.on("element", t, { priority: n.converterPriority || "low" });
    };
  }
  function VT(n) {
    const e = zT(n.model);
    return Um({ ...n, model: e });
  }
  function MT(n) {
    n = ut(n), n.model || (n.model = (s) => s ? n.view + ":" + s : n.view);
    const e = {
      view: n.view,
      model: n.model
    }, t = ga(pu(e, "start")), i = ga(pu(e, "end"));
    return (s) => {
      s.on(`element:${n.view}-start`, t, { priority: n.converterPriority || "normal" }), s.on(`element:${n.view}-end`, i, { priority: n.converterPriority || "normal" });
      const o = Ut.low, r = Ut.highest, a = Ut.get(n.converterPriority) / r;
      s.on("element", BT(e), { priority: o + a });
    };
  }
  function BT(n) {
    return (e, t, i) => {
      const s = `data-${n.view}`;
      if (!i.consumable.test(t.viewItem, { attributes: s + "-end-after" }) && !i.consumable.test(t.viewItem, { attributes: s + "-start-after" }) && !i.consumable.test(t.viewItem, { attributes: s + "-end-before" }) && !i.consumable.test(t.viewItem, { attributes: s + "-start-before" }))
        return;
      t.modelRange || Object.assign(t, i.convertChildren(t.viewItem, t.modelCursor)), i.consumable.consume(t.viewItem, { attributes: s + "-end-after" }) && o(t.modelRange.end, t.viewItem.getAttribute(s + "-end-after").split(",")), i.consumable.consume(t.viewItem, { attributes: s + "-start-after" }) && o(t.modelRange.end, t.viewItem.getAttribute(s + "-start-after").split(",")), i.consumable.consume(t.viewItem, { attributes: s + "-end-before" }) && o(t.modelRange.start, t.viewItem.getAttribute(s + "-end-before").split(",")), i.consumable.consume(t.viewItem, { attributes: s + "-start-before" }) && o(t.modelRange.start, t.viewItem.getAttribute(s + "-start-before").split(","));
      function o(r, a) {
        for (const l of a) {
          const c = n.model(l, i), u = i.writer.createElement("$marker", { "data-name": c });
          i.writer.insert(u, r), t.modelCursor.isEqual(r) ? t.modelCursor = t.modelCursor.getShiftedBy(1) : t.modelCursor = t.modelCursor._getTransformedByInsertion(r, 1), t.modelRange = t.modelRange._getTransformedByInsertion(r, 1)[0];
        }
      }
    };
  }
  function yl(n) {
    return typeof n == "string" ? n : typeof n == "object" && typeof n.name == "string" ? n.name : null;
  }
  function ga(n) {
    const e = new rt(n.view);
    return (t, i, s) => {
      const o = e.match(i.viewItem);
      if (!o)
        return;
      const r = o.match;
      if (r.name = !0, !s.consumable.test(i.viewItem, r))
        return;
      const a = OT(n.model, i.viewItem, s);
      a && s.safeInsert(a, i.modelCursor) && (s.consumable.consume(i.viewItem, r), s.convertChildren(i.viewItem, a), s.updateConversionResult(a, i));
    };
  }
  function OT(n, e, t) {
    return n instanceof Function ? n(e, t) : t.writer.createElement(n);
  }
  function NT(n) {
    typeof n.view == "string" && (n.view = { key: n.view });
    const e = n.view.key, t = typeof n.view.value == "undefined" ? /[\s\S]*/ : n.view.value;
    let i;
    return e == "class" || e == "style" ? i = {
      [e == "class" ? "classes" : "styles"]: t
    } : i = {
      attributes: {
        [e]: t
      }
    }, n.view.name && (i.name = n.view.name), n.view = i, e;
  }
  function Hm(n, e = null) {
    const t = e === null ? !0 : (o) => o.getAttribute(e), i = typeof n.model != "object" ? n.model : n.model.key, s = typeof n.model != "object" || typeof n.model.value == "undefined" ? t : n.model.value;
    n.model = { key: i, value: s };
  }
  function $m(n, e) {
    const t = new rt(n.view);
    return (i, s, o) => {
      if (!s.modelRange && e)
        return;
      const r = t.match(s.viewItem);
      if (!r || (DT(n.view, s.viewItem) ? r.match.name = !0 : delete r.match.name, !o.consumable.test(s.viewItem, r.match)))
        return;
      const a = n.model.key, l = typeof n.model.value == "function" ? n.model.value(s.viewItem, o) : n.model.value;
      if (l === null)
        return;
      s.modelRange || Object.assign(s, o.convertChildren(s.viewItem, s.modelCursor)), FT(s.modelRange, { key: a, value: l }, e, o) && (o.consumable.test(s.viewItem, { name: !0 }) && (r.match.name = !0), o.consumable.consume(s.viewItem, r.match));
    };
  }
  function DT(n, e) {
    const t = typeof n == "function" ? n(e) : n;
    return typeof t == "object" && !yl(t) ? !1 : !t.classes && !t.attributes && !t.styles;
  }
  function FT(n, e, t, i) {
    let s = !1;
    for (const o of Array.from(n.getItems({ shallow: t })))
      i.schema.checkAttribute(o, e.key) && (s = !0, !o.hasAttribute(e.key) && i.writer.setAttribute(e.key, e.value, o));
    return s;
  }
  function zT(n) {
    return (e, t) => {
      const i = typeof n == "string" ? n : n(e, t);
      return t.writer.createElement("$marker", { "data-name": i });
    };
  }
  function pu(n, e) {
    const t = (i, s) => {
      const o = i.getAttribute("name"), r = n.model(o, s);
      return s.writer.createElement("$marker", { "data-name": r });
    };
    return {
      // Upcast <markerGroup-start> and <markerGroup-end> elements.
      view: `${n.view}-${e}`,
      model: t
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function UT(n) {
    n.document.registerPostFixer((e) => HT(e, n));
  }
  function HT(n, e) {
    const t = e.document.selection, i = e.schema, s = [];
    let o = !1;
    for (const r of t.getRanges()) {
      const a = Wm(r, i);
      a && !a.isEqual(r) ? (s.push(a), o = !0) : s.push(r);
    }
    return o && n.setSelection(GT(s), { backward: t.isBackward }), !1;
  }
  function Wm(n, e) {
    return n.isCollapsed ? $T(n, e) : WT(n, e);
  }
  function $T(n, e) {
    const t = n.start, i = e.getNearestSelectionRange(t);
    if (!i) {
      const o = t.getAncestors().reverse().find((r) => e.isObject(r));
      return o ? _._createOn(o) : null;
    }
    if (!i.isCollapsed)
      return i;
    const s = i.start;
    return t.isEqual(s) ? null : new _(s);
  }
  function WT(n, e) {
    const { start: t, end: i } = n, s = e.checkChild(t, "$text"), o = e.checkChild(i, "$text"), r = e.getLimitElement(t), a = e.getLimitElement(i);
    if (r === a) {
      if (s && o)
        return null;
      if (qT(t, i, e)) {
        const d = t.nodeAfter && e.isSelectable(t.nodeAfter) ? null : e.getNearestSelectionRange(t, "forward"), f = i.nodeBefore && e.isSelectable(i.nodeBefore) ? null : e.getNearestSelectionRange(i, "backward"), m = d ? d.start : t, p = f ? f.end : i;
        return new _(m, p);
      }
    }
    const l = r && !r.is("rootElement"), c = a && !a.is("rootElement");
    if (l || c) {
      const u = t.nodeAfter && i.nodeBefore && t.nodeAfter.parent === i.nodeBefore.parent, d = l && (!u || !bu(t.nodeAfter, e)), h = c && (!u || !bu(i.nodeBefore, e));
      let f = t, m = i;
      return d && (f = C._createBefore(wu(r, e))), h && (m = C._createAfter(wu(a, e))), new _(f, m);
    }
    return null;
  }
  function wu(n, e) {
    let t = n, i = t;
    for (; e.isLimit(i) && i.parent; )
      t = i, i = i.parent;
    return t;
  }
  function qT(n, e, t) {
    const i = n.nodeAfter && !t.isLimit(n.nodeAfter) || t.checkChild(n, "$text"), s = e.nodeBefore && !t.isLimit(e.nodeBefore) || t.checkChild(e, "$text");
    return i || s;
  }
  function GT(n) {
    const e = [...n], t = /* @__PURE__ */ new Set();
    let i = 1;
    for (; i < e.length; ) {
      const o = e[i], r = e.slice(0, i);
      for (const [a, l] of r.entries())
        if (!t.has(a)) {
          if (o.isEqual(l))
            t.add(a);
          else if (o.isIntersecting(l)) {
            t.add(a), t.add(i);
            const c = o.getJoined(l);
            e.push(c);
          }
        }
      i++;
    }
    return e.filter((o, r) => !t.has(r));
  }
  function bu(n, e) {
    return n && e.isSelectable(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class jT extends $() {
    /**
     * Creates an editing controller instance.
     *
     * @param model Editing model.
     * @param stylesProcessor The styles processor instance.
     */
    constructor(e, t) {
      super(), this.model = e, this.view = new Bk(t), this.mapper = new Am(), this.downcastDispatcher = new xm({
        mapper: this.mapper,
        schema: e.schema
      });
      const i = this.model.document, s = i.selection, o = this.model.markers;
      this.listenTo(this.model, "_beforeChanges", () => {
        this.view._disableRendering(!0);
      }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
        this.view._disableRendering(!1);
      }, { priority: "lowest" }), this.listenTo(i, "change", () => {
        this.view.change((r) => {
          this.downcastDispatcher.convertChanges(i.differ, o, r), this.downcastDispatcher.convertSelection(s, o, r);
        });
      }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", PT(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", KT(this.mapper, this.model.schema, this.view), { priority: "high" }), this.downcastDispatcher.on("insert:$text", Pm(), { priority: "lowest" }), this.downcastDispatcher.on("insert", Rm(), { priority: "lowest" }), this.downcastDispatcher.on("remove", Xk(), { priority: "low" }), this.downcastDispatcher.on("cleanSelection", eT()), this.downcastDispatcher.on("selection", Yk(), { priority: "low" }), this.downcastDispatcher.on("selection", Qk(), { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((r) => {
        if (r.rootName == "$graveyard")
          return null;
        const a = new hm(this.view.document, r.name);
        return a.rootName = r.rootName, this.mapper.bindElements(r, a), a;
      });
    }
    /**
     * Removes all event listeners attached to the `EditingController`. Destroys all objects created
     * by `EditingController` that need to be destroyed.
     */
    destroy() {
      this.view.destroy(), this.stopListening();
    }
    /**
     * Calling this method will refresh the marker by triggering the downcast conversion for it.
     *
     * Reconverting the marker is useful when you want to change its {@link module:engine/view/element~Element view element}
     * without changing any marker data. For instance:
     *
     * ```ts
     * let isCommentActive = false;
     *
     * model.conversion.markerToHighlight( {
     * 	model: 'comment',
     * 	view: data => {
     * 		const classes = [ 'comment-marker' ];
     *
     * 		if ( isCommentActive ) {
     * 			classes.push( 'comment-marker--active' );
     * 		}
     *
     * 		return { classes };
     * 	}
     * } );
     *
     * // ...
     *
     * // Change the property that indicates if marker is displayed as active or not.
     * isCommentActive = true;
     *
     * // Reconverting will downcast and synchronize the marker with the new isCommentActive state value.
     * editor.editing.reconvertMarker( 'comment' );
     * ```
     *
     * **Note**: If you want to reconvert a model item, use {@link #reconvertItem} instead.
     *
     * @param markerOrName Name of a marker to update, or a marker instance.
     */
    reconvertMarker(e) {
      const t = typeof e == "string" ? e : e.name, i = this.model.markers.get(t);
      if (!i)
        throw new g("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: t });
      this.model.change(() => {
        this.model.markers._refresh(i);
      });
    }
    /**
     * Calling this method will downcast a model item on demand (by requesting a refresh in the {@link module:engine/model/differ~Differ}).
     *
     * You can use it if you want the view representation of a specific item updated as a response to external modifications. For instance,
     * when the view structure depends not only on the associated model data but also on some external state.
     *
     * **Note**: If you want to reconvert a model marker, use {@link #reconvertMarker} instead.
     *
     * @param item Item to refresh.
     */
    reconvertItem(e) {
      this.model.change(() => {
        this.model.document.differ._refreshItem(e);
      });
    }
  }
  function KT(n, e, t) {
    return (i, s) => {
      if (!(t.document.isComposing && !B.isAndroid))
        for (let o = 0; o < s.targetRanges.length; o++) {
          const r = s.targetRanges[o], a = n.toModelRange(r), l = Wm(a, e);
          !l || l.isEqual(a) || (s.targetRanges[o] = n.toViewRange(l));
        }
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Dn {
    constructor() {
      this._consumables = /* @__PURE__ */ new Map();
    }
    add(e, t) {
      let i;
      if (e.is("$text") || e.is("documentFragment")) {
        this._consumables.set(e, !0);
        return;
      }
      this._consumables.has(e) ? i = this._consumables.get(e) : (i = new ZT(e), this._consumables.set(e, i)), i.add(t);
    }
    /**
     * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
     * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.
     * It returns `true` when all items included in method's call can be consumed. Returns `false` when
     * first already consumed item is found and `null` when first non-consumable item is found.
     *
     * ```ts
     * viewConsumable.test( p, { name: true } ); // Tests element's name.
     * viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
     * viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
     * viewConsumable.test( p, { styles: 'color' } ); // Tests style.
     * viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
     * viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
     * viewConsumable.test( textNode ); // Tests text node.
     * viewConsumable.test( docFragment ); // Tests document fragment.
     * ```
     *
     * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
     *
     * ```ts
     * viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
     * viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
     * ```
     *
     * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
     * @param consumables.name If set to true element's name will be included.
     * @param consumables.attributes Attribute name or array of attribute names.
     * @param consumables.classes Class name or array of class names.
     * @param consumables.styles Style name or array of style names.
     * @returns Returns `true` when all items included in method's call can be consumed. Returns `false`
     * when first already consumed item is found and `null` when first non-consumable item is found.
     */
    test(e, t) {
      const i = this._consumables.get(e);
      return i === void 0 ? null : e.is("$text") || e.is("documentFragment") ? i : i.test(t);
    }
    /**
     * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
     * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
     * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
     *
     * ```ts
     * viewConsumable.consume( p, { name: true } ); // Consumes element's name.
     * viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
     * viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
     * viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
     * viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
     * viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
     * viewConsumable.consume( textNode ); // Consumes text node.
     * viewConsumable.consume( docFragment ); // Consumes document fragment.
     * ```
     *
     * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
     *
     * ```ts
     * viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
     * viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
     * ```
     *
     * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
     * @param consumables.name If set to true element's name will be included.
     * @param consumables.attributes Attribute name or array of attribute names.
     * @param consumables.classes Class name or array of class names.
     * @param consumables.styles Style name or array of style names.
     * @returns Returns `true` when all items included in method's call can be consumed,
     * otherwise returns `false`.
     */
    consume(e, t) {
      return this.test(e, t) ? (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !1) : this._consumables.get(e).consume(t), !0) : !1;
    }
    /**
     * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
     * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.
     * Method does not revert items that were never previously added for consumption, even if they are included in
     * method's call.
     *
     * ```ts
     * viewConsumable.revert( p, { name: true } ); // Reverts element's name.
     * viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
     * viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
     * viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
     * viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
     * viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
     * viewConsumable.revert( textNode ); // Reverts text node.
     * viewConsumable.revert( docFragment ); // Reverts document fragment.
     * ```
     *
     * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
     * consumption.
     *
     * ```ts
     * viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
     * viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
     * ```
     *
     * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
     * @param consumables.name If set to true element's name will be included.
     * @param consumables.attributes Attribute name or array of attribute names.
     * @param consumables.classes Class name or array of class names.
     * @param consumables.styles Style name or array of style names.
     */
    revert(e, t) {
      const i = this._consumables.get(e);
      i !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : i.revert(t));
    }
    /**
     * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include
     * element's name and all its attributes, classes and styles.
     */
    static consumablesFromElement(e) {
      const t = {
        element: e,
        name: !0,
        attributes: [],
        classes: [],
        styles: []
      }, i = e.getAttributeKeys();
      for (const r of i)
        r == "style" || r == "class" || t.attributes.push(r);
      const s = e.getClassNames();
      for (const r of s)
        t.classes.push(r);
      const o = e.getStyleNames();
      for (const r of o)
        t.styles.push(r);
      return t;
    }
    /**
     * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
     * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
     * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
     *
     * @param from View node or document fragment from which `ViewConsumable` will be created.
     * @param instance If provided, given `ViewConsumable` instance will be used
     * to add all consumables. It will be returned instead of a new instance.
     */
    static createFrom(e, t) {
      if (t || (t = new Dn()), e.is("$text"))
        return t.add(e), t;
      e.is("element") && t.add(e, Dn.consumablesFromElement(e)), e.is("documentFragment") && t.add(e);
      for (const i of e.getChildren())
        t = Dn.createFrom(i, t);
      return t;
    }
  }
  const Vs = ["attributes", "classes", "styles"];
  class ZT {
    /**
     * Creates ViewElementConsumables instance.
     *
     * @param from View node or document fragment from which `ViewElementConsumables` is being created.
     */
    constructor(e) {
      this.element = e, this._canConsumeName = null, this._consumables = {
        attributes: /* @__PURE__ */ new Map(),
        styles: /* @__PURE__ */ new Map(),
        classes: /* @__PURE__ */ new Map()
      };
    }
    /**
     * Adds consumable parts of the {@link module:engine/view/element~Element view element}.
     * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
     * styles still could be consumed):
     *
     * ```ts
     * consumables.add( { name: true } );
     * ```
     *
     * Attributes classes and styles:
     *
     * ```ts
     * consumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );
     * consumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
     * ```
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
     * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
     *
     * @param consumables Object describing which parts of the element can be consumed.
     * @param consumables.name If set to `true` element's name will be added as consumable.
     * @param consumables.attributes Attribute name or array of attribute names to add as consumable.
     * @param consumables.classes Class name or array of class names to add as consumable.
     * @param consumables.styles Style name or array of style names to add as consumable.
     */
    add(e) {
      e.name && (this._canConsumeName = !0);
      for (const t of Vs)
        t in e && this._add(t, e[t]);
    }
    /**
     * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.
     *
     * Element's name can be tested:
     *
     * ```ts
     * consumables.test( { name: true } );
     * ```
     *
     * Attributes classes and styles:
     *
     * ```ts
     * consumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );
     * consumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
     * ```
     *
     * @param consumables Object describing which parts of the element should be tested.
     * @param consumables.name If set to `true` element's name will be tested.
     * @param consumables.attributes Attribute name or array of attribute names to test.
     * @param consumables.classes Class name or array of class names to test.
     * @param consumables.styles Style name or array of style names to test.
     * @returns `true` when all tested items can be consumed, `null` when even one of the items
     * was never marked for consumption and `false` when even one of the items was already consumed.
     */
    test(e) {
      if (e.name && !this._canConsumeName)
        return this._canConsumeName;
      for (const t of Vs)
        if (t in e) {
          const i = this._test(t, e[t]);
          if (i !== !0)
            return i;
        }
      return !0;
    }
    /**
     * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item
     * is already consumed - it consumes all consumable items provided.
     * Element's name can be consumed:
     *
     * ```ts
     * consumables.consume( { name: true } );
     * ```
     *
     * Attributes classes and styles:
     *
     * ```ts
     * consumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );
     * consumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
     * ```
     *
     * @param consumables Object describing which parts of the element should be consumed.
     * @param consumables.name If set to `true` element's name will be consumed.
     * @param consumables.attributes Attribute name or array of attribute names to consume.
     * @param consumables.classes Class name or array of class names to consume.
     * @param consumables.styles Style name or array of style names to consume.
     */
    consume(e) {
      e.name && (this._canConsumeName = !1);
      for (const t of Vs)
        t in e && this._consume(t, e[t]);
    }
    /**
     * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.
     * Element's name can be reverted:
     *
     * ```ts
     * consumables.revert( { name: true } );
     * ```
     *
     * Attributes classes and styles:
     *
     * ```ts
     * consumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );
     * consumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
     * ```
     *
     * @param consumables Object describing which parts of the element should be reverted.
     * @param consumables.name If set to `true` element's name will be reverted.
     * @param consumables.attributes Attribute name or array of attribute names to revert.
     * @param consumables.classes Class name or array of class names to revert.
     * @param consumables.styles Style name or array of style names to revert.
     */
    revert(e) {
      e.name && (this._canConsumeName = !0);
      for (const t of Vs)
        t in e && this._revert(t, e[t]);
    }
    /**
     * Helper method that adds consumables of a given type: attribute, class or style.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
     * type is provided - it should be handled separately by providing actual style/class type.
     *
     * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
     * @param item Consumable item or array of items.
     */
    _add(e, t) {
      const i = Z(t), s = this._consumables[e];
      for (const o of i) {
        if (e === "attributes" && (o === "class" || o === "style"))
          throw new g("viewconsumable-invalid-attribute", this);
        if (s.set(o, !0), e === "styles")
          for (const r of this.element.document.stylesProcessor.getRelatedStyles(o))
            s.set(r, !0);
      }
    }
    /**
     * Helper method that tests consumables of a given type: attribute, class or style.
     *
     * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
     * @param item Consumable item or array of items.
     * @returns Returns `true` if all items can be consumed, `null` when one of the items cannot be
     * consumed and `false` when one of the items is already consumed.
     */
    _test(e, t) {
      const i = Z(t), s = this._consumables[e];
      for (const o of i)
        if (e === "attributes" && (o === "class" || o === "style")) {
          const r = o == "class" ? "classes" : "styles", a = this._test(r, [...this._consumables[r].keys()]);
          if (a !== !0)
            return a;
        } else {
          const r = s.get(o);
          if (r === void 0)
            return null;
          if (!r)
            return !1;
        }
      return !0;
    }
    /**
     * Helper method that consumes items of a given type: attribute, class or style.
     *
     * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
     * @param item Consumable item or array of items.
     */
    _consume(e, t) {
      const i = Z(t), s = this._consumables[e];
      for (const o of i)
        if (e === "attributes" && (o === "class" || o === "style")) {
          const r = o == "class" ? "classes" : "styles";
          this._consume(r, [...this._consumables[r].keys()]);
        } else if (s.set(o, !1), e == "styles")
          for (const r of this.element.document.stylesProcessor.getRelatedStyles(o))
            s.set(r, !1);
    }
    /**
     * Helper method that reverts items of a given type: attribute, class or style.
     *
     * @param type Type of the consumable item: `attributes`, `classes` or , `styles`.
     * @param item Consumable item or array of items.
     */
    _revert(e, t) {
      const i = Z(t), s = this._consumables[e];
      for (const o of i)
        if (e === "attributes" && (o === "class" || o === "style")) {
          const r = o == "class" ? "classes" : "styles";
          this._revert(r, [...this._consumables[r].keys()]);
        } else
          s.get(o) === !1 && s.set(o, !0);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class JT extends $() {
    /**
     * Creates a schema instance.
     */
    constructor() {
      super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e, t) => {
        t[0] = new ai(t[0]);
      }, { priority: "highest" }), this.on("checkChild", (e, t) => {
        t[0] = new ai(t[0]), t[1] = this.getDefinition(t[1]);
      }, { priority: "highest" });
    }
    /**
     * Registers a schema item. Can only be called once for every item name.
     *
     * ```ts
     * schema.register( 'paragraph', {
     * 	inheritAllFrom: '$block'
     * } );
     * ```
     */
    register(e, t) {
      if (this._sourceDefinitions[e])
        throw new g("schema-cannot-register-item-twice", this, {
          itemName: e
        });
      this._sourceDefinitions[e] = [
        Object.assign({}, t)
      ], this._clearCache();
    }
    /**
     * Extends a {@link #register registered} item's definition.
     *
     * Extending properties such as `allowIn` will add more items to the existing properties,
     * while redefining properties such as `isBlock` will override the previously defined ones.
     *
     * ```ts
     * schema.register( 'foo', {
     * 	allowIn: '$root',
     * 	isBlock: true;
     * } );
     * schema.extend( 'foo', {
     * 	allowIn: 'blockQuote',
     * 	isBlock: false
     * } );
     *
     * schema.getDefinition( 'foo' );
     * //	{
     * //		allowIn: [ '$root', 'blockQuote' ],
     * // 		isBlock: false
     * //	}
     * ```
     */
    extend(e, t) {
      if (!this._sourceDefinitions[e])
        throw new g("schema-cannot-extend-missing-item", this, {
          itemName: e
        });
      this._sourceDefinitions[e].push(Object.assign({}, t)), this._clearCache();
    }
    /**
     * Returns data of all registered items.
     *
     * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
     * checking a list of all block elements, etc).
     * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
     * in other cases.
     */
    getDefinitions() {
      return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
    }
    /**
     * Returns a definition of the given item or `undefined` if an item is not registered.
     *
     * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
     * checking a list of all block elements, etc).
     * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
     * in other cases.
     */
    getDefinition(e) {
      let t;
      return typeof e == "string" ? t = e : "is" in e && (e.is("$text") || e.is("$textProxy")) ? t = "$text" : t = e.name, this.getDefinitions()[t];
    }
    /**
     * Returns `true` if the given item is registered in the schema.
     *
     * ```ts
     * schema.isRegistered( 'paragraph' ); // -> true
     * schema.isRegistered( editor.model.document.getRoot() ); // -> true
     * schema.isRegistered( 'foo' ); // -> false
     * ```
     */
    isRegistered(e) {
      return !!this.getDefinition(e);
    }
    /**
     * Returns `true` if the given item is defined to be
     * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.
     *
     * ```ts
     * schema.isBlock( 'paragraph' ); // -> true
     * schema.isBlock( '$root' ); // -> false
     *
     * const paragraphElement = writer.createElement( 'paragraph' );
     * schema.isBlock( paragraphElement ); // -> true
     * ```
     *
     * See the {@glink framework/deep-dive/schema#block-elements Block elements} section of
     * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
     */
    isBlock(e) {
      const t = this.getDefinition(e);
      return !!(t && t.isBlock);
    }
    /**
     * Returns `true` if the given item should be treated as a limit element.
     *
     * It considers an item to be a limit element if its
     * {@link module:engine/model/schema~SchemaItemDefinition}'s
     * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or
     * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
     * was set to `true`.
     *
     * ```ts
     * schema.isLimit( 'paragraph' ); // -> false
     * schema.isLimit( '$root' ); // -> true
     * schema.isLimit( editor.model.document.getRoot() ); // -> true
     * schema.isLimit( 'imageBlock' ); // -> true
     * ```
     *
     * See the {@glink framework/deep-dive/schema#limit-elements Limit elements} section of
     * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
     */
    isLimit(e) {
      const t = this.getDefinition(e);
      return t ? !!(t.isLimit || t.isObject) : !1;
    }
    /**
     * Returns `true` if the given item should be treated as an object element.
     *
     * It considers an item to be an object element if its
     * {@link module:engine/model/schema~SchemaItemDefinition}'s
     * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
     * was set to `true`.
     *
     * ```ts
     * schema.isObject( 'paragraph' ); // -> false
     * schema.isObject( 'imageBlock' ); // -> true
     *
     * const imageElement = writer.createElement( 'imageBlock' );
     * schema.isObject( imageElement ); // -> true
     * ```
     *
     * See the {@glink framework/deep-dive/schema#object-elements Object elements} section of
     * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
     */
    isObject(e) {
      const t = this.getDefinition(e);
      return t ? !!(t.isObject || t.isLimit && t.isSelectable && t.isContent) : !1;
    }
    /**
     * Returns `true` if the given item is defined to be
     * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.
     *
     * ```ts
     * schema.isInline( 'paragraph' ); // -> false
     * schema.isInline( 'softBreak' ); // -> true
     *
     * const text = writer.createText( 'foo' );
     * schema.isInline( text ); // -> true
     * ```
     *
     * See the {@glink framework/deep-dive/schema#inline-elements Inline elements} section of
     * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
     */
    isInline(e) {
      const t = this.getDefinition(e);
      return !!(t && t.isInline);
    }
    /**
     * Returns `true` if the given item is defined to be
     * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.
     *
     * ```ts
     * schema.isSelectable( 'paragraph' ); // -> false
     * schema.isSelectable( 'heading1' ); // -> false
     * schema.isSelectable( 'imageBlock' ); // -> true
     * schema.isSelectable( 'tableCell' ); // -> true
     *
     * const text = writer.createText( 'foo' );
     * schema.isSelectable( text ); // -> false
     * ```
     *
     * See the {@glink framework/deep-dive/schema#selectable-elements Selectable elements section} of
     * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
     */
    isSelectable(e) {
      const t = this.getDefinition(e);
      return t ? !!(t.isSelectable || t.isObject) : !1;
    }
    /**
     * Returns `true` if the given item is defined to be
     * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.
     *
     * ```ts
     * schema.isContent( 'paragraph' ); // -> false
     * schema.isContent( 'heading1' ); // -> false
     * schema.isContent( 'imageBlock' ); // -> true
     * schema.isContent( 'horizontalLine' ); // -> true
     *
     * const text = writer.createText( 'foo' );
     * schema.isContent( text ); // -> true
     * ```
     *
     * See the {@glink framework/deep-dive/schema#content-elements Content elements section} of
     * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
     */
    isContent(e) {
      const t = this.getDefinition(e);
      return t ? !!(t.isContent || t.isObject) : !1;
    }
    /**
     * Checks whether the given node (`child`) can be a child of the given context.
     *
     * ```ts
     * schema.checkChild( model.document.getRoot(), paragraph ); // -> false
     *
     * schema.register( 'paragraph', {
     * 	allowIn: '$root'
     * } );
     * schema.checkChild( model.document.getRoot(), paragraph ); // -> true
     * ```
     *
     * Note: When verifying whether the given node can be a child of the given context, the
     * schema also verifies the entire context &ndash; from its root to its last element. Therefore, it is possible
     * for `checkChild()` to return `false` even though the context's last element can contain the checked child.
     * It happens if one of the context's elements does not allow its child.
     *
     * @fires checkChild
     * @param context The context in which the child will be checked.
     * @param def The child to check.
     */
    checkChild(e, t) {
      return t ? this._checkContextMatch(t, e) : !1;
    }
    /**
     * Checks whether the given attribute can be applied in the given context (on the last
     * item of the context).
     *
     * ```ts
     * schema.checkAttribute( textNode, 'bold' ); // -> false
     *
     * schema.extend( '$text', {
     * 	allowAttributes: 'bold'
     * } );
     * schema.checkAttribute( textNode, 'bold' ); // -> true
     * ```
     *
     * @fires checkAttribute
     * @param context The context in which the attribute will be checked.
     */
    checkAttribute(e, t) {
      const i = this.getDefinition(e.last);
      return i ? i.allowAttributes.includes(t) : !1;
    }
    /**
     * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).
     *
     * In other words &ndash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.
     *
     * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}
     * will be valid.
     *
     * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the
     * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.
     *
     * @param positionOrBaseElement The position or base element to which the `elementToMerge` will be merged.
     * @param elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.
     */
    checkMerge(e, t) {
      if (e instanceof C) {
        const i = e.nodeBefore, s = e.nodeAfter;
        if (!(i instanceof W))
          throw new g("schema-check-merge-no-element-before", this);
        if (!(s instanceof W))
          throw new g("schema-check-merge-no-element-after", this);
        return this.checkMerge(i, s);
      }
      for (const i of t.getChildren())
        if (!this.checkChild(e, i))
          return !1;
      return !0;
    }
    /**
     * Allows registering a callback to the {@link #checkChild} method calls.
     *
     * Callbacks allow you to implement rules which are not otherwise possible to achieve
     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
     * For example, by using this method you can disallow elements in specific contexts.
     *
     * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,
     * you can use that event instead.
     *
     * Example:
     *
     * ```ts
     * // Disallow heading1 directly inside a blockQuote.
     * schema.addChildCheck( ( context, childDefinition ) => {
     * 	if ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {
     * 		return false;
     * 	}
     * } );
     * ```
     *
     * Which translates to:
     *
     * ```ts
     * schema.on( 'checkChild', ( evt, args ) => {
     * 	const context = args[ 0 ];
     * 	const childDefinition = args[ 1 ];
     *
     * 	if ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {
     * 		// Prevent next listeners from being called.
     * 		evt.stop();
     * 		// Set the checkChild()'s return value.
     * 		evt.return = false;
     * 	}
     * }, { priority: 'high' } );
     * ```
     *
     * @param callback The callback to be called. It is called with two parameters:
     * {@link module:engine/model/schema~SchemaContext} (context) instance and
     * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).
     * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return
     * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.
     */
    addChildCheck(e) {
      this.on("checkChild", (t, [i, s]) => {
        if (!s)
          return;
        const o = e(i, s);
        typeof o == "boolean" && (t.stop(), t.return = o);
      }, { priority: "high" });
    }
    /**
     * Allows registering a callback to the {@link #checkAttribute} method calls.
     *
     * Callbacks allow you to implement rules which are not otherwise possible to achieve
     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
     * For example, by using this method you can disallow attribute if node to which it is applied
     * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).
     *
     * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,
     * you can use that event instead.
     *
     * Example:
     *
     * ```ts
     * // Disallow bold on $text inside heading1.
     * schema.addAttributeCheck( ( context, attributeName ) => {
     * 	if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
     * 		return false;
     * 	}
     * } );
     * ```
     *
     * Which translates to:
     *
     * ```ts
     * schema.on( 'checkAttribute', ( evt, args ) => {
     * 	const context = args[ 0 ];
     * 	const attributeName = args[ 1 ];
     *
     * 	if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
     * 		// Prevent next listeners from being called.
     * 		evt.stop();
     * 		// Set the checkAttribute()'s return value.
     * 		evt.return = false;
     * 	}
     * }, { priority: 'high' } );
     * ```
     *
     * @param callback The callback to be called. It is called with two parameters:
     * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.
     * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return
     * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.
     */
    addAttributeCheck(e) {
      this.on("checkAttribute", (t, [i, s]) => {
        const o = e(i, s);
        typeof o == "boolean" && (t.stop(), t.return = o);
      }, { priority: "high" });
    }
    /**
     * This method allows assigning additional metadata to the model attributes. For example,
     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is
     * used to mark formatting attributes (like `bold` or `italic`).
     *
     * ```ts
     * // Mark bold as a formatting attribute.
     * schema.setAttributeProperties( 'bold', {
     * 	isFormatting: true
     * } );
     *
     * // Override code not to be considered a formatting markup.
     * schema.setAttributeProperties( 'code', {
     * 	isFormatting: false
     * } );
     * ```
     *
     * Properties are not limited to members defined in the
     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:
     *
     * ```ts
     * schema.setAttributeProperties( 'blockQuote', {
     * 	customProperty: 'value'
     * } );
     * ```
     *
     * Subsequent calls with the same attribute will extend its custom properties:
     *
     * ```ts
     * schema.setAttributeProperties( 'blockQuote', {
     * 	one: 1
     * } );
     *
     * schema.setAttributeProperties( 'blockQuote', {
     * 	two: 2
     * } );
     *
     * console.log( schema.getAttributeProperties( 'blockQuote' ) );
     * // Logs: { one: 1, two: 2 }
     * ```
     *
     * @param attributeName A name of the attribute to receive the properties.
     * @param properties A dictionary of properties.
     */
    setAttributeProperties(e, t) {
      this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t);
    }
    /**
     * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.
     *
     * @param attributeName A name of the attribute.
     */
    getAttributeProperties(e) {
      return this._attributeProperties[e] || {};
    }
    /**
     * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire
     * selection/range/position or the root otherwise.
     *
     * @param selectionOrRangeOrPosition The selection/range/position to check.
     * @returns The lowest limit element containing the entire `selectionOrRangeOrPosition`.
     */
    getLimitElement(e) {
      let t;
      for (e instanceof C ? t = e.parent : t = (e instanceof _ ? [e] : Array.from(e.getRanges())).reduce((s, o) => {
        const r = o.getCommonAncestor();
        return s ? s.getCommonAncestor(r, { includeSelf: !0 }) : r;
      }, null); !this.isLimit(t) && t.parent; )
        t = t.parent;
      return t;
    }
    /**
     * Checks whether the attribute is allowed in selection:
     *
     * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
     * * if the selection is collapsed, then checks if on the selection position there's a text with the
     * specified attribute allowed.
     *
     * @param selection Selection which will be checked.
     * @param attribute The name of the attribute to check.
     */
    checkAttributeInSelection(e, t) {
      if (e.isCollapsed) {
        const s = [
          ...e.getFirstPosition().getAncestors(),
          new j("", e.getAttributes())
        ];
        return this.checkAttribute(s, t);
      } else {
        const i = e.getRanges();
        for (const s of i)
          for (const o of s)
            if (this.checkAttribute(o.item, t))
              return !0;
      }
      return !1;
    }
    /**
     * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).
     *
     * @param ranges Ranges to be validated.
     * @param attribute The name of the attribute to check.
     * @returns Ranges in which the attribute is allowed.
     */
    *getValidRanges(e, t) {
      e = h2(e);
      for (const i of e)
        yield* this._getValidRangesForRange(i, t);
    }
    /**
     * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is
     * nearest to that `position` and is a correct range for selection.
     *
     * The correct selection range might be collapsed when it is located in a position where the text node can be placed.
     * Non-collapsed range is returned when selection can be placed around element marked as an "object" in
     * the {@link module:engine/model/schema~Schema schema}.
     *
     * Direction of searching for the nearest correct selection range can be specified as:
     *
     * * `both` - searching will be performed in both ways,
     * * `forward` - searching will be performed only forward,
     * * `backward` - searching will be performed only backward.
     *
     * When valid selection range cannot be found, `null` is returned.
     *
     * @param position Reference position where new selection range should be looked for.
     * @param direction Search direction.
     * @returns Nearest selection range or `null` if one cannot be found.
     */
    getNearestSelectionRange(e, t = "both") {
      if (e.root.rootName == "$graveyard")
        return null;
      if (this.checkChild(e, "$text"))
        return new _(e);
      let i, s;
      const o = e.getAncestors().reverse().find((r) => this.isLimit(r)) || e.root;
      (t == "both" || t == "backward") && (i = new xt({
        boundaries: _._createIn(o),
        startPosition: e,
        direction: "backward"
      })), (t == "both" || t == "forward") && (s = new xt({
        boundaries: _._createIn(o),
        startPosition: e
      }));
      for (const r of d2(i, s)) {
        const a = r.walker == i ? "elementEnd" : "elementStart", l = r.value;
        if (l.type == a && this.isObject(l.item))
          return _._createOn(l.item);
        if (this.checkChild(l.nextPosition, "$text"))
          return new _(l.nextPosition);
      }
      return null;
    }
    /**
     * Tries to find position ancestors that allow to insert a given node.
     * It starts searching from the given position and goes node by node to the top of the model tree
     * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an
     * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.
     *
     * @param position The position that the search will start from.
     * @param node The node for which an allowed parent should be found or its name.
     * @returns Allowed parent or null if nothing was found.
     */
    findAllowedParent(e, t) {
      let i = e.parent;
      for (; i; ) {
        if (this.checkChild(i, t))
          return i;
        if (this.isLimit(i))
          return null;
        i = i.parent;
      }
      return null;
    }
    /**
     * Sets attributes allowed by the schema on a given node.
     *
     * @param node A node to set attributes on.
     * @param attributes Attributes keys and values.
     * @param writer An instance of the model writer.
     */
    setAllowedAttributes(e, t, i) {
      const s = i.model;
      for (const [o, r] of Object.entries(t))
        s.schema.checkAttribute(e, o) && i.setAttribute(o, r, e);
    }
    /**
     * Removes attributes disallowed by the schema.
     *
     * @param nodes Nodes that will be filtered.
     */
    removeDisallowedAttributes(e, t) {
      for (const i of e)
        if (i.is("$text"))
          _u(this, i, t);
        else {
          const o = _._createIn(i).getPositions();
          for (const r of o) {
            const a = r.nodeBefore || r.parent;
            _u(this, a, t);
          }
        }
    }
    /**
     * Gets attributes of a node that have a given property.
     *
     * @param node Node to get attributes from.
     * @param propertyName Name of the property that attribute must have to return it.
     * @param propertyValue Desired value of the property that we want to check.
     * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will
     * return attributes which given property's value is equal to this parameter.
     * @returns Object with attributes' names as key and attributes' values as value.
     */
    getAttributesWithProperty(e, t, i) {
      const s = {};
      for (const [o, r] of e.getAttributes()) {
        const a = this.getAttributeProperties(o);
        a[t] !== void 0 && (i === void 0 || i === a[t]) && (s[o] = r);
      }
      return s;
    }
    /**
     * Creates an instance of the schema context.
     */
    createContext(e) {
      return new ai(e);
    }
    _clearCache() {
      this._compiledDefinitions = null;
    }
    _compile() {
      const e = {}, t = this._sourceDefinitions, i = Object.keys(t);
      for (const s of i)
        e[s] = XT(t[s], s);
      for (const s of i)
        YT(e, s);
      for (const s of i)
        QT(e, s);
      for (const s of i)
        e2(e, s);
      for (const s of i)
        t2(e, s), i2(e, s);
      for (const s of i)
        n2(e, s), s2(e, s), o2(e, s);
      this._compiledDefinitions = e;
    }
    _checkContextMatch(e, t, i = t.length - 1) {
      const s = t.getItem(i);
      if (e.allowIn.includes(s.name)) {
        if (i == 0)
          return !0;
        {
          const o = this.getDefinition(s);
          return this._checkContextMatch(o, t, i - 1);
        }
      } else
        return !1;
    }
    /**
     * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges
     * inside the given range on which the attribute can be applied.
     *
     * This is a helper function for {@link ~Schema#getValidRanges}.
     *
     * @param range The range to process.
     * @param attribute The name of the attribute to check.
     * @returns Ranges in which the attribute is allowed.
     */
    *_getValidRangesForRange(e, t) {
      let i = e.start, s = e.start;
      for (const o of e.getItems({ shallow: !0 }))
        o.is("element") && (yield* this._getValidRangesForRange(_._createIn(o), t)), this.checkAttribute(o, t) || (i.isEqual(s) || (yield new _(i, s)), i = C._createAfter(o)), s = C._createAfter(o);
      i.isEqual(s) || (yield new _(i, s));
    }
    /**
     * Returns a model range which is optimal (in terms of UX) for inserting a widget block.
     *
     * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph
     * will be returned so that it is not split. If the selection is at the end of a paragraph,
     * the collapsed range after this paragraph will be returned.
     *
     * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range
     * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced
     * by the inserted widget block.
     *
     * @internal
     * @param selection The selection based on which the insertion position should be calculated.
     * @param place The place where to look for optimal insertion range.
     * The `auto` value will determine itself the best position for insertion.
     * The `before` value will try to find a position before selection.
     * The `after` value will try to find a position after selection.
     * @returns The optimal range.
     */
    findOptimalInsertionRange(e, t) {
      const i = e.getSelectedElement();
      if (i && this.isObject(i) && !this.isInline(i))
        return t == "before" || t == "after" ? new _(C._createAt(i, t)) : _._createOn(i);
      const s = me(e.getSelectedBlocks());
      if (!s)
        return new _(e.focus);
      if (s.isEmpty)
        return new _(C._createAt(s, 0));
      const o = C._createAfter(s);
      return e.focus.isTouching(o) ? new _(o) : new _(C._createBefore(s));
    }
  }
  class ai {
    /**
     * Creates an instance of the context.
     */
    constructor(e) {
      if (e instanceof ai)
        return e;
      let t;
      typeof e == "string" ? t = [e] : Array.isArray(e) ? t = e : t = e.getAncestors({ includeSelf: !0 }), this._items = t.map(u2);
    }
    /**
     * The number of items.
     */
    get length() {
      return this._items.length;
    }
    /**
     * The last item (the lowest node).
     */
    get last() {
      return this._items[this._items.length - 1];
    }
    /**
     * Iterable interface.
     *
     * Iterates over all context items.
     */
    [Symbol.iterator]() {
      return this._items[Symbol.iterator]();
    }
    /**
     * Returns a new schema context instance with an additional item.
     *
     * Item can be added as:
     *
     * ```ts
     * const context = new SchemaContext( [ '$root' ] );
     *
     * // An element.
     * const fooElement = writer.createElement( 'fooElement' );
     * const newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]
     *
     * // A text node.
     * const text = writer.createText( 'foobar' );
     * const newContext = context.push( text ); // [ '$root', '$text' ]
     *
     * // A string (element name).
     * const newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]
     * ```
     *
     * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item
     * (without ancestors).
     *
     * @param item An item that will be added to the current context.
     * @returns A new schema context instance with an additional item.
     */
    push(e) {
      const t = new ai([e]);
      return t._items = [...this._items, ...t._items], t;
    }
    /**
     * Gets an item on the given index.
     */
    getItem(e) {
      return this._items[e];
    }
    /**
     * Returns the names of items.
     */
    *getNames() {
      yield* this._items.map((e) => e.name);
    }
    /**
     * Checks whether the context ends with the given nodes.
     *
     * ```ts
     * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
     *
     * ctx.endsWith( '$text' ); // -> true
     * ctx.endsWith( 'paragraph $text' ); // -> true
     * ctx.endsWith( '$root' ); // -> false
     * ctx.endsWith( 'paragraph' ); // -> false
     * ```
     */
    endsWith(e) {
      return Array.from(this.getNames()).join(" ").endsWith(e);
    }
    /**
     * Checks whether the context starts with the given nodes.
     *
     * ```ts
     * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
     *
     * ctx.endsWith( '$root' ); // -> true
     * ctx.endsWith( '$root paragraph' ); // -> true
     * ctx.endsWith( '$text' ); // -> false
     * ctx.endsWith( 'paragraph' ); // -> false
     * ```
     */
    startsWith(e) {
      return Array.from(this.getNames()).join(" ").startsWith(e);
    }
  }
  function XT(n, e) {
    const t = {
      name: e,
      allowIn: [],
      allowContentOf: [],
      allowWhere: [],
      allowAttributes: [],
      allowAttributesOf: [],
      allowChildren: [],
      inheritTypesFrom: []
    };
    return r2(n, t), Yt(n, t, "allowIn"), Yt(n, t, "allowContentOf"), Yt(n, t, "allowWhere"), Yt(n, t, "allowAttributes"), Yt(n, t, "allowAttributesOf"), Yt(n, t, "allowChildren"), Yt(n, t, "inheritTypesFrom"), a2(n, t), t;
  }
  function YT(n, e) {
    const t = n[e];
    for (const i of t.allowChildren) {
      const s = n[i];
      s && s.allowIn.push(e);
    }
    t.allowChildren.length = 0;
  }
  function QT(n, e) {
    for (const t of n[e].allowContentOf)
      n[t] && l2(n, t).forEach((s) => {
        s.allowIn.push(e);
      });
    delete n[e].allowContentOf;
  }
  function e2(n, e) {
    for (const t of n[e].allowWhere) {
      const i = n[t];
      if (i) {
        const s = i.allowIn;
        n[e].allowIn.push(...s);
      }
    }
    delete n[e].allowWhere;
  }
  function t2(n, e) {
    for (const t of n[e].allowAttributesOf) {
      const i = n[t];
      if (i) {
        const s = i.allowAttributes;
        n[e].allowAttributes.push(...s);
      }
    }
    delete n[e].allowAttributesOf;
  }
  function i2(n, e) {
    const t = n[e];
    for (const i of t.inheritTypesFrom) {
      const s = n[i];
      if (s) {
        const o = Object.keys(s).filter((r) => r.startsWith("is"));
        for (const r of o)
          r in t || (t[r] = s[r]);
      }
    }
    delete t.inheritTypesFrom;
  }
  function n2(n, e) {
    const t = n[e], i = t.allowIn.filter((s) => n[s]);
    t.allowIn = Array.from(new Set(i));
  }
  function s2(n, e) {
    const t = n[e];
    for (const i of t.allowIn)
      n[i].allowChildren.push(e);
  }
  function o2(n, e) {
    const t = n[e];
    t.allowAttributes = Array.from(new Set(t.allowAttributes));
  }
  function r2(n, e) {
    for (const t of n) {
      const i = Object.keys(t).filter((s) => s.startsWith("is"));
      for (const s of i)
        e[s] = !!t[s];
    }
  }
  function Yt(n, e, t) {
    for (const i of n) {
      const s = i[t];
      typeof s == "string" ? e[t].push(s) : Array.isArray(s) && e[t].push(...s);
    }
  }
  function a2(n, e) {
    for (const t of n) {
      const i = t.inheritAllFrom;
      i && (e.allowContentOf.push(i), e.allowWhere.push(i), e.allowAttributesOf.push(i), e.inheritTypesFrom.push(i));
    }
  }
  function l2(n, e) {
    const t = n[e];
    return c2(n).filter((i) => i.allowIn.includes(t.name));
  }
  function c2(n) {
    return Object.keys(n).map((e) => n[e]);
  }
  function u2(n) {
    return typeof n == "string" || n.is("documentFragment") ? {
      name: typeof n == "string" ? n : "$documentFragment",
      *getAttributeKeys() {
      },
      getAttribute() {
      }
    } : {
      // '$text' means text nodes and text proxies.
      name: n.is("element") ? n.name : "$text",
      *getAttributeKeys() {
        yield* n.getAttributeKeys();
      },
      getAttribute(e) {
        return n.getAttribute(e);
      }
    };
  }
  function* d2(n, e) {
    let t = !1;
    for (; !t; ) {
      if (t = !0, n) {
        const i = n.next();
        i.done || (t = !1, yield {
          walker: n,
          value: i.value
        });
      }
      if (e) {
        const i = e.next();
        i.done || (t = !1, yield {
          walker: e,
          value: i.value
        });
      }
    }
  }
  function* h2(n) {
    for (const e of n)
      yield* e.getMinimalFlatRanges();
  }
  function _u(n, e, t) {
    for (const i of e.getAttributeKeys())
      n.checkAttribute(e, i) || t.removeAttribute(i, e);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class f2 extends G() {
    /**
     * Creates an upcast dispatcher that operates using the passed API.
     *
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi
     * @param conversionApi Additional properties for an interface that will be passed to events fired
     * by the upcast dispatcher.
     */
    constructor(e) {
      super(), this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this._emptyElementsToKeep = /* @__PURE__ */ new Set(), this.conversionApi = {
        ...e,
        consumable: null,
        writer: null,
        store: null,
        convertItem: (t, i) => this._convertItem(t, i),
        convertChildren: (t, i) => this._convertChildren(t, i),
        safeInsert: (t, i) => this._safeInsert(t, i),
        updateConversionResult: (t, i) => this._updateConversionResult(t, i),
        // Advanced API - use only if custom position handling is needed.
        splitToAllowedParent: (t, i) => this._splitToAllowedParent(t, i),
        getSplitParts: (t) => this._getSplitParts(t),
        keepEmptyElement: (t) => this._keepEmptyElement(t)
      };
    }
    /**
     * Starts the conversion process. The entry point for the conversion.
     *
     * @fires element
     * @fires text
     * @fires documentFragment
     * @param viewElement The part of the view to be converted.
     * @param writer An instance of the model writer.
     * @param context Elements will be converted according to this context.
     * @returns Model data that is the result of the conversion process
     * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's
     * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
     */
    convert(e, t, i = ["$root"]) {
      this.fire("viewCleanup", e), this._modelCursor = g2(i, t), this.conversionApi.writer = t, this.conversionApi.consumable = Dn.createFrom(e), this.conversionApi.store = {};
      const { modelRange: s } = this._convertItem(e, this._modelCursor), o = t.createDocumentFragment();
      if (s) {
        this._removeEmptyElements();
        for (const r of Array.from(this._modelCursor.parent.getChildren()))
          t.append(r, o);
        o.markers = m2(o, t);
      }
      return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, o;
    }
    /**
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem
     */
    _convertItem(e, t) {
      const i = { viewItem: e, modelCursor: t, modelRange: null };
      if (e.is("element") ? this.fire(`element:${e.name}`, i, this.conversionApi) : e.is("$text") ? this.fire("text", i, this.conversionApi) : this.fire("documentFragment", i, this.conversionApi), i.modelRange && !(i.modelRange instanceof _))
        throw new g("view-conversion-dispatcher-incorrect-result", this);
      return { modelRange: i.modelRange, modelCursor: i.modelCursor };
    }
    /**
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren
     */
    _convertChildren(e, t) {
      let i = t.is("position") ? t : C._createAt(t, 0);
      const s = new _(i);
      for (const o of Array.from(e.getChildren())) {
        const r = this._convertItem(o, i);
        r.modelRange instanceof _ && (s.end = r.modelRange.end, i = r.modelCursor);
      }
      return { modelRange: s, modelCursor: i };
    }
    /**
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert
     */
    _safeInsert(e, t) {
      const i = this._splitToAllowedParent(e, t);
      return i ? (this.conversionApi.writer.insert(e, i.position), !0) : !1;
    }
    /**
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult
     */
    _updateConversionResult(e, t) {
      const i = this._getSplitParts(e), s = this.conversionApi.writer;
      t.modelRange || (t.modelRange = s.createRange(s.createPositionBefore(e), s.createPositionAfter(i[i.length - 1])));
      const o = this._cursorParents.get(e);
      o ? t.modelCursor = s.createPositionAt(o, 0) : t.modelCursor = t.modelRange.end;
    }
    /**
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent
     */
    _splitToAllowedParent(e, t) {
      const { schema: i, writer: s } = this.conversionApi;
      let o = i.findAllowedParent(t, e);
      if (o) {
        if (o === t.parent)
          return { position: t };
        this._modelCursor.parent.getAncestors().includes(o) && (o = null);
      }
      if (!o)
        return Fm(t, e, i) ? {
          position: zm(t, s)
        } : null;
      const r = this.conversionApi.writer.split(t, o), a = [];
      for (const c of r.range.getWalker())
        if (c.type == "elementEnd")
          a.push(c.item);
        else {
          const u = a.pop(), d = c.item;
          this._registerSplitPair(u, d);
        }
      const l = r.range.end.parent;
      return this._cursorParents.set(e, l), {
        position: r.position,
        cursorParent: l
      };
    }
    /**
     * Registers that a `splitPart` element is a split part of the `originalPart` element.
     *
     * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.
     */
    _registerSplitPair(e, t) {
      this._splitParts.has(e) || this._splitParts.set(e, [e]);
      const i = this._splitParts.get(e);
      this._splitParts.set(t, i), i.push(t);
    }
    /**
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts
     */
    _getSplitParts(e) {
      let t;
      return this._splitParts.has(e) ? t = this._splitParts.get(e) : t = [e], t;
    }
    /**
     * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.
     */
    _keepEmptyElement(e) {
      this._emptyElementsToKeep.add(e);
    }
    /**
     * Checks if there are any empty elements created while splitting and removes them.
     *
     * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,
     * as some elements might have become empty after other empty elements were removed from them.
     */
    _removeEmptyElements() {
      let e = !1;
      for (const t of this._splitParts.keys())
        t.isEmpty && !this._emptyElementsToKeep.has(t) && (this.conversionApi.writer.remove(t), this._splitParts.delete(t), e = !0);
      e && this._removeEmptyElements();
    }
  }
  function m2(n, e) {
    const t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map(), s = _._createIn(n).getItems();
    for (const o of s)
      o.is("element", "$marker") && t.add(o);
    for (const o of t) {
      const r = o.getAttribute("data-name"), a = e.createPositionBefore(o);
      i.has(r) ? i.get(r).end = a.clone() : i.set(r, new _(a.clone())), e.remove(o);
    }
    return i;
  }
  function g2(n, e) {
    let t;
    for (const i of new ai(n)) {
      const s = {};
      for (const r of i.getAttributeKeys())
        s[r] = i.getAttribute(r);
      const o = e.createElement(i.name, s);
      t && e.insert(o, t), t = C._createAt(o, 0);
    }
    return t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class p2 {
    /**
     * Returns an HTML string created from the document fragment.
     */
    getHtml(e) {
      const i = E.document.implementation.createHTMLDocument("").createElement("div");
      return i.appendChild(e), i.innerHTML;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class w2 {
    /**
     * Creates a new instance of the HTML data processor class.
     *
     * @param document The view document instance.
     */
    constructor(e) {
      this.skipComments = !0, this.domParser = new DOMParser(), this.domConverter = new Qo(e, { renderingMode: "data" }), this.htmlWriter = new p2();
    }
    /**
     * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
     * to data format &ndash; in this case to an HTML string.
     *
     * @returns HTML string.
     */
    toData(e) {
      const t = this.domConverter.viewToDom(e);
      return this.htmlWriter.getHtml(t);
    }
    /**
     * Converts the provided HTML string to a view tree.
     *
     * @param data An HTML string.
     * @returns A converted view element.
     */
    toView(e) {
      const t = this._toDom(e);
      return this.domConverter.domToView(t, { skipComments: this.skipComments });
    }
    /**
     * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
     * and not processed during the conversion from the DOM to the view elements.
     *
     * The raw data can be later accessed by a
     * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
     *
     * @param pattern Pattern matching all view elements whose content should be treated as raw data.
     */
    registerRawContentMatcher(e) {
      this.domConverter.registerRawContentMatcher(e);
    }
    /**
     * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
     * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
     *
     * This mode allows for a more precise handling of the block fillers (so they do not leak into the editor content) but
     * bloats the editor data with additional markup.
     *
     * This mode may be required by some features and will be turned on by them automatically.
     *
     * @param type Whether to use the default or the marked `&nbsp;` block fillers.
     */
    useFillerType(e) {
      this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp";
    }
    /**
     * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
     * the provided data.
     */
    _toDom(e) {
      e.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (e = `<body>${e}</body>`);
      const t = this.domParser.parseFromString(e, "text/html"), i = t.createDocumentFragment(), s = t.body.childNodes;
      for (; s.length > 0; )
        i.appendChild(s[0]);
      return i;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class b2 extends G() {
    /**
     * Creates a data controller instance.
     *
     * @param model Data model.
     * @param stylesProcessor The styles processor instance.
     */
    constructor(e, t) {
      super(), this.model = e, this.mapper = new Am(), this.downcastDispatcher = new xm({
        mapper: this.mapper,
        schema: e.schema
      }), this.downcastDispatcher.on("insert:$text", Pm(), { priority: "lowest" }), this.downcastDispatcher.on("insert", Rm(), { priority: "lowest" }), this.upcastDispatcher = new f2({
        schema: e.schema
      }), this.viewDocument = new Xo(t), this.stylesProcessor = t, this.htmlProcessor = new w2(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new pm(this.viewDocument), this.upcastDispatcher.on("text", IT(), { priority: "lowest" }), this.upcastDispatcher.on("element", gu(), { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", gu(), { priority: "lowest" }), $().prototype.decorate.call(this, "init"), $().prototype.decorate.call(this, "set"), $().prototype.decorate.call(this, "get"), $().prototype.decorate.call(this, "toView"), $().prototype.decorate.call(this, "toModel"), this.on("init", () => {
        this.fire("ready");
      }, { priority: "lowest" }), this.on("ready", () => {
        this.model.enqueueChange({ isUndoable: !1 }, Dm);
      }, { priority: "lowest" });
    }
    /**
     * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and
     * formatted by the {@link #processor data processor}.
     *
     * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
     * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
     *
     * @fires get
     * @param options Additional configuration for the retrieved data. `DataController` provides two optional
     * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.
     * @param options.rootName Root name. Default 'main'.
     * @param options.trim Whether returned data should be trimmed. This option is set to `empty` by default,
     * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely
     * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).
     * @returns Output data.
     */
    get(e = {}) {
      const { rootName: t = "main", trim: i = "empty" } = e;
      if (!this._checkIfRootsExists([t]))
        throw new g("datacontroller-get-non-existent-root", this);
      const s = this.model.document.getRoot(t);
      return s.isAttached() || z("datacontroller-get-detached-root", this), i === "empty" && !this.model.hasContent(s, { ignoreWhitespaces: !0 }) ? "" : this.stringify(s, e);
    }
    /**
     * Returns the content of the given {@link module:engine/model/element~Element model's element} or
     * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters
     * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.
     *
     * @param modelElementOrFragment The element whose content will be stringified.
     * @param options Additional configuration passed to the conversion process.
     * @returns Output data.
     */
    stringify(e, t = {}) {
      const i = this.toView(e, t);
      return this.processor.toData(i);
    }
    /**
     * Returns the content of the given {@link module:engine/model/element~Element model element} or
     * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast
     * converters attached to {@link #downcastDispatcher} into a
     * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
     *
     * @fires toView
     * @param modelElementOrFragment Element or document fragment whose content will be converted.
     * @param options Additional configuration that will be available through the
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.
     * @returns Output view DocumentFragment.
     */
    toView(e, t = {}) {
      const i = this.viewDocument, s = this._viewWriter;
      this.mapper.clearBindings();
      const o = _._createIn(e), r = new ri(i);
      this.mapper.bindElements(e, r);
      const a = e.is("documentFragment") ? e.markers : _2(e);
      return this.downcastDispatcher.convert(o, a, s, t), r;
    }
    /**
     * Sets the initial input data parsed by the {@link #processor data processor} and
     * converted by the {@link #upcastDispatcher view-to-model converters}.
     * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.
     *
     * **Note** This method is {@link module:utils/observablemixin~Observable#decorate decorated} which is
     * used by e.g. collaborative editing plugin that syncs remote data on init.
     *
     * When data is passed as a string, it is initialized on the default `main` root:
     *
     * ```ts
     * dataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.
     * ```
     *
     * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
     *
     * ```ts
     * dataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.
     * ```
     *
     * @fires init
     * @param data Input data as a string or an object containing the `rootName` - `data`
     * pairs to initialize data on multiple roots at once.
     * @returns Promise that is resolved after the data is set on the editor.
     */
    init(e) {
      if (this.model.document.version)
        throw new g("datacontroller-init-document-not-empty", this);
      let t = {};
      if (typeof e == "string" ? t.main = e : t = e, !this._checkIfRootsExists(Object.keys(t)))
        throw new g("datacontroller-init-non-existent-root", this);
      return this.model.enqueueChange({ isUndoable: !1 }, (i) => {
        for (const s of Object.keys(t)) {
          const o = this.model.document.getRoot(s);
          i.insert(this.parse(t[s], o), o, 0);
        }
      }), Promise.resolve();
    }
    /**
     * Sets the input data parsed by the {@link #processor data processor} and
     * converted by the {@link #upcastDispatcher view-to-model converters}.
     * This method can be used any time to replace existing editor data with the new one without clearing the
     * {@link module:engine/model/document~Document#history document history}.
     *
     * This method also creates a batch with all the changes applied. If all you need is to parse data, use
     * the {@link #parse} method.
     *
     * When data is passed as a string it is set on the default `main` root:
     *
     * ```ts
     * dataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.
     * ```
     *
     * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
     *
     * ```ts
     * dataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.
     * ```
     *
     * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.
     *
     * ```ts
     * dataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );
     * ```
     *
     * @fires set
     * @param data Input data as a string or an object containing the `rootName` - `data`
     * pairs to set data on multiple roots at once.
     * @param options Options for setting data.
     * @param options.batchType The batch type that will be used to create a batch for the changes applied by this method.
     * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be
     * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,
     * the undo stack will be preserved instead and not cleared when new data is applied.
     */
    set(e, t = {}) {
      let i = {};
      if (typeof e == "string" ? i.main = e : i = e, !this._checkIfRootsExists(Object.keys(i)))
        throw new g("datacontroller-set-non-existent-root", this);
      this.model.enqueueChange(t.batchType || {}, (s) => {
        s.setSelection(null), s.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
        for (const o of Object.keys(i)) {
          const r = this.model.document.getRoot(o);
          s.remove(s.createRangeIn(r)), s.insert(this.parse(i[o], r), r, 0);
        }
      });
    }
    /**
     * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters
     * attached to the {@link #upcastDispatcher}.
     *
     * @see #set
     * @param data Data to parse.
     * @param context Base context in which the view will be converted to the model.
     * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
     * @returns Parsed data.
     */
    parse(e, t = "$root") {
      const i = this.processor.toView(e);
      return this.toModel(i, t);
    }
    /**
     * Returns the result of the given {@link module:engine/view/element~Element view element} or
     * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the
     * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.
     *
     * When marker elements were converted during the conversion process, it will be set as a document fragment's
     * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
     *
     * @fires toModel
     * @param viewElementOrFragment The element or document fragment whose content will be converted.
     * @param context Base context in which the view will be converted to the model.
     * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
     * @returns Output document fragment.
     */
    toModel(e, t = "$root") {
      return this.model.change((i) => this.upcastDispatcher.convert(e, i, t));
    }
    /**
     * Adds the style processor normalization rules.
     *
     * You can implement your own rules as well as use one of the available processor rules:
     *
     * * background: {@link module:engine/view/styles/background~addBackgroundRules}
     * * border: {@link module:engine/view/styles/border~addBorderRules}
     * * margin: {@link module:engine/view/styles/margin~addMarginRules}
     * * padding: {@link module:engine/view/styles/padding~addPaddingRules}
     */
    addStyleProcessorRules(e) {
      e(this.stylesProcessor);
    }
    /**
     * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}
     * and a {@link #processor processor} for view elements whose content should be treated as raw data
     * and not processed during the conversion from DOM to view elements.
     *
     * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}
     * `"$rawContent"`.
     *
     * @param pattern Pattern matching all view elements whose content should be treated as a raw data.
     */
    registerRawContentMatcher(e) {
      this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e), this.htmlProcessor.registerRawContentMatcher(e);
    }
    /**
     * Removes all event listeners set by the DataController.
     */
    destroy() {
      this.stopListening();
    }
    /**
     * Checks whether all provided root names are actually existing editor roots.
     *
     * @param rootNames Root names to check.
     * @returns Whether all provided root names are existing editor roots.
     */
    _checkIfRootsExists(e) {
      for (const t of e)
        if (!this.model.document.getRoot(t))
          return !1;
      return !0;
    }
  }
  function _2(n) {
    const e = [], t = n.root.document;
    if (!t)
      return /* @__PURE__ */ new Map();
    const i = _._createIn(n);
    for (const s of t.model.markers) {
      const o = s.getRange(), r = o.isCollapsed, a = o.start.isEqual(i.start) || o.end.isEqual(i.end);
      if (r && a)
        e.push([s.name, o]);
      else {
        const l = i.getIntersection(o);
        l && e.push([s.name, l]);
      }
    }
    return e.sort(([s, o], [r, a]) => {
      if (o.end.compareWith(a.start) !== "after")
        return 1;
      if (o.start.compareWith(a.end) !== "before")
        return -1;
      switch (o.start.compareWith(a.start)) {
        case "before":
          return 1;
        case "after":
          return -1;
        default:
          switch (o.end.compareWith(a.end)) {
            case "before":
              return 1;
            case "after":
              return -1;
            default:
              return r.localeCompare(s);
          }
      }
    }), new Map(e);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class v2 {
    /**
     * Creates a new conversion instance.
     */
    constructor(e, t) {
      this._helpers = /* @__PURE__ */ new Map(), this._downcast = Z(e), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: !0 }), this._upcast = Z(t), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: !1 });
    }
    /**
     * Define an alias for registered dispatcher.
     *
     * ```ts
     * const conversion = new Conversion(
     * 	[ dataDowncastDispatcher, editingDowncastDispatcher ],
     * 	upcastDispatcher
     * );
     *
     * conversion.addAlias( 'dataDowncast', dataDowncastDispatcher );
     * ```
     *
     * @param alias An alias of a dispatcher.
     * @param dispatcher Dispatcher which should have an alias.
     */
    addAlias(e, t) {
      const i = this._downcast.includes(t);
      if (!this._upcast.includes(t) && !i)
        throw new g("conversion-add-alias-dispatcher-not-registered", this);
      this._createConversionHelpers({ name: e, dispatchers: [t], isDowncast: i });
    }
    /**
     * Provides a chainable API to assign converters to a conversion dispatchers group.
     *
     * If the given group name has not been registered, the
     * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.
     *
     * You can use conversion helpers available directly in the `for()` chain or your custom ones via
     * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.
     *
     * # Using built-in conversion helpers
     *
     * The `for()` chain comes with a set of conversion helpers which you can use like this:
     *
     * ```ts
     * editor.conversion.for( 'downcast' )
     * 	.elementToElement( config1 )        // Adds an element-to-element downcast converter.
     * 	.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.
     *
     * editor.conversion.for( 'upcast' )
     * 	.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.
     * ```
     *
     * Refer to the documentation of built-in conversion helpers to learn about their configuration options.
     *
     * * downcast (model-to-view) conversion helpers:
     *
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.
     *
     * * upcast (view-to-model) conversion helpers:
     *
     *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},
     *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},
     *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.
     *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.
     *
     * # Using custom conversion helpers
     *
     * If you need to implement an atypical converter, you can do so by calling:
     *
     * ```ts
     * editor.conversion.for( direction ).add( customHelper );
     * ```
     *
     * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that
     * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.
     *
     * Example:
     *
     * ```ts
     * editor.conversion.for( 'upcast' ).add( dispatcher => {
     * 	dispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {
     * 		// Do something with a view <a> element.
     * 	} );
     * } );
     * ```
     *
     * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
     * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write
     * custom converters.
     *
     * @param groupName The name of dispatchers group to add the converters to.
     */
    for(e) {
      if (!this._helpers.has(e))
        throw new g("conversion-for-unknown-group", this);
      return this._helpers.get(e);
    }
    /**
     * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).
     * For example, the model `<paragraph>Foo</paragraph>` is turned into `<p>Foo</p>` in the view.
     *
     * ```ts
     * // A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).
     * editor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );
     *
     * // Override other converters by specifying a converter definition with a higher priority.
     * editor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );
     *
     * // View specified as an object instead of a string.
     * editor.conversion.elementToElement( {
     * 	model: 'fancyParagraph',
     * 	view: {
     * 		name: 'p',
     * 		classes: 'fancy'
     * 	}
     * } );
     *
     * // Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.
     * editor.conversion.elementToElement( {
     * 	model: 'paragraph',
     * 	view: 'p',
     * 	upcastAlso: [
     * 		'div',
     * 		{
     * 			// Any element with the `display: block` style.
     * 			styles: {
     * 				display: 'block'
     * 			}
     * 		}
     * 	]
     * } );
     *
     * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
     * editor.conversion.elementToElement( {
     * 	model: 'heading',
     * 	view: 'h2',
     * 	// Convert "heading-like" paragraphs to headings.
     * 	upcastAlso: viewElement => {
     * 		const fontSize = viewElement.getStyle( 'font-size' );
     *
     * 		if ( !fontSize ) {
     * 			return null;
     * 		}
     *
     * 		const match = fontSize.match( /(\d+)\s*px/ );
     *
     * 		if ( !match ) {
     * 			return null;
     * 		}
     *
     * 		const size = Number( match[ 1 ] );
     *
     * 		if ( size > 26 ) {
     * 			// Returned value can be an object with the matched properties.
     * 			// These properties will be "consumed" during the conversion.
     * 			// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
     *
     * 			return { name: true, styles: [ 'font-size' ] };
     * 		}
     *
     * 		return null;
     * 	}
     * } );
     * ```
     *
     * `definition.model` is a `String` with a model element name to convert from or to.
     *
     * @param definition The converter definition.
     */
    elementToElement(e) {
      this.for("downcast").elementToElement(e);
      for (const { model: t, view: i } of xr(e))
        this.for("upcast").elementToElement({
          model: t,
          view: i,
          converterPriority: e.converterPriority
        });
    }
    /**
     * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).
     * For example, a model text node with `"Foo"` as data and the `bold` attribute will be turned to `<strong>Foo</strong>` in the view.
     *
     * ```ts
     * // A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).
     * editor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );
     *
     * // Override other converters by specifying a converter definition with a higher priority.
     * editor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );
     *
     * // View specified as an object instead of a string.
     * editor.conversion.attributeToElement( {
     * 	model: 'bold',
     * 	view: {
     * 		name: 'span',
     * 		classes: 'bold'
     * 	}
     * } );
     *
     * // Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.
     * // The same attribute on different elements may then be handled by a different converter.
     * editor.conversion.attributeToElement( {
     * 	model: {
     * 		key: 'textDecoration',
     * 		values: [ 'underline', 'lineThrough' ],
     * 		name: '$text'
     * 	},
     * 	view: {
     * 		underline: {
     * 			name: 'span',
     * 			styles: {
     * 				'text-decoration': 'underline'
     * 			}
     * 		},
     * 		lineThrough: {
     * 			name: 'span',
     * 			styles: {
     * 				'text-decoration': 'line-through'
     * 			}
     * 		}
     * 	}
     * } );
     *
     * // Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.
     * editor.conversion.attributeToElement( {
     * 	model: 'bold',
     * 	view: 'strong',
     * 	upcastAlso: [
     * 		'b',
     * 		{
     * 			name: 'span',
     * 			classes: 'bold'
     * 		},
     * 		{
     * 			name: 'span',
     * 			styles: {
     * 				'font-weight': 'bold'
     * 			}
     * 		},
     * 		viewElement => {
     * 			const fontWeight = viewElement.getStyle( 'font-weight' );
     *
     * 			if ( viewElement.is( 'element', 'span' ) && fontWeight && /\d+/.test() && Number( fontWeight ) > 500 ) {
     * 				// Returned value can be an object with the matched properties.
     * 				// These properties will be "consumed" during the conversion.
     * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
     *
     * 				return {
     * 					name: true,
     * 					styles: [ 'font-weight' ]
     * 				};
     * 			}
     * 		}
     * 	]
     * } );
     *
     * // Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).
     * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
     * editor.conversion.attributeToElement( {
     * 	model: {
     * 		key: 'fontSize',
     * 		values: [ 'big', 'small' ]
     * 	},
     * 	view: {
     * 		big: {
     * 			name: 'span',
     * 			styles: {
     * 				'font-size': '1.2em'
     * 			}
     * 		},
     * 		small: {
     * 			name: 'span',
     * 			styles: {
     * 				'font-size': '0.8em'
     * 			}
     * 		}
     * 	},
     * 	upcastAlso: {
     * 		big: viewElement => {
     * 			const fontSize = viewElement.getStyle( 'font-size' );
     *
     * 			if ( !fontSize ) {
     * 				return null;
     * 			}
     *
     * 			const match = fontSize.match( /(\d+)\s*px/ );
     *
     * 			if ( !match ) {
     * 				return null;
     * 			}
     *
     * 			const size = Number( match[ 1 ] );
     *
     * 			if ( viewElement.is( 'element', 'span' ) && size > 10 ) {
     * 				// Returned value can be an object with the matched properties.
     * 				// These properties will be "consumed" during the conversion.
     * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
     *
     * 				return { name: true, styles: [ 'font-size' ] };
     * 			}
     *
     * 			return null;
     * 		},
     * 		small: viewElement => {
     * 			const fontSize = viewElement.getStyle( 'font-size' );
     *
     * 			if ( !fontSize ) {
     * 				return null;
     * 			}
     *
     * 			const match = fontSize.match( /(\d+)\s*px/ );
     *
     * 			if ( !match ) {
     * 				return null;
     * 			}
     *
     * 			const size = Number( match[ 1 ] );
     *
     * 			if ( viewElement.is( 'element', 'span' ) && size < 10 ) {
     * 				// Returned value can be an object with the matched properties.
     * 				// These properties will be "consumed" during the conversion.
     * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
     *
     * 				return { name: true, styles: [ 'font-size' ] };
     * 			}
     *
     * 			return null;
     * 		}
     * 	}
     * } );
     * ```
     *
     * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object
     * describing the attribute key and value to convert or a `String` specifying just the attribute key (in such a case
     * `value` is set to `true`).
     *
     * @param definition The converter definition.
     */
    attributeToElement(e) {
      this.for("downcast").attributeToElement(e);
      for (const { model: t, view: i } of xr(e))
        this.for("upcast").elementToAttribute({
          view: i,
          model: t,
          converterPriority: e.converterPriority
        });
    }
    /**
     * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa). For example,
     * `<imageBlock src='foo.jpg'></imageBlock>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).
     * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.
     * To convert the text attributes,
     * the {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}should be set up.
     *
     * ```ts
     * // A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).
     * editor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );
     *
     * // Attribute values are strictly specified.
     * editor.conversion.attributeToAttribute( {
     * 	model: {
     * 		name: 'imageInline',
     * 		key: 'aside',
     * 		values: [ 'aside' ]
     * 	},
     * 	view: {
     * 		aside: {
     * 			name: 'img',
     * 			key: 'class',
     * 			value: [ 'aside', 'half-size' ]
     * 		}
     * 	}
     * } );
     *
     * // Set the style attribute.
     * editor.conversion.attributeToAttribute( {
     * 	model: {
     * 		name: 'imageInline',
     * 		key: 'aside',
     * 		values: [ 'aside' ]
     * 	},
     * 	view: {
     * 		aside: {
     * 			name: 'img',
     * 			key: 'style',
     * 			value: {
     * 				float: 'right',
     * 				width: '50%',
     * 				margin: '5px'
     * 			}
     * 		}
     * 	}
     * } );
     *
     * // Conversion from and to a model attribute key whose value is an enum (`align=right|center`).
     * // Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.
     * editor.conversion.attributeToAttribute( {
     * 	model: {
     * 		key: 'align',
     * 		values: [ 'right', 'center' ]
     * 	},
     * 	view: {
     * 		right: {
     * 			key: 'class',
     * 			value: 'align-right'
     * 		},
     * 		center: {
     * 			key: 'class',
     * 			value: 'align-center'
     * 		}
     * 	},
     * 	upcastAlso: {
     * 		right: {
     * 			styles: {
     * 				'text-align': 'right'
     * 			}
     * 		},
     * 		center: {
     * 			styles: {
     * 				'text-align': 'center'
     * 			}
     * 		}
     * 	}
     * } );
     * ```
     *
     * The `definition.model` parameter specifies which model attribute should be converted from and to.
     * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.
     * The `key` property is the model attribute key to convert from and to.
     * The `values` are the possible model attribute values. If the `values` parameter is not set, the model attribute value
     * will be the same as the view attribute value.
     * If `name` is set, the conversion will be set up only for model elements with the given name.
     *
     * The `definition.view` parameter specifies which view attribute should be converted from and to.
     * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.
     * The `key` property is the view attribute key to convert from and to.
     * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be
     * the same as the model attribute value.
     * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.
     * If `key` is `'style'`, `value` is an object with key-value pairs.
     * In other cases, `value` is a `String`.
     * If `name` is set, the conversion will be set up only for model elements with the given name.
     * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`
     * to `{ key, value, [ name ] }` objects.
     *
     * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.
     * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`
     * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.
     *
     * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should
     * be given in both parameters.
     *
     * @param definition The converter definition.
     * @param definition.model The model attribute to convert from and to.
     * @param definition.view The view attribute to convert from and to.
     * @param definition.upcastAlso Any view element matching `definition.upcastAlso` will also be converted to the given model attribute.
     * `definition.upcastAlso` is used only if `config.model.values` is specified.
     */
    attributeToAttribute(e) {
      this.for("downcast").attributeToAttribute(e);
      for (const { model: t, view: i } of xr(e))
        this.for("upcast").attributeToAttribute({
          view: i,
          model: t
        });
    }
    /**
     * Creates and caches conversion helpers for given dispatchers group.
     *
     * @param options.name Group name.
     */
    _createConversionHelpers({ name: e, dispatchers: t, isDowncast: i }) {
      if (this._helpers.has(e))
        throw new g("conversion-group-exists", this);
      const s = i ? new Jk(t) : new ST(t);
      this._helpers.set(e, s);
    }
  }
  function* xr(n) {
    if (n.model.values)
      for (const e of n.model.values) {
        const t = { key: n.model.key, value: e }, i = n.view[e], s = n.upcastAlso ? n.upcastAlso[e] : void 0;
        yield* vu(t, i, s);
      }
    else
      yield* vu(n.model, n.view, n.upcastAlso);
  }
  function* vu(n, e, t) {
    if (yield { model: n, view: e }, t)
      for (const i of Z(t))
        yield { model: n, view: i };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class qe {
    /**
     * Base operation constructor.
     *
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e) {
      this.baseVersion = e, this.isDocumentOperation = this.baseVersion !== null, this.batch = null;
    }
    /**
     * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws
     * an error if operation is not valid.
     *
     * @internal
     */
    _validate() {
    }
    /**
     * Custom toJSON method to solve child-parent circular dependencies.
     *
     * @returns Clone of this object with the operation property replaced with string.
     */
    toJSON() {
      const e = Object.assign({}, this);
      return e.__className = this.constructor.className, delete e.batch, delete e.isDocumentOperation, e;
    }
    /**
     * Name of the operation class used for serialization.
     */
    static get className() {
      return "Operation";
    }
    /**
     * Creates `Operation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param doc Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      return new this(e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Cl(n, e) {
    const t = Gm(e), i = t.reduce((r, a) => r + a.offsetSize, 0), s = n.parent;
    is(n);
    const o = n.index;
    return s._insertChild(o, t), ts(s, o + t.length), ts(s, o), new _(n, n.getShiftedBy(i));
  }
  function qm(n) {
    if (!n.isFlat)
      throw new g("operation-utils-remove-range-not-flat", this);
    const e = n.start.parent;
    is(n.start), is(n.end);
    const t = e._removeChildren(n.start.index, n.end.index - n.start.index);
    return ts(e, n.start.index), t;
  }
  function es(n, e) {
    if (!n.isFlat)
      throw new g("operation-utils-move-range-not-flat", this);
    const t = qm(n);
    return e = e._getTransformedByDeletion(n.start, n.end.offset - n.start.offset), Cl(e, t);
  }
  function y2(n, e, t) {
    is(n.start), is(n.end);
    for (const i of n.getItems({ shallow: !0 })) {
      const s = i.is("$textProxy") ? i.textNode : i;
      t !== null ? s._setAttribute(e, t) : s._removeAttribute(e), ts(s.parent, s.index);
    }
    ts(n.end.parent, n.end.index);
  }
  function Gm(n) {
    const e = [];
    function t(i) {
      if (typeof i == "string")
        e.push(new j(i));
      else if (i instanceof st)
        e.push(new j(i.data, i.getAttributes()));
      else if (i instanceof vi)
        e.push(i);
      else if (We(i))
        for (const s of i)
          t(s);
    }
    t(n);
    for (let i = 1; i < e.length; i++) {
      const s = e[i], o = e[i - 1];
      s instanceof j && o instanceof j && jm(s, o) && (e.splice(i - 1, 2, new j(o.data + s.data, o.getAttributes())), i--);
    }
    return e;
  }
  function ts(n, e) {
    const t = n.getChild(e - 1), i = n.getChild(e);
    if (t && i && t.is("$text") && i.is("$text") && jm(t, i)) {
      const s = new j(t.data + i.data, t.getAttributes());
      n._removeChildren(e - 1, 2), n._insertChild(e - 1, s);
    }
  }
  function is(n) {
    const e = n.textNode, t = n.parent;
    if (e) {
      const i = n.offset - e.startOffset, s = e.index;
      t._removeChildren(s, 1);
      const o = new j(e.data.substr(0, i), e.getAttributes()), r = new j(e.data.substr(i), e.getAttributes());
      t._insertChild(s, [o, r]);
    }
  }
  function jm(n, e) {
    const t = n.getAttributes(), i = e.getAttributes();
    for (const s of t) {
      if (s[1] !== e.getAttribute(s[0]))
        return !1;
      i.next();
    }
    return i.next().done;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class H extends qe {
    /**
     * Creates a move operation.
     *
     * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
     * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
     * `sourcePosition` with offset shifted by `howMany`.
     * @param targetPosition Position at which moved nodes will be inserted.
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e, t, i, s) {
      super(s), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t, this.targetPosition = i.clone(), this.targetPosition.stickiness = "toNone";
    }
    /**
     * @inheritDoc
     */
    get type() {
      return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move";
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      return [
        _._createFromPositionAndShift(this.sourcePosition, this.howMany),
        _._createFromPositionAndShift(this.targetPosition, 0)
      ];
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     */
    clone() {
      return new H(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
    }
    /**
     * Returns the start position of the moved range after it got moved. This may be different than
     * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
     * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
     * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
     *
     * ```
     *  vv              vv
     * abcdefg ===> adefbcg
     *      ^          ^
     *      targetPos  movedRangeStart
     *      offset 6   offset 4
     *```
     */
    getMovedRangeStart() {
      return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
      return new H(this.getMovedRangeStart(), this.howMany, e, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _validate() {
      const e = this.sourcePosition.parent, t = this.targetPosition.parent, i = this.sourcePosition.offset, s = this.targetPosition.offset;
      if (i + this.howMany > e.maxOffset)
        throw new g("move-operation-nodes-do-not-exist", this);
      if (e === t && i < s && s < i + this.howMany)
        throw new g("move-operation-range-into-itself", this);
      if (this.sourcePosition.root == this.targetPosition.root && Ee(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
        const o = this.sourcePosition.path.length - 1;
        if (this.targetPosition.path[o] >= i && this.targetPosition.path[o] < i + this.howMany)
          throw new g("move-operation-node-into-itself", this);
      }
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      es(_._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return e.sourcePosition = this.sourcePosition.toJSON(), e.targetPosition = this.targetPosition.toJSON(), e;
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "MoveOperation";
    }
    /**
     * Creates `MoveOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      const i = C.fromJSON(e.sourcePosition, t), s = C.fromJSON(e.targetPosition, t);
      return new this(i, e.howMany, s, e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class be extends qe {
    /**
     * Creates an insert operation.
     *
     * @param position Position of insertion.
     * @param nodes The list of nodes to be inserted.
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e, t, i) {
      super(i), this.position = e.clone(), this.position.stickiness = "toNone", this.nodes = new On(Gm(t)), this.shouldReceiveAttributes = !1;
    }
    /**
     * @inheritDoc
     */
    get type() {
      return "insert";
    }
    /**
     * Total offset size of inserted nodes.
     */
    get howMany() {
      return this.nodes.maxOffset;
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      return this.position.clone();
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     */
    clone() {
      const e = new On([...this.nodes].map((i) => i._clone(!0))), t = new be(this.position, e, this.baseVersion);
      return t.shouldReceiveAttributes = this.shouldReceiveAttributes, t;
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      const e = this.position.root.document.graveyard, t = new C(e, [0]);
      return new H(this.position, this.nodes.maxOffset, t, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _validate() {
      const e = this.position.parent;
      if (!e || e.maxOffset < this.position.offset)
        throw new g("insert-operation-position-invalid", this);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      const e = this.nodes;
      this.nodes = new On([...e].map((t) => t._clone(!0))), Cl(this.position, e);
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return e.position = this.position.toJSON(), e.nodes = this.nodes.toJSON(), e;
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "InsertOperation";
    }
    /**
     * Creates `InsertOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      const i = [];
      for (const o of e.nodes)
        o.name ? i.push(W.fromJSON(o)) : i.push(j.fromJSON(o));
      const s = new be(C.fromJSON(e.position, t), i, e.baseVersion);
      return s.shouldReceiveAttributes = e.shouldReceiveAttributes, s;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class K extends qe {
    /**
     * Creates a split operation.
     *
     * @param splitPosition Position at which an element should be split.
     * @param howMany Total offset size of elements that are in the split element after `position`.
     * @param insertionPosition Position at which the clone of split element (or element from graveyard) will be inserted.
     * @param graveyardPosition Position in the graveyard root before the element which
     * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e, t, i, s, o) {
      super(o), this.splitPosition = e.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t, this.insertionPosition = i, this.graveyardPosition = s ? s.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
    }
    /**
     * @inheritDoc
     */
    get type() {
      return "split";
    }
    /**
     * Position inside the new clone of a split element.
     *
     * This is a position where nodes that are after the split position will be moved to.
     */
    get moveTargetPosition() {
      const e = this.insertionPosition.path.slice();
      return e.push(0), new C(this.insertionPosition.root, e);
    }
    /**
     * Artificial range that contains all the nodes from the split element that will be moved to the new element.
     * The range starts at {@link #splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
     */
    get movedRange() {
      const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
      return new _(this.splitPosition, e);
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      const e = [
        _._createFromPositionAndShift(this.splitPosition, 0),
        _._createFromPositionAndShift(this.insertionPosition, 0)
      ];
      return this.graveyardPosition && e.push(_._createFromPositionAndShift(this.graveyardPosition, 0)), e;
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns Clone of this operation.
     */
    clone() {
      return new K(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      const e = this.splitPosition.root.document.graveyard, t = new C(e, [0]);
      return new oe(this.moveTargetPosition, this.howMany, this.splitPosition, t, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _validate() {
      const e = this.splitPosition.parent, t = this.splitPosition.offset;
      if (!e || e.maxOffset < t)
        throw new g("split-operation-position-invalid", this);
      if (e.parent) {
        if (this.howMany != e.maxOffset - this.splitPosition.offset)
          throw new g("split-operation-how-many-invalid", this);
        if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
          throw new g("split-operation-graveyard-position-invalid", this);
      } else
        throw new g("split-operation-split-in-root", this);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      const e = this.splitPosition.parent;
      if (this.graveyardPosition)
        es(_._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
      else {
        const i = e._clone();
        Cl(this.insertionPosition, i);
      }
      const t = new _(C._createAt(e, this.splitPosition.offset), C._createAt(e, e.maxOffset));
      es(t, this.moveTargetPosition);
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return e.splitPosition = this.splitPosition.toJSON(), e.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()), e;
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "SplitOperation";
    }
    /**
     * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion
     * position is after the split element.
     */
    static getInsertionPosition(e) {
      const t = e.path.slice(0, -1);
      return t[t.length - 1]++, new C(e.root, t, "toPrevious");
    }
    /**
     * Creates `SplitOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      const i = C.fromJSON(e.splitPosition, t), s = C.fromJSON(e.insertionPosition, t), o = e.graveyardPosition ? C.fromJSON(e.graveyardPosition, t) : null;
      return new this(i, e.howMany, s, o, e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class oe extends qe {
    /**
     * Creates a merge operation.
     *
     * @param sourcePosition Position inside the merged element. All nodes from that
     * element after that position will be moved to {@link #targetPosition}.
     * @param howMany Summary offset size of nodes which will be moved from the merged element to the new parent.
     * @param targetPosition Position which the nodes from the merged elements will be moved to.
     * @param graveyardPosition Position in graveyard to which the merged element will be moved.
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e, t, i, s, o) {
      super(o), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t, this.targetPosition = i.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = s.clone();
    }
    /**
     * @inheritDoc
     */
    get type() {
      return "merge";
    }
    /**
     * Position before the merged element (which will be deleted).
     */
    get deletionPosition() {
      return new C(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
    }
    /**
     * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.
     * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
     */
    get movedRange() {
      const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
      return new _(this.sourcePosition, e);
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      const e = this.sourcePosition.parent;
      return [
        _._createOn(e),
        // These could be positions but `Selectable` type only supports `Iterable<Range>`.
        _._createFromPositionAndShift(this.targetPosition, 0),
        _._createFromPositionAndShift(this.graveyardPosition, 0)
      ];
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     */
    clone() {
      return new oe(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      const e = this.targetPosition._getTransformedByMergeOperation(this), t = this.sourcePosition.path.slice(0, -1), i = new C(this.sourcePosition.root, t)._getTransformedByMergeOperation(this);
      return new K(e, this.howMany, i, this.graveyardPosition, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _validate() {
      const e = this.sourcePosition.parent, t = this.targetPosition.parent;
      if (e.parent)
        if (t.parent) {
          if (this.howMany != e.maxOffset)
            throw new g("merge-operation-how-many-invalid", this);
        } else
          throw new g("merge-operation-target-position-invalid", this);
      else
        throw new g("merge-operation-source-position-invalid", this);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      const e = this.sourcePosition.parent, t = _._createIn(e);
      es(t, this.targetPosition), es(_._createOn(e), this.graveyardPosition);
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return e.sourcePosition = e.sourcePosition.toJSON(), e.targetPosition = e.targetPosition.toJSON(), e.graveyardPosition = e.graveyardPosition.toJSON(), e;
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "MergeOperation";
    }
    /**
     * Creates `MergeOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      const i = C.fromJSON(e.sourcePosition, t), s = C.fromJSON(e.targetPosition, t), o = C.fromJSON(e.graveyardPosition, t);
      return new this(i, e.howMany, s, o, e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Re extends qe {
    /**
     * @param name Marker name.
     * @param oldRange Marker range before the change.
     * @param newRange Marker range after the change.
     * @param markers Marker collection on which change should be executed.
     * @param affectsData Specifies whether the marker operation affects the data produced by the data pipeline
     * (is persisted in the editor's data).
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e, t, i, s, o, r) {
      super(r), this.name = e, this.oldRange = t ? t.clone() : null, this.newRange = i ? i.clone() : null, this.affectsData = o, this._markers = s;
    }
    /**
     * @inheritDoc
     */
    get type() {
      return "marker";
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      const e = [];
      return this.oldRange && e.push(this.oldRange.clone()), this.newRange && (this.oldRange ? e.push(...this.newRange.getDifference(this.oldRange)) : e.push(this.newRange.clone())), e;
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     */
    clone() {
      return new Re(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      return new Re(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name);
    }
    /**
     * @inheritDoc
     * @internal
     */
    toJSON() {
      const e = super.toJSON();
      return this.oldRange && (e.oldRange = this.oldRange.toJSON()), this.newRange && (e.newRange = this.newRange.toJSON()), delete e._markers, e;
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "MarkerOperation";
    }
    /**
     * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      return new Re(e.name, e.oldRange ? _.fromJSON(e.oldRange, t) : null, e.newRange ? _.fromJSON(e.newRange, t) : null, t.model.markers, e.affectsData, e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ae extends qe {
    /**
     * Creates an operation that changes, removes or adds attributes.
     *
     * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
     * have an attribute with the same key as the added attribute.
     *
     * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
     * must have an attribute with that key added.
     *
     * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
     * operation's ranges must already have an attribute with given key and `oldValue` as value
     *
     * @param range Range on which the operation should be applied. Must be a flat range.
     * @param key Key of an attribute to change or remove.
     * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
     * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e, t, i, s, o) {
      super(o), this.range = e.clone(), this.key = t, this.oldValue = i === void 0 ? null : i, this.newValue = s === void 0 ? null : s;
    }
    /**
     * @inheritDoc
     */
    get type() {
      return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute";
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      return this.range.clone();
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     */
    clone() {
      return new ae(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      return new ae(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return e.range = this.range.toJSON(), e;
    }
    /**
     * @inheritDoc
     * @internal
     */
    _validate() {
      if (!this.range.isFlat)
        throw new g("attribute-operation-range-not-flat", this);
      for (const e of this.range.getItems({ shallow: !0 })) {
        if (this.oldValue !== null && !_o(e.getAttribute(this.key), this.oldValue))
          throw new g("attribute-operation-wrong-old-value", this, { item: e, key: this.key, value: this.oldValue });
        if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key))
          throw new g("attribute-operation-attribute-exists", this, { node: e, key: this.key });
      }
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      _o(this.oldValue, this.newValue) || y2(this.range, this.key, this.newValue);
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "AttributeOperation";
    }
    /**
     * Creates `AttributeOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      return new ae(_.fromJSON(e.range, t), e.key, e.oldValue, e.newValue, e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ue extends qe {
    get type() {
      return "noop";
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      return null;
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     */
    clone() {
      return new ue(this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      return new ue(this.baseVersion + 1);
    }
    /** @internal */
    _execute() {
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "NoOperation";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Le extends qe {
    /**
     * Creates an operation that changes element's name.
     *
     * @param position Position before an element to change.
     * @param oldName Current name of the element.
     * @param newName New name for the element.
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e, t, i, s) {
      super(s), this.position = e, this.position.stickiness = "toNext", this.oldName = t, this.newName = i;
    }
    /**
     * @inheritDoc
     */
    get type() {
      return "rename";
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      return this.position.nodeAfter;
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns Clone of this operation.
     */
    clone() {
      return new Le(this.position.clone(), this.oldName, this.newName, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      return new Le(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _validate() {
      const e = this.position.nodeAfter;
      if (e instanceof W) {
        if (e.name !== this.oldName)
          throw new g("rename-operation-wrong-name", this);
      } else
        throw new g("rename-operation-wrong-position", this);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      const e = this.position.nodeAfter;
      e.name = this.newName;
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return e.position = this.position.toJSON(), e;
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "RenameOperation";
    }
    /**
     * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      return new Le(C.fromJSON(e.position, t), e.oldName, e.newName, e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class It extends qe {
    /**
     * Creates an operation that changes, removes or adds attributes on root element.
     *
     * @see module:engine/model/operation/attributeoperation~AttributeOperation
     * @param root Root element to change.
     * @param key Key of an attribute to change or remove.
     * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
     * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
     * can be applied or `null` if the operation operates on detached (non-document) tree.
     */
    constructor(e, t, i, s, o) {
      super(o), this.root = e, this.key = t, this.oldValue = i === void 0 ? null : i, this.newValue = s === void 0 ? null : s;
    }
    /**
     * @inheritDoc
     */
    get type() {
      return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute";
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      return this.root;
    }
    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns Clone of this operation.
     */
    clone() {
      return new It(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     */
    getReversed() {
      return new It(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _validate() {
      if (this.root != this.root.root || this.root.is("documentFragment"))
        throw new g("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
      if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue)
        throw new g("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
      if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key))
        throw new g("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return e.root = this.root.toJSON(), e;
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "RootAttributeOperation";
    }
    /**
     * Creates `RootAttributeOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      if (!t.getRoot(e.root))
        throw new g("rootattribute-operation-fromjson-no-root", this, { rootName: e.root });
      return new It(t.getRoot(e.root), e.key, e.oldValue, e.newValue, e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class gt extends qe {
    /**
     * Creates an operation that creates or removes a root element.
     *
     * @param rootName Root name to create or detach.
     * @param elementName Root element name.
     * @param isAdd Specifies whether the operation adds (`true`) or detaches the root (`false`).
     * @param document Document which owns the root.
     * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation can be applied.
     */
    constructor(e, t, i, s, o) {
      if (super(o), this.rootName = e, this.elementName = t, this.isAdd = i, this._document = s, !this._document.getRoot(this.rootName)) {
        const r = this._document.createRoot(this.elementName, this.rootName);
        r._isAttached = !1;
      }
    }
    /**
     * @inheritDoc
     */
    get type() {
      return this.isAdd ? "addRoot" : "detachRoot";
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      return this._document.getRoot(this.rootName);
    }
    /**
     * @inheritDoc
     */
    clone() {
      return new gt(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
    }
    /**
     * @inheritDoc
     */
    getReversed() {
      return new gt(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */
    _execute() {
      this._document.getRoot(this.rootName)._isAttached = this.isAdd;
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return delete e._document, e;
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "RootOperation";
    }
    /**
     * Creates `RootOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      return new gt(e.rootName, e.elementName, e.isAdd, t, e.baseVersion);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Qe = {};
  Qe[ae.className] = ae;
  Qe[be.className] = be;
  Qe[Re.className] = Re;
  Qe[H.className] = H;
  Qe[ue.className] = ue;
  Qe[qe.className] = qe;
  Qe[Le.className] = Le;
  Qe[It.className] = It;
  Qe[gt.className] = gt;
  Qe[K.className] = K;
  Qe[oe.className] = oe;
  class C2 {
    /**
     * Creates an operation instance from a JSON object (parsed JSON string).
     *
     * @param json Deserialized JSON object.
     * @param document Document on which this operation will be applied.
     */
    static fromJSON(e, t) {
      return Qe[e.__className].fromJSON(e, t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const pa = /* @__PURE__ */ new Map();
  function U(n, e, t) {
    let i = pa.get(n);
    i || (i = /* @__PURE__ */ new Map(), pa.set(n, i)), i.set(e, t);
  }
  function k2(n, e) {
    const t = pa.get(n);
    return t && t.has(e) ? t.get(e) : T2;
  }
  function T2(n) {
    return [n];
  }
  function yu(n, e, t = {}) {
    const i = k2(n.constructor, e.constructor);
    try {
      return n = n.clone(), i(n, e, t);
    } catch (s) {
      throw s;
    }
  }
  function E2(n, e, t) {
    n = n.slice(), e = e.slice();
    const i = new A2(t.document, t.useRelations, t.forceWeakRemove);
    i.setOriginalOperations(n), i.setOriginalOperations(e);
    const s = i.originalOperations;
    if (n.length == 0 || e.length == 0)
      return { operationsA: n, operationsB: e, originalOperations: s };
    const o = /* @__PURE__ */ new WeakMap();
    for (const l of n)
      o.set(l, 0);
    const r = {
      nextBaseVersionA: n[n.length - 1].baseVersion + 1,
      nextBaseVersionB: e[e.length - 1].baseVersion + 1,
      originalOperationsACount: n.length,
      originalOperationsBCount: e.length
    };
    let a = 0;
    for (; a < n.length; ) {
      const l = n[a], c = o.get(l);
      if (c == e.length) {
        a++;
        continue;
      }
      const u = e[c], d = yu(l, u, i.getContext(l, u, !0)), h = yu(u, l, i.getContext(u, l, !1));
      i.updateRelation(l, u), i.setOriginalOperations(d, l), i.setOriginalOperations(h, u);
      for (const f of d)
        o.set(f, c + h.length);
      n.splice(a, 1, ...d), e.splice(c, 1, ...h);
    }
    if (t.padWithNoOps) {
      const l = n.length - r.originalOperationsACount, c = e.length - r.originalOperationsBCount;
      ku(n, c - l), ku(e, l - c);
    }
    return Cu(n, r.nextBaseVersionB), Cu(e, r.nextBaseVersionA), { operationsA: n, operationsB: e, originalOperations: s };
  }
  class A2 {
    /**
     * Creates `ContextFactory` instance.
     *
     * @param document Document which the operations change.
     * @param useRelations Whether during transformation relations should be used (used during undo for
     * better conflict resolution).
     * @param forceWeakRemove If set to `false`, remove operation will be always stronger than move operation,
     * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.
     */
    constructor(e, t, i = !1) {
      this.originalOperations = /* @__PURE__ */ new Map(), this._history = e.history, this._useRelations = t, this._forceWeakRemove = !!i, this._relations = /* @__PURE__ */ new Map();
    }
    /**
     * Sets "original operation" for given operations.
     *
     * During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two
     * or multiple operations. When gathering additional data it is important that all operations can be somehow linked
     * so a cloned and transformed "version" still kept track of the data assigned earlier to it.
     *
     * The original operation object will be used as such an universal linking id. Throughout the transformation process
     * all cloned operations will refer to "the original operation" when storing and reading additional data.
     *
     * If `takeFrom` is not set, each operation from `operations` array will be assigned itself as "the original operation".
     * This should be used as an initialization step.
     *
     * If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned
     * for `takeFrom` operation. This should be used to update original operations. It should be used in a way that
     * `operations` are the result of `takeFrom` transformation to ensure proper "original operation propagation".
     */
    setOriginalOperations(e, t = null) {
      const i = t ? this.originalOperations.get(t) : null;
      for (const s of e)
        this.originalOperations.set(s, i || s);
    }
    /**
     * Saves a relation between operations `opA` and `opB`.
     *
     * Relations are then later used to help solve conflicts when operations are transformed.
     */
    updateRelation(e, t) {
      if (e instanceof H)
        t instanceof oe ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof H && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter"));
      else if (e instanceof K) {
        if (t instanceof oe)
          e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore");
        else if (t instanceof H)
          if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition))
            this._setRelation(e, t, "splitBefore");
          else {
            const i = _._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (e.splitPosition.hasSameParentAs(t.sourcePosition) && i.containsPosition(e.splitPosition)) {
              const s = i.end.offset - e.splitPosition.offset, o = e.splitPosition.offset - i.start.offset;
              this._setRelation(e, t, { howMany: s, offset: o });
            }
          }
      } else if (e instanceof oe)
        t instanceof oe ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"), e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"), e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof K ? e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource") : t instanceof H && t.howMany > 0 && (e.sourcePosition.isEqual(t.sourcePosition.getShiftedBy(t.howMany)) && this._setRelation(e, t, "mergeSourceAffected"), e.targetPosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeTargetWasBefore"));
      else if (e instanceof Re) {
        const i = e.newRange;
        if (!i)
          return;
        if (t instanceof H) {
          const s = _._createFromPositionAndShift(t.sourcePosition, t.howMany), o = s.containsPosition(i.start) || s.start.isEqual(i.start), r = s.containsPosition(i.end) || s.end.isEqual(i.end);
          (o || r) && !s.containsRange(i) && this._setRelation(e, t, {
            side: o ? "left" : "right",
            path: o ? i.start.path.slice() : i.end.path.slice()
          });
        } else if (t instanceof oe) {
          const s = i.start.isEqual(t.targetPosition), o = i.start.isEqual(t.deletionPosition), r = i.end.isEqual(t.deletionPosition), a = i.end.isEqual(t.sourcePosition);
          (s || o || r || a) && this._setRelation(e, t, {
            wasInLeftElement: s,
            wasStartBeforeMergedElement: o,
            wasEndBeforeMergedElement: r,
            wasInRightElement: a
          });
        }
      }
    }
    /**
     * Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.
     */
    getContext(e, t, i) {
      return {
        aIsStrong: i,
        aWasUndone: this._wasUndone(e),
        bWasUndone: this._wasUndone(t),
        abRelation: this._useRelations ? this._getRelation(e, t) : null,
        baRelation: this._useRelations ? this._getRelation(t, e) : null,
        forceWeakRemove: this._forceWeakRemove
      };
    }
    /**
     * Returns whether given operation `op` has already been undone.
     *
     * Information whether an operation was undone gives more context when making a decision when two operations are in conflict.
     */
    _wasUndone(e) {
      const t = this.originalOperations.get(e);
      return t.wasUndone || this._history.isUndoneOperation(t);
    }
    /**
     * Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation
     * was set earlier or `null` if there was no relation between those operations.
     *
     * This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.
     *
     * When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the
     * undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,
     * we look forward in the future and ask if in that future `opB` was undone.
     *
     * Relations is a backward process to `wasUndone()`.
     *
     * Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing
     * operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is
     * a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation
     * between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make
     * a better decision when resolving a conflict between two operations, because we know more about the context of
     * those two operations.
     *
     * This is why this function does not return a relation directly between `opA` and `opB` because we need to look
     * back to search for a meaningful contextual information.
     */
    _getRelation(e, t) {
      const i = this.originalOperations.get(t), s = this._history.getUndoneOperation(i);
      if (!s)
        return null;
      const o = this.originalOperations.get(e), r = this._relations.get(o);
      return r && r.get(s) || null;
    }
    /**
     * Helper function for `ContextFactory#updateRelations`.
     */
    _setRelation(e, t, i) {
      const s = this.originalOperations.get(e), o = this.originalOperations.get(t);
      let r = this._relations.get(s);
      r || (r = /* @__PURE__ */ new Map(), this._relations.set(s, r)), r.set(o, i);
    }
  }
  function Cu(n, e) {
    for (const t of n)
      t.baseVersion = e++;
  }
  function ku(n, e) {
    for (let t = 0; t < e; t++)
      n.push(new ue(0));
  }
  U(ae, ae, (n, e, t) => {
    if (n.key === e.key && n.range.start.hasSameParentAs(e.range.start)) {
      const i = n.range.getDifference(e.range).map((o) => new ae(o, n.key, n.oldValue, n.newValue, 0)), s = n.range.getIntersection(e.range);
      return s && t.aIsStrong && i.push(new ae(s, e.key, e.newValue, n.newValue, 0)), i.length == 0 ? [new ue(0)] : i;
    } else
      return [n];
  });
  U(ae, be, (n, e) => {
    if (n.range.start.hasSameParentAs(e.position) && n.range.containsPosition(e.position)) {
      const i = n.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map((s) => new ae(s, n.key, n.oldValue, n.newValue, n.baseVersion));
      if (e.shouldReceiveAttributes) {
        const s = Km(e, n.key, n.oldValue);
        s && i.unshift(s);
      }
      return i;
    }
    return n.range = n.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [n];
  });
  function Km(n, e, t) {
    const s = n.nodes.getNode(0).getAttribute(e);
    if (s == t)
      return null;
    const o = new _(n.position, n.position.getShiftedBy(n.howMany));
    return new ae(o, e, s, t, 0);
  }
  U(ae, oe, (n, e) => {
    const t = [];
    n.range.start.hasSameParentAs(e.deletionPosition) && (n.range.containsPosition(e.deletionPosition) || n.range.start.isEqual(e.deletionPosition)) && t.push(_._createFromPositionAndShift(e.graveyardPosition, 1));
    const i = n.range._getTransformedByMergeOperation(e);
    return i.isCollapsed || t.push(i), t.map((s) => new ae(s, n.key, n.oldValue, n.newValue, n.baseVersion));
  });
  U(ae, H, (n, e) => x2(n.range, e).map((i) => new ae(i, n.key, n.oldValue, n.newValue, n.baseVersion)));
  function x2(n, e) {
    const t = _._createFromPositionAndShift(e.sourcePosition, e.howMany);
    let i = null, s = [];
    t.containsRange(n, !0) ? i = n : n.start.hasSameParentAs(t.start) ? (s = n.getDifference(t), i = n.getIntersection(t)) : s = [n];
    const o = [];
    for (let r of s) {
      r = r._getTransformedByDeletion(e.sourcePosition, e.howMany);
      const a = e.getMovedRangeStart(), l = r.start.hasSameParentAs(a), c = r._getTransformedByInsertion(a, e.howMany, l);
      o.push(...c);
    }
    return i && o.push(i._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, !1)[0]), o;
  }
  U(ae, K, (n, e) => {
    if (n.range.end.isEqual(e.insertionPosition))
      return e.graveyardPosition || n.range.end.offset++, [n];
    if (n.range.start.hasSameParentAs(e.splitPosition) && n.range.containsPosition(e.splitPosition)) {
      const t = n.clone();
      return t.range = new _(e.moveTargetPosition.clone(), n.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), n.range.end = e.splitPosition.clone(), n.range.end.stickiness = "toPrevious", [n, t];
    }
    return n.range = n.range._getTransformedBySplitOperation(e), [n];
  });
  U(be, ae, (n, e) => {
    const t = [n];
    if (n.shouldReceiveAttributes && n.position.hasSameParentAs(e.range.start) && e.range.containsPosition(n.position)) {
      const i = Km(n, e.key, e.newValue);
      i && t.push(i);
    }
    return t;
  });
  U(be, be, (n, e, t) => n.position.isEqual(e.position) && t.aIsStrong ? [n] : (n.position = n.position._getTransformedByInsertOperation(e), [n]));
  U(be, H, (n, e) => (n.position = n.position._getTransformedByMoveOperation(e), [n]));
  U(be, K, (n, e) => (n.position = n.position._getTransformedBySplitOperation(e), [n]));
  U(be, oe, (n, e) => (n.position = n.position._getTransformedByMergeOperation(e), [n]));
  U(Re, be, (n, e) => (n.oldRange && (n.oldRange = n.oldRange._getTransformedByInsertOperation(e)[0]), n.newRange && (n.newRange = n.newRange._getTransformedByInsertOperation(e)[0]), [n]));
  U(Re, Re, (n, e, t) => {
    if (n.name == e.name)
      if (t.aIsStrong)
        n.oldRange = e.newRange ? e.newRange.clone() : null;
      else
        return [new ue(0)];
    return [n];
  });
  U(Re, oe, (n, e) => (n.oldRange && (n.oldRange = n.oldRange._getTransformedByMergeOperation(e)), n.newRange && (n.newRange = n.newRange._getTransformedByMergeOperation(e)), [n]));
  U(Re, H, (n, e, t) => {
    if (n.oldRange && (n.oldRange = _._createFromRanges(n.oldRange._getTransformedByMoveOperation(e))), n.newRange) {
      if (t.abRelation) {
        const i = _._createFromRanges(n.newRange._getTransformedByMoveOperation(e));
        if (t.abRelation.side == "left" && e.targetPosition.isEqual(n.newRange.start))
          return n.newRange.end = i.end, n.newRange.start.path = t.abRelation.path, [n];
        if (t.abRelation.side == "right" && e.targetPosition.isEqual(n.newRange.end))
          return n.newRange.start = i.start, n.newRange.end.path = t.abRelation.path, [n];
      }
      n.newRange = _._createFromRanges(n.newRange._getTransformedByMoveOperation(e));
    }
    return [n];
  });
  U(Re, K, (n, e, t) => {
    if (n.oldRange && (n.oldRange = n.oldRange._getTransformedBySplitOperation(e)), n.newRange) {
      if (t.abRelation) {
        const i = n.newRange._getTransformedBySplitOperation(e);
        return n.newRange.start.isEqual(e.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? n.newRange.start = C._createAt(e.insertionPosition) : n.newRange.start.isEqual(e.splitPosition) && !t.abRelation.wasInLeftElement && (n.newRange.start = C._createAt(e.moveTargetPosition)), n.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasInRightElement ? n.newRange.end = C._createAt(e.moveTargetPosition) : n.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? n.newRange.end = C._createAt(e.insertionPosition) : n.newRange.end = i.end, [n];
      }
      n.newRange = n.newRange._getTransformedBySplitOperation(e);
    }
    return [n];
  });
  U(oe, be, (n, e) => (n.sourcePosition.hasSameParentAs(e.position) && (n.howMany += e.howMany), n.sourcePosition = n.sourcePosition._getTransformedByInsertOperation(e), n.targetPosition = n.targetPosition._getTransformedByInsertOperation(e), [n]));
  U(oe, oe, (n, e, t) => {
    if (n.sourcePosition.isEqual(e.sourcePosition) && n.targetPosition.isEqual(e.targetPosition))
      if (t.bWasUndone) {
        const i = e.graveyardPosition.path.slice();
        return i.push(0), n.sourcePosition = new C(e.graveyardPosition.root, i), n.howMany = 0, [n];
      } else
        return [new ue(0)];
    if (n.sourcePosition.isEqual(e.sourcePosition) && !n.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
      const i = n.targetPosition.root.rootName == "$graveyard", s = e.targetPosition.root.rootName == "$graveyard";
      if (s && !i || !(i && !s) && t.aIsStrong) {
        const l = e.targetPosition._getTransformedByMergeOperation(e), c = n.targetPosition._getTransformedByMergeOperation(e);
        return [new H(l, n.howMany, c, 0)];
      } else
        return [new ue(0)];
    }
    return n.sourcePosition.hasSameParentAs(e.targetPosition) && (n.howMany += e.howMany), n.sourcePosition = n.sourcePosition._getTransformedByMergeOperation(e), n.targetPosition = n.targetPosition._getTransformedByMergeOperation(e), (!n.graveyardPosition.isEqual(e.graveyardPosition) || !t.aIsStrong) && (n.graveyardPosition = n.graveyardPosition._getTransformedByMergeOperation(e)), [n];
  });
  U(oe, H, (n, e, t) => {
    const i = _._createFromPositionAndShift(e.sourcePosition, e.howMany);
    return e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && n.deletionPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(n.sourcePosition) ? [new ue(0)] : (e.sourcePosition.getShiftedBy(e.howMany).isEqual(n.sourcePosition) ? n.sourcePosition.stickiness = "toNone" : e.targetPosition.isEqual(n.sourcePosition) && t.abRelation == "mergeSourceAffected" ? n.sourcePosition.stickiness = "toNext" : e.sourcePosition.isEqual(n.targetPosition) ? (n.targetPosition.stickiness = "toNone", n.howMany -= e.howMany) : e.targetPosition.isEqual(n.targetPosition) && t.abRelation == "mergeTargetWasBefore" ? (n.targetPosition.stickiness = "toPrevious", n.howMany += e.howMany) : (n.sourcePosition.hasSameParentAs(e.targetPosition) && (n.howMany += e.howMany), n.sourcePosition.hasSameParentAs(e.sourcePosition) && (n.howMany -= e.howMany)), n.sourcePosition = n.sourcePosition._getTransformedByMoveOperation(e), n.targetPosition = n.targetPosition._getTransformedByMoveOperation(e), n.sourcePosition.stickiness = "toPrevious", n.targetPosition.stickiness = "toNext", n.graveyardPosition.isEqual(e.targetPosition) || (n.graveyardPosition = n.graveyardPosition._getTransformedByMoveOperation(e)), [n]);
  });
  U(oe, K, (n, e, t) => {
    if (e.graveyardPosition && (n.graveyardPosition = n.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), n.deletionPosition.isEqual(e.graveyardPosition) && (n.howMany = e.howMany)), n.targetPosition.isEqual(e.splitPosition)) {
      const i = e.howMany != 0, s = e.graveyardPosition && n.deletionPosition.isEqual(e.graveyardPosition);
      if (i || s || t.abRelation == "mergeTargetNotMoved")
        return n.sourcePosition = n.sourcePosition._getTransformedBySplitOperation(e), [n];
    }
    if (n.sourcePosition.isEqual(e.splitPosition)) {
      if (t.abRelation == "mergeSourceNotMoved")
        return n.howMany = 0, n.targetPosition = n.targetPosition._getTransformedBySplitOperation(e), [n];
      if (t.abRelation == "mergeSameElement" || n.sourcePosition.offset > 0)
        return n.sourcePosition = e.moveTargetPosition.clone(), n.targetPosition = n.targetPosition._getTransformedBySplitOperation(e), [n];
    }
    return n.sourcePosition.hasSameParentAs(e.splitPosition) && (n.howMany = e.splitPosition.offset), n.sourcePosition = n.sourcePosition._getTransformedBySplitOperation(e), n.targetPosition = n.targetPosition._getTransformedBySplitOperation(e), [n];
  });
  U(H, be, (n, e) => {
    const i = _._createFromPositionAndShift(n.sourcePosition, n.howMany)._getTransformedByInsertOperation(e, !1)[0];
    return n.sourcePosition = i.start, n.howMany = i.end.offset - i.start.offset, n.targetPosition.isEqual(e.position) || (n.targetPosition = n.targetPosition._getTransformedByInsertOperation(e)), [n];
  });
  U(H, H, (n, e, t) => {
    const i = _._createFromPositionAndShift(n.sourcePosition, n.howMany), s = _._createFromPositionAndShift(e.sourcePosition, e.howMany);
    let o = t.aIsStrong, r = !t.aIsStrong;
    t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? r = !0 : (t.abRelation == "insertAfter" || t.baRelation == "insertBefore") && (r = !1);
    let a;
    if (n.targetPosition.isEqual(e.targetPosition) && r ? a = n.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : a = n.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Tu(n, e) && Tu(e, n))
      return [e.getReversed()];
    if (i.containsPosition(e.targetPosition) && i.containsRange(s, !0))
      return i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), qi([i], a);
    if (s.containsPosition(n.targetPosition) && s.containsRange(i, !0))
      return i.start = i.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), qi([i], a);
    const u = Ee(n.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
    if (u == "prefix" || u == "extension")
      return i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), qi([i], a);
    n.type == "remove" && e.type != "remove" && !t.aWasUndone && !t.forceWeakRemove ? o = !0 : n.type != "remove" && e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && (o = !1);
    const d = [], h = i.getDifference(s);
    for (const m of h) {
      m.start = m.start._getTransformedByDeletion(e.sourcePosition, e.howMany), m.end = m.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
      const p = Ee(m.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same", b = m._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, p);
      d.push(...b);
    }
    const f = i.getIntersection(s);
    return f !== null && o && (f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), d.length === 0 ? d.push(f) : d.length == 1 ? s.start.isBefore(i.start) || s.start.isEqual(i.start) ? d.unshift(f) : d.push(f) : d.splice(1, 0, f)), d.length === 0 ? [new ue(n.baseVersion)] : qi(d, a);
  });
  U(H, K, (n, e, t) => {
    let i = n.targetPosition.clone();
    (!n.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || t.abRelation == "moveTargetAfter") && (i = n.targetPosition._getTransformedBySplitOperation(e));
    const s = _._createFromPositionAndShift(n.sourcePosition, n.howMany);
    if (s.end.isEqual(e.insertionPosition))
      return e.graveyardPosition || n.howMany++, n.targetPosition = i, [n];
    if (s.start.hasSameParentAs(e.splitPosition) && s.containsPosition(e.splitPosition)) {
      let a = new _(e.splitPosition, s.end);
      a = a._getTransformedBySplitOperation(e);
      const l = [
        new _(s.start, e.splitPosition),
        a
      ];
      return qi(l, i);
    }
    n.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (i = e.moveTargetPosition), n.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (i = n.targetPosition);
    const r = [s._getTransformedBySplitOperation(e)];
    if (e.graveyardPosition) {
      const a = s.start.isEqual(e.graveyardPosition) || s.containsPosition(e.graveyardPosition);
      n.howMany > 1 && a && !t.aWasUndone && r.push(_._createFromPositionAndShift(e.insertionPosition, 1));
    }
    return qi(r, i);
  });
  U(H, oe, (n, e, t) => {
    const i = _._createFromPositionAndShift(n.sourcePosition, n.howMany);
    if (e.deletionPosition.hasSameParentAs(n.sourcePosition) && i.containsPosition(e.sourcePosition)) {
      if (n.type == "remove" && !t.forceWeakRemove) {
        if (!t.aWasUndone) {
          const r = [];
          let a = e.graveyardPosition.clone(), l = e.targetPosition._getTransformedByMergeOperation(e);
          n.howMany > 1 && (r.push(new H(n.sourcePosition, n.howMany - 1, n.targetPosition, 0)), a = a._getTransformedByMove(n.sourcePosition, n.targetPosition, n.howMany - 1), l = l._getTransformedByMove(n.sourcePosition, n.targetPosition, n.howMany - 1));
          const c = e.deletionPosition._getCombined(n.sourcePosition, n.targetPosition), u = new H(a, 1, c, 0), d = u.getMovedRangeStart().path.slice();
          d.push(0);
          const h = new C(u.targetPosition.root, d);
          l = l._getTransformedByMove(a, c, 1);
          const f = new H(l, e.howMany, h, 0);
          return r.push(u), r.push(f), r;
        }
      } else if (n.howMany == 1)
        return t.bWasUndone ? (n.sourcePosition = e.graveyardPosition.clone(), n.targetPosition = n.targetPosition._getTransformedByMergeOperation(e), [n]) : [new ue(0)];
    }
    const o = _._createFromPositionAndShift(n.sourcePosition, n.howMany)._getTransformedByMergeOperation(e);
    return n.sourcePosition = o.start, n.howMany = o.end.offset - o.start.offset, n.targetPosition = n.targetPosition._getTransformedByMergeOperation(e), [n];
  });
  U(Le, be, (n, e) => (n.position = n.position._getTransformedByInsertOperation(e), [n]));
  U(Le, oe, (n, e) => n.position.isEqual(e.deletionPosition) ? (n.position = e.graveyardPosition.clone(), n.position.stickiness = "toNext", [n]) : (n.position = n.position._getTransformedByMergeOperation(e), [n]));
  U(Le, H, (n, e) => (n.position = n.position._getTransformedByMoveOperation(e), [n]));
  U(Le, Le, (n, e, t) => {
    if (n.position.isEqual(e.position))
      if (t.aIsStrong)
        n.oldName = e.newName;
      else
        return [new ue(0)];
    return [n];
  });
  U(Le, K, (n, e) => {
    const t = n.position.path, i = e.splitPosition.getParentPath();
    if (Ee(t, i) == "same" && !e.graveyardPosition) {
      const s = new Le(n.position.getShiftedBy(1), n.oldName, n.newName, 0);
      return [n, s];
    }
    return n.position = n.position._getTransformedBySplitOperation(e), [n];
  });
  U(It, It, (n, e, t) => {
    if (n.root === e.root && n.key === e.key) {
      if (!t.aIsStrong || n.newValue === e.newValue)
        return [new ue(0)];
      n.oldValue = e.newValue;
    }
    return [n];
  });
  U(gt, gt, (n, e) => n.rootName === e.rootName && n.isAdd === e.isAdd ? [new ue(0)] : [n]);
  U(K, be, (n, e) => (n.splitPosition.hasSameParentAs(e.position) && n.splitPosition.offset < e.position.offset && (n.howMany += e.howMany), n.splitPosition = n.splitPosition._getTransformedByInsertOperation(e), n.insertionPosition = n.insertionPosition._getTransformedByInsertOperation(e), [n]));
  U(K, oe, (n, e, t) => {
    if (!n.graveyardPosition && !t.bWasUndone && n.splitPosition.hasSameParentAs(e.sourcePosition)) {
      const i = e.graveyardPosition.path.slice();
      i.push(0);
      const s = new C(e.graveyardPosition.root, i), o = K.getInsertionPosition(new C(e.graveyardPosition.root, i)), r = new K(s, 0, o, null, 0);
      return n.splitPosition = n.splitPosition._getTransformedByMergeOperation(e), n.insertionPosition = K.getInsertionPosition(n.splitPosition), n.graveyardPosition = r.insertionPosition.clone(), n.graveyardPosition.stickiness = "toNext", [r, n];
    }
    return n.splitPosition.hasSameParentAs(e.deletionPosition) && !n.splitPosition.isAfter(e.deletionPosition) && n.howMany--, n.splitPosition.hasSameParentAs(e.targetPosition) && (n.howMany += e.howMany), n.splitPosition = n.splitPosition._getTransformedByMergeOperation(e), n.insertionPosition = K.getInsertionPosition(n.splitPosition), n.graveyardPosition && (n.graveyardPosition = n.graveyardPosition._getTransformedByMergeOperation(e)), [n];
  });
  U(K, H, (n, e, t) => {
    const i = _._createFromPositionAndShift(e.sourcePosition, e.howMany);
    if (n.graveyardPosition) {
      const o = i.start.isEqual(n.graveyardPosition) || i.containsPosition(n.graveyardPosition);
      if (!t.bWasUndone && o) {
        const r = n.splitPosition._getTransformedByMoveOperation(e), a = n.graveyardPosition._getTransformedByMoveOperation(e), l = a.path.slice();
        l.push(0);
        const c = new C(a.root, l);
        return [new H(r, n.howMany, c, 0)];
      }
      n.graveyardPosition = n.graveyardPosition._getTransformedByMoveOperation(e);
    }
    const s = n.splitPosition.isEqual(e.targetPosition);
    if (s && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore"))
      return n.howMany += e.howMany, n.splitPosition = n.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), n.insertionPosition = K.getInsertionPosition(n.splitPosition), [n];
    if (s && t.abRelation && t.abRelation.howMany) {
      const { howMany: o, offset: r } = t.abRelation;
      return n.howMany += o, n.splitPosition = n.splitPosition.getShiftedBy(r), [n];
    }
    if (n.splitPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(n.splitPosition)) {
      const o = e.howMany - (n.splitPosition.offset - e.sourcePosition.offset);
      return n.howMany -= o, n.splitPosition.hasSameParentAs(e.targetPosition) && n.splitPosition.offset < e.targetPosition.offset && (n.howMany += e.howMany), n.splitPosition = e.sourcePosition.clone(), n.insertionPosition = K.getInsertionPosition(n.splitPosition), [n];
    }
    return e.sourcePosition.isEqual(e.targetPosition) || (n.splitPosition.hasSameParentAs(e.sourcePosition) && n.splitPosition.offset <= e.sourcePosition.offset && (n.howMany -= e.howMany), n.splitPosition.hasSameParentAs(e.targetPosition) && n.splitPosition.offset < e.targetPosition.offset && (n.howMany += e.howMany)), n.splitPosition.stickiness = "toNone", n.splitPosition = n.splitPosition._getTransformedByMoveOperation(e), n.splitPosition.stickiness = "toNext", n.graveyardPosition ? n.insertionPosition = n.insertionPosition._getTransformedByMoveOperation(e) : n.insertionPosition = K.getInsertionPosition(n.splitPosition), [n];
  });
  U(K, K, (n, e, t) => {
    if (n.splitPosition.isEqual(e.splitPosition)) {
      if (!n.graveyardPosition && !e.graveyardPosition)
        return [new ue(0)];
      if (n.graveyardPosition && e.graveyardPosition && n.graveyardPosition.isEqual(e.graveyardPosition))
        return [new ue(0)];
      if (t.abRelation == "splitBefore")
        return n.howMany = 0, n.graveyardPosition = n.graveyardPosition._getTransformedBySplitOperation(e), [n];
    }
    if (n.graveyardPosition && e.graveyardPosition && n.graveyardPosition.isEqual(e.graveyardPosition)) {
      const i = n.splitPosition.root.rootName == "$graveyard", s = e.splitPosition.root.rootName == "$graveyard";
      if (s && !i || !(i && !s) && t.aIsStrong) {
        const l = [];
        return e.howMany && l.push(new H(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), n.howMany && l.push(new H(n.splitPosition, n.howMany, n.moveTargetPosition, 0)), l;
      } else
        return [new ue(0)];
    }
    if (n.graveyardPosition && (n.graveyardPosition = n.graveyardPosition._getTransformedBySplitOperation(e)), n.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore")
      return n.howMany++, [n];
    if (e.splitPosition.isEqual(n.insertionPosition) && t.baRelation == "splitBefore") {
      const i = e.insertionPosition.path.slice();
      i.push(0);
      const s = new C(e.insertionPosition.root, i), o = new H(n.insertionPosition, 1, s, 0);
      return [n, o];
    }
    return n.splitPosition.hasSameParentAs(e.splitPosition) && n.splitPosition.offset < e.splitPosition.offset && (n.howMany -= e.howMany), n.splitPosition = n.splitPosition._getTransformedBySplitOperation(e), n.insertionPosition = K.getInsertionPosition(n.splitPosition), [n];
  });
  function Tu(n, e) {
    return n.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null;
  }
  function qi(n, e) {
    const t = [];
    for (let i = 0; i < n.length; i++) {
      const s = n[i], o = new H(s.start, s.end.offset - s.start.offset, e, 0);
      t.push(o);
      for (let r = i + 1; r < n.length; r++)
        n[r] = n[r]._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany)[0];
      e = e._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany);
    }
    return t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class le extends G(C) {
    /**
     * Creates a live position.
     *
     * @see module:engine/model/position~Position
     */
    constructor(e, t, i = "toNone") {
      if (super(e, t, i), !this.root.is("rootElement"))
        throw new g("model-liveposition-root-not-rootelement", e);
      S2.call(this);
    }
    /**
     * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
     * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
     * referring to it).
     */
    detach() {
      this.stopListening();
    }
    /**
     * Creates a {@link module:engine/model/position~Position position instance}, which is equal to this live position.
     */
    toPosition() {
      return new C(this.root, this.path.slice(), this.stickiness);
    }
    /**
     * Creates a `LivePosition` instance that is equal to position.
     */
    static fromPosition(e, t) {
      return new this(e.root, e.path.slice(), t || e.stickiness);
    }
  }
  le.prototype.is = function(n) {
    return n === "livePosition" || n === "model:livePosition" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n == "position" || n === "model:position";
  };
  function S2() {
    this.listenTo(this.root.document.model, "applyOperation", (n, e) => {
      const t = e[0];
      t.isDocumentOperation && I2.call(this, t);
    }, { priority: "low" });
  }
  function I2(n) {
    const e = this.getTransformedByOperation(n);
    if (!this.isEqual(e)) {
      const t = this.toPosition();
      this.path = e.path, this.root = e.root, this.fire("change", t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Li {
    /**
     * Creates a batch instance.
     *
     * @see module:engine/model/model~Model#enqueueChange
     * @see module:engine/model/model~Model#change
     * @param type A set of flags that specify the type of the batch. Batch type can alter how some of the features work
     * when encountering a given `Batch` instance (for example, when a feature listens to applied operations).
     */
    constructor(e = {}) {
      typeof e == "string" && (e = e === "transparent" ? { isUndoable: !1 } : {}, z("batch-constructor-deprecated-string-type"));
      const { isUndoable: t = !0, isLocal: i = !0, isUndo: s = !1, isTyping: o = !1 } = e;
      this.operations = [], this.isUndoable = t, this.isLocal = i, this.isUndo = s, this.isTyping = o;
    }
    /**
     * The type of the batch.
     *
     * **This property has been deprecated and is always set to the `'default'` value.**
     *
     * It can be one of the following values:
     * * `'default'` &ndash; All "normal" batches. This is the most commonly used type.
     * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing
     * changes.
     *
     * @deprecated
     */
    get type() {
      return z("batch-type-deprecated"), "default";
    }
    /**
     * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.
     * If there are no operations in the batch or neither operation has the base version set, it returns `null`.
     */
    get baseVersion() {
      for (const e of this.operations)
        if (e.baseVersion !== null)
          return e.baseVersion;
      return null;
    }
    /**
     * Adds an operation to the batch instance.
     *
     * @param operation An operation to add.
     * @returns The added operation.
     */
    addOperation(e) {
      return e.batch = this, this.operations.push(e), e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class P2 {
    /**
     * Creates a `Differ` instance.
     *
     * @param markerCollection Model's marker collection.
     */
    constructor(e) {
      this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changedRoots = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set(), this._markerCollection = e;
    }
    /**
     * Informs whether there are any changes buffered in `Differ`.
     */
    get isEmpty() {
      return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
    }
    /**
     * Buffers the given operation. An operation has to be buffered before it is executed.
     *
     * @param operationToBuffer An operation to buffer.
     */
    bufferOperation(e) {
      const t = e;
      switch (t.type) {
        case "insert": {
          if (this._isInInsertedElement(t.position.parent))
            return;
          this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
          break;
        }
        case "addAttribute":
        case "removeAttribute":
        case "changeAttribute": {
          for (const i of t.range.getItems({ shallow: !0 }))
            this._isInInsertedElement(i.parent) || this._markAttribute(i);
          break;
        }
        case "remove":
        case "move":
        case "reinsert": {
          if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition))
            return;
          const i = this._isInInsertedElement(t.sourcePosition.parent), s = this._isInInsertedElement(t.targetPosition.parent);
          i || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), s || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
          break;
        }
        case "rename": {
          if (this._isInInsertedElement(t.position.parent))
            return;
          this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
          const i = _._createFromPositionAndShift(t.position, 1);
          for (const s of this._markerCollection.getMarkersIntersectingRange(i)) {
            const o = s.getData();
            this.bufferMarkerChange(s.name, o, o);
          }
          break;
        }
        case "split": {
          const i = t.splitPosition.parent;
          this._isInInsertedElement(i) || this._markRemove(i, t.splitPosition.offset, t.howMany), this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
          break;
        }
        case "merge": {
          const i = t.sourcePosition.parent;
          this._isInInsertedElement(i.parent) || this._markRemove(i.parent, i.startOffset, 1);
          const s = t.graveyardPosition.parent;
          this._markInsert(s, t.graveyardPosition.offset, 1);
          const o = t.targetPosition.parent;
          this._isInInsertedElement(o) || this._markInsert(o, t.targetPosition.offset, i.maxOffset);
          break;
        }
        case "detachRoot":
        case "addRoot": {
          const i = t.affectedSelectable;
          if (!i._isLoaded || i.isAttached() == t.isAdd)
            return;
          this._bufferRootStateChange(t.rootName, t.isAdd);
          break;
        }
        case "addRootAttribute":
        case "removeRootAttribute":
        case "changeRootAttribute": {
          if (!t.root._isLoaded)
            return;
          const i = t.root.rootName;
          this._bufferRootAttributeChange(i, t.key, t.oldValue, t.newValue);
          break;
        }
      }
      this._cachedChanges = null;
    }
    /**
     * Buffers a marker change.
     *
     * @param markerName The name of the marker that changed.
     * @param oldMarkerData Marker data before the change.
     * @param newMarkerData Marker data after the change.
     */
    bufferMarkerChange(e, t, i) {
      t.range && t.range.root.is("rootElement") && !t.range.root._isLoaded && (t.range = null), i.range && i.range.root.is("rootElement") && !i.range.root._isLoaded && (i.range = null);
      let s = this._changedMarkers.get(e);
      s ? s.newMarkerData = i : (s = { newMarkerData: i, oldMarkerData: t }, this._changedMarkers.set(e, s)), s.oldMarkerData.range == null && i.range == null && this._changedMarkers.delete(e);
    }
    /**
     * Returns all markers that should be removed as a result of buffered changes.
     *
     * @returns Markers to remove. Each array item is an object containing the `name` and `range` properties.
     */
    getMarkersToRemove() {
      const e = [];
      for (const [t, i] of this._changedMarkers)
        i.oldMarkerData.range != null && e.push({ name: t, range: i.oldMarkerData.range });
      return e;
    }
    /**
     * Returns all markers which should be added as a result of buffered changes.
     *
     * @returns Markers to add. Each array item is an object containing the `name` and `range` properties.
     */
    getMarkersToAdd() {
      const e = [];
      for (const [t, i] of this._changedMarkers)
        i.newMarkerData.range != null && e.push({ name: t, range: i.newMarkerData.range });
      return e;
    }
    /**
     * Returns all markers which changed.
     */
    getChangedMarkers() {
      return Array.from(this._changedMarkers).map(([e, t]) => ({
        name: e,
        data: {
          oldRange: t.oldMarkerData.range,
          newRange: t.newMarkerData.range
        }
      }));
    }
    /**
     * Checks whether some of the buffered changes affect the editor data.
     *
     * Types of changes which affect the editor data:
     *
     * * model structure changes,
     * * attribute changes,
     * * a root is added or detached,
     * * changes of markers which were defined as `affectsData`,
     * * changes of markers' `affectsData` property.
     */
    hasDataChanges() {
      if (this.getChanges().length || this._changedRoots.size > 0)
        return !0;
      for (const { newMarkerData: e, oldMarkerData: t } of this._changedMarkers.values()) {
        if (e.affectsData !== t.affectsData)
          return !0;
        if (e.affectsData) {
          const i = e.range && !t.range, s = !e.range && t.range, o = e.range && t.range && !e.range.isEqual(t.range);
          if (i || s || o)
            return !0;
        }
      }
      return !1;
    }
    /**
     * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}
     * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.
     *
     * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done
     * on the model. The items are sorted by the position on which the change happened. If a position
     * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.
     *
     * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.
     *
     * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the
     * previous {@link #getChanges} call, the next call will return the cached value.
     *
     * @param options Additional options.
     * @param options.includeChangesInGraveyard If set to `true`, also changes that happened
     * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.
     * @returns Diff between the old and the new model tree state.
     */
    getChanges(e = {}) {
      if (this._cachedChanges)
        return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
      let t = [];
      for (const i of this._changesInElement.keys()) {
        const s = this._changesInElement.get(i).sort((u, d) => u.offset === d.offset ? u.type != d.type ? u.type == "remove" ? -1 : 1 : 0 : u.offset < d.offset ? -1 : 1), o = this._elementSnapshots.get(i), r = Eu(i.getChildren()), a = R2(o.length, s);
        let l = 0, c = 0;
        for (const u of a)
          if (u === "i")
            t.push(this._getInsertDiff(i, l, r[l])), l++;
          else if (u === "r")
            t.push(this._getRemoveDiff(i, l, o[c])), c++;
          else if (u === "a") {
            const d = r[l].attributes, h = o[c].attributes;
            let f;
            if (r[l].name == "$text")
              f = new _(C._createAt(i, l), C._createAt(i, l + 1));
            else {
              const m = i.offsetToIndex(l);
              f = new _(C._createAt(i, l), C._createAt(i.getChild(m), 0));
            }
            t.push(...this._getAttributesDiff(f, h, d)), l++, c++;
          } else
            l++, c++;
      }
      t.sort((i, s) => i.position.root != s.position.root ? i.position.root.rootName < s.position.root.rootName ? -1 : 1 : i.position.isEqual(s.position) ? i.changeCount - s.changeCount : i.position.isBefore(s.position) ? -1 : 1);
      for (let i = 1, s = 0; i < t.length; i++) {
        const o = t[s], r = t[i], a = o.type == "remove" && r.type == "remove" && o.name == "$text" && r.name == "$text" && o.position.isEqual(r.position), l = o.type == "insert" && r.type == "insert" && o.name == "$text" && r.name == "$text" && o.position.parent == r.position.parent && o.position.offset + o.length == r.position.offset, c = o.type == "attribute" && r.type == "attribute" && o.position.parent == r.position.parent && o.range.isFlat && r.range.isFlat && o.position.offset + o.length == r.position.offset && o.attributeKey == r.attributeKey && o.attributeOldValue == r.attributeOldValue && o.attributeNewValue == r.attributeNewValue;
        a || l || c ? (o.length++, c && (o.range.end = o.range.end.getShiftedBy(1)), t[i] = null) : s = i;
      }
      t = t.filter((i) => i);
      for (const i of t)
        delete i.changeCount, i.type == "attribute" && (delete i.position, delete i.length);
      return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(L2), e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
    }
    /**
     * Returns all roots that have changed (either were attached, or detached, or their attributes changed).
     *
     * @returns Diff between the old and the new roots state.
     */
    getChangedRoots() {
      return Array.from(this._changedRoots.values()).map((e) => {
        const t = { ...e };
        return t.state !== void 0 && delete t.attributes, t;
      });
    }
    /**
     * Returns a set of model items that were marked to get refreshed.
     */
    getRefreshedItems() {
      return new Set(this._refreshedItems);
    }
    /**
     * Resets `Differ`. Removes all buffered changes.
     */
    reset() {
      this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
    }
    /**
     * Buffers the root state change after the root was attached or detached
     */
    _bufferRootStateChange(e, t) {
      if (!this._changedRoots.has(e)) {
        this._changedRoots.set(e, { name: e, state: t ? "attached" : "detached" });
        return;
      }
      const i = this._changedRoots.get(e);
      i.state !== void 0 ? (delete i.state, i.attributes === void 0 && this._changedRoots.delete(e)) : i.state = t ? "attached" : "detached";
    }
    /**
     * Buffers a root attribute change.
     */
    _bufferRootAttributeChange(e, t, i, s) {
      const o = this._changedRoots.get(e) || { name: e }, r = o.attributes || {};
      if (r[t]) {
        const a = r[t];
        s === a.oldValue ? delete r[t] : a.newValue = s;
      } else
        r[t] = { oldValue: i, newValue: s };
      Object.entries(r).length === 0 ? (delete o.attributes, o.state === void 0 && this._changedRoots.delete(e)) : (o.attributes = r, this._changedRoots.set(e, o));
    }
    /**
     * Marks the given `item` in differ to be "refreshed". It means that the item will be marked as removed and inserted
     * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.
     *
     * @internal
     * @param item Item to refresh.
     */
    _refreshItem(e) {
      if (this._isInInsertedElement(e.parent))
        return;
      this._markRemove(e.parent, e.startOffset, e.offsetSize), this._markInsert(e.parent, e.startOffset, e.offsetSize), this._refreshedItems.add(e);
      const t = _._createOn(e);
      for (const i of this._markerCollection.getMarkersIntersectingRange(t)) {
        const s = i.getData();
        this.bufferMarkerChange(i.name, s, s);
      }
      this._cachedChanges = null;
    }
    /**
     * Buffers all the data related to given root like it was all just added to the editor.
     *
     * Following changes are buffered:
     *
     * * root is attached,
     * * all root content is inserted,
     * * all root attributes are added,
     * * all markers inside the root are added.
     *
     * @internal
     */
    _bufferRootLoad(e) {
      if (e.isAttached()) {
        this._bufferRootStateChange(e.rootName, !0), this._markInsert(e, 0, e.maxOffset);
        for (const t of e.getAttributeKeys())
          this._bufferRootAttributeChange(e.rootName, t, null, e.getAttribute(t));
        for (const t of this._markerCollection)
          if (t.getRange().root == e) {
            const i = t.getData();
            this.bufferMarkerChange(t.name, { ...i, range: null }, i);
          }
      }
    }
    /**
     * Saves and handles an insert change.
     */
    _markInsert(e, t, i) {
      if (e.root.is("rootElement") && !e.root._isLoaded)
        return;
      const s = { type: "insert", offset: t, howMany: i, count: this._changeCount++ };
      this._markChange(e, s);
    }
    /**
     * Saves and handles a remove change.
     */
    _markRemove(e, t, i) {
      if (e.root.is("rootElement") && !e.root._isLoaded)
        return;
      const s = { type: "remove", offset: t, howMany: i, count: this._changeCount++ };
      this._markChange(e, s), this._removeAllNestedChanges(e, t, i);
    }
    /**
     * Saves and handles an attribute change.
     */
    _markAttribute(e) {
      if (e.root.is("rootElement") && !e.root._isLoaded)
        return;
      const t = { type: "attribute", offset: e.startOffset, howMany: e.offsetSize, count: this._changeCount++ };
      this._markChange(e.parent, t);
    }
    /**
     * Saves and handles a model change.
     */
    _markChange(e, t) {
      this._makeSnapshot(e);
      const i = this._getChangesForElement(e);
      this._handleChange(t, i), i.push(t);
      for (let s = 0; s < i.length; s++)
        i[s].howMany < 1 && (i.splice(s, 1), s--);
    }
    /**
     * Gets an array of changes that have already been saved for a given element.
     */
    _getChangesForElement(e) {
      let t;
      return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [], this._changesInElement.set(e, t)), t;
    }
    /**
     * Saves a children snapshot for a given element.
     */
    _makeSnapshot(e) {
      this._elementSnapshots.has(e) || this._elementSnapshots.set(e, Eu(e.getChildren()));
    }
    /**
     * For a given newly saved change, compares it with a change already done on the element and modifies the incoming
     * change and/or the old change.
     *
     * @param inc Incoming (new) change.
     * @param changes An array containing all the changes done on that element.
     */
    _handleChange(e, t) {
      e.nodesToHandle = e.howMany;
      for (const i of t) {
        const s = e.offset + e.howMany, o = i.offset + i.howMany;
        if (e.type == "insert" && (i.type == "insert" && (e.offset <= i.offset ? i.offset += e.howMany : e.offset < o && (i.howMany += e.nodesToHandle, e.nodesToHandle = 0)), i.type == "remove" && e.offset < i.offset && (i.offset += e.howMany), i.type == "attribute")) {
          if (e.offset <= i.offset)
            i.offset += e.howMany;
          else if (e.offset < o) {
            const r = i.howMany;
            i.howMany = e.offset - i.offset, t.unshift({
              type: "attribute",
              offset: s,
              howMany: r - i.howMany,
              count: this._changeCount++
            });
          }
        }
        if (e.type == "remove") {
          if (i.type == "insert") {
            if (s <= i.offset)
              i.offset -= e.howMany;
            else if (s <= o)
              if (e.offset < i.offset) {
                const r = s - i.offset;
                i.offset = e.offset, i.howMany -= r, e.nodesToHandle -= r;
              } else
                i.howMany -= e.nodesToHandle, e.nodesToHandle = 0;
            else if (e.offset <= i.offset)
              e.nodesToHandle -= i.howMany, i.howMany = 0;
            else if (e.offset < o) {
              const r = o - e.offset;
              i.howMany -= r, e.nodesToHandle -= r;
            }
          }
          if (i.type == "remove" && (s <= i.offset ? i.offset -= e.howMany : e.offset < i.offset && (e.nodesToHandle += i.howMany, i.howMany = 0)), i.type == "attribute") {
            if (s <= i.offset)
              i.offset -= e.howMany;
            else if (e.offset < i.offset) {
              const r = s - i.offset;
              i.offset = e.offset, i.howMany -= r;
            } else if (e.offset < o)
              if (s <= o) {
                const r = i.howMany;
                i.howMany = e.offset - i.offset;
                const a = r - i.howMany - e.nodesToHandle;
                t.unshift({
                  type: "attribute",
                  offset: e.offset,
                  howMany: a,
                  count: this._changeCount++
                });
              } else
                i.howMany -= o - e.offset;
          }
        }
        if (e.type == "attribute") {
          if (i.type == "insert")
            if (e.offset < i.offset && s > i.offset) {
              if (s > o) {
                const r = {
                  type: "attribute",
                  offset: o,
                  howMany: s - o,
                  count: this._changeCount++
                };
                this._handleChange(r, t), t.push(r);
              }
              e.nodesToHandle = i.offset - e.offset, e.howMany = e.nodesToHandle;
            } else
              e.offset >= i.offset && e.offset < o && (s > o ? (e.nodesToHandle = s - o, e.offset = o) : e.nodesToHandle = 0);
          if (i.type == "remove" && e.offset < i.offset && s > i.offset) {
            const r = {
              type: "attribute",
              offset: i.offset,
              howMany: s - i.offset,
              count: this._changeCount++
            };
            this._handleChange(r, t), t.push(r), e.nodesToHandle = i.offset - e.offset, e.howMany = e.nodesToHandle;
          }
          i.type == "attribute" && (e.offset >= i.offset && s <= o ? (e.nodesToHandle = 0, e.howMany = 0, e.offset = 0) : e.offset <= i.offset && s >= o && (i.howMany = 0));
        }
      }
      e.howMany = e.nodesToHandle, delete e.nodesToHandle;
    }
    /**
     * Returns an object with a single insert change description.
     *
     * @param parent The element in which the change happened.
     * @param offset The offset at which change happened.
     * @param elementSnapshot The snapshot of the removed element a character.
     * @returns The diff item.
     */
    _getInsertDiff(e, t, i) {
      return {
        type: "insert",
        position: C._createAt(e, t),
        name: i.name,
        attributes: new Map(i.attributes),
        length: 1,
        changeCount: this._changeCount++,
        _element: i.element
      };
    }
    /**
     * Returns an object with a single remove change description.
     *
     * @param parent The element in which change happened.
     * @param offset The offset at which change happened.
     * @param elementSnapshot The snapshot of the removed element a character.
     * @returns The diff item.
     */
    _getRemoveDiff(e, t, i) {
      return {
        type: "remove",
        position: C._createAt(e, t),
        name: i.name,
        attributes: new Map(i.attributes),
        length: 1,
        changeCount: this._changeCount++,
        _element: i.element
      };
    }
    /**
     * Returns an array of objects where each one is a single attribute change description.
     *
     * @param range The range where the change happened.
     * @param oldAttributes A map, map iterator or compatible object that contains attributes before the change.
     * @param newAttributes A map, map iterator or compatible object that contains attributes after the change.
     * @returns An array containing one or more diff items.
     */
    _getAttributesDiff(e, t, i) {
      const s = [];
      i = new Map(i);
      for (const [o, r] of t) {
        const a = i.has(o) ? i.get(o) : null;
        a !== r && s.push({
          type: "attribute",
          position: e.start,
          range: e.clone(),
          length: 1,
          attributeKey: o,
          attributeOldValue: r,
          attributeNewValue: a,
          changeCount: this._changeCount++
        }), i.delete(o);
      }
      for (const [o, r] of i)
        s.push({
          type: "attribute",
          position: e.start,
          range: e.clone(),
          length: 1,
          attributeKey: o,
          attributeOldValue: null,
          attributeNewValue: r,
          changeCount: this._changeCount++
        });
      return s;
    }
    /**
     * Checks whether given element or any of its parents is an element that is buffered as an inserted element.
     */
    _isInInsertedElement(e) {
      const t = e.parent;
      if (!t)
        return !1;
      const i = this._changesInElement.get(t), s = e.startOffset;
      if (i) {
        for (const o of i)
          if (o.type == "insert" && s >= o.offset && s < o.offset + o.howMany)
            return !0;
      }
      return this._isInInsertedElement(t);
    }
    /**
     * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`
     * and `howMany`.
     */
    _removeAllNestedChanges(e, t, i) {
      const s = new _(C._createAt(e, t), C._createAt(e, t + i));
      for (const o of s.getItems({ shallow: !0 }))
        o.is("element") && (this._elementSnapshots.delete(o), this._changesInElement.delete(o), this._removeAllNestedChanges(o, 0, o.maxOffset));
    }
  }
  function Eu(n) {
    const e = [];
    for (const t of n)
      if (t.is("$text"))
        for (let i = 0; i < t.data.length; i++)
          e.push({
            name: "$text",
            attributes: new Map(t.getAttributes())
          });
      else
        e.push({
          name: t.name,
          attributes: new Map(t.getAttributes()),
          element: t
        });
    return e;
  }
  function R2(n, e) {
    const t = [];
    let i = 0, s = 0;
    for (const o of e) {
      if (o.offset > i) {
        for (let r = 0; r < o.offset - i; r++)
          t.push("e");
        s += o.offset - i;
      }
      if (o.type == "insert") {
        for (let r = 0; r < o.howMany; r++)
          t.push("i");
        i = o.offset + o.howMany;
      } else if (o.type == "remove") {
        for (let r = 0; r < o.howMany; r++)
          t.push("r");
        i = o.offset, s += o.howMany;
      } else
        t.push(..."a".repeat(o.howMany).split("")), i = o.offset + o.howMany, s += o.howMany;
    }
    if (s < n)
      for (let o = 0; o < n - s - i; o++)
        t.push("e");
    return t;
  }
  function L2(n) {
    const e = "position" in n && n.position.root.rootName == "$graveyard", t = "range" in n && n.range.root.rootName == "$graveyard";
    return !e && !t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class V2 {
    constructor() {
      this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map(), this._version = 0, this._gaps = /* @__PURE__ */ new Map();
    }
    /**
     * The version of the last operation in the history.
     *
     * The history version is incremented automatically when a new operation is added to the history.
     * Setting the version manually should be done only in rare circumstances when a gap is planned
     * between history versions. When doing so, a gap will be created and the history will accept adding
     * an operation with base version equal to the new history version.
     */
    get version() {
      return this._version;
    }
    set version(e) {
      this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e), this._version = e;
    }
    /**
     * The last history operation.
     */
    get lastOperation() {
      return this._operations[this._operations.length - 1];
    }
    /**
     * Adds an operation to the history and increments the history version.
     *
     * The operation's base version should be equal to the history version. Otherwise an error is thrown.
     */
    addOperation(e) {
      if (e.baseVersion !== this.version)
        throw new g("model-document-history-addoperation-incorrect-version", this, {
          operation: e,
          historyVersion: this.version
        });
      this._operations.push(e), this._version++, this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1);
    }
    /**
     * Returns operations from the given range of operation base versions that were added to the history.
     *
     * Note that there may be gaps in operations base versions.
     *
     * @param fromBaseVersion Base version from which operations should be returned (inclusive).
     * @param toBaseVersion Base version up to which operations should be returned (exclusive).
     * @returns History operations for the given range, in chronological order.
     */
    getOperations(e, t = this.version) {
      if (!this._operations.length)
        return [];
      const i = this._operations[0];
      e === void 0 && (e = i.baseVersion);
      let s = t - 1;
      for (const [a, l] of this._gaps)
        e > a && e < l && (e = l), s > a && s < l && (s = a - 1);
      if (s < i.baseVersion || e > this.lastOperation.baseVersion)
        return [];
      let o = this._baseVersionToOperationIndex.get(e);
      o === void 0 && (o = 0);
      let r = this._baseVersionToOperationIndex.get(s);
      return r === void 0 && (r = this._operations.length - 1), this._operations.slice(
        o,
        // The `toIndex` should be included in the returned operations, so add `1`.
        r + 1
      );
    }
    /**
     * Returns operation from the history that bases on given `baseVersion`.
     *
     * @param baseVersion Base version of the operation to get.
     * @returns Operation with given base version or `undefined` if there is no such operation in history.
     */
    getOperation(e) {
      const t = this._baseVersionToOperationIndex.get(e);
      if (t !== void 0)
        return this._operations[t];
    }
    /**
     * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,
     * history is keeping more context information about operations, which helps in operational transformation.
     *
     * @param undoneOperation Operation which is undone by `undoingOperation`.
     * @param undoingOperation Operation which undoes `undoneOperation`.
     */
    setOperationAsUndone(e, t) {
      this._undoPairs.set(t, e), this._undoneOperations.add(e);
    }
    /**
     * Checks whether given `operation` is undoing any other operation.
     *
     * @param operation Operation to check.
     * @returns `true` if given `operation` is undoing any other operation, `false` otherwise.
     */
    isUndoingOperation(e) {
      return this._undoPairs.has(e);
    }
    /**
     * Checks whether given `operation` has been undone by any other operation.
     *
     * @param operation Operation to check.
     * @returns `true` if given `operation` has been undone any other operation, `false` otherwise.
     */
    isUndoneOperation(e) {
      return this._undoneOperations.has(e);
    }
    /**
     * For given `undoingOperation`, returns the operation which has been undone by it.
     *
     * @returns Operation that has been undone by given `undoingOperation` or `undefined`
     * if given `undoingOperation` is not undoing any other operation.
     */
    getUndoneOperation(e) {
      return this._undoPairs.get(e);
    }
    /**
     * Resets the history of operations.
     */
    reset() {
      this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Eo extends W {
    /**
     * Creates root element.
     *
     * @param document Document that is an owner of this root.
     * @param name Node name.
     * @param rootName Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
     */
    constructor(e, t, i = "main") {
      super(t), this._isAttached = !0, this._isLoaded = !0, this._document = e, this.rootName = i;
    }
    /**
     * {@link module:engine/model/document~Document Document} that owns this root element.
     */
    get document() {
      return this._document;
    }
    /**
     * Informs if the root element is currently attached to the document, or not.
     *
     * A detached root is equivalent to being removed and cannot contain any children or markers.
     *
     * By default, a newly added root is attached. It can be detached using
     * {@link module:engine/model/writer~Writer#detachRoot `Writer#detachRoot`}. A detached root can be re-attached again using
     * {@link module:engine/model/writer~Writer#addRoot `Writer#addRoot`}.
     */
    isAttached() {
      return this._isAttached;
    }
    /**
     * Converts `RootElement` instance to `string` containing its name.
     *
     * @returns `RootElement` instance converted to `string`.
     */
    toJSON() {
      return this.rootName;
    }
  }
  Eo.prototype.is = function(n, e) {
    return e ? e === this.name && (n === "rootElement" || n === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "element" || n === "model:element") : n === "rootElement" || n === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    n === "element" || n === "model:element" || n === "node" || n === "model:node";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Au = "$graveyard";
  class M2 extends G() {
    /**
     * Creates an empty document instance with no {@link #roots} (other than
     * the {@link #graveyard graveyard root}).
     */
    constructor(e) {
      super(), this.model = e, this.history = new V2(), this.selection = new lt(this), this.roots = new Ce({ idProperty: "rootName" }), this.differ = new P2(e.markers), this.isReadOnly = !1, this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", Au), this.listenTo(e, "applyOperation", (t, i) => {
        const s = i[0];
        s.isDocumentOperation && this.differ.bufferOperation(s);
      }, { priority: "high" }), this.listenTo(e, "applyOperation", (t, i) => {
        const s = i[0];
        s.isDocumentOperation && this.history.addOperation(s);
      }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
        this._hasSelectionChangedFromTheLastChangeBlock = !0;
      }), this.listenTo(e.markers, "update", (t, i, s, o, r) => {
        const a = { ...i.getData(), range: o };
        this.differ.bufferMarkerChange(i.name, r, a), s === null && i.on("change", (l, c) => {
          const u = i.getData();
          this.differ.bufferMarkerChange(i.name, { ...u, range: c }, u);
        });
      }), this.registerPostFixer((t) => {
        let i = !1;
        for (const s of this.roots)
          !s.isAttached() && !s.isEmpty && (t.remove(t.createRangeIn(s)), i = !0);
        for (const s of this.model.markers)
          s.getRange().root.isAttached() || (t.removeMarker(s), i = !0);
        return i;
      });
    }
    /**
     * The document version. Every applied operation increases the version number. It is used to
     * ensure that operations are applied on a proper document version.
     *
     * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.
     *
     * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,
     * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.
     */
    get version() {
      return this.history.version;
    }
    set version(e) {
      this.history.version = e;
    }
    /**
     * The graveyard tree root. A document always has a graveyard root that stores removed nodes.
     */
    get graveyard() {
      return this.getRoot(Au);
    }
    /**
     * Creates a new root.
     *
     * **Note:** do not use this method after the editor has been initialized! If you want to dynamically add a root, use
     * {@link module:engine/model/writer~Writer#addRoot `model.Writer#addRoot`} instead.
     *
     * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
     * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
     * @param rootName A unique root name.
     * @returns The created root.
     */
    createRoot(e = "$root", t = "main") {
      if (this.roots.get(t))
        throw new g("model-document-createroot-name-exists", this, { name: t });
      const i = new Eo(this, e, t);
      return this.roots.add(i), i;
    }
    /**
     * Removes all event listeners set by the document instance.
     */
    destroy() {
      this.selection.destroy(), this.stopListening();
    }
    /**
     * Returns a root by its name.
     *
     * Detached roots are returned by this method. This is to be able to operate on the detached root (for example, to be able to create
     * a position inside such a root for undo feature purposes).
     *
     * @param name The root name of the root to return.
     * @returns The root registered under a given name or `null` when there is no root with the given name.
     */
    getRoot(e = "main") {
      return this.roots.get(e);
    }
    /**
     * Returns an array with names of all roots added to the document (except the {@link #graveyard graveyard root}).
     *
     * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
     * on the document data know which roots are still a part of the document and should be processed.
     *
     * @param includeDetached Specified whether detached roots should be returned as well.
     */
    getRootNames(e = !1) {
      return this.getRoots(e).map((t) => t.rootName);
    }
    /**
     * Returns an array with all roots added to the document (except the {@link #graveyard graveyard root}).
     *
     * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
     * on the document data know which roots are still a part of the document and should be processed.
     *
     * @param includeDetached Specified whether detached roots should be returned as well.
     */
    getRoots(e = !1) {
      return this.roots.filter((t) => t != this.graveyard && (e || t.isAttached()) && t._isLoaded);
    }
    /**
     * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features
     * will operate on a correct model state.
     *
     * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after
     * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but
     * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made
     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
     * not be fixed in the new document tree state.
     *
     * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the
     * executed changes block. Thanks to that, all changes done by the callback will be added to the same
     * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent
     * for the user.
     *
     * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the
     * callback should add an empty paragraph so that the editor is never empty:
     *
     * ```ts
     * document.registerPostFixer( writer => {
     * 	const changes = document.differ.getChanges();
     *
     * 	// Check if the changes lead to an empty root in the editor.
     * 	for ( const entry of changes ) {
     * 		if ( entry.type == 'remove' && entry.position.root.isEmpty ) {
     * 			writer.insertElement( 'paragraph', entry.position.root, 0 );
     *
     * 			// It is fine to return early, even if multiple roots would need to be fixed.
     * 			// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.
     * 			return true;
     * 		}
     * 	}
     *
     * 	return false;
     * } );
     * ```
     */
    registerPostFixer(e) {
      this._postFixers.add(e);
    }
    /**
     * A custom `toJSON()` method to solve child-parent circular dependencies.
     *
     * @returns A clone of this object with the document property changed to a string.
     */
    toJSON() {
      const e = zf(this);
      return e.selection = "[engine.model.DocumentSelection]", e.model = "[engine.model.Model]", e;
    }
    /**
     * Check if there were any changes done on document, and if so, call post-fixers,
     * fire `change` event for features and conversion and then reset the differ.
     * Fire `change:data` event when at least one operation or buffered marker changes the data.
     *
     * @internal
     * @fires change
     * @fires change:data
     * @param writer The writer on which post-fixers will be called.
     */
    _handleChangeBlock(e) {
      this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1;
    }
    /**
     * Returns whether there is a buffered change or if the selection has changed from the last
     * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}
     * or {@link module:engine/model/model~Model#change `change()` block}.
     *
     * @returns Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.
     */
    _hasDocumentChangedFromTheLastChangeBlock() {
      return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
    }
    /**
     * Returns the default root for this document which is either the first root that was added to the document using
     * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
     *
     * @returns The default root for this document.
     */
    _getDefaultRoot() {
      const e = this.getRoots();
      return e.length ? e[0] : this.graveyard;
    }
    /**
     * Returns the default range for this selection. The default range is a collapsed range that starts and ends
     * at the beginning of this selection's document {@link #_getDefaultRoot default root}.
     *
     * @internal
     */
    _getDefaultRange() {
      const e = this._getDefaultRoot(), t = this.model, i = t.schema, s = t.createPositionFromPath(e, [0]);
      return i.getNearestSelectionRange(s) || t.createRange(s);
    }
    /**
     * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for
     * the {@link #selection document's selection}.
     *
     * @internal
     * @param range A range to check.
     * @returns `true` if `range` is valid, `false` otherwise.
     */
    _validateSelectionRange(e) {
      return xu(e.start) && xu(e.end);
    }
    /**
     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
     *
     * @param writer The writer on which post-fixer callbacks will be called.
     */
    _callPostFixers(e) {
      let t = !1;
      do
        for (const i of this._postFixers)
          if (this.selection.refresh(), t = i(e), t)
            break;
      while (t);
    }
  }
  function xu(n) {
    const e = n.textNode;
    if (e) {
      const t = e.data, i = n.offset - e.startOffset;
      return !hl(t, i) && !fl(t, i);
    }
    return !0;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class B2 extends G() {
    constructor() {
      super(...arguments), this._markers = /* @__PURE__ */ new Map();
    }
    /**
     * Iterable interface.
     *
     * Iterates over all {@link ~Marker markers} added to the collection.
     */
    [Symbol.iterator]() {
      return this._markers.values();
    }
    /**
     * Checks if given {@link ~Marker marker} or marker name is in the collection.
     *
     * @param markerOrName Name of marker or marker instance to check.
     * @returns `true` if marker is in the collection, `false` otherwise.
     */
    has(e) {
      const t = e instanceof Fi ? e.name : e;
      return this._markers.has(t);
    }
    /**
     * Returns {@link ~Marker marker} with given `markerName`.
     *
     * @param markerName Name of marker to get.
     * @returns Marker with given name or `null` if such marker was
     * not added to the collection.
     */
    get(e) {
      return this._markers.get(e) || null;
    }
    /**
     * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
     * {@link module:engine/model/range~Range range}.
     *
     * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in
     * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired
     * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}
     * flag has changed.
     *
     * @internal
     * @fires update
     * @param markerOrName Name of marker to set or marker instance to update.
     * @param range Marker range.
     * @param managedUsingOperations Specifies whether the marker is managed using operations.
     * @param affectsData Specifies whether the marker affects the data produced by the data pipeline
     * (is persisted in the editor's data).
     * @returns `Marker` instance which was added or updated.
     */
    _set(e, t, i = !1, s = !1) {
      const o = e instanceof Fi ? e.name : e;
      if (o.includes(","))
        throw new g("markercollection-incorrect-marker-name", this);
      const r = this._markers.get(o);
      if (r) {
        const c = r.getData(), u = r.getRange();
        let d = !1;
        return u.isEqual(t) || (r._attachLiveRange(Pe.fromRange(t)), d = !0), i != r.managedUsingOperations && (r._managedUsingOperations = i, d = !0), typeof s == "boolean" && s != r.affectsData && (r._affectsData = s, d = !0), d && this.fire(`update:${o}`, r, u, t, c), r;
      }
      const a = Pe.fromRange(t), l = new Fi(o, a, i, s);
      return this._markers.set(o, l), this.fire(`update:${o}`, l, null, t, { ...l.getData(), range: null }), l;
    }
    /**
     * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
     *
     * @internal
     * @fires update
     * @param markerOrName Marker or name of a marker to remove.
     * @returns `true` if marker was found and removed, `false` otherwise.
     */
    _remove(e) {
      const t = e instanceof Fi ? e.name : e, i = this._markers.get(t);
      return i ? (this._markers.delete(t), this.fire(`update:${t}`, i, i.getRange(), null, i.getData()), this._destroyMarker(i), !0) : !1;
    }
    /**
     * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}
     * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast
     * conversion} for the marker.
     *
     * @internal
     * @fires update
     * @param markerOrName Marker or name of a marker to refresh.
     */
    _refresh(e) {
      const t = e instanceof Fi ? e.name : e, i = this._markers.get(t);
      if (!i)
        throw new g("markercollection-refresh-marker-not-exists", this);
      const s = i.getRange();
      this.fire(`update:${t}`, i, s, s, i.getData());
    }
    /**
     * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.
     */
    *getMarkersAtPosition(e) {
      for (const t of this)
        t.getRange().containsPosition(e) && (yield t);
    }
    /**
     * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.
     */
    *getMarkersIntersectingRange(e) {
      for (const t of this)
        t.getRange().getIntersection(e) !== null && (yield t);
    }
    /**
     * Destroys marker collection and all markers inside it.
     */
    destroy() {
      for (const e of this._markers.values())
        this._destroyMarker(e);
      this._markers = null, this.stopListening();
    }
    /**
     * Iterates over all markers that starts with given `prefix`.
     *
     * ```ts
     * const markerFooA = markersCollection._set( 'foo:a', rangeFooA );
     * const markerFooB = markersCollection._set( 'foo:b', rangeFooB );
     * const markerBarA = markersCollection._set( 'bar:a', rangeBarA );
     * const markerFooBarA = markersCollection._set( 'foobar:a', rangeFooBarA );
     * Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
     * Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
     * ```
     */
    *getMarkersGroup(e) {
      for (const t of this._markers.values())
        t.name.startsWith(e + ":") && (yield t);
    }
    /**
     * Destroys the marker.
     */
    _destroyMarker(e) {
      e.stopListening(), e._detachLiveRange();
    }
  }
  class Fi extends G(jt) {
    /**
     * Creates a marker instance.
     *
     * @param name Marker name.
     * @param liveRange Range marked by the marker.
     * @param managedUsingOperations Specifies whether the marker is managed using operations.
     * @param affectsData Specifies whether the marker affects the data produced by the data pipeline (is persisted in the editor's data).
     */
    constructor(e, t, i, s) {
      super(), this.name = e, this._liveRange = this._attachLiveRange(t), this._managedUsingOperations = i, this._affectsData = s;
    }
    /**
     * A value indicating if the marker is managed using operations.
     * See {@link ~Marker marker class description} to learn more about marker types.
     * See {@link module:engine/model/writer~Writer#addMarker}.
     */
    get managedUsingOperations() {
      if (!this._liveRange)
        throw new g("marker-destroyed", this);
      return this._managedUsingOperations;
    }
    /**
     * A value indicating if the marker changes the data.
     */
    get affectsData() {
      if (!this._liveRange)
        throw new g("marker-destroyed", this);
      return this._affectsData;
    }
    /**
     * Returns the marker data (properties defining the marker).
     */
    getData() {
      return {
        range: this.getRange(),
        affectsData: this.affectsData,
        managedUsingOperations: this.managedUsingOperations
      };
    }
    /**
     * Returns current marker start position.
     */
    getStart() {
      if (!this._liveRange)
        throw new g("marker-destroyed", this);
      return this._liveRange.start.clone();
    }
    /**
     * Returns current marker end position.
     */
    getEnd() {
      if (!this._liveRange)
        throw new g("marker-destroyed", this);
      return this._liveRange.end.clone();
    }
    /**
     * Returns a range that represents the current state of the marker.
     *
     * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a
     * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only
     * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
     * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
     * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
     * that it's data is up-to-date.
     */
    getRange() {
      if (!this._liveRange)
        throw new g("marker-destroyed", this);
      return this._liveRange.toRange();
    }
    /**
     * Binds new live range to the marker and detach the old one if is attached.
     *
     * @internal
     * @param liveRange Live range to attach
     * @returns Attached live range.
     */
    _attachLiveRange(e) {
      return this._liveRange && this._detachLiveRange(), e.delegate("change:range").to(this), e.delegate("change:content").to(this), this._liveRange = e, e;
    }
    /**
     * Unbinds and destroys currently attached live range.
     *
     * @internal
     */
    _detachLiveRange() {
      this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
    }
  }
  Fi.prototype.is = function(n) {
    return n === "marker" || n === "model:marker";
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class O2 extends qe {
    /**
     * Creates an insert operation.
     *
     * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
     * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
     * `sourcePosition` with offset shifted by `howMany`.
     */
    constructor(e, t) {
      super(null), this.sourcePosition = e.clone(), this.howMany = t;
    }
    /**
     * @inheritDoc
     */
    get type() {
      return "detach";
    }
    /**
     * @inheritDoc
     */
    get affectedSelectable() {
      return null;
    }
    /**
     * @inheritDoc
     */
    toJSON() {
      const e = super.toJSON();
      return e.sourcePosition = this.sourcePosition.toJSON(), e;
    }
    /**
     * @inheritDoc
     * @internal
     */
    _validate() {
      if (this.sourcePosition.root.document)
        throw new g("detach-operation-on-document-node", this);
    }
    /**
     * @inheritDoc
     * @internal
     */
    _execute() {
      qm(_._createFromPositionAndShift(this.sourcePosition, this.howMany));
    }
    /**
     * @inheritDoc
     */
    static get className() {
      return "DetachOperation";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Et extends jt {
    /**
     * Creates an empty `DocumentFragment`.
     *
     * **Note:** Constructor of this class shouldn't be used directly in the code.
     * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.
     *
     * @internal
     * @param children Nodes to be contained inside the `DocumentFragment`.
     */
    constructor(e) {
      super(), this.markers = /* @__PURE__ */ new Map(), this._children = new On(), e && this._insertChild(0, e);
    }
    /**
     * Returns an iterator that iterates over all nodes contained inside this document fragment.
     */
    [Symbol.iterator]() {
      return this.getChildren();
    }
    /**
     * Number of this document fragment's children.
     */
    get childCount() {
      return this._children.length;
    }
    /**
     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.
     */
    get maxOffset() {
      return this._children.maxOffset;
    }
    /**
     * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
     */
    get isEmpty() {
      return this.childCount === 0;
    }
    /**
     * Artificial next sibling. Returns `null`. Added for compatibility reasons.
     */
    get nextSibling() {
      return null;
    }
    /**
     * Artificial previous sibling. Returns `null`. Added for compatibility reasons.
     */
    get previousSibling() {
      return null;
    }
    /**
     * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
     */
    get root() {
      return this;
    }
    /**
     * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
     */
    get parent() {
      return null;
    }
    /**
     * Artificial owner of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
     */
    get document() {
      return null;
    }
    /**
     * Returns `false` as `DocumentFragment` by definition is not attached to a document. Added for compatibility reasons.
     */
    isAttached() {
      return !1;
    }
    /**
     * Returns empty array. Added for compatibility reasons.
     */
    getAncestors() {
      return [];
    }
    /**
     * Gets the child at the given index. Returns `null` if incorrect index was passed.
     *
     * @param index Index of child.
     * @returns Child node.
     */
    getChild(e) {
      return this._children.getNode(e);
    }
    /**
     * Returns an iterator that iterates over all of this document fragment's children.
     */
    getChildren() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
     *
     * @param node Child node to look for.
     * @returns Child node's index.
     */
    getChildIndex(e) {
      return this._children.getNodeIndex(e);
    }
    /**
     * Returns the starting offset of given child. Starting offset is equal to the sum of
     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
     * given node is not a child of this document fragment.
     *
     * @param node Child node to look for.
     * @returns Child node's starting offset.
     */
    getChildStartOffset(e) {
      return this._children.getNodeStartOffset(e);
    }
    /**
     * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
     */
    getPath() {
      return [];
    }
    /**
     * Returns a descendant node by its path relative to this element.
     *
     * ```ts
     * // <this>a<b>c</b></this>
     * this.getNodeByPath( [ 0 ] );     // -> "a"
     * this.getNodeByPath( [ 1 ] );     // -> <b>
     * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
     * ```
     *
     * @param relativePath Path of the node to find, relative to this element.
     */
    getNodeByPath(e) {
      let t = this;
      for (const i of e)
        t = t.getChild(t.offsetToIndex(i));
      return t;
    }
    /**
     * Converts offset "position" to index "position".
     *
     * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
     * too high, returns index after last child.
     *
     * ```ts
     * const textNode = new Text( 'foo' );
     * const pElement = new Element( 'p' );
     * const docFrag = new DocumentFragment( [ textNode, pElement ] );
     * docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
     * docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
     * docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
     * docFrag.offsetToIndex( 2 ); // Returns 0.
     * docFrag.offsetToIndex( 3 ); // Returns 1.
     * docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
     * ```
     *
     * @param offset Offset to look for.
     * @returns Index of a node that occupies given offset.
     */
    offsetToIndex(e) {
      return this._children.offsetToIndex(e);
    }
    /**
     * Converts `DocumentFragment` instance to plain object and returns it.
     * Takes care of converting all of this document fragment's children.
     *
     * @returns `DocumentFragment` instance converted to plain object.
     */
    toJSON() {
      const e = [];
      for (const t of this._children)
        e.push(t.toJSON());
      return e;
    }
    /**
     * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
     * Converts `DocumentFragment` children to proper nodes.
     *
     * @param json Plain object to be converted to `DocumentFragment`.
     * @returns `DocumentFragment` instance created using given plain object.
     */
    static fromJSON(e) {
      const t = [];
      for (const i of e)
        i.name ? t.push(W.fromJSON(i)) : t.push(j.fromJSON(i));
      return new Et(t);
    }
    /**
     * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.
     *
     * @internal
     * @param items Items to be inserted.
     */
    _appendChild(e) {
      this._insertChild(this.childCount, e);
    }
    /**
     * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
     * to this document fragment.
     *
     * @internal
     * @param index Index at which nodes should be inserted.
     * @param items Items to be inserted.
     */
    _insertChild(e, t) {
      const i = N2(t);
      for (const s of i)
        s.parent !== null && s._remove(), s.parent = this;
      this._children._insertNodes(e, i);
    }
    /**
     * Removes one or more nodes starting at the given index
     * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
     *
     * @internal
     * @param index Index of the first node to remove.
     * @param howMany Number of nodes to remove.
     * @returns Array containing removed nodes.
     */
    _removeChildren(e, t = 1) {
      const i = this._children._removeNodes(e, t);
      for (const s of i)
        s.parent = null;
      return i;
    }
  }
  Et.prototype.is = function(n) {
    return n === "documentFragment" || n === "model:documentFragment";
  };
  function N2(n) {
    return typeof n == "string" ? [new j(n)] : (We(n) || (n = [n]), Array.from(n).map((e) => typeof e == "string" ? new j(e) : e instanceof st ? new j(e.data, e.getAttributes()) : e));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class D2 {
    /**
     * Creates a writer instance.
     *
     * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or
     * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.
     *
     * @internal
     */
    constructor(e, t) {
      this.model = e, this.batch = t;
    }
    /**
     * Creates a new {@link module:engine/model/text~Text text node}.
     *
     * ```ts
     * writer.createText( 'foo' );
     * writer.createText( 'foo', { bold: true } );
     * ```
     *
     * @param data Text data.
     * @param attributes Text attributes.
     * @returns {module:engine/model/text~Text} Created text node.
     */
    createText(e, t) {
      return new j(e, t);
    }
    /**
     * Creates a new {@link module:engine/model/element~Element element}.
     *
     * ```ts
     * writer.createElement( 'paragraph' );
     * writer.createElement( 'paragraph', { alignment: 'center' } );
     * ```
     *
     * @param name Name of the element.
     * @param attributes Elements attributes.
     * @returns Created element.
     */
    createElement(e, t) {
      return new W(e, t);
    }
    /**
     * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
     *
     * @returns Created document fragment.
     */
    createDocumentFragment() {
      return new Et();
    }
    /**
     * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.
     * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
     *
     * @param element The element to clone.
     * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any child.
     */
    cloneElement(e, t = !0) {
      return e._clone(t);
    }
    /**
     * Inserts item on given position.
     *
     * ```ts
     * const paragraph = writer.createElement( 'paragraph' );
     * writer.insert( paragraph, position );
     * ```
     *
     * Instead of using position you can use parent and offset:
     *
     * ```ts
     * const text = writer.createText( 'foo' );
     * writer.insert( text, paragraph, 5 );
     * ```
     *
     * You can also use `end` instead of the offset to insert at the end:
     *
     * ```ts
     * const text = writer.createText( 'foo' );
     * writer.insert( text, paragraph, 'end' );
     * ```
     *
     * Or insert before or after another element:
     *
     * ```ts
     * const paragraph = writer.createElement( 'paragraph' );
     * writer.insert( paragraph, anotherParagraph, 'after' );
     * ```
     *
     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
     *
     * Note that if the item already has parent it will be removed from the previous parent.
     *
     * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,
     * `model-writer-insert-forbidden-move` is thrown.
     *
     * If you want to move {@link module:engine/model/range~Range range} instead of an
     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
     *
     * **Note:** For a paste-like content insertion mechanism see
     * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.
     *
     * @param item Item or document fragment to insert.
     * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
     */
    insert(e, t, i = 0) {
      if (this._assertWriterUsedCorrectly(), e instanceof j && e.data == "")
        return;
      const s = C._createAt(t, i);
      if (e.parent)
        if (Pu(e.root, s.root)) {
          this.move(_._createOn(e), s);
          return;
        } else {
          if (e.root.document)
            throw new g("model-writer-insert-forbidden-move", this);
          this.remove(e);
        }
      const o = s.root.document ? s.root.document.version : null, r = new be(s, e, o);
      if (e instanceof j && (r.shouldReceiveAttributes = !0), this.batch.addOperation(r), this.model.applyOperation(r), e instanceof Et)
        for (const [a, l] of e.markers) {
          const c = C._createAt(l.root, 0), d = { range: new _(l.start._getCombined(c, s), l.end._getCombined(c, s)), usingOperation: !0, affectsData: !0 };
          this.model.markers.has(a) ? this.updateMarker(a, d) : this.addMarker(a, d);
        }
    }
    insertText(e, t, i, s) {
      t instanceof Et || t instanceof W || t instanceof C ? this.insert(this.createText(e), t, i) : this.insert(this.createText(e, t), i, s);
    }
    insertElement(e, t, i, s) {
      t instanceof Et || t instanceof W || t instanceof C ? this.insert(this.createElement(e), t, i) : this.insert(this.createElement(e, t), i, s);
    }
    /**
     * Inserts item at the end of the given parent.
     *
     * ```ts
     * const paragraph = writer.createElement( 'paragraph' );
     * writer.append( paragraph, root );
     * ```
     *
     * Note that if the item already has parent it will be removed from the previous parent.
     *
     * If you want to move {@link module:engine/model/range~Range range} instead of an
     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
     *
     * @param item Item or document fragment to insert.
     */
    append(e, t) {
      this.insert(e, t, "end");
    }
    appendText(e, t, i) {
      t instanceof Et || t instanceof W ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), i, "end");
    }
    appendElement(e, t, i) {
      t instanceof Et || t instanceof W ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), i, "end");
    }
    /**
     * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}
     * or on a {@link module:engine/model/range~Range range}.
     *
     * @param key Attribute key.
     * @param value Attribute new value.
     * @param itemOrRange Model item or range on which the attribute will be set.
     */
    setAttribute(e, t, i) {
      if (this._assertWriterUsedCorrectly(), i instanceof _) {
        const s = i.getMinimalFlatRanges();
        for (const o of s)
          Su(this, e, t, o);
      } else
        Iu(this, e, t, i);
    }
    /**
     * Sets values of attributes on a {@link module:engine/model/item~Item model item}
     * or on a {@link module:engine/model/range~Range range}.
     *
     * ```ts
     * writer.setAttributes( {
     * 	bold: true,
     * 	italic: true
     * }, range );
     * ```
     *
     * @param attributes Attributes keys and values.
     * @param itemOrRange Model item or range on which the attributes will be set.
     */
    setAttributes(e, t) {
      for (const [i, s] of wt(e))
        this.setAttribute(i, s, t);
    }
    /**
     * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}
     * or from a {@link module:engine/model/range~Range range}.
     *
     * @param key Attribute key.
     * @param itemOrRange Model item or range from which the attribute will be removed.
     */
    removeAttribute(e, t) {
      if (this._assertWriterUsedCorrectly(), t instanceof _) {
        const i = t.getMinimalFlatRanges();
        for (const s of i)
          Su(this, e, null, s);
      } else
        Iu(this, e, null, t);
    }
    /**
     * Removes all attributes from all elements in the range or from the given item.
     *
     * @param itemOrRange Model item or range from which all attributes will be removed.
     */
    clearAttributes(e) {
      this._assertWriterUsedCorrectly();
      const t = (i) => {
        for (const s of i.getAttributeKeys())
          this.removeAttribute(s, i);
      };
      if (!(e instanceof _))
        t(e);
      else
        for (const i of e.getItems())
          t(i);
    }
    /**
     * Moves all items in the source range to the target position.
     *
     * ```ts
     * writer.move( sourceRange, targetPosition );
     * ```
     *
     * Instead of the target position you can use parent and offset or define that range should be moved to the end
     * or before or after chosen item:
     *
     * ```ts
     * // Moves all items in the range to the paragraph at offset 5:
     * writer.move( sourceRange, paragraph, 5 );
     * // Moves all items in the range to the end of a blockquote:
     * writer.move( sourceRange, blockquote, 'end' );
     * // Moves all items in the range to a position after an image:
     * writer.move( sourceRange, image, 'after' );
     * ```
     *
     * These parameters work the same way as {@link #createPositionAt `writer.createPositionAt()`}.
     *
     * Note that items can be moved only within the same tree. It means that you can move items within the same root
     * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},
     * but you can not move items from document fragment to the document or from one detached element to another. Use
     * {@link module:engine/model/writer~Writer#insert} in such cases.
     *
     * @param range Source range.
     * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
     */
    move(e, t, i) {
      if (this._assertWriterUsedCorrectly(), !(e instanceof _))
        throw new g("writer-move-invalid-range", this);
      if (!e.isFlat)
        throw new g("writer-move-range-not-flat", this);
      const s = C._createAt(t, i);
      if (s.isEqual(e.start))
        return;
      if (this._addOperationForAffectedMarkers("move", e), !Pu(e.root, s.root))
        throw new g("writer-move-different-document", this);
      const o = e.root.document ? e.root.document.version : null, r = new H(e.start, e.end.offset - e.start.offset, s, o);
      this.batch.addOperation(r), this.model.applyOperation(r);
    }
    /**
     * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.
     *
     * @param itemOrRange Model item or range to remove.
     */
    remove(e) {
      this._assertWriterUsedCorrectly();
      const i = (e instanceof _ ? e : _._createOn(e)).getMinimalFlatRanges().reverse();
      for (const s of i)
        this._addOperationForAffectedMarkers("move", s), F2(s.start, s.end.offset - s.start.offset, this.batch, this.model);
    }
    /**
     * Merges two siblings at the given position.
     *
     * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or
     * `writer-merge-no-element-after` error will be thrown.
     *
     * @param position Position between merged elements.
     */
    merge(e) {
      this._assertWriterUsedCorrectly();
      const t = e.nodeBefore, i = e.nodeAfter;
      if (this._addOperationForAffectedMarkers("merge", e), !(t instanceof W))
        throw new g("writer-merge-no-element-before", this);
      if (!(i instanceof W))
        throw new g("writer-merge-no-element-after", this);
      e.root.document ? this._merge(e) : this._mergeDetached(e);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.
     *
     * @param root Root of the position.
     * @param path Position path. See {@link module:engine/model/position~Position#path}.
     * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
     */
    createPositionFromPath(e, t, i) {
      return this.model.createPositionFromPath(e, t, i);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.
     *
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
     */
    createPositionAt(e, t) {
      return this.model.createPositionAt(e, t);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.
     *
     * @param item Item after which the position should be placed.
     */
    createPositionAfter(e) {
      return this.model.createPositionAfter(e);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.
     *
     * @param item Item after which the position should be placed.
     */
    createPositionBefore(e) {
      return this.model.createPositionBefore(e);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.
     *
     * @param start Start position.
     * @param end End position. If not set, range will be collapsed at `start` position.
     */
    createRange(e, t) {
      return this.model.createRange(e, t);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.
     *
     * @param element Element which is a parent for the range.
     */
    createRangeIn(e) {
      return this.model.createRangeIn(e);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.
     *
     * @param element Element which is a parent for the range.
     */
    createRangeOn(e) {
      return this.model.createRangeOn(e);
    }
    createSelection(...e) {
      return this.model.createSelection(...e);
    }
    /**
     * Performs merge action in a detached tree.
     *
     * @param position Position between merged elements.
     */
    _mergeDetached(e) {
      const t = e.nodeBefore, i = e.nodeAfter;
      this.move(_._createIn(i), C._createAt(t, "end")), this.remove(i);
    }
    /**
     * Performs merge action in a non-detached tree.
     *
     * @param position Position between merged elements.
     */
    _merge(e) {
      const t = C._createAt(e.nodeBefore, "end"), i = C._createAt(e.nodeAfter, 0), s = e.root.document.graveyard, o = new C(s, [0]), r = e.root.document.version, a = new oe(i, e.nodeAfter.maxOffset, t, o, r);
      this.batch.addOperation(a), this.model.applyOperation(a);
    }
    /**
     * Renames the given element.
     *
     * @param element The element to rename.
     * @param newName New element name.
     */
    rename(e, t) {
      if (this._assertWriterUsedCorrectly(), !(e instanceof W))
        throw new g("writer-rename-not-element-instance", this);
      const i = e.root.document ? e.root.document.version : null, s = new Le(C._createBefore(e), e.name, t, i);
      this.batch.addOperation(s), this.model.applyOperation(s);
    }
    /**
     * Splits elements starting from the given position and going to the top of the model tree as long as given
     * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.
     *
     * The element needs to have a parent. It cannot be a root element nor a document fragment.
     * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.
     *
     * @param position Position of split.
     * @param limitElement Stop splitting when this element will be reached.
     * @returns Split result with properties:
     * * `position` - Position between split elements.
     * * `range` - Range that stars from the end of the first split element and ends at the beginning of the first copy element.
     */
    split(e, t) {
      this._assertWriterUsedCorrectly();
      let i = e.parent;
      if (!i.parent)
        throw new g("writer-split-element-no-parent", this);
      if (t || (t = i.parent), !e.parent.getAncestors({ includeSelf: !0 }).includes(t))
        throw new g("writer-split-invalid-limit-element", this);
      let s, o;
      do {
        const r = i.root.document ? i.root.document.version : null, a = i.maxOffset - e.offset, l = K.getInsertionPosition(e), c = new K(e, a, l, null, r);
        this.batch.addOperation(c), this.model.applyOperation(c), !s && !o && (s = i, o = e.parent.nextSibling), e = this.createPositionAfter(e.parent), i = e.parent;
      } while (i !== t);
      return {
        position: e,
        range: new _(C._createAt(s, "end"), C._createAt(o, 0))
      };
    }
    /**
     * Wraps the given range with the given element or with a new element (if a string was passed).
     *
     * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).
     * If not, an error will be thrown.
     *
     * @param range Range to wrap.
     * @param elementOrString Element or name of element to wrap the range with.
     */
    wrap(e, t) {
      if (this._assertWriterUsedCorrectly(), !e.isFlat)
        throw new g("writer-wrap-range-not-flat", this);
      const i = t instanceof W ? t : new W(t);
      if (i.childCount > 0)
        throw new g("writer-wrap-element-not-empty", this);
      if (i.parent !== null)
        throw new g("writer-wrap-element-attached", this);
      this.insert(i, e.start);
      const s = new _(e.start.getShiftedBy(1), e.end.getShiftedBy(1));
      this.move(s, C._createAt(i, 0));
    }
    /**
     * Unwraps children of the given element – all its children are moved before it and then the element is removed.
     * Throws error if you try to unwrap an element which does not have a parent.
     *
     * @param element Element to unwrap.
     */
    unwrap(e) {
      if (this._assertWriterUsedCorrectly(), e.parent === null)
        throw new g("writer-unwrap-element-no-parent", this);
      this.move(_._createIn(e), this.createPositionAfter(e)), this.remove(e);
    }
    /**
     * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
     * changes in the document and updates its range automatically, when model tree changes.
     *
     * As the first parameter you can set marker name.
     *
     * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See
     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
     * markers managed by operations and not-managed by operations.
     *
     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
     * `true` when the marker change changes the data returned by the
     * {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
     *
     * Create marker directly base on marker's name:
     *
     * ```ts
     * addMarker( markerName, { range, usingOperation: false } );
     * ```
     *
     * Create marker using operation:
     *
     * ```ts
     * addMarker( markerName, { range, usingOperation: true } );
     * ```
     *
     * Create marker that affects the editor data:
     *
     * ```ts
     * addMarker( markerName, { range, usingOperation: false, affectsData: true } );
     * ```
     *
     * Note: For efficiency reasons, it's best to create and keep as little markers as possible.
     *
     * @see module:engine/model/markercollection~Marker
     * @param name Name of a marker to create - must be unique.
     * @param options.usingOperation Flag indicating that the marker should be added by MarkerOperation.
     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
     * @param options.range Marker range.
     * @param options.affectsData Flag indicating that the marker changes the editor data.
     * @returns Marker that was set.
     */
    addMarker(e, t) {
      if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean")
        throw new g("writer-addmarker-no-usingoperation", this);
      const i = t.usingOperation, s = t.range, o = t.affectsData === void 0 ? !1 : t.affectsData;
      if (this.model.markers.has(e))
        throw new g("writer-addmarker-marker-exists", this);
      if (!s)
        throw new g("writer-addmarker-no-range", this);
      return i ? (vn(this, e, null, s, o), this.model.markers.get(e)) : this.model.markers._set(e, s, i, o);
    }
    /**
     * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
     * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the
     * marker's range directly using this method.
     *
     * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique
     * name is created and returned.
     *
     * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model
     * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.
     *
     * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See
     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
     * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.
     *
     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
     * `true` when the marker change changes the data returned by
     * the {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
     *
     * Update marker directly base on marker's name:
     *
     * ```ts
     * updateMarker( markerName, { range } );
     * ```
     *
     * Update marker using operation:
     *
     * ```ts
     * updateMarker( marker, { range, usingOperation: true } );
     * updateMarker( markerName, { range, usingOperation: true } );
     * ```
     *
     * Change marker's option (start using operations to manage it):
     *
     * ```ts
     * updateMarker( marker, { usingOperation: true } );
     * ```
     *
     * Change marker's option (inform the engine, that the marker does not affect the data anymore):
     *
     * ```ts
     * updateMarker( markerName, { affectsData: false } );
     * ```
     *
     * @see module:engine/model/markercollection~Marker
     * @param markerOrName Name of a marker to update, or a marker instance.
     * @param options If options object is not defined then marker will be refreshed by triggering
     * downcast conversion for this marker with the same data.
     * @param options.range Marker range to update.
     * @param options.usingOperation Flag indicated whether the marker should be added by MarkerOperation.
     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
     * @param options.affectsData Flag indicating that the marker changes the editor data.
     */
    updateMarker(e, t) {
      this._assertWriterUsedCorrectly();
      const i = typeof e == "string" ? e : e.name, s = this.model.markers.get(i);
      if (!s)
        throw new g("writer-updatemarker-marker-not-exists", this);
      if (!t) {
        z("writer-updatemarker-reconvert-using-editingcontroller", { markerName: i }), this.model.markers._refresh(s);
        return;
      }
      const o = typeof t.usingOperation == "boolean", r = typeof t.affectsData == "boolean", a = r ? t.affectsData : s.affectsData;
      if (!o && !t.range && !r)
        throw new g("writer-updatemarker-wrong-options", this);
      const l = s.getRange(), c = t.range ? t.range : l;
      if (o && t.usingOperation !== s.managedUsingOperations) {
        t.usingOperation ? vn(this, i, null, c, a) : (vn(this, i, l, null, a), this.model.markers._set(i, c, void 0, a));
        return;
      }
      s.managedUsingOperations ? vn(this, i, l, c, a) : this.model.markers._set(i, c, void 0, a);
    }
    /**
     * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
     * The marker is removed accordingly to how it has been created, so if the marker was created using operation,
     * it will be destroyed using operation.
     *
     * @param markerOrName Marker or marker name to remove.
     */
    removeMarker(e) {
      this._assertWriterUsedCorrectly();
      const t = typeof e == "string" ? e : e.name;
      if (!this.model.markers.has(t))
        throw new g("writer-removemarker-no-marker", this);
      const i = this.model.markers.get(t);
      if (!i.managedUsingOperations) {
        this.model.markers._remove(t);
        return;
      }
      const s = i.getRange();
      vn(this, t, s, null, i.affectsData);
    }
    /**
     * Adds a new root to the document (or re-attaches a {@link #detachRoot detached root}).
     *
     * Throws an error, if trying to add a root that is already added and attached.
     *
     * @param rootName Name of the added root.
     * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
     * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
     * @returns The added root element.
     */
    addRoot(e, t = "$root") {
      this._assertWriterUsedCorrectly();
      const i = this.model.document.getRoot(e);
      if (i && i.isAttached())
        throw new g("writer-addroot-root-exists", this);
      const s = this.model.document, o = new gt(e, t, !0, s, s.version);
      return this.batch.addOperation(o), this.model.applyOperation(o), this.model.document.getRoot(e);
    }
    /**
     * Detaches the root from the document.
     *
     * All content and markers are removed from the root upon detaching. New content and new markers cannot be added to the root, as long
     * as it is detached.
     *
     * A root cannot be fully removed from the document, it can be only detached. A root is permanently removed only after you
     * re-initialize the editor and do not specify the root in the initial data.
     *
     * A detached root can be re-attached using {@link #addRoot}.
     *
     * Throws an error if the root does not exist or the root is already detached.
     *
     * @param rootOrName Name of the detached root.
     */
    detachRoot(e) {
      this._assertWriterUsedCorrectly();
      const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
      if (!t || !t.isAttached())
        throw new g("writer-detachroot-no-root", this);
      for (const o of this.model.markers)
        o.getRange().root === t && this.removeMarker(o);
      for (const o of t.getAttributeKeys())
        this.removeAttribute(o, t);
      this.remove(this.createRangeIn(t));
      const i = this.model.document, s = new gt(t.rootName, t.name, !1, i, i.version);
      this.batch.addOperation(s), this.model.applyOperation(s);
    }
    setSelection(...e) {
      this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...e);
    }
    /**
     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
     *
     * The location can be specified in the same form as
     * {@link #createPositionAt `writer.createPositionAt()`} parameters.
     *
     * @param itemOrPosition
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
     */
    setSelectionFocus(e, t) {
      this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e, t);
    }
    setSelectionAttribute(e, t) {
      if (this._assertWriterUsedCorrectly(), typeof e == "string")
        this._setSelectionAttribute(e, t);
      else
        for (const [i, s] of wt(e))
          this._setSelectionAttribute(i, s);
    }
    /**
     * Removes attribute(s) with given key(s) from the selection.
     *
     * Remove one attribute:
     *
     * ```ts
     * writer.removeSelectionAttribute( 'italic' );
     * ```
     *
     * Remove multiple attributes:
     *
     * ```ts
     * writer.removeSelectionAttribute( [ 'italic', 'bold' ] );
     * ```
     *
     * @param keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.
     */
    removeSelectionAttribute(e) {
      if (this._assertWriterUsedCorrectly(), typeof e == "string")
        this._removeSelectionAttribute(e);
      else
        for (const t of e)
          this._removeSelectionAttribute(t);
    }
    /**
     * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}
     * of the selection from left to right.
     *
     * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,
     * then the selection (after being moved by the user) inherits attributes from its left-hand side.
     * This method allows to temporarily override this behavior by forcing the gravity to the right.
     *
     * For the following model fragment:
     *
     * ```xml
     * <$text bold="true" linkHref="url">bar[]</$text><$text bold="true">biz</$text>
     * ```
     *
     * * Default gravity: selection will have the `bold` and `linkHref` attributes.
     * * Overridden gravity: selection will have `bold` attribute.
     *
     * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
     * of the process.
     *
     * @returns The unique id which allows restoring the gravity.
     */
    overrideSelectionGravity() {
      return this.model.document.selection._overrideGravity();
    }
    /**
     * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.
     *
     * Restoring the gravity is only possible using the unique identifier returned by
     * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored
     * the same number of times it was overridden.
     *
     * @param uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.
     */
    restoreSelectionGravity(e) {
      this.model.document.selection._restoreGravity(e);
    }
    /**
     * @param key Key of the attribute to remove.
     * @param value Attribute value.
     */
    _setSelectionAttribute(e, t) {
      const i = this.model.document.selection;
      if (i.isCollapsed && i.anchor.parent.isEmpty) {
        const s = lt._getStoreAttributeKey(e);
        this.setAttribute(s, t, i.anchor.parent);
      }
      i._setAttribute(e, t);
    }
    /**
     * @param key Key of the attribute to remove.
     */
    _removeSelectionAttribute(e) {
      const t = this.model.document.selection;
      if (t.isCollapsed && t.anchor.parent.isEmpty) {
        const i = lt._getStoreAttributeKey(e);
        this.removeAttribute(i, t.anchor.parent);
      }
      t._removeAttribute(e);
    }
    /**
     * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.
     */
    _assertWriterUsedCorrectly() {
      if (this.model._currentWriter !== this)
        throw new g("writer-incorrect-use", this);
    }
    /**
     * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers
     * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range
     * can be later correctly processed during undo.
     *
     * @param type Writer action type.
     * @param positionOrRange Position or range where the writer action happens.
     */
    _addOperationForAffectedMarkers(e, t) {
      for (const i of this.model.markers) {
        if (!i.managedUsingOperations)
          continue;
        const s = i.getRange();
        let o = !1;
        if (e === "move") {
          const r = t;
          o = r.containsPosition(s.start) || r.start.isEqual(s.start) || r.containsPosition(s.end) || r.end.isEqual(s.end);
        } else {
          const r = t, a = r.nodeBefore, l = r.nodeAfter, c = s.start.parent == a && s.start.isAtEnd, u = s.end.parent == l && s.end.offset == 0, d = s.end.nodeAfter == l, h = s.start.nodeAfter == l;
          o = c || u || d || h;
        }
        o && this.updateMarker(i.name, { range: s });
      }
    }
  }
  function Su(n, e, t, i) {
    const s = n.model, o = s.document;
    let r = i.start, a, l, c;
    for (const d of i.getWalker({ shallow: !0 }))
      c = d.item.getAttribute(e), a && l != c && (l != t && u(), r = a), a = d.nextPosition, l = c;
    a instanceof C && a != r && l != t && u();
    function u() {
      const d = new _(r, a), h = d.root.document ? o.version : null, f = new ae(d, e, l, t, h);
      n.batch.addOperation(f), s.applyOperation(f);
    }
  }
  function Iu(n, e, t, i) {
    const s = n.model, o = s.document, r = i.getAttribute(e);
    let a, l;
    if (r != t) {
      if (i.root === i) {
        const u = i.document ? o.version : null;
        l = new It(i, e, r, t, u);
      } else {
        a = new _(C._createBefore(i), n.createPositionAfter(i));
        const u = a.root.document ? o.version : null;
        l = new ae(a, e, r, t, u);
      }
      n.batch.addOperation(l), s.applyOperation(l);
    }
  }
  function vn(n, e, t, i, s) {
    const o = n.model, r = o.document, a = new Re(e, t, i, o.markers, !!s, r.version);
    n.batch.addOperation(a), o.applyOperation(a);
  }
  function F2(n, e, t, i) {
    let s;
    if (n.root.document) {
      const o = i.document, r = new C(o.graveyard, [0]);
      s = new H(n, e, r, o.version);
    } else
      s = new O2(n, e);
    t.addOperation(s), i.applyOperation(s);
  }
  function Pu(n, e) {
    return n === e || n instanceof Eo && e instanceof Eo;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function z2(n, e, t = {}) {
    if (e.isCollapsed)
      return;
    const i = e.getFirstRange();
    if (i.root.rootName == "$graveyard")
      return;
    const s = n.schema;
    n.change((o) => {
      if (!t.doNotResetEntireContent && Z2(s, e)) {
        K2(o, e);
        return;
      }
      const r = {};
      if (!t.doNotAutoparagraph) {
        const c = e.getSelectedElement();
        c && Object.assign(r, s.getAttributesWithProperty(c, "copyOnReplace", !0));
      }
      const [a, l] = U2(i);
      a.isTouching(l) || o.remove(o.createRange(a, l)), t.leaveUnmerged || ($2(o, a, l), s.removeDisallowedAttributes(a.parent.getChildren(), o)), Ym(o, e, a), !t.doNotAutoparagraph && G2(s, a) && Xm(o, a, e, r), a.detach(), l.detach();
    });
  }
  function U2(n) {
    const e = n.root.document.model, t = n.start;
    let i = n.end;
    if (e.hasContent(n, { ignoreMarkers: !0 })) {
      const s = H2(i);
      if (s && i.isTouching(e.createPositionAt(s, 0))) {
        const o = e.createSelection(n);
        e.modifySelection(o, { direction: "backward" });
        const r = o.getLastPosition(), a = e.createRange(r, i);
        e.hasContent(a, { ignoreMarkers: !0 }) || (i = r);
      }
    }
    return [
      le.fromPosition(t, "toPrevious"),
      le.fromPosition(i, "toNext")
    ];
  }
  function H2(n) {
    const e = n.parent, t = e.root.document.model.schema, i = e.getAncestors({ parentFirst: !0, includeSelf: !0 });
    for (const s of i) {
      if (t.isLimit(s))
        return null;
      if (t.isBlock(s))
        return s;
    }
  }
  function $2(n, e, t) {
    const i = n.model;
    if (!kl(n.model.schema, e, t))
      return;
    const [s, o] = q2(e, t);
    !s || !o || (!i.hasContent(s, { ignoreMarkers: !0 }) && i.hasContent(o, { ignoreMarkers: !0 }) ? Jm(n, e, t, s.parent) : Zm(n, e, t, s.parent));
  }
  function Zm(n, e, t, i) {
    const s = e.parent, o = t.parent;
    if (!(s == i || o == i)) {
      for (e = n.createPositionAfter(s), t = n.createPositionBefore(o), t.isEqual(e) || n.insert(o, e), n.merge(e); t.parent.isEmpty; ) {
        const r = t.parent;
        t = n.createPositionBefore(r), n.remove(r);
      }
      kl(n.model.schema, e, t) && Zm(n, e, t, i);
    }
  }
  function Jm(n, e, t, i) {
    const s = e.parent, o = t.parent;
    if (!(s == i || o == i)) {
      for (e = n.createPositionAfter(s), t = n.createPositionBefore(o), t.isEqual(e) || n.insert(s, t); e.parent.isEmpty; ) {
        const r = e.parent;
        e = n.createPositionBefore(r), n.remove(r);
      }
      t = n.createPositionBefore(o), W2(n, t), kl(n.model.schema, e, t) && Jm(n, e, t, i);
    }
  }
  function W2(n, e) {
    const t = e.nodeBefore, i = e.nodeAfter;
    t.name != i.name && n.rename(t, i.name), n.clearAttributes(t), n.setAttributes(Object.fromEntries(i.getAttributes()), t), n.merge(e);
  }
  function kl(n, e, t) {
    const i = e.parent, s = t.parent;
    return i == s || n.isLimit(i) || n.isLimit(s) ? !1 : j2(e, t, n);
  }
  function q2(n, e) {
    const t = n.getAncestors(), i = e.getAncestors();
    let s = 0;
    for (; t[s] && t[s] == i[s]; )
      s++;
    return [t[s], i[s]];
  }
  function G2(n, e) {
    const t = n.checkChild(e, "$text"), i = n.checkChild(e, "paragraph");
    return !t && i;
  }
  function j2(n, e, t) {
    const i = new _(n, e);
    for (const s of i.getWalker())
      if (t.isLimit(s.item))
        return !1;
    return !0;
  }
  function Xm(n, e, t, i = {}) {
    const s = n.createElement("paragraph");
    n.model.schema.setAllowedAttributes(s, i, n), n.insert(s, e), Ym(n, t, n.createPositionAt(s, 0));
  }
  function K2(n, e) {
    const t = n.model.schema.getLimitElement(e);
    n.remove(n.createRangeIn(t)), Xm(n, n.createPositionAt(t, 0), e);
  }
  function Z2(n, e) {
    const t = n.getLimitElement(e);
    if (!e.containsEntireContent(t))
      return !1;
    const i = e.getFirstRange();
    return i.start.parent == i.end.parent ? !1 : n.checkChild(t, "paragraph");
  }
  function Ym(n, e, t) {
    e instanceof lt ? n.setSelection(t) : e.setTo(t);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function J2(n, e) {
    return n.change((t) => {
      const i = t.createDocumentFragment(), s = e.getFirstRange();
      if (!s || s.isCollapsed)
        return i;
      const o = s.start.root, r = s.start.getCommonPath(s.end), a = o.getNodeByPath(r);
      let l;
      s.start.parent == s.end.parent ? l = s : l = t.createRange(t.createPositionAt(a, s.start.path[r.length]), t.createPositionAt(a, s.end.path[r.length] + 1));
      const c = l.end.offset - l.start.offset;
      for (const u of l.getItems({ shallow: !0 }))
        u.is("$textProxy") ? t.appendText(u.data, u.getAttributes(), i) : t.append(t.cloneElement(u, !0), i);
      if (l != s) {
        const u = s._getTransformedByMove(l.start, t.createPositionAt(i, 0), c)[0], d = t.createRange(t.createPositionAt(i, 0), u.start), h = t.createRange(u.end, t.createPositionAt(i, "end"));
        Ru(h, t), Ru(d, t);
      }
      return i;
    });
  }
  function Ru(n, e) {
    const t = [];
    Array.from(n.getItems({ direction: "backward" })).map((i) => e.createRangeOn(i)).filter((i) => (i.start.isAfter(n.start) || i.start.isEqual(n.start)) && (i.end.isBefore(n.end) || i.end.isEqual(n.end))).forEach((i) => {
      t.push(i.start.parent), e.remove(i);
    }), t.forEach((i) => {
      let s = i;
      for (; s.parent && s.isEmpty; ) {
        const o = e.createRangeOn(s);
        s = s.parent, e.remove(o);
      }
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function X2(n, e, t) {
    return n.change((i) => {
      const s = t || n.document.selection;
      s.isCollapsed || n.deleteContent(s, { doNotAutoparagraph: !0 });
      const o = new Y2(n, i, s.anchor), r = [];
      let a;
      if (e.is("documentFragment")) {
        if (e.markers.size) {
          const u = [];
          for (const [d, h] of e.markers) {
            const { start: f, end: m } = h, p = f.isEqual(m);
            u.push({ position: f, name: d, isCollapsed: p }, { position: m, name: d, isCollapsed: p });
          }
          u.sort(({ position: d }, { position: h }) => d.isBefore(h) ? 1 : -1);
          for (const { position: d, name: h, isCollapsed: f } of u) {
            let m = null, p = null;
            const b = d.parent === e && d.isAtStart, v = d.parent === e && d.isAtEnd;
            !b && !v ? (m = i.createElement("$marker"), i.insert(m, d)) : f && (p = b ? "start" : "end"), r.push({
              name: h,
              element: m,
              collapsed: p
            });
          }
        }
        a = e.getChildren();
      } else
        a = [e];
      o.handleNodes(a);
      let l = o.getSelectionRange();
      if (e.is("documentFragment") && r.length) {
        const u = l ? Pe.fromRange(l) : null, d = {};
        for (let h = r.length - 1; h >= 0; h--) {
          const { name: f, element: m, collapsed: p } = r[h], b = !d[f];
          if (b && (d[f] = []), m) {
            const v = i.createPositionAt(m, "before");
            d[f].push(v), i.remove(m);
          } else {
            const v = o.getAffectedRange();
            if (!v) {
              p && d[f].push(o.position);
              continue;
            }
            p ? d[f].push(v[p]) : d[f].push(b ? v.start : v.end);
          }
        }
        for (const [h, [f, m]] of Object.entries(d))
          f && m && f.root === m.root && f.root.document && !i.model.markers.has(h) && i.addMarker(h, {
            usingOperation: !0,
            affectsData: !0,
            range: new _(f, m)
          });
        u && (l = u.toRange(), u.detach());
      }
      /* istanbul ignore else -- @preserve */
      l && (s instanceof lt ? i.setSelection(l) : s.setTo(l));
      const c = o.getAffectedRange() || n.createRange(s.anchor);
      return o.destroy(), c;
    });
  }
  class Y2 {
    constructor(e, t, i) {
      this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = e, this.writer = t, this.position = i, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = e.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0);
    }
    /**
     * Handles insertion of a set of nodes.
     *
     * @param nodes Nodes to insert.
     */
    handleNodes(e) {
      for (const t of Array.from(e))
        this._handleNode(t);
      this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
    }
    /**
     * Updates the last node after the auto paragraphing.
     *
     * @param node The last auto paragraphing node.
     */
    _updateLastNodeFromAutoParagraph(e) {
      const t = this.writer.createPositionAfter(this._lastNode), i = this.writer.createPositionAfter(e);
      if (i.isAfter(t)) {
        this._lastNode = e;
        /* istanbul ignore if -- @preserve */
        if (this.position.parent != e || !this.position.isAtEnd)
          throw new g("insertcontent-invalid-insertion-position", this);
        this.position = i, this._setAffectedBoundaries(this.position);
      }
    }
    /**
     * Returns range to be selected after insertion.
     * Returns `null` if there is no valid range to select after insertion.
     */
    getSelectionRange() {
      return this._nodeToSelect ? _._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
    }
    /**
     * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state
     * before the insertion. Returns `null` if no changes were done.
     */
    getAffectedRange() {
      return this._affectedStart ? new _(this._affectedStart, this._affectedEnd) : null;
    }
    /**
     * Destroys `Insertion` instance.
     */
    destroy() {
      this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
    }
    /**
     * Handles insertion of a single node.
     */
    _handleNode(e) {
      if (this.schema.isObject(e)) {
        this._handleObject(e);
        return;
      }
      let t = this._checkAndAutoParagraphToAllowedPosition(e);
      if (!t && (t = this._checkAndSplitToAllowedPosition(e), !t)) {
        this._handleDisallowedNode(e);
        return;
      }
      this._appendToFragment(e), this._firstNode || (this._firstNode = e), this._lastNode = e;
    }
    /**
     * Inserts the temporary DocumentFragment into the model.
     */
    _insertPartialFragment() {
      if (this._documentFragment.isEmpty)
        return;
      const e = le.fromPosition(this.position, "toNext");
      this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e.toPosition(), e.detach();
    }
    /**
     * @param node The object element.
     */
    _handleObject(e) {
      this._checkAndSplitToAllowedPosition(e) ? this._appendToFragment(e) : this._tryAutoparagraphing(e);
    }
    /**
     * @param node The disallowed node which needs to be handled.
     */
    _handleDisallowedNode(e) {
      e.is("element") ? this.handleNodes(e.getChildren()) : this._tryAutoparagraphing(e);
    }
    /**
     * Append a node to the temporary DocumentFragment.
     *
     * @param node The node to insert.
     */
    _appendToFragment(e) {
      /* istanbul ignore if -- @preserve */
      if (!this.schema.checkChild(this.position, e))
        throw new g("insertcontent-wrong-position", this, { node: e, position: this.position });
      this.writer.insert(e, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize), this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null, this._filterAttributesOf.push(e);
    }
    /**
     * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to
     * mark the affected range.
     *
     * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed
     * during merging, but the logic there is more complicated so it is left out of this function.
     */
    _setAffectedBoundaries(e) {
      this._affectedStart || (this._affectedStart = le.fromPosition(e, "toPrevious")), (!this._affectedEnd || this._affectedEnd.isBefore(e)) && (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = le.fromPosition(e, "toNext"));
    }
    /**
     * Merges the previous sibling of the first node if it should be merged.
     *
     * After the content was inserted we may try to merge it with its siblings.
     * This should happen only if the selection was in those elements initially.
     */
    _mergeOnLeft() {
      const e = this._firstNode;
      if (!(e instanceof W) || !this._canMergeLeft(e))
        return;
      const t = le._createBefore(e);
      t.stickiness = "toNext";
      const i = le.fromPosition(this.position, "toNext");
      this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = le._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = le._createAt(t.nodeBefore, "end", "toNext")), this.position = i.toPosition(), i.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
    }
    /**
     * Merges the next sibling of the last node if it should be merged.
     *
     * After the content was inserted we may try to merge it with its siblings.
     * This should happen only if the selection was in those elements initially.
     */
    _mergeOnRight() {
      const e = this._lastNode;
      if (!(e instanceof W) || !this._canMergeRight(e))
        return;
      const t = le._createAfter(e);
      t.stickiness = "toNext";
      /* istanbul ignore if -- @preserve */
      if (!this.position.isEqual(t))
        throw new g("insertcontent-invalid-insertion-position", this);
      this.position = C._createAt(t.nodeBefore, "end");
      const i = le.fromPosition(this.position, "toPrevious");
      this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = le._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = le._createAt(t.nodeBefore, 0, "toPrevious")), this.position = i.toPosition(), i.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
    }
    /**
     * Checks whether specified node can be merged with previous sibling element.
     *
     * @param node The node which could potentially be merged.
     */
    _canMergeLeft(e) {
      const t = e.previousSibling;
      return t instanceof W && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e);
    }
    /**
     * Checks whether specified node can be merged with next sibling element.
     *
     * @param node The node which could potentially be merged.
     */
    _canMergeRight(e) {
      const t = e.nextSibling;
      return t instanceof W && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t);
    }
    /**
     * Tries wrapping the node in a new paragraph and inserting it this way.
     *
     * @param node The node which needs to be autoparagraphed.
     */
    _tryAutoparagraphing(e) {
      const t = this.writer.createElement("paragraph");
      this._getAllowedIn(this.position.parent, t) && this.schema.checkChild(t, e) && (t._appendChild(e), this._handleNode(t));
    }
    /**
     * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.
     * It also handles inserting the paragraph.
     *
     * @returns Whether an allowed position was found.
     * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.
     */
    _checkAndAutoParagraphToAllowedPosition(e) {
      if (this.schema.checkChild(this.position.parent, e))
        return !0;
      if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e))
        return !1;
      this._insertPartialFragment();
      const t = this.writer.createElement("paragraph");
      return this.writer.insert(t, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = t, this.position = this.writer.createPositionAt(t, 0), !0;
    }
    /**
     * @returns Whether an allowed position was found.
     * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
     */
    _checkAndSplitToAllowedPosition(e) {
      const t = this._getAllowedIn(this.position.parent, e);
      if (!t)
        return !1;
      for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent; )
        if (this.position.isAtStart) {
          const i = this.position.parent;
          this.position = this.writer.createPositionBefore(i), i.isEmpty && i.parent === t && this.writer.remove(i);
        } else if (this.position.isAtEnd)
          this.position = this.writer.createPositionAfter(this.position.parent);
        else {
          const i = this.writer.createPositionAfter(this.position.parent);
          this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = i, this.canMergeWith.add(this.position.nodeAfter);
        }
      return !0;
    }
    /**
     * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
     *
     * @param contextElement The element in which context the node should be checked.
     * @param childNode The node to check.
     */
    _getAllowedIn(e, t) {
      return this.schema.checkChild(e, t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Q2(n, e, t, i = {}) {
    if (!n.schema.isObject(e))
      throw new g("insertobject-element-not-an-object", n, { object: e });
    const s = t || n.document.selection;
    let o = s;
    i.findOptimalPosition && n.schema.isBlock(e) && (o = n.createSelection(n.schema.findOptimalInsertionRange(s, i.findOptimalPosition)));
    const r = me(s.getSelectedBlocks()), a = {};
    return r && Object.assign(a, n.schema.getAttributesWithProperty(r, "copyOnReplace", !0)), n.change((l) => {
      o.isCollapsed || n.deleteContent(o, { doNotAutoparagraph: !0 });
      let c = e;
      const u = o.anchor.parent;
      !n.schema.checkChild(u, e) && n.schema.checkChild(u, "paragraph") && n.schema.checkChild("paragraph", e) && (c = l.createElement("paragraph"), l.insert(e, c)), n.schema.setAllowedAttributes(c, a, l);
      const d = n.insertContent(c, o);
      return d.isCollapsed || i.setSelection && eE(l, e, i.setSelection, a), d;
    });
  }
  function eE(n, e, t, i) {
    const s = n.model;
    if (t == "on") {
      n.setSelection(e, "on");
      return;
    }
    if (t != "after")
      throw new g("insertobject-invalid-place-parameter-value", s);
    let o = e.nextSibling;
    if (s.schema.isInline(e)) {
      n.setSelection(e, "after");
      return;
    }
    !(o && s.schema.checkChild(o, "$text")) && s.schema.checkChild(e.parent, "paragraph") && (o = n.createElement("paragraph"), s.schema.setAllowedAttributes(o, i, n), s.insertContent(o, n.createPositionAfter(e))), o && n.setSelection(o, 0);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const tE = ' ,.?!:;"-()';
  function iE(n, e, t = {}) {
    const i = n.schema, s = t.direction != "backward", o = t.unit ? t.unit : "character", r = !!t.treatEmojiAsSingleUnit, a = e.focus, l = new xt({
      boundaries: rE(a, s),
      singleCharacters: !0,
      direction: s ? "forward" : "backward"
    }), c = { walker: l, schema: i, isForward: s, unit: o, treatEmojiAsSingleUnit: r };
    let u;
    for (; u = l.next(); ) {
      if (u.done)
        return;
      const d = nE(c, u.value);
      if (d) {
        e instanceof lt ? n.change((h) => {
          h.setSelectionFocus(d);
        }) : e.setFocus(d);
        return;
      }
    }
  }
  function nE(n, e) {
    const { isForward: t, walker: i, unit: s, schema: o, treatEmojiAsSingleUnit: r } = n, { type: a, item: l, nextPosition: c } = e;
    if (a == "text")
      return n.unit === "word" ? oE(i, t) : sE(i, s, r);
    if (a == (t ? "elementStart" : "elementEnd")) {
      if (o.isSelectable(l))
        return C._createAt(l, t ? "after" : "before");
      if (o.checkChild(c, "$text"))
        return c;
    } else {
      if (o.isLimit(l)) {
        i.skip(() => !0);
        return;
      }
      if (o.checkChild(c, "$text"))
        return c;
    }
  }
  function sE(n, e, t) {
    const i = n.position.textNode;
    if (i) {
      const s = i.data;
      let o = n.position.offset - i.startOffset;
      for (; hl(s, o) || e == "character" && fl(s, o) || t && lm(s, o); )
        n.next(), o = n.position.offset - i.startOffset;
    }
    return n.position;
  }
  function oE(n, e) {
    let t = n.position.textNode;
    for (t || (t = e ? n.position.nodeAfter : n.position.nodeBefore); t && t.is("$text"); ) {
      const i = n.position.offset - t.startOffset;
      if (lE(t, i, e))
        t = e ? n.position.nodeAfter : n.position.nodeBefore;
      else {
        if (aE(t.data, i, e))
          break;
        n.next();
      }
    }
    return n.position;
  }
  function rE(n, e) {
    const t = n.root, i = C._createAt(t, e ? "end" : 0);
    return e ? new _(n, i) : new _(i, n);
  }
  function aE(n, e, t) {
    const i = e + (t ? 0 : -1);
    return tE.includes(n.charAt(i));
  }
  function lE(n, e, t) {
    return e === (t ? n.offsetSize : 0);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  let cE = class extends $() {
    // @if CK_DEBUG_ENGINE // private _operationLogs: Array<string>;
    // @if CK_DEBUG_ENGINE // private _appliedOperations: Array<Operation>;
    constructor() {
      super(), this.markers = new B2(), this.document = new M2(this), this.schema = new JT(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((e) => this.decorate(e)), this.on("applyOperation", (e, t) => {
        t[0]._validate();
      }, { priority: "highest" }), this.schema.register("$root", {
        isLimit: !0
      }), this.schema.register("$container", {
        allowIn: ["$root", "$container"]
      }), this.schema.register("$block", {
        allowIn: ["$root", "$container"],
        isBlock: !0
      }), this.schema.register("$blockObject", {
        allowWhere: "$block",
        isBlock: !0,
        isObject: !0
      }), this.schema.register("$inlineObject", {
        allowWhere: "$text",
        allowAttributesOf: "$text",
        isInline: !0,
        isObject: !0
      }), this.schema.register("$text", {
        allowIn: "$block",
        isInline: !0,
        isContent: !0
      }), this.schema.register("$clipboardHolder", {
        allowContentOf: "$root",
        allowChildren: "$text",
        isLimit: !0
      }), this.schema.register("$documentFragment", {
        allowContentOf: "$root",
        allowChildren: "$text",
        isLimit: !0
      }), this.schema.register("$marker"), this.schema.addChildCheck((e, t) => {
        if (t.name === "$marker")
          return !0;
      }), UT(this), this.document.registerPostFixer(Dm), this.on("insertContent", (e, [t, i]) => {
        e.return = X2(this, t, i);
      }), this.on("insertObject", (e, [t, i, s]) => {
        e.return = Q2(this, t, i, s);
      }), this.on("canEditAt", (e) => {
        const t = !this.document.isReadOnly;
        e.return = t, t || e.stop();
      });
    }
    /**
     * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes
     * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),
     * the {@link module:engine/model/document~Document#selection document's selection}, and
     * {@link module:engine/model/model~Model#markers model markers}.
     *
     * ```ts
     * model.change( writer => {
     * 	writer.insertText( 'foo', paragraph, 'end' );
     * } );
     * ```
     *
     * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined
     * into a single undo step.
     *
     * ```ts
     * model.change( writer => {
     * 	writer.insertText( 'foo', paragraph, 'end' ); // foo.
     *
     * 	model.change( writer => {
     * 		writer.insertText( 'bar', paragraph, 'end' ); // foobar.
     * 	} );
     *
     * 	writer.insertText( 'bom', paragraph, 'end' ); // foobarbom.
     * } );
     * ```
     *
     * The callback of the `change()` block is executed synchronously.
     *
     * You can also return a value from the change block.
     *
     * ```ts
     * const img = model.change( writer => {
     * 	return writer.createElement( 'img' );
     * } );
     * ```
     *
     * @see #enqueueChange
     * @typeParam TReturn The return type of the provided callback.
     * @param callback Callback function which may modify the model.
     */
    change(e) {
      try {
        return this._pendingChanges.length === 0 ? (this._pendingChanges.push({ batch: new Li(), callback: e }), this._runPendingChanges()[0]) : e(this._currentWriter);
      } catch (t) {
        /* istanbul ignore next -- @preserve */
        g.rethrowUnexpectedError(t, this);
      }
    }
    enqueueChange(e, t) {
      try {
        e ? typeof e == "function" ? (t = e, e = new Li()) : e instanceof Li || (e = new Li(e)) : e = new Li(), this._pendingChanges.push({ batch: e, callback: t }), this._pendingChanges.length == 1 && this._runPendingChanges();
      } catch (i) {
        /* istanbul ignore next -- @preserve */
        g.rethrowUnexpectedError(i, this);
      }
    }
    /**
     * {@link module:utils/observablemixin~Observable#decorate Decorated} function for applying
     * {@link module:engine/model/operation/operation~Operation operations} to the model.
     *
     * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).
     * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.
     * See also {@glink framework/architecture/editing-engine#changing-the-model Changing the model} section
     * of the {@glink framework/architecture/editing-engine Editing architecture} guide.
     *
     * @param operation The operation to apply.
     */
    applyOperation(e) {
      e._execute();
    }
    // @if CK_DEBUG_ENGINE // public getAppliedOperation(): string {
    // @if CK_DEBUG_ENGINE // 	if ( !this._appliedOperations ) {
    // @if CK_DEBUG_ENGINE // 		return '';
    // @if CK_DEBUG_ENGINE // 	}
    // @if CK_DEBUG_ENGINE // 	return this._appliedOperations.map( operation => JSON.stringify( operation ) ).join( '-------' );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // public createReplayer( stringifiedOperations: string ): typeof OperationReplayer {
    // @if CK_DEBUG_ENGINE // 	return new OperationReplayer( this, '-------', stringifiedOperations );
    // @if CK_DEBUG_ENGINE // }
    /**
     * Inserts content at the position in the editor specified by the selection, as one would expect the paste
     * functionality to work.
     *
     * **Note**: If you want to insert an {@glink framework/deep-dive/schema#object-elements object element}
     * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.
     *
     * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting
     * the content, clears the given selection's content before inserting nodes and moves the selection
     * to its target position at the end of the process.
     * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &ndash; just like the
     * pasting feature should do.
     *
     * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.
     *
     * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used
     * inside a {@link #change `change()` block}.
     *
     * # Conversion and schema
     *
     * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content
     * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does
     * is only adding nodes to the model. Additionally, you need to define
     * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
     * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
     *
     * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods
     * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML
     * unless converters are defined for all elements and attributes in that HTML.
     *
     * # Examples
     *
     * Using `insertContent()` with a manually created model structure:
     *
     * ```ts
     * // Let's create a document fragment containing such content as:
     * //
     * // <paragraph>foo</paragraph>
     * // <blockQuote>
     * //    <paragraph>bar</paragraph>
     * // </blockQuote>
     * const docFrag = editor.model.change( writer => {
     * 	const p1 = writer.createElement( 'paragraph' );
     * 	const p2 = writer.createElement( 'paragraph' );
     * 	const blockQuote = writer.createElement( 'blockQuote' );
     * 	const docFrag = writer.createDocumentFragment();
     *
     * 	writer.append( p1, docFrag );
     * 	writer.append( blockQuote, docFrag );
     * 	writer.append( p2, blockQuote );
     * 	writer.insertText( 'foo', p1 );
     * 	writer.insertText( 'bar', p2 );
     *
     * 	return docFrag;
     * } );
     *
     * // insertContent() does not have to be used in a change() block. It can, though,
     * // so this code could be moved to the callback defined above.
     * editor.model.insertContent( docFrag );
     * ```
     *
     * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):
     *
     * ```ts
     * // You can create your own HtmlDataProcessor instance or use editor.data.processor
     * // if you have not overridden the default one (which is the HtmlDataProcessor instance).
     * const htmlDP = new HtmlDataProcessor( viewDocument );
     *
     * // Convert an HTML string to a view document fragment:
     * const viewFragment = htmlDP.toView( htmlString );
     *
     * // Convert the view document fragment to a model document fragment
     * // in the context of $root. This conversion takes the schema into
     * // account so if, for example, the view document fragment contained a bare text node,
     * // this text node cannot be a child of $root, so it will be automatically
     * // wrapped with a <paragraph>. You can define the context yourself (in the second parameter),
     * // and e.g. convert the content like it would happen in a <paragraph>.
     * // Note: The clipboard feature uses a custom context called $clipboardHolder
     * // which has a loosened schema.
     * const modelFragment = editor.data.toModel( viewFragment );
     *
     * editor.model.insertContent( modelFragment );
     * ```
     *
     * By default this method will use the document selection but it can also be used with a position, range or selection instance.
     *
     * ```ts
     * // Insert text at the current document selection position.
     * editor.model.change( writer => {
     * 	editor.model.insertContent( writer.createText( 'x' ) );
     * } );
     *
     * // Insert text at a given position - the document selection will not be modified.
     * editor.model.change( writer => {
     * 	editor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );
     *
     * 	// Which is a shorthand for:
     * 	editor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );
     * } );
     * ```
     *
     * If you want the document selection to be moved to the inserted content, use the
     * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting
     * the content:
     *
     * ```ts
     * editor.model.change( writer => {
     * 	const paragraph = writer.createElement( 'paragraph' );
     *
     * 	// Insert an empty paragraph at the beginning of the root.
     * 	editor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );
     *
     * 	// Move the document selection to the inserted paragraph.
     * 	writer.setSelection( paragraph, 'in' );
     * } );
     * ```
     *
     * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,
     * the new content will be inserted at the passed selection (instead of document selection):
     *
     * ```ts
     * editor.model.change( writer => {
     * 	// Create a selection in a paragraph that will be used as a place of insertion.
     * 	const selection = writer.createSelection( paragraph, 'in' );
     *
     * 	// Insert the new text at the created selection.
     * 	editor.model.insertContent( writer.createText( 'x' ), selection );
     *
     * 	// insertContent() modifies the passed selection instance so it can be used to set the document selection.
     * 	// Note: This is not necessary when you passed the document selection to insertContent().
     * 	writer.setSelection( selection );
     * } );
     * ```
     *
     * @fires insertContent
     * @param content The content to insert.
     * @param selectable The selection into which the content should be inserted.
     * If not provided the current model document selection will be used.
     * @param placeOrOffset To be used when a model item was passed as `selectable`.
     * This param defines a position in relation to that item.
     * at the insertion position.
     */
    insertContent(e, t, i, ...s) {
      const o = Sr(t, i);
      return this.fire("insertContent", [e, o, i, ...s]);
    }
    /**
     * Inserts an {@glink framework/deep-dive/schema#object-elements object element} at a specific position in the editor content.
     *
     * This is a high-level API:
     * * It takes the {@link #schema schema} into consideration,
     * * It clears the content of passed `selectable` before inserting,
     * * It can move the selection at the end of the process,
     * * It will copy the selected block's attributes to preserve them upon insertion,
     * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,
     * * etc.
     *
     * # Notes
     *
     * * If you want to insert a non-object content, see {@link #insertContent} instead.
     * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.
     * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside
     * a {@link #change `change()` block}.
     * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.
     * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does
     * is only adding nodes to the model. Additionally, you need to define
     * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
     * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
     *
     * # Examples
     *
     * Use the following code to insert an object at the current selection and keep the selection on the inserted element:
     *
     * ```ts
     * const rawHtmlEmbedElement = writer.createElement( 'rawHtml' );
     *
     * model.insertObject( rawHtmlEmbedElement, null, null, {
     * 	setSelection: 'on'
     * } );
     * ```
     *
     * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:
     *
     * ```ts
     * const pageBreakElement = writer.createElement( 'pageBreak' );
     *
     * model.insertObject( pageBreakElement, null, null, {
     * 	setSelection: 'after'
     * } );
     * ```
     *
     * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):
     *
     * ```ts
     * const tableElement = writer.createElement( 'table' );
     *
     * model.insertObject( tableElement, null, null, {
     * 	findOptimalPosition: 'auto'
     * } );
     * ```
     *
     * Use the following code to insert an object at the specific range (also: replace the content of the range):
     *
     * ```ts
     * const tableElement = writer.createElement( 'table' );
     * const range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );
     *
     * model.insertObject( tableElement, range );
     * ```
     *
     * @param element An object to be inserted into the model document.
     * @param selectable A selectable where the content should be inserted. If not specified, the current
     * {@link module:engine/model/document~Document#selection document selection} will be used instead.
     * @param placeOrOffset Specifies the exact place or offset for the insertion to take place, relative to `selectable`.
     * @param options Additional options.
     * @param options.findOptimalPosition An option that, when set, adjusts the insertion position (relative to
     * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).
     * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.
     * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.
     * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.
     *
     * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.
     * @param options.setSelection An option that, when set, moves the
     * {@link module:engine/model/document~Document#selection document selection} after inserting the object.
     * * When `'on'`, the document selection will be set on the inserted object.
     * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no
     * such text node, a paragraph will be created and the document selection will be moved inside it.
     * at the insertion position.
     */
    insertObject(e, t, i, s, ...o) {
      const r = Sr(t, i);
      return this.fire("insertObject", [e, r, s, s, ...o]);
    }
    /**
     * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
     *
     * **Note:** For the sake of predictability, the resulting selection should always be collapsed.
     * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
     * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
     * then that behavior should be implemented in the view's listener. At the same time, the table feature
     * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
     * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
     * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
     *
     * @fires deleteContent
     * @param selection Selection of which the content should be deleted.
     * @param options.leaveUnmerged Whether to merge elements after removing the content of the selection.
     *
     * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:
     *
     * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)
     * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
     *
     * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}
     * elements will not be merged.
     *
     * @param options.doNotResetEntireContent Whether to skip replacing the entire content with a
     * paragraph when the entire content was selected.
     *
     * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:
     *
     * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
     * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)
     *
     * @param options.doNotAutoparagraph Whether to create a paragraph if after content deletion selection is moved
     * to a place where text cannot be inserted.
     *
     * For example `<paragraph>x</paragraph>[<imageBlock src="foo.jpg"></imageBlock>]` will become:
     *
     * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
     * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).
     *
     * **Note:** if there is no valid position for the selection, the paragraph will always be created:
     *
     * `[<imageBlock src="foo.jpg"></imageBlock>]` -> `<paragraph>[]</paragraph>`.
     *
     * @param options.direction The direction in which the content is being consumed.
     * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to
     * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.
     */
    deleteContent(e, t) {
      z2(this, e, t);
    }
    /**
     * Modifies the selection. Currently, the supported modifications are:
     *
     * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
     * Possible values for `unit` are:
     *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
     *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
     *  with a symbol before it ("base character") to create one user-perceived character. For example, `q̣̇` is a normal
     *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
     *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
     *  why `'character'` value is most natural and common method of modifying selection.
     *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
     *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
     *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
     *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
     *  For example `𨭎` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
     *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
     *  extension will include whole "surrogate pair".
     *  * `'word'` - moves selection by a whole word.
     *
     * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
     *
     * @fires modifySelection
     * @param selection The selection to modify.
     * @param options.direction The direction in which the selection should be modified.
     * @param options.unit The unit by which selection should be modified.
     * @param options.treatEmojiAsSingleUnit Whether multi-characer emoji sequences should be handled as single unit.
     */
    modifySelection(e, t) {
      iE(this, e, t);
    }
    /**
     * Gets a clone of the selected content.
     *
     * For example, for the following selection:
     *
     * ```html
     * <paragraph>x</paragraph>
     * <blockQuote>
     * 	<paragraph>y</paragraph>
     * 	<heading1>fir[st</heading1>
     * </blockQuote>
     * <paragraph>se]cond</paragraph>
     * <paragraph>z</paragraph>
     * ```
     *
     * It will return a document fragment with such a content:
     *
     * ```html
     * <blockQuote>
     * 	<heading1>st</heading1>
     * </blockQuote>
     * <paragraph>se</paragraph>
     * ```
     *
     * @fires getSelectedContent
     * @param selection The selection of which content will be returned.
     */
    getSelectedContent(e) {
      return J2(this, e);
    }
    /**
     * Checks whether the given {@link module:engine/model/range~Range range} or
     * {@link module:engine/model/element~Element element} has any meaningful content.
     *
     * Meaningful content is:
     *
     * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain
     * any non-whitespace characters),
     * * or any {@link module:engine/model/schema~Schema#isContent content element},
     * * or any {@link module:engine/model/markercollection~Marker marker} which
     * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.
     *
     * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.
     * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)
     * is considered non-empty.
     *
     * @param rangeOrElement Range or element to check.
     * @param options.ignoreWhitespaces Whether text node with whitespaces only should be considered empty.
     * @param options.ignoreMarkers Whether markers should be ignored.
     */
    hasContent(e, t = {}) {
      const i = e instanceof _ ? e : _._createIn(e);
      if (i.isCollapsed)
        return !1;
      const { ignoreWhitespaces: s = !1, ignoreMarkers: o = !1 } = t;
      if (!o) {
        for (const r of this.markers.getMarkersIntersectingRange(i))
          if (r.affectsData)
            return !0;
      }
      for (const r of i.getItems())
        if (this.schema.isContent(r))
          if (r.is("$textProxy"))
            if (s) {
              if (r.data.search(/\S/) !== -1)
                return !0;
            } else
              return !0;
          else
            return !0;
      return !1;
    }
    /**
     * Check whether given selectable is at a place in the model where it can be edited (returns `true`) or not (returns `false`).
     *
     * Should be used instead of {@link module:core/editor/editor~Editor#isReadOnly} to check whether a user action can happen at
     * given selectable. It may be decorated and used differently in different environment (e.g. multi-root editor can disable
     * a particular root).
     *
     * This method is decorated. Although this method accepts any parameter of `Selectable` type, the
     * {@link ~Model#event:canEditAt `canEditAt` event} is fired with `selectable` normalized to an instance of
     * {@link module:engine/model/selection~Selection} or {@link module:engine/model/documentselection~DocumentSelection}
     *
     * @fires canEditAt
     */
    canEditAt(e) {
      const t = Sr(e);
      return this.fire("canEditAt", [t]);
    }
    /**
     * Creates a position from the given root and path in that root.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.
     *
     * @param root Root of the position.
     * @param path Position path. See {@link module:engine/model/position~Position#path}.
     * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
     */
    createPositionFromPath(e, t, i) {
      return new C(e, t, i);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/model/position~Position position},
     * * a parent element and offset in that element,
     * * a parent element and `'end'` (the position will be set at the end of that element),
     * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`
     * (the position will be set before or after the given model item).
     *
     * This method is a shortcut to other factory methods such as:
     *
     * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},
     * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},
     *
     * @param itemOrPosition
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
     */
    createPositionAt(e, t) {
      return C._createAt(e, t);
    }
    /**
     * Creates a new position after the given {@link module:engine/model/item~Item model item}.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.
     *
     * @param item Item after which the position should be placed.
     */
    createPositionAfter(e) {
      return C._createAfter(e);
    }
    /**
     * Creates a new position before the given {@link module:engine/model/item~Item model item}.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.
     *
     * @param item Item before which the position should be placed.
     */
    createPositionBefore(e) {
      return C._createBefore(e);
    }
    /**
     * Creates a range spanning from the `start` position to the `end` position.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:
     *
     * ```ts
     * model.change( writer => {
     * 	const range = writer.createRange( start, end );
     * } );
     * ```
     *
     * @param start Start position.
     * @param end End position. If not set, the range will be collapsed to the `start` position.
     */
    createRange(e, t) {
      return new _(e, t);
    }
    /**
     * Creates a range inside the given element which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:
     *
     * ```ts
     * model.change( writer => {
     * 	const range = writer.createRangeIn( paragraph );
     * } );
     * ```
     *
     * @param element Element which is a parent for the range.
     */
    createRangeIn(e) {
      return _._createIn(e);
    }
    /**
     * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.
     *
     * Note: This method is also available on `writer` instance as
     * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:
     *
     * ```ts
     * model.change( writer => {
     * 	const range = writer.createRangeOn( paragraph );
     * } );
     * ```
     *
     * @param item
     */
    createRangeOn(e) {
      return _._createOn(e);
    }
    createSelection(...e) {
      return new De(...e);
    }
    /**
     * Creates a {@link module:engine/model/batch~Batch} instance.
     *
     * **Note:** In most cases creating a batch instance is not necessary as they are created when using:
     *
     * * {@link #change `change()`},
     * * {@link #enqueueChange `enqueueChange()`}.
     *
     * @param type {@link module:engine/model/batch~Batch#constructor The type} of the batch.
     */
    createBatch(e) {
      return new Li(e);
    }
    /**
     * Creates an operation instance from a JSON object (parsed JSON string).
     *
     * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.
     *
     * @param json Deserialized JSON object.
     */
    createOperationFromJSON(e) {
      return C2.fromJSON(e, this.document);
    }
    /**
     * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.
     */
    destroy() {
      this.document.destroy(), this.stopListening();
    }
    /**
     * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}
     * which calls callbacks and returns array of values returned by these callbacks.
     */
    _runPendingChanges() {
      const e = [];
      this.fire("_beforeChanges");
      try {
        for (; this._pendingChanges.length; ) {
          const t = this._pendingChanges[0].batch;
          this._currentWriter = new D2(this, t);
          const i = this._pendingChanges[0].callback(this._currentWriter);
          e.push(i), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
        }
      } finally {
        this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
      }
      return e;
    }
  };
  function Sr(n, e) {
    if (n)
      return n instanceof De || n instanceof lt ? n : n instanceof vi ? e || e === 0 ? new De(n, e) : n.is("rootElement") ? new De(n, "in") : new De(n, "on") : new De(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class uE extends Gt {
    constructor() {
      super(...arguments), this.domEventType = "click";
    }
    /**
     * @inheritDoc
     */
    onDomEvent(e) {
      this.fire(e.type, e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class er extends Gt {
    constructor() {
      super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
    }
    /**
     * @inheritDoc
     */
    onDomEvent(e) {
      this.fire(e.type, e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Mt {
    /**
     * @param document The view document instance in which this upcast writer operates.
     */
    constructor(e) {
      this.document = e;
    }
    /**
     * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
     *
     * @param children A list of nodes to be inserted into the created document fragment.
     * @returns The created document fragment.
     */
    createDocumentFragment(e) {
      return new ri(this.document, e);
    }
    /**
     * Creates a new {@link module:engine/view/element~Element} instance.
     *
     * Attributes can be passed in various formats:
     *
     * ```ts
     * upcastWriter.createElement( 'div', { class: 'editor', contentEditable: 'true' } ); // object
     * upcastWriter.createElement( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
     * upcastWriter.createElement( 'div', mapOfAttributes ); // map
     * ```
     *
     * @param name Node name.
     * @param attrs Collection of attributes.
     * @param children A list of nodes to be inserted into created element.
     * @returns Created element.
     */
    createElement(e, t, i) {
      return new at(this.document, e, t, i);
    }
    /**
     * Creates a new {@link module:engine/view/text~Text} instance.
     *
     * @param data The text's data.
     * @returns The created text node.
     */
    createText(e) {
      return new ie(this.document, e);
    }
    /**
     * Clones the provided element.
     *
     * @see module:engine/view/element~Element#_clone
     * @param element Element to be cloned.
     * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any children.
     * @returns Clone of this element.
     */
    clone(e, t = !1) {
      return e._clone(t);
    }
    /**
     * Appends a child node or a list of child nodes at the end of this node
     * and sets the parent of these nodes to this element.
     *
     * @see module:engine/view/element~Element#_appendChild
     * @param items Items to be inserted.
     * @param element Element to which items will be appended.
     * @returns Number of appended nodes.
     */
    appendChild(e, t) {
      return t._appendChild(e);
    }
    /**
     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
     * this element.
     *
     * @see module:engine/view/element~Element#_insertChild
     * @param index Offset at which nodes should be inserted.
     * @param items Items to be inserted.
     * @param element Element to which items will be inserted.
     * @returns Number of inserted nodes.
     */
    insertChild(e, t, i) {
      return i._insertChild(e, t);
    }
    /**
     * Removes the given number of child nodes starting at the given index and set the parent of these nodes to `null`.
     *
     * @see module:engine/view/element~Element#_removeChildren
     * @param index Offset from which nodes will be removed.
     * @param howMany Number of nodes to remove.
     * @param element Element which children will be removed.
     * @returns The array containing removed nodes.
     */
    removeChildren(e, t, i) {
      return i._removeChildren(e, t);
    }
    /**
     * Removes given element from the view structure. Will not have effect on detached elements.
     *
     * @param element Element which will be removed.
     * @returns The array containing removed nodes.
     */
    remove(e) {
      const t = e.parent;
      return t ? this.removeChildren(t.getChildIndex(e), 1, t) : [];
    }
    /**
     * Replaces given element with the new one in the view structure. Will not have effect on detached elements.
     *
     * @param oldElement Element which will be replaced.
     * @param newElement Element which will be inserted in the place of the old element.
     * @returns Whether old element was successfully replaced.
     */
    replace(e, t) {
      const i = e.parent;
      if (i) {
        const s = i.getChildIndex(e);
        return this.removeChildren(s, 1, i), this.insertChild(s, t, i), !0;
      }
      return !1;
    }
    /**
     * Removes given element from view structure and places its children in its position.
     * It does nothing if element has no parent.
     *
     * @param element Element to unwrap.
     */
    unwrapElement(e) {
      const t = e.parent;
      if (t) {
        const i = t.getChildIndex(e);
        this.remove(e), this.insertChild(i, e.getChildren(), t);
      }
    }
    /**
     * Renames element by creating a copy of a given element but with its name changed and then moving contents of the
     * old element to the new one.
     *
     * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
     *
     * @param newName New element name.
     * @param  element Element to be renamed.
     * @returns New element or null if the old element was not replaced (happens for detached elements).
     */
    rename(e, t) {
      const i = new at(this.document, e, t.getAttributes(), t.getChildren());
      return this.replace(t, i) ? i : null;
    }
    /**
     * Adds or overwrites element's attribute with a specified key and value.
     *
     * ```ts
     * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
     * ```
     *
     * @see module:engine/view/element~Element#_setAttribute
     * @param key Attribute key.
     * @param value Attribute value.
     * @param element Element for which attribute will be set.
     */
    setAttribute(e, t, i) {
      i._setAttribute(e, t);
    }
    /**
     * Removes attribute from the element.
     *
     * ```ts
     * writer.removeAttribute( 'href', linkElement );
     * ```
     *
     * @see module:engine/view/element~Element#_removeAttribute
     * @param key Attribute key.
     * @param element Element from which attribute will be removed.
     */
    removeAttribute(e, t) {
      t._removeAttribute(e);
    }
    /**
     * Adds specified class to the element.
     *
     * ```ts
     * writer.addClass( 'foo', linkElement );
     * writer.addClass( [ 'foo', 'bar' ], linkElement );
     * ```
     *
     * @see module:engine/view/element~Element#_addClass
     * @param className Single class name or array of class names which will be added.
     * @param element Element for which class will be added.
     */
    addClass(e, t) {
      t._addClass(e);
    }
    /**
     * Removes specified class from the element.
     *
     * ```ts
     * writer.removeClass( 'foo', linkElement );
     * writer.removeClass( [ 'foo', 'bar' ], linkElement );
     * ```
     *
     * @see module:engine/view/element~Element#_removeClass
     * @param className Single class name or array of class names which will be removed.
     * @param element Element from which class will be removed.
     */
    removeClass(e, t) {
      t._removeClass(e);
    }
    setStyle(e, t, i) {
      Ne(e) && i === void 0 ? t._setStyle(e) : i._setStyle(e, t);
    }
    /**
     * Removes specified style from the element.
     *
     * ```ts
     * writer.removeStyle( 'color', element );  // Removes 'color' style.
     * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
     * ```
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
     *
     * @see module:engine/view/element~Element#_removeStyle
     * @param property Style property name or names to be removed.
     * @param element Element from which style will be removed.
     */
    removeStyle(e, t) {
      t._removeStyle(e);
    }
    /**
     * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
     * so they can be used to add special data to elements.
     *
     * @see module:engine/view/element~Element#_setCustomProperty
     * @param key Custom property name/key.
     * @param value Custom property value to be stored.
     * @param element Element for which custom property will be set.
     */
    setCustomProperty(e, t, i) {
      i._setCustomProperty(e, t);
    }
    /**
     * Removes a custom property stored under the given key.
     *
     * @see module:engine/view/element~Element#_removeCustomProperty
     * @param key Name/key of the custom property to be removed.
     * @param element Element from which the custom property will be removed.
     * @returns Returns true if property was removed.
     */
    removeCustomProperty(e, t) {
      return t._removeCustomProperty(e);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/view/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
     *
     * This method is a shortcut to other constructors such as:
     *
     * * {@link #createPositionBefore},
     * * {@link #createPositionAfter},
     *
     * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
     */
    createPositionAt(e, t) {
      return k._createAt(e, t);
    }
    /**
     * Creates a new position after given view item.
     *
     * @param item View item after which the position should be located.
     */
    createPositionAfter(e) {
      return k._createAfter(e);
    }
    /**
     * Creates a new position before given view item.
     *
     * @param item View item before which the position should be located.
     */
    createPositionBefore(e) {
      return k._createBefore(e);
    }
    /**
     * Creates a range spanning from `start` position to `end` position.
     *
     * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
     *
     * @param start Start position.
     * @param end End position. If not set, range will be collapsed at `start` position.
     */
    createRange(e, t) {
      return new N(e, t);
    }
    /**
     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
     */
    createRangeOn(e) {
      return N._createOn(e);
    }
    /**
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @param element Element which is a parent for the range.
     */
    createRangeIn(e) {
      return N._createIn(e);
    }
    createSelection(...e) {
      return new St(...e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const dE = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i, hE = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i, fE = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i, mE = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i, gE = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i, pE = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi, wE = /* @__PURE__ */ new Set([
    // CSS Level 1
    "black",
    "silver",
    "gray",
    "white",
    "maroon",
    "red",
    "purple",
    "fuchsia",
    "green",
    "lime",
    "olive",
    "yellow",
    "navy",
    "blue",
    "teal",
    "aqua",
    // CSS Level 2 (Revision 1)
    "orange",
    // CSS Color Module Level 3
    "aliceblue",
    "antiquewhite",
    "aquamarine",
    "azure",
    "beige",
    "bisque",
    "blanchedalmond",
    "blueviolet",
    "brown",
    "burlywood",
    "cadetblue",
    "chartreuse",
    "chocolate",
    "coral",
    "cornflowerblue",
    "cornsilk",
    "crimson",
    "cyan",
    "darkblue",
    "darkcyan",
    "darkgoldenrod",
    "darkgray",
    "darkgreen",
    "darkgrey",
    "darkkhaki",
    "darkmagenta",
    "darkolivegreen",
    "darkorange",
    "darkorchid",
    "darkred",
    "darksalmon",
    "darkseagreen",
    "darkslateblue",
    "darkslategray",
    "darkslategrey",
    "darkturquoise",
    "darkviolet",
    "deeppink",
    "deepskyblue",
    "dimgray",
    "dimgrey",
    "dodgerblue",
    "firebrick",
    "floralwhite",
    "forestgreen",
    "gainsboro",
    "ghostwhite",
    "gold",
    "goldenrod",
    "greenyellow",
    "grey",
    "honeydew",
    "hotpink",
    "indianred",
    "indigo",
    "ivory",
    "khaki",
    "lavender",
    "lavenderblush",
    "lawngreen",
    "lemonchiffon",
    "lightblue",
    "lightcoral",
    "lightcyan",
    "lightgoldenrodyellow",
    "lightgray",
    "lightgreen",
    "lightgrey",
    "lightpink",
    "lightsalmon",
    "lightseagreen",
    "lightskyblue",
    "lightslategray",
    "lightslategrey",
    "lightsteelblue",
    "lightyellow",
    "limegreen",
    "linen",
    "magenta",
    "mediumaquamarine",
    "mediumblue",
    "mediumorchid",
    "mediumpurple",
    "mediumseagreen",
    "mediumslateblue",
    "mediumspringgreen",
    "mediumturquoise",
    "mediumvioletred",
    "midnightblue",
    "mintcream",
    "mistyrose",
    "moccasin",
    "navajowhite",
    "oldlace",
    "olivedrab",
    "orangered",
    "orchid",
    "palegoldenrod",
    "palegreen",
    "paleturquoise",
    "palevioletred",
    "papayawhip",
    "peachpuff",
    "peru",
    "pink",
    "plum",
    "powderblue",
    "rosybrown",
    "royalblue",
    "saddlebrown",
    "salmon",
    "sandybrown",
    "seagreen",
    "seashell",
    "sienna",
    "skyblue",
    "slateblue",
    "slategray",
    "slategrey",
    "snow",
    "springgreen",
    "steelblue",
    "tan",
    "thistle",
    "tomato",
    "turquoise",
    "violet",
    "wheat",
    "whitesmoke",
    "yellowgreen",
    // CSS Color Module Level 3 (System Colors)
    "activeborder",
    "activecaption",
    "appworkspace",
    "background",
    "buttonface",
    "buttonhighlight",
    "buttonshadow",
    "buttontext",
    "captiontext",
    "graytext",
    "highlight",
    "highlighttext",
    "inactiveborder",
    "inactivecaption",
    "inactivecaptiontext",
    "infobackground",
    "infotext",
    "menu",
    "menutext",
    "scrollbar",
    "threeddarkshadow",
    "threedface",
    "threedhighlight",
    "threedlightshadow",
    "threedshadow",
    "window",
    "windowframe",
    "windowtext",
    // CSS Color Module Level 4
    "rebeccapurple",
    // Keywords
    "currentcolor",
    "transparent"
  ]);
  function Qm(n) {
    return n.startsWith("#") ? dE.test(n) : n.startsWith("rgb") ? hE.test(n) || fE.test(n) : n.startsWith("hsl") ? mE.test(n) || gE.test(n) : wE.has(n.toLowerCase());
  }
  const bE = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
  function _E(n) {
    return bE.includes(n);
  }
  const vE = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
  function tr(n) {
    return vE.test(n);
  }
  const yE = /^[+-]?[0-9]*([.][0-9]+)?%$/;
  function eg(n) {
    return yE.test(n);
  }
  const CE = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];
  function kE(n) {
    return CE.includes(n);
  }
  const TE = ["center", "top", "bottom", "left", "right"];
  function EE(n) {
    return TE.includes(n);
  }
  const AE = ["fixed", "scroll", "local"];
  function xE(n) {
    return AE.includes(n);
  }
  const SE = /^url\(/;
  function IE(n) {
    return SE.test(n);
  }
  function Fn(n = "") {
    if (n === "")
      return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
    const e = Tl(n), t = e[0], i = e[2] || t, s = e[1] || t, o = e[3] || s;
    return { top: t, bottom: i, right: s, left: o };
  }
  function zn(n) {
    return (e) => {
      const { top: t, right: i, bottom: s, left: o } = e, r = [];
      return [t, i, o, s].every((a) => !!a) ? r.push([n, PE(e)]) : (t && r.push([n + "-top", t]), i && r.push([n + "-right", i]), s && r.push([n + "-bottom", s]), o && r.push([n + "-left", o])), r;
    };
  }
  function PE({ top: n, right: e, bottom: t, left: i }) {
    const s = [];
    return i !== e ? s.push(n, e, t, i) : t !== n ? s.push(n, e, t) : e !== n ? s.push(n, e) : s.push(n), s.join(" ");
  }
  function tg(n) {
    return (e) => ({
      path: n,
      value: Fn(e)
    });
  }
  function Tl(n) {
    const e = n.matchAll(pE);
    return Array.from(e).map((t) => t[0]);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function El(n) {
    n.setNormalizer("background", RE()), n.setNormalizer("background-color", LE()), n.setReducer("background", VE()), n.setStyleRelation("background", ["background-color"]);
  }
  function RE() {
    return (n) => {
      const e = {}, t = Tl(n);
      for (const i of t)
        kE(i) ? (e.repeat = e.repeat || [], e.repeat.push(i)) : EE(i) ? (e.position = e.position || [], e.position.push(i)) : xE(i) ? e.attachment = i : Qm(i) ? e.color = i : IE(i) && (e.image = i);
      return {
        path: "background",
        value: e
      };
    };
  }
  function LE() {
    return (n) => ({ path: "background.color", value: n });
  }
  function VE() {
    return (n) => {
      const e = [];
      return e.push(["background-color", n.color]), e;
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function ig(n) {
    n.setNormalizer("border", ME()), n.setNormalizer("border-top", Ms("top")), n.setNormalizer("border-right", Ms("right")), n.setNormalizer("border-bottom", Ms("bottom")), n.setNormalizer("border-left", Ms("left")), n.setNormalizer("border-color", Ir("color")), n.setNormalizer("border-width", Ir("width")), n.setNormalizer("border-style", Ir("style")), n.setNormalizer("border-top-color", Ge("color", "top")), n.setNormalizer("border-top-style", Ge("style", "top")), n.setNormalizer("border-top-width", Ge("width", "top")), n.setNormalizer("border-right-color", Ge("color", "right")), n.setNormalizer("border-right-style", Ge("style", "right")), n.setNormalizer("border-right-width", Ge("width", "right")), n.setNormalizer("border-bottom-color", Ge("color", "bottom")), n.setNormalizer("border-bottom-style", Ge("style", "bottom")), n.setNormalizer("border-bottom-width", Ge("width", "bottom")), n.setNormalizer("border-left-color", Ge("color", "left")), n.setNormalizer("border-left-style", Ge("style", "left")), n.setNormalizer("border-left-width", Ge("width", "left")), n.setExtractor("border-top", Bs("top")), n.setExtractor("border-right", Bs("right")), n.setExtractor("border-bottom", Bs("bottom")), n.setExtractor("border-left", Bs("left")), n.setExtractor("border-top-color", "border.color.top"), n.setExtractor("border-right-color", "border.color.right"), n.setExtractor("border-bottom-color", "border.color.bottom"), n.setExtractor("border-left-color", "border.color.left"), n.setExtractor("border-top-width", "border.width.top"), n.setExtractor("border-right-width", "border.width.right"), n.setExtractor("border-bottom-width", "border.width.bottom"), n.setExtractor("border-left-width", "border.width.left"), n.setExtractor("border-top-style", "border.style.top"), n.setExtractor("border-right-style", "border.style.right"), n.setExtractor("border-bottom-style", "border.style.bottom"), n.setExtractor("border-left-style", "border.style.left"), n.setReducer("border-color", zn("border-color")), n.setReducer("border-style", zn("border-style")), n.setReducer("border-width", zn("border-width")), n.setReducer("border-top", Os("top")), n.setReducer("border-right", Os("right")), n.setReducer("border-bottom", Os("bottom")), n.setReducer("border-left", Os("left")), n.setReducer("border", OE()), n.setStyleRelation("border", [
      "border-color",
      "border-style",
      "border-width",
      "border-top",
      "border-right",
      "border-bottom",
      "border-left",
      "border-top-color",
      "border-right-color",
      "border-bottom-color",
      "border-left-color",
      "border-top-style",
      "border-right-style",
      "border-bottom-style",
      "border-left-style",
      "border-top-width",
      "border-right-width",
      "border-bottom-width",
      "border-left-width"
    ]), n.setStyleRelation("border-color", [
      "border-top-color",
      "border-right-color",
      "border-bottom-color",
      "border-left-color"
    ]), n.setStyleRelation("border-style", [
      "border-top-style",
      "border-right-style",
      "border-bottom-style",
      "border-left-style"
    ]), n.setStyleRelation("border-width", [
      "border-top-width",
      "border-right-width",
      "border-bottom-width",
      "border-left-width"
    ]), n.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]), n.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]), n.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]), n.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"]);
  }
  function ME() {
    return (n) => {
      const { color: e, style: t, width: i } = ng(n);
      return {
        path: "border",
        value: {
          color: Fn(e),
          style: Fn(t),
          width: Fn(i)
        }
      };
    };
  }
  function Ms(n) {
    return (e) => {
      const { color: t, style: i, width: s } = ng(e), o = {};
      return t !== void 0 && (o.color = { [n]: t }), i !== void 0 && (o.style = { [n]: i }), s !== void 0 && (o.width = { [n]: s }), {
        path: "border",
        value: o
      };
    };
  }
  function Ir(n) {
    return (e) => ({
      path: "border",
      value: BE(e, n)
    });
  }
  function BE(n, e) {
    return {
      [e]: Fn(n)
    };
  }
  function Ge(n, e) {
    return (t) => ({
      path: "border",
      value: {
        [n]: {
          [e]: t
        }
      }
    });
  }
  function Bs(n) {
    return (e, t) => {
      if (t.border)
        return Pn(t.border, n);
    };
  }
  function Pn(n, e) {
    const t = {};
    return n.width && n.width[e] && (t.width = n.width[e]), n.style && n.style[e] && (t.style = n.style[e]), n.color && n.color[e] && (t.color = n.color[e]), t;
  }
  function ng(n) {
    const e = {}, t = Tl(n);
    for (const i of t)
      tr(i) || /thin|medium|thick/.test(i) ? e.width = i : _E(i) ? e.style = i : e.color = i;
    return e;
  }
  function OE() {
    return (e) => {
      const t = Pn(e, "top"), i = Pn(e, "right"), s = Pn(e, "bottom"), o = Pn(e, "left"), r = [t, i, s, o], a = {
        width: n(r, "width"),
        style: n(r, "style"),
        color: n(r, "color")
      }, l = zi(a, "all");
      return l.length ? l : [
        ...Object.entries(a).reduce((u, [d, h]) => (h && (u.push([`border-${d}`, h]), r.forEach((f) => delete f[d])), u), []),
        ...zi(t, "top"),
        ...zi(i, "right"),
        ...zi(s, "bottom"),
        ...zi(o, "left")
      ];
    };
    function n(e, t) {
      return e.map((i) => i[t]).reduce((i, s) => i == s ? i : null);
    }
  }
  function Os(n) {
    return (e) => zi(e, n);
  }
  function zi(n, e) {
    const t = [];
    if (n && n.width && t.push("width"), n && n.style && t.push("style"), n && n.color && t.push("color"), t.length == 3) {
      const i = t.map((s) => n[s]).join(" ");
      return [
        e == "all" ? ["border", i] : [`border-${e}`, i]
      ];
    }
    return e == "all" ? [] : t.map((i) => [`border-${e}-${i}`, n[i]]);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function NE(n) {
    n.setNormalizer("margin", tg("margin")), n.setNormalizer("margin-top", (e) => ({ path: "margin.top", value: e })), n.setNormalizer("margin-right", (e) => ({ path: "margin.right", value: e })), n.setNormalizer("margin-bottom", (e) => ({ path: "margin.bottom", value: e })), n.setNormalizer("margin-left", (e) => ({ path: "margin.left", value: e })), n.setReducer("margin", zn("margin")), n.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function DE(n) {
    n.setNormalizer("padding", tg("padding")), n.setNormalizer("padding-top", (e) => ({ path: "padding.top", value: e })), n.setNormalizer("padding-right", (e) => ({ path: "padding.right", value: e })), n.setNormalizer("padding-bottom", (e) => ({ path: "padding.bottom", value: e })), n.setNormalizer("padding-left", (e) => ({ path: "padding.left", value: e })), n.setReducer("padding", zn("padding")), n.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"]);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class FE {
    /**
     * Creates collection instance.
     */
    constructor() {
      this._commands = /* @__PURE__ */ new Map();
    }
    /**
     * Registers a new command.
     *
     * @param commandName The name of the command.
     */
    add(e, t) {
      this._commands.set(e, t);
    }
    /**
     * Retrieves a command from the collection.
     *
     * @param commandName The name of the command.
     */
    get(e) {
      return this._commands.get(e);
    }
    /**
     * Executes a command.
     *
     * @param commandName The name of the command.
     * @param commandParams Command parameters.
     * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
     */
    execute(e, ...t) {
      const i = this.get(e);
      if (!i)
        throw new g("commandcollection-command-not-found", this, { commandName: e });
      return i.execute(...t);
    }
    /**
     * Returns iterator of command names.
     */
    *names() {
      yield* this._commands.keys();
    }
    /**
     * Returns iterator of command instances.
     */
    *commands() {
      yield* this._commands.values();
    }
    /**
     * Iterable interface.
     *
     * Returns `[ commandName, commandInstance ]` pairs.
     */
    [Symbol.iterator]() {
      return this._commands[Symbol.iterator]();
    }
    /**
     * Destroys all collection commands.
     */
    destroy() {
      for (const e of this.commands())
        e.destroy();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class zE extends ne {
    /**
     * Creates an instance of the keystroke handler.
     */
    constructor(e) {
      super(), this.editor = e;
    }
    /**
     * Registers a handler for the specified keystroke.
     *
     * The handler can be specified as a command name or a callback.
     *
     * @param keystroke Keystroke defined in a format accepted by
     * the {@link module:utils/keyboard~parseKeystroke} function.
     * @param callback If a string is passed, then the keystroke will
     * {@link module:core/editor/editor~Editor#execute execute a command}.
     * If a function, then it will be called with the
     * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
     * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
     * @param options Additional options.
     * @param options.priority The priority of the keystroke callback. The higher the priority value
     * the sooner the callback will be executed. Keystrokes having the same priority
     * are called in the order they were added.
     */
    set(e, t, i = {}) {
      if (typeof t == "string") {
        const s = t;
        t = (o, r) => {
          this.editor.execute(s), r();
        };
      }
      super.set(e, t, i);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Pr = "contentEditing", Lu = "common";
  class UE {
    /**
     * @inheritDoc
     */
    constructor(e) {
      this.keystrokeInfos = /* @__PURE__ */ new Map(), this._editor = e;
      const t = e.config.get("menuBar.isVisible"), i = e.locale.t;
      this.addKeystrokeInfoCategory({
        id: Pr,
        label: i("Content editing keystrokes"),
        description: i("These keyboard shortcuts allow for quick access to content editing features.")
      });
      const s = [
        {
          label: i("Close contextual balloons, dropdowns, and dialogs"),
          keystroke: "Esc"
        },
        {
          label: i("Open the accessibility help dialog"),
          keystroke: "Alt+0"
        },
        {
          label: i("Move focus between form fields (inputs, buttons, etc.)"),
          keystroke: [["Tab"], ["Shift+Tab"]]
        },
        {
          label: i("Move focus to the toolbar, navigate between toolbars"),
          keystroke: "Alt+F10",
          mayRequireFn: !0
        },
        {
          label: i("Navigate through the toolbar or menu bar"),
          keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
        },
        {
          // eslint-disable-next-line max-len
          label: i("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
          keystroke: [["Enter"], ["Space"]]
        }
      ];
      t && s.push({
        label: i("Move focus to the menu bar, navigate between menu bars"),
        keystroke: "Alt+F9",
        mayRequireFn: !0
      }), this.addKeystrokeInfoCategory({
        id: "navigation",
        label: i("User interface and content navigation keystrokes"),
        description: i("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
        groups: [
          {
            id: "common",
            keystrokes: s
          }
        ]
      });
    }
    /**
     * Adds a top-level category in the {@link #keystrokeInfos keystroke information database} with a label and optional description.
     *
     * Categories organize keystrokes and help users to find the right keystroke. Each category can have multiple groups
     * of keystrokes that narrow down the context in which the keystrokes are available. Every keystroke category comes
     * with a `'common'` group by default.
     *
     * By default, two categories are available:
     * * `'contentEditing'` for keystrokes related to content creation,
     * * `'navigation'` for keystrokes related to navigation in the UI and the content.
     *
     * To create a new keystroke category with new groups, use the following code:
     *
     * ```js
     * class MyPlugin extends Plugin {
     * 	// ...
     * 	init() {
     * 		const editor = this.editor;
     * 		const t = editor.t;
     *
     * 		// ...
     *
     * 		editor.accessibility.addKeystrokeInfoCategory( {
     * 			id: 'myCategory',
     * 			label: t( 'My category' ),
     * 			description: t( 'My category description.' ),
     * 			groups: [
     * 				{
     * 					id: 'myGroup',
     * 					label: t( 'My keystroke group' ),
     * 					keystrokes: [
     * 						{
     * 							label: t( 'Keystroke label 1' ),
     * 							keystroke: 'Ctrl+Shift+N'
     * 						},
     * 						{
     * 							label: t( 'Keystroke label 2' ),
     * 							keystroke: 'Ctrl+Shift+M'
     * 						}
     * 					]
     * 				}
     * 			]
     * 		};
     * 	}
     * }
     * ```
     *
     * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}.
     */
    addKeystrokeInfoCategory({ id: e, label: t, description: i, groups: s }) {
      this.keystrokeInfos.set(e, {
        id: e,
        label: t,
        description: i,
        groups: /* @__PURE__ */ new Map()
      }), this.addKeystrokeInfoGroup({
        categoryId: e,
        id: Lu
      }), s && s.forEach((o) => {
        this.addKeystrokeInfoGroup({
          categoryId: e,
          ...o
        });
      });
    }
    /**
     * Adds a group of keystrokes in a specific category to the {@link #keystrokeInfos keystroke information database}.
     *
     * Groups narrow down the context in which the keystrokes are available. When `categoryId` is not specified,
     * the group goes to the `'contentEditing'` category (default).
     *
     * To create a new group within an existing category, use the following code:
     *
     * ```js
     * class MyPlugin extends Plugin {
     * 	// ...
     * 	init() {
     * 		const editor = this.editor;
     * 		const t = editor.t;
     *
     * 		// ...
     *
     * 		editor.accessibility.addKeystrokeInfoGroup( {
     * 			id: 'myGroup',
     * 			categoryId: 'navigation',
     * 			label: t( 'My keystroke group' ),
     * 			keystrokes: [
     * 				{
     * 					label: t( 'Keystroke label 1' ),
     * 					keystroke: 'Ctrl+Shift+N'
     * 				},
     * 				{
     * 					label: t( 'Keystroke label 2' ),
     * 					keystroke: 'Ctrl+Shift+M'
     * 				}
     * 			]
     * 		} );
     * 	}
     * }
     * ```
     *
     * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoCategory}, and {@link #addKeystrokeInfos}.
     */
    addKeystrokeInfoGroup({ categoryId: e = Pr, id: t, label: i, keystrokes: s }) {
      const o = this.keystrokeInfos.get(e);
      if (!o)
        throw new g("accessibility-unknown-keystroke-info-category", this._editor, { groupId: t, categoryId: e });
      o.groups.set(t, {
        id: t,
        label: i,
        keystrokes: s || []
      });
    }
    /**
     * Adds information about keystrokes to the {@link #keystrokeInfos keystroke information database}.
     *
     * Keystrokes without specified `groupId` or `categoryId` go to the `'common'` group in the `'contentEditing'` category (default).
     *
     * To add a keystroke brought by your plugin (using default group and category), use the following code:
     *
     * ```js
     * class MyPlugin extends Plugin {
     * 	// ...
     * 	init() {
     * 		const editor = this.editor;
     * 		const t = editor.t;
     *
     * 		// ...
     *
     * 		editor.accessibility.addKeystrokeInfos( {
     * 			keystrokes: [
     * 				{
     * 					label: t( 'Keystroke label' ),
     * 					keystroke: 'CTRL+B'
     * 				}
     * 			]
     * 		} );
     * 	}
     * }
     * ```
     * To add a keystroke in a specific existing `'widget'` group in the default `'contentEditing'` category:
     *
     * ```js
     * class MyPlugin extends Plugin {
     * 	// ...
     * 	init() {
     * 		const editor = this.editor;
     * 		const t = editor.t;
     *
     * 		// ...
     *
     * 		editor.accessibility.addKeystrokeInfos( {
     * 			// Add a keystroke to the existing "widget" group.
     * 			groupId: 'widget',
     * 			keystrokes: [
     * 				{
     * 					label: t( 'A an action on a selected widget' ),
     * 					keystroke: 'Ctrl+D',
     * 				}
     * 			]
     * 		} );
     * 	}
     * }
     * ```
     *
     * To add a keystroke to another existing category (using default group):
     *
     * ```js
     * class MyPlugin extends Plugin {
     * 	// ...
     * 	init() {
     * 		const editor = this.editor;
     * 		const t = editor.t;
     *
     * 		// ...
     *
     * 		editor.accessibility.addKeystrokeInfos( {
     * 			// Add keystrokes to the "navigation" category (one of defaults).
     * 			categoryId: 'navigation',
     * 			keystrokes: [
     * 				{
     * 					label: t( 'Keystroke label' ),
     * 					keystroke: 'CTRL+B'
     * 				}
     * 			]
     * 		} );
     * 	}
     * }
     * ```
     *
     * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfoCategory}.
     */
    addKeystrokeInfos({ categoryId: e = Pr, groupId: t = Lu, keystrokes: i }) {
      if (!this.keystrokeInfos.has(e))
        throw new g("accessibility-unknown-keystroke-info-category", this._editor, { categoryId: e, keystrokes: i });
      const s = this.keystrokeInfos.get(e);
      if (!s.groups.has(t))
        throw new g("accessibility-unknown-keystroke-info-group", this._editor, { groupId: t, categoryId: e, keystrokes: i });
      s.groups.get(t).keystrokes.push(...i);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class HE extends $() {
    /**
     * Creates a new instance of the editor class.
     *
     * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
     *
     * @param config The editor configuration.
     */
    constructor(e = {}) {
      super();
      const t = this.constructor, { translations: i, ...s } = t.defaultConfig || {}, { translations: o = i, ...r } = e, a = e.language || s.language;
      this._context = e.context || new um({ language: a, translations: o }), this._context._addEditor(this, !e.context);
      const l = Array.from(t.builtinPlugins || []);
      this.config = new Jf(r, s), this.config.define("plugins", l), this.config.define(this._context._getEditorConfig()), this.plugins = new cm(this, l, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new FE(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new cE(), this.on("change:isReadOnly", () => {
        this.model.document.isReadOnly = this.isReadOnly;
      });
      const c = new ZC();
      this.data = new b2(this.model, c), this.editing = new jT(this.model, c), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new v2([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new zE(this), this.keystrokes.listenTo(this.editing.view.document), this.accessibility = new UE(this);
    }
    /**
     * Defines whether the editor is in the read-only mode.
     *
     * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
     * to modify the document by using them. Also, the editable element(s) become non-editable.
     *
     * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:
     *
     * ```ts
     * editor.enableReadOnlyMode( 'feature-id' );
     * ```
     *
     * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:
     *
     * ```ts
     * editor.disableReadOnlyMode( 'feature-id' );
     * ```
     *
     * @readonly
     * @observable
     */
    get isReadOnly() {
      return this._readOnlyLocks.size > 0;
    }
    set isReadOnly(e) {
      throw new g("editor-isreadonly-has-no-setter");
    }
    /**
     * Turns on the read-only mode in the editor.
     *
     * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking
     * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at
     * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which
     * could lead to errors).
     *
     * Each read-only mode request is identified by a unique id (also called "lock"). If multiple plugins requested to turn on the
     * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).
     *
     * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.
     *
     * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:
     *
     * ```ts
     * editor.isReadOnly; // `false`.
     * editor.enableReadOnlyMode( 'my-feature-id' );
     * editor.isReadOnly; // `true`.
     * ```
     *
     * You can turn off the read-only mode ("clear the lock") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:
     *
     * ```ts
     * editor.enableReadOnlyMode( 'my-feature-id' );
     * // ...
     * editor.disableReadOnlyMode( 'my-feature-id' );
     * editor.isReadOnly; // `false`.
     * ```
     *
     * All "locks" need to be removed to enable editing:
     *
     * ```ts
     * editor.enableReadOnlyMode( 'my-feature-id' );
     * editor.enableReadOnlyMode( 'my-other-feature-id' );
     * // ...
     * editor.disableReadOnlyMode( 'my-feature-id' );
     * editor.isReadOnly; // `true`.
     * editor.disableReadOnlyMode( 'my-other-feature-id' );
     * editor.isReadOnly; // `false`.
     * ```
     *
     * @param lockId A unique ID for setting the editor to the read-only state.
     */
    enableReadOnlyMode(e) {
      if (typeof e != "string" && typeof e != "symbol")
        throw new g("editor-read-only-lock-id-invalid", null, { lockId: e });
      this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1));
    }
    /**
     * Removes the read-only lock from the editor with given lock ID.
     *
     * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.
     *
     * @param lockId The lock ID for setting the editor to the read-only state.
     */
    disableReadOnlyMode(e) {
      if (typeof e != "string" && typeof e != "symbol")
        throw new g("editor-read-only-lock-id-invalid", null, { lockId: e });
      this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0));
    }
    /**
     * Sets the data in the editor.
     *
     * ```ts
     * editor.setData( '<p>This is editor!</p>' );
     * ```
     *
     * If your editor implementation uses multiple roots, you should pass an object with keys corresponding
     * to the editor root names and values equal to the data that should be set in each root:
     *
     * ```ts
     * editor.setData( {
     *     header: '<p>Content for header part.</p>',
     *     content: '<p>Content for main part.</p>',
     *     footer: '<p>Content for footer part.</p>'
     * } );
     * ```
     *
     * By default the editor accepts HTML. This can be controlled by injecting a different data processor.
     * See the {@glink features/markdown Markdown output} guide for more details.
     *
     * @param data Input data.
     */
    setData(e) {
      this.data.set(e);
    }
    /**
     * Gets the data from the editor.
     *
     * ```ts
     * editor.getData(); // -> '<p>This is editor!</p>'
     * ```
     *
     * If your editor implementation uses multiple roots, you should pass root name as one of the options:
     *
     * ```ts
     * editor.getData( { rootName: 'header' } ); // -> '<p>Content for header part.</p>'
     * ```
     *
     * By default, the editor outputs HTML. This can be controlled by injecting a different data processor.
     * See the {@glink features/markdown Markdown output} guide for more details.
     *
     * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
     * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
     *
     * @param options Additional configuration for the retrieved data.
     * Editor features may introduce more configuration options that can be set through this parameter.
     * @param options.rootName Root name. Defaults to `'main'`.
     * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
     * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
     * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
     * @returns Output data.
     */
    getData(e) {
      return this.data.get(e);
    }
    /**
     * Loads and initializes plugins specified in the configuration.
     *
     * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
     */
    initPlugins() {
      const e = this.config, t = e.get("plugins"), i = e.get("removePlugins") || [], s = e.get("extraPlugins") || [], o = e.get("substitutePlugins") || [];
      return this.plugins.init(t.concat(s), i, o);
    }
    /**
     * Destroys the editor instance, releasing all resources used by it.
     *
     * **Note** The editor cannot be destroyed during the initialization phase so if it is called
     * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
     *
     * @fires destroy
     * @returns A promise that resolves once the editor instance is fully destroyed.
     */
    destroy() {
      let e = Promise.resolve();
      return this.state == "initializing" && (e = new Promise((t) => this.once("ready", t))), e.then(() => {
        this.fire("destroy"), this.stopListening(), this.commands.destroy();
      }).then(() => this.plugins.destroy()).then(() => {
        this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
      }).then(() => this._context._removeEditor(this));
    }
    /**
     * Executes the specified command with given parameters.
     *
     * Shorthand for:
     *
     * ```ts
     * editor.commands.get( commandName ).execute( ... );
     * ```
     *
     * @param commandName The name of the command to execute.
     * @param commandParams Command parameters.
     * @returns The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.
     */
    execute(e, ...t) {
      try {
        return this.commands.execute(e, ...t);
      } catch (i) {
        /* istanbul ignore next -- @preserve */
        g.rethrowUnexpectedError(i, this);
      }
    }
    /**
     * Focuses the editor.
     *
     * **Note** To explicitly focus the editing area of the editor, use the
     * {@link module:engine/view/view~View#focus `editor.editing.view.focus()`} method of the editing view.
     *
     * Check out the {@glink framework/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section
     * of the {@glink framework/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.
     */
    focus() {
      this.editing.view.focus();
    }
    /* istanbul ignore next -- @preserve */
    /**
     * Creates and initializes a new editor instance.
     *
     * This is an abstract method. Every editor type needs to implement its own initialization logic.
     *
     * See the `create()` methods of the existing editor types to learn how to use them:
     *
     * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
     * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
     * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
     * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
     */
    static create(...e) {
      throw new Error("This is an abstract method.");
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function $E(n) {
    if (!di(n.updateSourceElement))
      throw new g("attachtoform-missing-elementapi-interface", n);
    const e = n.sourceElement;
    if (WE(e) && e.form) {
      let t;
      const i = e.form, s = () => n.updateSourceElement();
      di(i.submit) && (t = i.submit, i.submit = () => {
        s(), t.apply(i);
      }), i.addEventListener("submit", s), n.on("destroy", () => {
        i.removeEventListener("submit", s), t && (i.submit = t);
      });
    }
  }
  function WE(n) {
    return !!n && n.tagName.toLowerCase() === "textarea";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function wa(n) {
    class e extends n {
      updateSourceElement(i) {
        if (!this.sourceElement)
          throw new g("editor-missing-sourceelement", this);
        const s = this.config.get("updateSourceElementOnDestroy"), o = this.sourceElement instanceof HTMLTextAreaElement;
        if (!s && !o) {
          Fc(this.sourceElement, "");
          return;
        }
        const r = typeof i == "string" ? i : this.data.get();
        Fc(this.sourceElement, r);
      }
    }
    return e;
  }
  wa.updateSourceElement = wa(Object).prototype.updateSourceElement;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Vu extends Zo {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "PendingActions";
    }
    /**
     * @inheritDoc
     */
    init() {
      this.set("hasAny", !1), this._actions = new Ce({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
    }
    /**
     * Adds an action to the list of pending actions.
     *
     * This method returns an action object with an observable message property.
     * The action object can be later used in the {@link #remove} method. It also allows you to change the message.
     *
     * @param message The action message.
     * @returns An observable object that represents a pending action.
     */
    add(e) {
      if (typeof e != "string")
        throw new g("pendingactions-add-invalid-message", this);
      const t = new ($())();
      return t.set("message", e), this._actions.add(t), this.hasAny = !0, t;
    }
    /**
     * Removes an action from the list of pending actions.
     *
     * @param action An action object.
     */
    remove(e) {
      this._actions.remove(e), this.hasAny = !!this._actions.length;
    }
    /**
     * Returns the first action from the list or null if the list is empty
     *
     * @returns The pending action object.
     */
    get first() {
      return this._actions.get(0);
    }
    /**
     * Iterable interface.
     */
    [Symbol.iterator]() {
      return this._actions[Symbol.iterator]();
    }
  }
  const qE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', GE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', jE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', KE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', ZE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>', JE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', XE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>', YE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', QE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.035 1C2.446 1 2 1.54 2 2.098V10.5h1.5v-8h13v8H18V2.098C18 1.539 17.48 1 16.9 1H3.035Zm10.453 2.61a1.885 1.885 0 0 0-1.442.736 1.89 1.89 0 0 0 1.011 2.976 1.903 1.903 0 0 0 2.253-1.114 1.887 1.887 0 0 0-1.822-2.598ZM7.463 8.163a.611.611 0 0 0-.432.154L5.071 10.5h5.119L7.88 8.348a.628.628 0 0 0-.417-.185Zm6.236 1.059a.62.62 0 0 0-.42.164L12.07 10.5h2.969l-.92-1.113a.618.618 0 0 0-.42-.165ZM.91 11.5a.91.91 0 0 0-.91.912v6.877c0 .505.405.91.91.91h18.178a.91.91 0 0 0 .912-.91v-6.877a.908.908 0 0 0-.912-.912H.91ZM3.668 13h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516L3.668 13Zm4.947 0h1.801v4.3h2.7v1.4h-4.5V13h-.001Zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9V13h-.001Zm-8.517 1.457-.614 2.059h1.262l-.648-2.059Z"/></svg>', e5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>', t5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>', i5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>', n5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1l4.16-4.482ZM17.8 1c.652 0 1.2.47 1.2 1.1v14.362c0 .64-.532 1.038-1.184 1.038H2.184C1.532 17.5 1 17.103 1 16.462V2.1C1 1.47 1.537 1 2.2 1h15.6Zm-5.655 6a2.128 2.128 0 0 1 .157-2.364A2.133 2.133 0 1 1 12.145 7Z"/></svg>', s5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h9.494a2.97 2.97 0 0 1-.414-.287 2.998 2.998 0 0 1-1.055-2.03 3.003 3.003 0 0 1 .693-2.185l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L1.5 13.6V2.5h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.134 2.134 0 0 0-1.875-.978Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/></svg>', o5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1c-.662 0-1.2.47-1.2 1.1v14.248c0 .64.533 1.152 1.185 1.152h6.623v-7.236L6.617 9.15a.694.694 0 0 0-.957-.033L1.602 13.55V2.553l14.798.003V9.7H18V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.723 2.805a2.094 2.094 0 0 0-1.621.832 2.127 2.127 0 0 0 1.136 3.357 2.13 2.13 0 0 0 2.611-1.506 2.133 2.133 0 0 0-.76-2.244 2.13 2.13 0 0 0-1.366-.44Z"/><path clip-rule="evenodd" d="M19.898 12.369v6.187a.844.844 0 0 1-.844.844h-8.719a.844.844 0 0 1-.843-.844v-7.312a.844.844 0 0 1 .843-.844h2.531a.843.843 0 0 1 .597.248l.838.852h4.75c.223 0 .441.114.6.272a.844.844 0 0 1 .247.597Zm-1.52.654-4.377.02-1.1-1.143H11v6h7.4l-.023-4.877Z"/></svg>', r5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h7.029a5.401 5.401 0 0 1 .615-4.338l.762-1.232-2.975-2.78a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v6.023c.449.131.887.32 1.307.573l.058.033c.046.028.09.057.135.086V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.15 2.15 0 0 0-1.611.834 2.118 2.118 0 0 0-.438 1.158 2.14 2.14 0 0 0 1.277 2.096 2.132 2.132 0 0 0 2.645-3.11 2.13 2.13 0 0 0-1.873-.978Z"/><path d="M16.63 10.294a3.003 3.003 0 0 0-4.142.887l-.117.177a.647.647 0 0 0-.096.492.664.664 0 0 0 .278.418.7.7 0 0 0 .944-.234 1.741 1.741 0 0 1 2.478-.463 1.869 1.869 0 0 1 .476 2.55.637.637 0 0 0-.071.5.646.646 0 0 0 .309.396.627.627 0 0 0 .869-.19l.027-.041a3.226 3.226 0 0 0-.956-4.492Zm-6.061 3.78-.044.066a3.228 3.228 0 0 0 .82 4.403 3.005 3.005 0 0 0 4.275-.798l.13-.197a.626.626 0 0 0 .092-.475.638.638 0 0 0-.268-.402.713.713 0 0 0-.99.26l-.018.029a1.741 1.741 0 0 1-2.477.461 1.87 1.87 0 0 1-.475-2.55l.029-.047a.647.647 0 0 0 .086-.485.66.66 0 0 0-.275-.408l-.04-.027a.609.609 0 0 0-.845.17Z"/><path d="M15.312 13.925c.24-.36.154-.838-.19-1.067-.346-.23-.82-.124-1.059.236l-1.268 1.907c-.239.36-.153.838.192 1.067.345.23.818.123 1.057-.236l1.268-1.907Z"/></svg>', a5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', l5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', c5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', u5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', d5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', h5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', f5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', m5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', g5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', p5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', w5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', b5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', _5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', v5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', y5 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', C5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M13 5.5H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2ZM13 7a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-8A.5.5 0 0 1 2 7h11Z"/></svg>', k5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M7 9.5H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2ZM7 11a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4A.5.5 0 0 1 2 11h5Z"/></svg>', T5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M10 7.5H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2ZM10 9a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6A.5.5 0 0 1 2 9h8Z"/></svg>', E5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', A5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', x5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', S5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>', I5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>', P5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', R5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', L5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', V5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>', M5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>', B5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>', O5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', N5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>', D5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>', F5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>', z5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>', U5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>', H5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 9v10h-2v-8h-2V9h4zM4 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1V11H4v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H3a1 1 0 0 1 1 1v4.5z"/></svg>', $5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm16.076 8.343V18.5h-6.252c.067-.626.27-1.22.61-1.78.338-.561 1.006-1.305 2.005-2.232.804-.749 1.297-1.257 1.479-1.523.245-.368.368-.732.368-1.092 0-.398-.107-.703-.32-.917-.214-.214-.51-.32-.886-.32-.372 0-.669.111-.889.336-.22.224-.347.596-.38 1.117l-1.778-.178c.106-.982.438-1.686.997-2.114.558-.427 1.257-.64 2.095-.64.918 0 1.64.247 2.164.742.525.495.787 1.11.787 1.847 0 .419-.075.818-.225 1.197-.15.378-.388.775-.714 1.19-.216.275-.605.67-1.168 1.187-.563.516-.92.859-1.07 1.028a3.11 3.11 0 0 0-.365.495h3.542z"/></svg>', W5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm9.989 7.53 1.726-.209c.055.44.203.777.445 1.01.24.232.533.349.876.349.368 0 .678-.14.93-.42.251-.279.377-.655.377-1.13 0-.448-.12-.803-.362-1.066a1.153 1.153 0 0 0-.882-.393c-.228 0-.501.044-.819.133l.197-1.453c.482.012.85-.092 1.105-.315.253-.222.38-.517.38-.885 0-.313-.093-.563-.279-.75-.186-.185-.434-.278-.743-.278a1.07 1.07 0 0 0-.78.317c-.216.212-.347.52-.394.927l-1.644-.28c.114-.562.287-1.012.517-1.348.231-.337.553-.601.965-.794a3.24 3.24 0 0 1 1.387-.289c.876 0 1.579.28 2.108.838.436.457.653.973.653 1.549 0 .817-.446 1.468-1.339 1.955.533.114.96.37 1.28.768.319.398.478.878.478 1.441 0 .817-.298 1.513-.895 2.088-.596.576-1.339.864-2.228.864-.842 0-1.54-.243-2.094-.727-.555-.485-.876-1.118-.965-1.901z"/></svg>', q5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm13.55 10v-1.873h-3.81v-1.561l4.037-5.91h1.498v5.904h1.156v1.567h-1.156V18.5H17.05zm0-3.44v-3.18l-2.14 3.18h2.14z"/></svg>', G5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm9.578 7.607 1.777-.184c.05.402.201.72.45.955a1.223 1.223 0 0 0 1.81-.101c.258-.303.387-.759.387-1.368 0-.572-.128-1-.384-1.286-.256-.285-.59-.428-1-.428-.512 0-.971.226-1.377.679l-1.448-.21.915-4.843h4.716v1.67H15.56l-.28 1.58a2.697 2.697 0 0 1 1.219-.298 2.68 2.68 0 0 1 2.012.863c.55.576.825 1.323.825 2.241a3.36 3.36 0 0 1-.666 2.05c-.605.821-1.445 1.232-2.52 1.232-.86 0-1.56-.23-2.101-.692-.542-.461-.866-1.081-.971-1.86z"/></svg>', j5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm15.595 2.973-1.726.19c-.043-.355-.153-.617-.33-.787-.178-.169-.409-.253-.692-.253-.377 0-.695.169-.956.507-.26.339-.424 1.043-.492 2.114.445-.525.997-.787 1.657-.787.745 0 1.383.284 1.914.85.531.568.797 1.3.797 2.197 0 .952-.28 1.716-.838 2.291-.559.576-1.276.864-2.152.864-.94 0-1.712-.365-2.317-1.095-.605-.73-.908-1.927-.908-3.59 0-1.705.316-2.935.946-3.688.63-.753 1.45-1.13 2.457-1.13.706 0 1.291.198 1.755.594.463.395.758.97.885 1.723zm-4.043 3.891c0 .58.133 1.028.4 1.343.266.315.57.473.914.473.33 0 .605-.13.825-.388.22-.258.33-.68.33-1.27 0-.604-.118-1.047-.355-1.329a1.115 1.115 0 0 0-.89-.422c-.342 0-.632.134-.869.403s-.355.666-.355 1.19z"/></svg>', K5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>', Z5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2h14zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5l-.001-1.001zm-3.478-6.013-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965l-.014-.014zM2 10H1v5h1v-2h2v2h1v-5H4v2H2v-2zm7 0H6v1h1v4h1v-4h1v-1zm8 0h-1v5h3v-1h-2v-4zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5zM10 7v1H4V7h6zm3-2v1H4V5h9zm-3-2v1H4V3h6z"/></svg>', J5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', X5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>', Y5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.5v3h4v-3H3Zm0 4v3h4v-3H3Zm0 4v3h4v-3H3Zm5 3h4v-3H8v3Zm5 0h4v-3h-4v3Zm4-4v-3h-4v3h4Zm0-4v-3h-4v3h4Zm1.5 8A1.5 1.5 0 0 1 17 18H3a1.5 1.5 0 0 1-1.5-1.5V3c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13.5Zm-6.5-4v-3H8v3h4Zm0-4v-3H8v3h4Z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const x = {
    bold: P5,
    cancel: qE,
    caption: GE,
    check: jE,
    cog: KE,
    colorPalette: ZE,
    eraser: JE,
    history: XE,
    image: n5,
    imageUpload: s5,
    imageAssetManager: o5,
    imageUrl: r5,
    lowVision: YE,
    textAlternative: QE,
    loupe: e5,
    previousArrow: t5,
    nextArrow: i5,
    importExport: M5,
    paragraph: R5,
    plus: L5,
    text: V5,
    alignBottom: a5,
    alignMiddle: l5,
    alignTop: c5,
    alignLeft: u5,
    alignCenter: d5,
    alignRight: h5,
    alignJustify: f5,
    objectLeft: _5,
    objectCenter: g5,
    objectRight: v5,
    objectFullWidth: w5,
    objectInline: b5,
    objectBlockLeft: m5,
    objectBlockRight: p5,
    objectSizeFull: y5,
    objectSizeLarge: C5,
    objectSizeSmall: k5,
    objectSizeMedium: T5,
    pencil: E5,
    pilcrow: A5,
    quote: x5,
    threeVerticalDots: S5,
    dragIndicator: I5,
    redo: B5,
    undo: O5,
    bulletedList: N5,
    numberedList: D5,
    todoList: F5,
    codeBlock: z5,
    browseFiles: U5,
    heading1: H5,
    heading2: $5,
    heading3: W5,
    heading4: q5,
    heading5: G5,
    heading6: j5,
    horizontalLine: K5,
    html: Z5,
    indent: J5,
    outdent: X5,
    table: Y5
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ke extends Ce {
    /**
     * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
     *
     * @param initialItems The initial items of the collection.
     */
    constructor(e = []) {
      super(e, {
        // An #id Number attribute should be legal and not break the `ViewCollection` instance.
        // https://github.com/ckeditor/ckeditor5-ui/issues/93
        idProperty: "viewUid"
      }), this.on("add", (t, i, s) => {
        this._renderViewIntoCollectionParent(i, s);
      }), this.on("remove", (t, i) => {
        i.element && this._parentElement && i.element.remove();
      }), this._parentElement = null;
    }
    /**
     * Destroys the view collection along with child views.
     * See the view {@link module:ui/view~View#destroy} method.
     */
    destroy() {
      this.map((e) => e.destroy());
    }
    /**
     * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
     * {@link #remove removing} views in the collection synchronizes their
     * {@link module:ui/view~View#element elements} in the parent element.
     *
     * @param element A new parent element.
     */
    setParent(e) {
      this._parentElement = e;
      for (const t of this)
        this._renderViewIntoCollectionParent(t);
    }
    /**
     * Delegates selected events coming from within views in the collection to any
     * {@link module:utils/emittermixin~Emitter}.
     *
     * For the following views and collection:
     *
     * ```ts
     * const viewA = new View();
     * const viewB = new View();
     * const viewC = new View();
     *
     * const views = parentView.createCollection();
     *
     * views.delegate( 'eventX' ).to( viewB );
     * views.delegate( 'eventX', 'eventY' ).to( viewC );
     *
     * views.add( viewA );
     * ```
     *
     * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
     *
     * ```ts
     * viewA.fire( 'eventX', customData );
     * ```
     *
     * and `eventY` is delegated (fired by) `viewC` along with `customData`:
     *
     * ```ts
     * viewA.fire( 'eventY', customData );
     * ```
     *
     * See {@link module:utils/emittermixin~Emitter#delegate}.
     *
     * @param events {@link module:ui/view~View} event names to be delegated to another
     * {@link module:utils/emittermixin~Emitter}.
     * @returns Object with `to` property, a function which accepts the destination
     * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
     */
    delegate(...e) {
      if (!e.length || !Q5(e))
        throw new g("ui-viewcollection-delegate-wrong-events", this);
      return {
        to: (t) => {
          for (const i of this)
            for (const s of e)
              i.delegate(s).to(t);
          this.on("add", (i, s) => {
            for (const o of e)
              s.delegate(o).to(t);
          }), this.on("remove", (i, s) => {
            for (const o of e)
              s.stopDelegating(o, t);
          });
        }
      };
    }
    /**
     * This method {@link module:ui/view~View#render renders} a new view added to the collection.
     *
     * If the {@link #_parentElement parent element} of the collection is set, this method also adds
     * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
     *
     * **Note**: If index is not specified, the view's element is pushed as the last child
     * of the parent element.
     *
     * @param view A new view added to the collection.
     * @param index An index the view holds in the collection. When not specified,
     * the view is added at the end.
     */
    _renderViewIntoCollectionParent(e, t) {
      e.isRendered || e.render(), e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t]);
    }
    /**
     * Removes a child view from the collection. If the {@link #setParent parent element} of the
     * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
     * in DOM, reflecting the order of the collection.
     *
     * See the {@link #add} method.
     *
     * @param subject The view to remove, its id or index in the collection.
     * @returns The removed view.
     */
    remove(e) {
      return super.remove(e);
    }
  }
  function Q5(n) {
    return n.every((e) => typeof e == "string");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const eA = "http://www.w3.org/1999/xhtml";
  class Ve extends G() {
    /**
     * Creates an instance of the {@link ~Template} class.
     *
     * @param def The definition of the template.
     */
    constructor(e) {
      super(), Object.assign(this, Bu(Mu(e))), this._isRendered = !1, this._revertData = null;
    }
    /**
     * Renders a DOM Node (an HTML element or text) out of the template.
     *
     * ```ts
     * const domNode = new Template( { ... } ).render();
     * ```
     *
     * See: {@link #apply}.
     */
    render() {
      const e = this._renderNode({
        intoFragment: !0
      });
      return this._isRendered = !0, e;
    }
    /**
     * Applies the template to an existing DOM Node, either HTML element or text.
     *
     * **Note:** No new DOM nodes will be created. Applying extends:
     *
     * {@link module:ui/template~TemplateDefinition attributes},
     * {@link module:ui/template~TemplateDefinition event listeners}, and
     * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
     *
     * **Note:** Existing `class` and `style` attributes are extended when a template
     * is applied to an HTML element, while other attributes and `textContent` are overridden.
     *
     * **Note:** The process of applying a template can be easily reverted using the
     * {@link module:ui/template~Template#revert} method.
     *
     * ```ts
     * const element = document.createElement( 'div' );
     * const observable = new Model( { divClass: 'my-div' } );
     * const emitter = Object.create( EmitterMixin );
     * const bind = Template.bind( observable, emitter );
     *
     * new Template( {
     * 	attributes: {
     * 		id: 'first-div',
     * 		class: bind.to( 'divClass' )
     * 	},
     * 	on: {
     * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
     * 	},
     * 	children: [
     * 		'Div text.'
     * 	]
     * } ).apply( element );
     *
     * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
     * ```
     *
     * @see module:ui/template~Template#render
     * @see module:ui/template~Template#revert
     * @param node Root node for the template to apply.
     */
    apply(e) {
      return this._revertData = Du(), this._renderNode({
        node: e,
        intoFragment: !1,
        isApplying: !0,
        revertData: this._revertData
      }), e;
    }
    /**
     * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
     *
     * @param node The root node for the template to revert. In most of the cases, it is the
     * same node used by {@link module:ui/template~Template#apply}.
     */
    revert(e) {
      if (!this._revertData)
        throw new g("ui-template-revert-not-applied", [this, e]);
      this._revertTemplateFromNode(e, this._revertData);
    }
    /**
     * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
     * instances and returns them one by one.
     *
     * ```ts
     * const viewFoo = new View();
     * const viewBar = new View();
     * const viewBaz = new View();
     * const template = new Template( {
     * 	tag: 'div',
     * 	children: [
     * 		viewFoo,
     * 		{
     * 			tag: 'div',
     * 			children: [
     * 				viewBar
     * 			]
     * 		},
     * 		viewBaz
     * 	]
     * } );
     *
     * // Logs: viewFoo, viewBar, viewBaz
     * for ( const view of template.getViews() ) {
     * 	console.log( view );
     * }
     * ```
     */
    *getViews() {
      function* e(t) {
        if (t.children)
          for (const i of t.children)
            Ao(i) ? yield i : Al(i) && (yield* e(i));
      }
      yield* e(this);
    }
    /**
     * An entry point to the interface which binds DOM nodes to
     * {@link module:utils/observablemixin~Observable observables}.
     * There are two types of bindings:
     *
     * * HTML element attributes or text `textContent` synchronized with attributes of an
     * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
     * and {@link module:ui/template~BindChain#if}.
     *
     * ```ts
     * const bind = Template.bind( observable, emitter );
     *
     * new Template( {
     * 	attributes: {
     * 		// Binds the element "class" attribute to observable#classAttribute.
     * 		class: bind.to( 'classAttribute' )
     * 	}
     * } ).render();
     * ```
     *
     * * DOM events fired on HTML element propagated through
     * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
     *
     * ```ts
     * const bind = Template.bind( observable, emitter );
     *
     * new Template( {
     * 	on: {
     * 		// Will be fired by the observable.
     * 		click: bind( 'elementClicked' )
     * 	}
     * } ).render();
     * ```
     *
     * Also see {@link module:ui/view~View#bindTemplate}.
     *
     * @param observable An observable which provides boundable attributes.
     * @param emitter An emitter that listens to observable attribute
     * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
     */
    static bind(e, t) {
      return {
        to(i, s) {
          return new tA({
            eventNameOrFunction: i,
            attribute: i,
            observable: e,
            emitter: t,
            callback: s
          });
        },
        if(i, s, o) {
          return new sg({
            observable: e,
            emitter: t,
            attribute: i,
            valueIfTrue: s,
            callback: o
          });
        }
      };
    }
    /**
     * Extends an existing {@link module:ui/template~Template} instance with some additional content
     * from another {@link module:ui/template~TemplateDefinition}.
     *
     * ```ts
     * const bind = Template.bind( observable, emitter );
     *
     * const template = new Template( {
     * 	tag: 'p',
     * 	attributes: {
     * 		class: 'a',
     * 		data-x: bind.to( 'foo' )
     * 	},
     * 	children: [
     * 		{
     * 			tag: 'span',
     * 			attributes: {
     * 				class: 'b'
     * 			},
     * 			children: [
     * 				'Span'
     * 			]
     * 		}
     * 	]
     *  } );
     *
     * // Instance-level extension.
     * Template.extend( template, {
     * 	attributes: {
     * 		class: 'b',
     * 		data-x: bind.to( 'bar' )
     * 	},
     * 	children: [
     * 		{
     * 			attributes: {
     * 				class: 'c'
     * 			}
     * 		}
     * 	]
     * } );
     *
     * // Child extension.
     * Template.extend( template.children[ 0 ], {
     * 	attributes: {
     * 		class: 'd'
     * 	}
     * } );
     * ```
     *
     * the `outerHTML` of `template.render()` is:
     *
     * ```html
     * <p class="a b" data-x="{ observable.foo } { observable.bar }">
     * 	<span class="b c d">Span</span>
     * </p>
     * ```
     *
     * @param template An existing template instance to be extended.
     * @param def Additional definition to be applied to a template.
     */
    static extend(e, t) {
      if (e._isRendered)
        throw new g("template-extend-render", [this, e]);
      lg(e, Bu(Mu(t)));
    }
    /**
     * Renders a DOM Node (either an HTML element or text) out of the template.
     *
     * @param data Rendering data.
     */
    _renderNode(e) {
      let t;
      if (e.node ? t = this.tag && this.text : t = this.tag ? this.text : !this.text, t)
        throw new g("ui-template-wrong-syntax", this);
      return this.text ? this._renderText(e) : this._renderElement(e);
    }
    /**
     * Renders an HTML element out of the template.
     *
     * @param data Rendering data.
     */
    _renderElement(e) {
      let t = e.node;
      return t || (t = e.node = document.createElementNS(this.ns || eA, this.tag)), this._renderAttributes(e), this._renderElementChildren(e), this._setUpListeners(e), t;
    }
    /**
     * Renders a text node out of {@link module:ui/template~Template#text}.
     *
     * @param data Rendering data.
     */
    _renderText(e) {
      let t = e.node;
      return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""), ro(this.text) ? this._bindToObservable({
        schema: this.text,
        updater: nA(t),
        data: e
      }) : t.textContent = this.text.join(""), t;
    }
    /**
     * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
     *
     * @param data Rendering data.
     */
    _renderAttributes(e) {
      if (!this.attributes)
        return;
      const t = e.node, i = e.revertData;
      for (const s in this.attributes) {
        const o = t.getAttribute(s), r = this.attributes[s];
        i && (i.attributes[s] = o);
        const a = Nu(r) ? r[0].ns : null;
        if (ro(r)) {
          const l = Nu(r) ? r[0].value : r;
          i && Fu(s) && l.unshift(o), this._bindToObservable({
            schema: l,
            updater: sA(t, s, a),
            data: e
          });
        } else if (s == "style" && typeof r[0] != "string")
          this._renderStyleAttribute(r[0], e);
        else {
          i && o && Fu(s) && r.unshift(o);
          const l = r.map((c) => c && (c.value || c)).reduce((c, u) => c.concat(u), []).reduce(ag, "");
          Yi(l) || t.setAttributeNS(a, s, l);
        }
      }
    }
    /**
     * Renders the `style` attribute of an HTML element based on
     * {@link module:ui/template~Template#attributes}.
     *
     * A style attribute is an object with static values:
     *
     * ```ts
     * attributes: {
     * 	style: {
     * 		color: 'red'
     * 	}
     * }
     * ```
     *
     * or values bound to {@link module:ui/model~Model} properties:
     *
     * ```ts
     * attributes: {
     * 	style: {
     * 		color: bind.to( ... )
     * 	}
     * }
     * ```
     *
     * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
     * needed.
     *
     * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
     * @param data Rendering data.
     */
    _renderStyleAttribute(e, t) {
      const i = t.node;
      for (const s in e) {
        const o = e[s];
        ro(o) ? this._bindToObservable({
          schema: [o],
          updater: oA(i, s),
          data: t
        }) : i.style[s] = o;
      }
    }
    /**
     * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
     *
     * @param data Rendering data.
     */
    _renderElementChildren(e) {
      const t = e.node, i = e.intoFragment ? document.createDocumentFragment() : t, s = e.isApplying;
      let o = 0;
      for (const r of this.children)
        if (xl(r)) {
          if (!s) {
            r.setParent(t);
            for (const a of r)
              i.appendChild(a.element);
          }
        } else if (Ao(r))
          s || (r.isRendered || r.render(), i.appendChild(r.element));
        else if (Ht(r))
          i.appendChild(r);
        else if (s) {
          const a = e.revertData, l = Du();
          a.children.push(l), r._renderNode({
            intoFragment: !1,
            node: i.childNodes[o++],
            isApplying: !0,
            revertData: l
          });
        } else
          i.appendChild(r.render());
      e.intoFragment && t.appendChild(i);
    }
    /**
     * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
     * on an HTML element.
     *
     * @param data Rendering data.
     */
    _setUpListeners(e) {
      if (this.eventListeners)
        for (const t in this.eventListeners) {
          const i = this.eventListeners[t].map((s) => {
            const [o, r] = t.split("@");
            return s.activateDomEventListener(o, r, e);
          });
          e.revertData && e.revertData.bindings.push(i);
        }
    }
    /**
     * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
     * activates the binding and sets its initial value.
     *
     * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
     * text node `textContent`.
     *
     * @param options Binding options.
     * @param options.updater A function which updates the DOM (like attribute or text).
     * @param options.data Rendering data.
     */
    _bindToObservable({ schema: e, updater: t, data: i }) {
      const s = i.revertData;
      og(e, t, i);
      const o = e.filter((r) => !Yi(r)).filter((r) => r.observable).map((r) => r.activateAttributeListener(e, t, i));
      s && s.bindings.push(o);
    }
    /**
     * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
     * return it to the original state.
     *
     * @param node A node to be reverted.
     * @param revertData An object that stores information about what changes have been made by
     * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
     */
    _revertTemplateFromNode(e, t) {
      for (const s of t.bindings)
        for (const o of s)
          o();
      if (t.text) {
        e.textContent = t.text;
        return;
      }
      const i = e;
      for (const s in t.attributes) {
        const o = t.attributes[s];
        o === null ? i.removeAttribute(s) : i.setAttribute(s, o);
      }
      for (let s = 0; s < t.children.length; ++s)
        this._revertTemplateFromNode(i.childNodes[s], t.children[s]);
    }
  }
  class ps {
    /**
     * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
     *
     * @param def The definition of the binding.
     */
    constructor(e) {
      this.attribute = e.attribute, this.observable = e.observable, this.emitter = e.emitter, this.callback = e.callback;
    }
    /**
     * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
     * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
     * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
     *
     * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
     * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
     * {@link module:ui/template~TemplateBinding#observable}.
     */
    getValue(e) {
      const t = this.observable[this.attribute];
      return this.callback ? this.callback(t, e) : t;
    }
    /**
     * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
     * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
     * value of {@link module:ui/template~TemplateValueSchema}.
     *
     * @param schema A full schema to generate an attribute or text in the DOM.
     * @param updater A DOM updater function used to update the native DOM attribute or text.
     * @param data Rendering data.
     * @returns A function to sever the listener binding.
     */
    activateAttributeListener(e, t, i) {
      const s = () => og(e, t, i);
      return this.emitter.listenTo(this.observable, `change:${this.attribute}`, s), () => {
        this.emitter.stopListening(this.observable, `change:${this.attribute}`, s);
      };
    }
  }
  class tA extends ps {
    constructor(e) {
      super(e), this.eventNameOrFunction = e.eventNameOrFunction;
    }
    /**
     * Activates the listener for the native DOM event, which when fired, is propagated by
     * the {@link module:ui/template~TemplateBinding#emitter}.
     *
     * @param domEvtName The name of the native DOM event.
     * @param domSelector The selector in the DOM to filter delegated events.
     * @param data Rendering data.
     * @returns A function to sever the listener binding.
     */
    activateDomEventListener(e, t, i) {
      const s = (o, r) => {
        (!t || r.target.matches(t)) && (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(r) : this.observable.fire(this.eventNameOrFunction, r));
      };
      return this.emitter.listenTo(i.node, e, s), () => {
        this.emitter.stopListening(i.node, e, s);
      };
    }
  }
  class sg extends ps {
    constructor(e) {
      super(e), this.valueIfTrue = e.valueIfTrue;
    }
    /**
     * @inheritDoc
     */
    getValue(e) {
      const t = super.getValue(e);
      return Yi(t) ? !1 : this.valueIfTrue || !0;
    }
  }
  function ro(n) {
    return n ? (n.value && (n = n.value), Array.isArray(n) ? n.some(ro) : n instanceof ps) : !1;
  }
  function iA(n, e) {
    return n.map((t) => t instanceof ps ? t.getValue(e) : t);
  }
  function og(n, e, { node: t }) {
    const i = iA(n, t);
    let s;
    n.length == 1 && n[0] instanceof sg ? s = i[0] : s = i.reduce(ag, ""), Yi(s) ? e.remove() : e.set(s);
  }
  function nA(n) {
    return {
      set(e) {
        n.textContent = e;
      },
      remove() {
        n.textContent = "";
      }
    };
  }
  function sA(n, e, t) {
    return {
      set(i) {
        n.setAttributeNS(t, e, i);
      },
      remove() {
        n.removeAttributeNS(t, e);
      }
    };
  }
  function oA(n, e) {
    return {
      set(t) {
        n.style[e] = t;
      },
      remove() {
        n.style[e] = null;
      }
    };
  }
  function Mu(n) {
    return al(n, (t) => {
      if (t && (t instanceof ps || Al(t) || Ao(t) || xl(t)))
        return t;
    });
  }
  function Bu(n) {
    if (typeof n == "string" ? n = lA(n) : n.text && cA(n), n.on && (n.eventListeners = aA(n.on), delete n.on), !n.text) {
      n.attributes && rA(n.attributes);
      const e = [];
      if (n.children)
        if (xl(n.children))
          e.push(n.children);
        else
          for (const t of n.children)
            Al(t) || Ao(t) || Ht(t) ? e.push(t) : e.push(new Ve(t));
      n.children = e;
    }
    return n;
  }
  function rA(n) {
    for (const e in n)
      n[e].value && (n[e].value = Z(n[e].value)), rg(n, e);
  }
  function aA(n) {
    for (const e in n)
      rg(n, e);
    return n;
  }
  function lA(n) {
    return {
      text: [n]
    };
  }
  function cA(n) {
    n.text = Z(n.text);
  }
  function rg(n, e) {
    n[e] = Z(n[e]);
  }
  function ag(n, e) {
    return Yi(e) ? n : Yi(n) ? e : `${n} ${e}`;
  }
  function Ou(n, e) {
    for (const t in e)
      n[t] ? n[t].push(...e[t]) : n[t] = e[t];
  }
  function lg(n, e) {
    if (e.attributes && (n.attributes || (n.attributes = {}), Ou(n.attributes, e.attributes)), e.eventListeners && (n.eventListeners || (n.eventListeners = {}), Ou(n.eventListeners, e.eventListeners)), e.text && n.text.push(...e.text), e.children && e.children.length) {
      if (n.children.length != e.children.length)
        throw new g("ui-template-extend-children-mismatch", n);
      let t = 0;
      for (const i of e.children)
        lg(n.children[t++], i);
    }
  }
  function Yi(n) {
    return !n && n !== 0;
  }
  function Ao(n) {
    return n instanceof T;
  }
  function Al(n) {
    return n instanceof Ve;
  }
  function xl(n) {
    return n instanceof ke;
  }
  function Nu(n) {
    return J(n[0]) && n[0].ns;
  }
  function Du() {
    return {
      children: [],
      bindings: [],
      attributes: {}
    };
  }
  function Fu(n) {
    return n == "class" || n == "style";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class T extends Me($()) {
    /**
     * Creates an instance of the {@link module:ui/view~View} class.
     *
     * Also see {@link #render}.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(), this.element = null, this.isRendered = !1, this.locale = e, this.t = e && e.t, this._viewCollections = new Ce(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t, i) => {
        i.locale = e, i.t = e && e.t;
      }), this.decorate("render");
    }
    /**
     * Shorthand for {@link module:ui/template~Template.bind}, a binding
     * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
     *
     * It provides {@link module:ui/template~BindChain#to `to()`} and
     * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
     * observable attributes and attach DOM listeners.
     *
     * ```ts
     * class SampleView extends View {
     * 	constructor( locale ) {
     * 		super( locale );
     *
     * 		const bind = this.bindTemplate;
     *
     * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
     * 		// the state of the view in DOM.
     * 		this.set( {
     * 			elementClass: 'foo',
     * 		 	isEnabled: true
     * 		 } );
     *
     * 		this.setTemplate( {
     * 			tag: 'p',
     *
     * 			attributes: {
     * 				// The class HTML attribute will follow elementClass
     * 				// and isEnabled view attributes.
     * 				class: [
     * 					bind.to( 'elementClass' )
     * 					bind.if( 'isEnabled', 'present-when-enabled' )
     * 				]
     * 			},
     *
     * 			on: {
     * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
     * 				click: bind.to( 'clicked' )
     * 			}
     * 		} );
     * 	}
     * }
     * ```
     */
    get bindTemplate() {
      return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Ve.bind(this, this);
    }
    /**
     * Creates a new collection of views, which can be used as
     * {@link module:ui/template~Template#children} of this view.
     *
     * ```ts
     * class SampleView extends View {
     * 	constructor( locale ) {
     * 		super( locale );
     *
     * 		const child = new ChildView( locale );
     * 		this.items = this.createCollection( [ child ] );
     *
     * 		this.setTemplate( {
     * 			tag: 'p',
     *
     * 			// `items` collection will render here.
     * 			children: this.items
     * 		} );
     * 	}
     * }
     *
     * const view = new SampleView( locale );
     * view.render();
     *
     * // It will append <p><child#element></p> to the <body>.
     * document.body.appendChild( view.element );
     * ```
     *
     * @param views Initial views of the collection.
     * @returns A new collection of view instances.
     */
    createCollection(e) {
      const t = new ke(e);
      return this._viewCollections.add(t), t;
    }
    /**
     * Registers a new child view under the view instance. Once registered, a child
     * view is managed by its parent, including {@link #render rendering}
     * and {@link #destroy destruction}.
     *
     * To revert this, use {@link #deregisterChild}.
     *
     * ```ts
     * class SampleView extends View {
     * 	constructor( locale ) {
     * 		super( locale );
     *
     * 		this.childA = new SomeChildView( locale );
     * 		this.childB = new SomeChildView( locale );
     *
     * 		this.setTemplate( { tag: 'p' } );
     *
     * 		// Register the children.
     * 		this.registerChild( [ this.childA, this.childB ] );
     * 	}
     *
     * 	render() {
     * 		super.render();
     *
     * 		this.element.appendChild( this.childA.element );
     * 		this.element.appendChild( this.childB.element );
     * 	}
     * }
     *
     * const view = new SampleView( locale );
     *
     * view.render();
     *
     * // Will append <p><childA#element><b></b><childB#element></p>.
     * document.body.appendChild( view.element );
     * ```
     *
     * **Note**: There's no need to add child views if they're already referenced in the
     * {@link #template}:
     *
     * ```ts
     * class SampleView extends View {
     * 	constructor( locale ) {
     * 		super( locale );
     *
     * 		this.childA = new SomeChildView( locale );
     * 		this.childB = new SomeChildView( locale );
     *
     * 		this.setTemplate( {
     * 			tag: 'p',
     *
     * 			// These children will be added automatically. There's no
     * 			// need to call {@link #registerChild} for any of them.
     * 			children: [ this.childA, this.childB ]
     * 		} );
     * 	}
     *
     * 	// ...
     * }
     * ```
     *
     * @param children Children views to be registered.
     */
    registerChild(e) {
      We(e) || (e = [e]);
      for (const t of e)
        this._unboundChildren.add(t);
    }
    /**
     * The opposite of {@link #registerChild}. Removes a child view from this view instance.
     * Once removed, the child is no longer managed by its parent, e.g. it can safely
     * become a child of another parent view.
     *
     * @see #registerChild
     * @param children Child views to be removed.
     */
    deregisterChild(e) {
      We(e) || (e = [e]);
      for (const t of e)
        this._unboundChildren.remove(t);
    }
    /**
     * Sets the {@link #template} of the view with with given definition.
     *
     * A shorthand for:
     *
     * ```ts
     * view.setTemplate( definition );
     * ```
     *
     * @param definition Definition of view's template.
     */
    setTemplate(e) {
      this.template = new Ve(e);
    }
    /**
     * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
     * with given definition.
     *
     * A shorthand for:
     *
     * ```ts
     * Template.extend( view.template, definition );
     * ```
     *
     * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
     *
     * @param definition Definition which extends the {@link #template}.
     */
    extendTemplate(e) {
      Ve.extend(this.template, e);
    }
    /**
     * Recursively renders the view.
     *
     * Once the view is rendered:
     * * the {@link #element} becomes an HTML element out of {@link #template},
     * * the {@link #isRendered} flag is set `true`.
     *
     * **Note**: The children of the view:
     * * defined directly in the {@link #template}
     * * residing in collections created by the {@link #createCollection} method,
     * * and added by {@link #registerChild}
     * are also rendered in the process.
     *
     * In general, `render()` method is the right place to keep the code which refers to the
     * {@link #element} and should be executed at the very beginning of the view's life cycle.
     *
     * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
     * the view is rendered. To allow an early customization of the view (e.g. by its parent),
     * such references should be done in `render()`.
     *
     * ```ts
     * class SampleView extends View {
     * 	constructor() {
     * 		this.setTemplate( {
     * 			// ...
     * 		} );
     * 	},
     *
     * 	render() {
     * 		// View#element becomes available.
     * 		super.render();
     *
     * 		// The "scroll" listener depends on #element.
     * 		this.listenTo( window, 'scroll', () => {
     * 			// A reference to #element would render the #template and make it non-extendable.
     * 			if ( window.scrollY > 0 ) {
     * 				this.element.scrollLeft = 100;
     * 			} else {
     * 				this.element.scrollLeft = 0;
     * 			}
     * 		} );
     * 	}
     * }
     *
     * const view = new SampleView();
     *
     * // Let's customize the view before it gets rendered.
     * view.extendTemplate( {
     * 	attributes: {
     * 		class: [
     * 			'additional-class'
     * 		]
     * 	}
     * } );
     *
     * // Late rendering allows customization of the view.
     * view.render();
     * ```
     */
    render() {
      if (this.isRendered)
        throw new g("ui-view-render-already-rendered", this);
      this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0;
    }
    /**
     * Recursively destroys the view instance and child views added by {@link #registerChild} and
     * residing in collections created by the {@link #createCollection}.
     *
     * Destruction disables all event listeners:
     * * created on the view, e.g. `view.on( 'event', () => {} )`,
     * * defined in the {@link #template} for DOM events.
     */
    destroy() {
      this.stopListening(), this._viewCollections.map((e) => e.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Fe extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${Ze()}`;
      const t = this.bindTemplate;
      this.setTemplate({
        tag: "label",
        attributes: {
          class: [
            "ck",
            "ck-label"
          ],
          id: this.id,
          for: t.to("for")
        },
        children: [
          {
            text: t.to("text")
          }
        ]
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class uA extends T {
    /**
     * @inheritDoc
     */
    constructor(e, t) {
      super(e);
      const i = e.t, s = new Fe();
      s.text = i("Help Contents. To close this dialog press ESC."), this.setTemplate({
        tag: "div",
        attributes: {
          class: ["ck", "ck-accessibility-help-dialog__content"],
          "aria-labelledby": s.id,
          role: "document",
          tabindex: -1
        },
        children: [
          tt(document, "p", {}, i("Below, you can find a list of keyboard shortcuts that can be used in the editor.")),
          ...this._createCategories(Array.from(t.values())),
          s
        ]
      });
    }
    /**
     * @inheritDoc
     */
    focus() {
      this.element.focus();
    }
    /**
     * Creates `<section><h3>Category label</h3>...</section>` elements for each category of keystrokes.
     */
    _createCategories(e) {
      return e.map((t) => {
        const i = [
          // Category header.
          tt(document, "h3", {}, t.label),
          // Category definitions (<dl>) and their optional headers (<h4>).
          ...Array.from(t.groups.values()).map((s) => this._createGroup(s)).flat()
        ];
        return t.description && i.splice(1, 0, tt(document, "p", {}, t.description)), tt(document, "section", {}, i);
      });
    }
    /**
     * Creates `[<h4>Optional label</h4>]<dl>...</dl>` elements for each group of keystrokes in a category.
     */
    _createGroup(e) {
      const t = e.keystrokes.sort((s, o) => s.label.localeCompare(o.label)).map((s) => this._createGroupRow(s)).flat(), i = [
        tt(document, "dl", {}, t)
      ];
      return e.label && i.unshift(tt(document, "h4", {}, e.label)), i;
    }
    /**
     * Creates `<dt>Keystroke label</dt><dd>Keystroke definition</dd>` elements for each keystroke in a group.
     */
    _createGroupRow(e) {
      const t = this.locale.t, i = tt(document, "dt"), s = tt(document, "dd"), o = hA(e.keystroke), r = [];
      for (const a of o)
        r.push(a.map(dA).join(""));
      return i.innerHTML = e.label, s.innerHTML = r.join(", ") + (e.mayRequireFn && B.isMac ? ` ${t("(may require <kbd>Fn</kbd>)")}` : ""), [i, s];
    }
  }
  function dA(n) {
    return ko(n).split("+").map((e) => `<kbd>${e}</kbd>`).join("+");
  }
  function hA(n) {
    return typeof n == "string" ? [[n]] : typeof n[0] == "string" ? [n] : n;
  }
  const zu = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6.628a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/><path d="M8.5 9.125a.3.3 0 0 0-.253-.296L5.11 8.327a.75.75 0 1 1 .388-1.449l4.04.716c.267.072.624.08.893.009l4.066-.724a.75.75 0 1 1 .388 1.45l-3.132.5a.3.3 0 0 0-.253.296v1.357a.3.3 0 0 0 .018.102l1.615 4.438a.75.75 0 0 1-1.41.513l-1.35-3.71a.3.3 0 0 0-.281-.197h-.209a.3.3 0 0 0-.282.198l-1.35 3.711a.75.75 0 0 1-1.41-.513l1.64-4.509a.3.3 0 0 0 .019-.103V9.125Z"/><path clip-rule="evenodd" d="M10 18.5a8.5 8.5 0 1 1 0-17 8.5 8.5 0 0 1 0 17Zm0 1.5c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10Z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class fA extends w {
    constructor() {
      super(...arguments), this.contentView = null;
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Tt];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "AccessibilityHelp";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale.t;
      e.ui.componentFactory.add("accessibilityHelp", () => {
        const i = this._createButton(P);
        return i.set({
          tooltip: !0,
          withText: !1,
          label: t("Accessibility help")
        }), i;
      }), e.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
        const i = this._createButton(de);
        return i.label = t("Accessibility"), i;
      }), e.keystrokes.set("Alt+0", (i, s) => {
        this._showDialog(), s();
      }), this._setupRootLabels();
    }
    /**
     * Creates a button to show accessibility help dialog, for use either in toolbar or in menu bar.
     */
    _createButton(e) {
      const i = this.editor.locale, s = new e(i);
      return s.set({
        keystroke: "Alt+0",
        icon: zu
      }), s.on("execute", () => this._showDialog()), s;
    }
    /**
     * Injects a help text into each editing root's `aria-label` attribute allowing assistive technology users
     * to discover the availability of the Accessibility help dialog.
     */
    _setupRootLabels() {
      const e = this.editor, t = e.editing.view, i = e.t;
      e.ui.on("ready", () => {
        t.change((o) => {
          for (const r of t.document.roots)
            s(o, r);
        }), e.on("addRoot", (o, r) => {
          const a = e.editing.view.document.getRoot(r.rootName);
          t.change((l) => s(l, a));
        }, { priority: "low" });
      });
      function s(o, r) {
        const l = `${r.getAttribute("aria-label")}. ${i("Press %0 for help.", [ko("Alt+0")])}`;
        o.setAttribute("aria-label", l, r);
      }
    }
    /**
     * Shows the accessibility help dialog. Also, creates {@link #contentView} on demand.
     */
    _showDialog() {
      const e = this.editor, t = e.plugins.get("Dialog"), i = e.locale.t;
      this.contentView || (this.contentView = new uA(e.locale, e.accessibility.keystrokeInfos)), t.show({
        id: "accessibilityHelp",
        className: "ck-accessibility-help-dialog",
        title: i("Accessibility help"),
        icon: zu,
        hasCloseButton: !0,
        content: this.contentView
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class mA extends ke {
    /**
     * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
     *
     * @param locale The {@link module:core/editor/editor~Editor editor's locale} instance.
     * @param initialItems The initial items of the collection.
     */
    constructor(e, t = []) {
      super(t), this.locale = e;
    }
    /**
     * The element holding elements of the body region.
     */
    get bodyCollectionContainer() {
      return this._bodyCollectionContainer;
    }
    /**
     * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
     * the body collection.
     */
    attachToDom() {
      this._bodyCollectionContainer = new Ve({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-reset_all",
            "ck-body",
            "ck-rounded-corners"
          ],
          dir: this.locale.uiLanguageDirection
        },
        children: this
      }).render();
      let e = document.querySelector(".ck-body-wrapper");
      e || (e = tt(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(e)), e.appendChild(this._bodyCollectionContainer);
    }
    /**
     * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
     * anymore to clean-up the DOM structure.
     */
    detachFromDom() {
      super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
      const e = document.querySelector(".ck-body-wrapper");
      e && e.childElementCount == 0 && e.remove();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class dt extends T {
    /**
     * @inheritDoc
     */
    constructor() {
      super();
      const e = this.bindTemplate;
      this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.set("isVisible", !0), this.setTemplate({
        tag: "svg",
        ns: "http://www.w3.org/2000/svg",
        attributes: {
          class: [
            "ck",
            "ck-icon",
            e.if("isVisible", "ck-hidden", (t) => !t),
            // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
            // (https://github.com/ckeditor/ckeditor5/issues/12599).
            "ck-reset_all-excluded",
            // The class to remove the dynamic color inheritance is toggleable
            // (https://github.com/ckeditor/ckeditor5/issues/12599).
            e.if("isColorInherited", "ck-icon_inherit-color")
          ],
          viewBox: e.to("viewBox")
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
        this._updateXMLContent(), this._colorFillPaths();
      }), this.on("change:fillColor", () => {
        this._colorFillPaths();
      });
    }
    /**
     * Updates the {@link #element} with the value of {@link #content}.
     */
    _updateXMLContent() {
      if (this.content) {
        const t = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), i = t.getAttribute("viewBox");
        i && (this.viewBox = i);
        for (const { name: s, value: o } of Array.from(t.attributes))
          dt.presentationalAttributeNames.includes(s) && this.element.setAttribute(s, o);
        for (; this.element.firstChild; )
          this.element.removeChild(this.element.firstChild);
        for (; t.childNodes.length > 0; )
          this.element.appendChild(t.childNodes[0]);
      }
    }
    /**
     * Fills all child `path.ck-icon__fill` with the `#fillColor`.
     */
    _colorFillPaths() {
      this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((e) => {
        e.style.fill = this.fillColor;
      });
    }
  }
  dt.presentationalAttributeNames = [
    "alignment-baseline",
    "baseline-shift",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-rendering",
    "cursor",
    "direction",
    "display",
    "dominant-baseline",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "image-rendering",
    "letter-spacing",
    "lighting-color",
    "marker-end",
    "marker-mid",
    "marker-start",
    "mask",
    "opacity",
    "overflow",
    "paint-order",
    "pointer-events",
    "shape-rendering",
    "stop-color",
    "stop-opacity",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "text-anchor",
    "text-decoration",
    "text-overflow",
    "text-rendering",
    "transform",
    "unicode-bidi",
    "vector-effect",
    "visibility",
    "white-space",
    "word-spacing",
    "writing-mode"
  ];
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class gA extends T {
    /**
     * @inheritDoc
     */
    constructor() {
      super(), this.set({
        style: void 0,
        text: void 0,
        id: void 0
      });
      const e = this.bindTemplate;
      this.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-button__label"
          ],
          style: e.to("style"),
          id: e.to("id")
        },
        children: [
          {
            text: e.to("text")
          }
        ]
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class P extends T {
    /**
     * Creates an instance of the button view class.
     *
     * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
     * @param labelView The instance of the button's label. If not provided, an instance of
     * {@link module:ui/button/buttonlabelview~ButtonLabelView} is used.
     */
    constructor(e, t = new gA()) {
      super(e), this._focusDelayed = null;
      const i = this.bindTemplate, s = Ze();
      this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${s}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._setupLabelView(t), this.iconView = new dt(), this.iconView.extendTemplate({
        attributes: {
          class: "ck-button__icon"
        }
      }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
      const o = {
        tag: "button",
        attributes: {
          class: [
            "ck",
            "ck-button",
            i.to("class"),
            i.if("isEnabled", "ck-disabled", (r) => !r),
            i.if("isVisible", "ck-hidden", (r) => !r),
            i.to("isOn", (r) => r ? "ck-on" : "ck-off"),
            i.if("withText", "ck-button_with-text"),
            i.if("withKeystroke", "ck-button_with-keystroke")
          ],
          role: i.to("role"),
          type: i.to("type", (r) => r || "button"),
          tabindex: i.to("tabindex"),
          "aria-checked": i.to("ariaChecked"),
          "aria-label": i.to("ariaLabel"),
          "aria-labelledby": i.to("ariaLabelledBy"),
          "aria-disabled": i.if("isEnabled", !0, (r) => !r),
          "aria-pressed": i.to("isOn", (r) => this.isToggleable ? String(!!r) : !1),
          "data-cke-tooltip-text": i.to("_tooltipString"),
          "data-cke-tooltip-position": i.to("tooltipPosition")
        },
        children: this.children,
        on: {
          click: i.to((r) => {
            this.isEnabled ? this.fire("execute") : r.preventDefault();
          })
        }
      };
      B.isSafari && (this._focusDelayed || (this._focusDelayed = dl(() => this.focus(), 0)), o.on.mousedown = i.to(() => {
        this._focusDelayed();
      }), o.on.mouseup = i.to(() => {
        this._focusDelayed.cancel();
      })), this.setTemplate(o);
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
    }
    /**
     * Focuses the {@link #element} of the button.
     */
    focus() {
      this.element.focus();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      this._focusDelayed && this._focusDelayed.cancel(), super.destroy();
    }
    /**
     * Binds the label view instance it with button attributes.
     */
    _setupLabelView(e) {
      return e.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy"), e;
    }
    /**
     * Creates a view that displays a keystroke next to a {@link #labelView label }
     * and binds it with button attributes.
     */
    _createKeystrokeView() {
      const e = new T();
      return e.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-button__keystroke"
          ]
        },
        children: [
          {
            text: this.bindTemplate.to("keystroke", (t) => ko(t))
          }
        ]
      }), e;
    }
    /**
     * Gets the text for the tooltip from the combination of
     * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
     *
     * @see #tooltip
     * @see #_tooltipString
     * @param tooltip Button tooltip.
     * @param label Button label.
     * @param keystroke Button keystroke.
     */
    _getTooltipString(e, t, i) {
      return e ? typeof e == "string" ? e : (i && (i = ko(i)), e instanceof Function ? e(t, i) : `${t}${i ? ` (${i})` : ""}`) : "";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ir extends P {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({
        attributes: {
          class: "ck-switchbutton"
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.children.add(this.toggleSwitchView);
    }
    /**
     * Creates a toggle child view.
     */
    _createToggleView() {
      const e = new T();
      return e.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-button__toggle"
          ]
        },
        children: [
          {
            tag: "span",
            attributes: {
              class: [
                "ck",
                "ck-button__toggle__inner"
              ]
            }
          }
        ]
      }), e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class cg extends P {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.buttonView = this, this._fileInputView = new pA(e), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.on("execute", () => {
        this._fileInputView.open();
      }), this.extendTemplate({
        attributes: {
          class: "ck-file-dialog-button"
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.children.add(this._fileInputView);
    }
  }
  class pA extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
      const t = this.bindTemplate;
      this.setTemplate({
        tag: "input",
        attributes: {
          class: [
            "ck-hidden"
          ],
          type: "file",
          tabindex: "-1",
          accept: t.to("acceptedType"),
          multiple: t.to("allowMultipleFiles")
        },
        on: {
          // Removing from code coverage since we cannot programmatically set input element files.
          change: t.to(
            /* istanbul ignore next -- @preserve */
            () => {
              this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
            }
          )
        }
      });
    }
    /**
     * Opens file dialog.
     */
    open() {
      this.element.click();
    }
  }
  const nr = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ug extends T {
    /**
     * Creates an instance of the collapsible view.
     *
     * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
     * @param childViews An optional array of initial child views to be inserted into the collapsible.
     */
    constructor(e, t) {
      super(e);
      const i = this.bindTemplate;
      this.set("isCollapsed", !1), this.set("label", ""), this.buttonView = this._createButtonView(), this.children = this.createCollection(), this.set("_collapsibleAriaLabelUid", void 0), t && this.children.addMany(t), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-collapsible",
            i.if("isCollapsed", "ck-collapsible_collapsed")
          ]
        },
        children: [
          this.buttonView,
          {
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-collapsible__children"
              ],
              role: "region",
              hidden: i.if("isCollapsed", "hidden"),
              "aria-labelledby": i.to("_collapsibleAriaLabelUid")
            },
            children: this.children
          }
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id;
    }
    /**
     * Focuses the first focusable.
     */
    focus() {
      this.buttonView.focus();
    }
    /**
     * Creates the main {@link #buttonView} of the collapsible.
     */
    _createButtonView() {
      const e = new P(this.locale), t = e.bindTemplate;
      return e.set({
        withText: !0,
        icon: nr
      }), e.extendTemplate({
        attributes: {
          "aria-expanded": t.to("isOn", (i) => String(i))
        }
      }), e.bind("label").to(this), e.bind("isOn").to(this, "isCollapsed", (i) => !i), e.on("execute", () => {
        this.isCollapsed = !this.isCollapsed;
      }), e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function ns(n, e) {
    const t = n.t, i = {
      Black: t("Black"),
      "Dim grey": t("Dim grey"),
      Grey: t("Grey"),
      "Light grey": t("Light grey"),
      White: t("White"),
      Red: t("Red"),
      Orange: t("Orange"),
      Yellow: t("Yellow"),
      "Light green": t("Light green"),
      Green: t("Green"),
      Aquamarine: t("Aquamarine"),
      Turquoise: t("Turquoise"),
      "Light blue": t("Light blue"),
      Blue: t("Blue"),
      Purple: t("Purple")
    };
    return e.map((s) => {
      const o = i[s.label];
      return o && o != s.label && (s.label = o), s;
    });
  }
  function ss(n) {
    return n.map(wA).filter((e) => !!e);
  }
  function wA(n) {
    return typeof n == "string" ? {
      model: n,
      label: n,
      hasBorder: !1,
      view: {
        name: "span",
        styles: {
          color: n
        }
      }
    } : {
      model: n.color,
      label: n.label || n.color,
      hasBorder: n.hasBorder === void 0 ? !1 : n.hasBorder,
      view: {
        name: "span",
        styles: {
          color: `${n.color}`
        }
      }
    };
  }
  const bA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class dg extends P {
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set("color", void 0), this.set("hasBorder", !1), this.icon = bA, this.extendTemplate({
        attributes: {
          style: {
            backgroundColor: t.to("color")
          },
          class: [
            "ck",
            "ck-color-grid__tile",
            t.if("hasBorder", "ck-color-selector__color-tile_bordered")
          ]
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.iconView.fillColor = "hsl(0, 0%, 100%)";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Uu extends T {
    /**
     * Creates an instance of a color grid containing {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
     *
     * @fires execute
     * @param locale The localization services instance.
     * @param options Component configuration
     * @param options.colorDefinitions Array with definitions
     * required to create the {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
     * @param options.columns A number of columns to display the tiles.
     */
    constructor(e, t) {
      super(e);
      const i = t && t.colorDefinitions ? t.colorDefinitions : [];
      this.columns = t && t.columns ? t.columns : 5;
      const s = {
        gridTemplateColumns: `repeat( ${this.columns}, 1fr)`
      };
      this.set("selectedColor", void 0), this.items = this.createCollection(), this.focusTracker = new Q(), this.keystrokes = new ne(), this.items.on("add", (o, r) => {
        r.isOn = r.color === this.selectedColor;
      }), i.forEach((o) => {
        const r = new dg();
        r.set({
          color: o.color,
          label: o.label,
          tooltip: !0,
          hasBorder: o.options.hasBorder
        }), r.on("execute", () => {
          this.fire("execute", {
            value: o.color,
            hasBorder: o.options.hasBorder,
            label: o.label
          });
        }), this.items.add(r);
      }), this.setTemplate({
        tag: "div",
        children: this.items,
        attributes: {
          class: [
            "ck",
            "ck-color-grid"
          ],
          style: s
        }
      }), this.on("change:selectedColor", (o, r, a) => {
        for (const l of this.items)
          l.isOn = l.color === a;
      });
    }
    /**
     * Focuses the first focusable in {@link #items}.
     */
    focus() {
      this.items.length && this.items.first.focus();
    }
    /**
     * Focuses the last focusable in {@link #items}.
     */
    focusLast() {
      this.items.length && this.items.last.focus();
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render();
      for (const e of this.items)
        this.focusTracker.add(e.element);
      this.items.on("add", (e, t) => {
        this.focusTracker.add(t.element);
      }), this.items.on("remove", (e, t) => {
        this.focusTracker.remove(t.element);
      }), this.keystrokes.listenTo(this.element), Ka({
        keystrokeHandler: this.keystrokes,
        focusTracker: this.focusTracker,
        gridItems: this.items,
        numberOfColumns: this.columns,
        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
      });
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
  }
  function hg(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
  }
  var fg = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  const Hu = /* @__PURE__ */ hg(fg);
  var $u = {
    red: 0,
    orange: 60,
    yellow: 120,
    green: 180,
    blue: 240,
    purple: 300
  };
  function Wu(n) {
    var e, t = [], i = 1, s;
    if (typeof n == "string")
      if (Hu[n])
        t = Hu[n].slice(), s = "rgb";
      else if (n === "transparent")
        i = 0, s = "rgb", t = [0, 0, 0];
      else if (/^#[A-Fa-f0-9]+$/.test(n)) {
        var o = n.slice(1), r = o.length, a = r <= 4;
        i = 1, a ? (t = [
          parseInt(o[0] + o[0], 16),
          parseInt(o[1] + o[1], 16),
          parseInt(o[2] + o[2], 16)
        ], r === 4 && (i = parseInt(o[3] + o[3], 16) / 255)) : (t = [
          parseInt(o[0] + o[1], 16),
          parseInt(o[2] + o[3], 16),
          parseInt(o[4] + o[5], 16)
        ], r === 8 && (i = parseInt(o[6] + o[7], 16) / 255)), t[0] || (t[0] = 0), t[1] || (t[1] = 0), t[2] || (t[2] = 0), s = "rgb";
      } else if (e = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(n)) {
        var l = e[1], c = l === "rgb", o = l.replace(/a$/, "");
        s = o;
        var r = o === "cmyk" ? 4 : o === "gray" ? 1 : 3;
        t = e[2].trim().split(/\s*[,\/]\s*|\s+/).map(function(h, f) {
          if (/%$/.test(h))
            return f === r ? parseFloat(h) / 100 : o === "rgb" ? parseFloat(h) * 255 / 100 : parseFloat(h);
          if (o[f] === "h") {
            if (/deg$/.test(h))
              return parseFloat(h);
            if ($u[h] !== void 0)
              return $u[h];
          }
          return parseFloat(h);
        }), l === o && t.push(1), i = c || t[r] === void 0 ? 1 : t[r], t = t.slice(0, r);
      } else
        n.length > 10 && /[0-9](?:\s|\/)/.test(n) && (t = n.match(/([0-9]+)/g).map(function(u) {
          return parseFloat(u);
        }), s = n.match(/([a-z])/ig).join("").toLowerCase());
    else
      isNaN(n) ? Array.isArray(n) || n.length ? (t = [n[0], n[1], n[2]], s = "rgb", i = n.length === 4 ? n[3] : 1) : n instanceof Object && (n.r != null || n.red != null || n.R != null ? (s = "rgb", t = [
        n.r || n.red || n.R || 0,
        n.g || n.green || n.G || 0,
        n.b || n.blue || n.B || 0
      ]) : (s = "hsl", t = [
        n.h || n.hue || n.H || 0,
        n.s || n.saturation || n.S || 0,
        n.l || n.lightness || n.L || n.b || n.brightness
      ]), i = n.a || n.alpha || n.opacity || 1, n.opacity != null && (i /= 100)) : (s = "rgb", t = [n >>> 16, (n & 65280) >>> 8, n & 255]);
    return {
      space: s,
      values: t,
      alpha: i
    };
  }
  const os = fg, mg = {};
  for (const n of Object.keys(os))
    mg[os[n]] = n;
  const I = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  var gg = I;
  for (const n of Object.keys(I)) {
    if (!("channels" in I[n]))
      throw new Error("missing channels property: " + n);
    if (!("labels" in I[n]))
      throw new Error("missing channel labels property: " + n);
    if (I[n].labels.length !== I[n].channels)
      throw new Error("channel and label counts mismatch: " + n);
    const { channels: e, labels: t } = I[n];
    delete I[n].channels, delete I[n].labels, Object.defineProperty(I[n], "channels", { value: e }), Object.defineProperty(I[n], "labels", { value: t });
  }
  I.rgb.hsl = function(n) {
    const e = n[0] / 255, t = n[1] / 255, i = n[2] / 255, s = Math.min(e, t, i), o = Math.max(e, t, i), r = o - s;
    let a, l;
    o === s ? a = 0 : e === o ? a = (t - i) / r : t === o ? a = 2 + (i - e) / r : i === o && (a = 4 + (e - t) / r), a = Math.min(a * 60, 360), a < 0 && (a += 360);
    const c = (s + o) / 2;
    return o === s ? l = 0 : c <= 0.5 ? l = r / (o + s) : l = r / (2 - o - s), [a, l * 100, c * 100];
  };
  I.rgb.hsv = function(n) {
    let e, t, i, s, o;
    const r = n[0] / 255, a = n[1] / 255, l = n[2] / 255, c = Math.max(r, a, l), u = c - Math.min(r, a, l), d = function(h) {
      return (c - h) / 6 / u + 1 / 2;
    };
    return u === 0 ? (s = 0, o = 0) : (o = u / c, e = d(r), t = d(a), i = d(l), r === c ? s = i - t : a === c ? s = 1 / 3 + e - i : l === c && (s = 2 / 3 + t - e), s < 0 ? s += 1 : s > 1 && (s -= 1)), [
      s * 360,
      o * 100,
      c * 100
    ];
  };
  I.rgb.hwb = function(n) {
    const e = n[0], t = n[1];
    let i = n[2];
    const s = I.rgb.hsl(n)[0], o = 1 / 255 * Math.min(e, Math.min(t, i));
    return i = 1 - 1 / 255 * Math.max(e, Math.max(t, i)), [s, o * 100, i * 100];
  };
  I.rgb.cmyk = function(n) {
    const e = n[0] / 255, t = n[1] / 255, i = n[2] / 255, s = Math.min(1 - e, 1 - t, 1 - i), o = (1 - e - s) / (1 - s) || 0, r = (1 - t - s) / (1 - s) || 0, a = (1 - i - s) / (1 - s) || 0;
    return [o * 100, r * 100, a * 100, s * 100];
  };
  function _A(n, e) {
    return (n[0] - e[0]) ** 2 + (n[1] - e[1]) ** 2 + (n[2] - e[2]) ** 2;
  }
  I.rgb.keyword = function(n) {
    const e = mg[n];
    if (e)
      return e;
    let t = 1 / 0, i;
    for (const s of Object.keys(os)) {
      const o = os[s], r = _A(n, o);
      r < t && (t = r, i = s);
    }
    return i;
  };
  I.keyword.rgb = function(n) {
    return os[n];
  };
  I.rgb.xyz = function(n) {
    let e = n[0] / 255, t = n[1] / 255, i = n[2] / 255;
    e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92, t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92, i = i > 0.04045 ? ((i + 0.055) / 1.055) ** 2.4 : i / 12.92;
    const s = e * 0.4124 + t * 0.3576 + i * 0.1805, o = e * 0.2126 + t * 0.7152 + i * 0.0722, r = e * 0.0193 + t * 0.1192 + i * 0.9505;
    return [s * 100, o * 100, r * 100];
  };
  I.rgb.lab = function(n) {
    const e = I.rgb.xyz(n);
    let t = e[0], i = e[1], s = e[2];
    t /= 95.047, i /= 100, s /= 108.883, t = t > 8856e-6 ? t ** (1 / 3) : 7.787 * t + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116;
    const o = 116 * i - 16, r = 500 * (t - i), a = 200 * (i - s);
    return [o, r, a];
  };
  I.hsl.rgb = function(n) {
    const e = n[0] / 360, t = n[1] / 100, i = n[2] / 100;
    let s, o, r;
    if (t === 0)
      return r = i * 255, [r, r, r];
    i < 0.5 ? s = i * (1 + t) : s = i + t - i * t;
    const a = 2 * i - s, l = [0, 0, 0];
    for (let c = 0; c < 3; c++)
      o = e + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? r = a + (s - a) * 6 * o : 2 * o < 1 ? r = s : 3 * o < 2 ? r = a + (s - a) * (2 / 3 - o) * 6 : r = a, l[c] = r * 255;
    return l;
  };
  I.hsl.hsv = function(n) {
    const e = n[0];
    let t = n[1] / 100, i = n[2] / 100, s = t;
    const o = Math.max(i, 0.01);
    i *= 2, t *= i <= 1 ? i : 2 - i, s *= o <= 1 ? o : 2 - o;
    const r = (i + t) / 2, a = i === 0 ? 2 * s / (o + s) : 2 * t / (i + t);
    return [e, a * 100, r * 100];
  };
  I.hsv.rgb = function(n) {
    const e = n[0] / 60, t = n[1] / 100;
    let i = n[2] / 100;
    const s = Math.floor(e) % 6, o = e - Math.floor(e), r = 255 * i * (1 - t), a = 255 * i * (1 - t * o), l = 255 * i * (1 - t * (1 - o));
    switch (i *= 255, s) {
      case 0:
        return [i, l, r];
      case 1:
        return [a, i, r];
      case 2:
        return [r, i, l];
      case 3:
        return [r, a, i];
      case 4:
        return [l, r, i];
      case 5:
        return [i, r, a];
    }
  };
  I.hsv.hsl = function(n) {
    const e = n[0], t = n[1] / 100, i = n[2] / 100, s = Math.max(i, 0.01);
    let o, r;
    r = (2 - t) * i;
    const a = (2 - t) * s;
    return o = t * s, o /= a <= 1 ? a : 2 - a, o = o || 0, r /= 2, [e, o * 100, r * 100];
  };
  I.hwb.rgb = function(n) {
    const e = n[0] / 360;
    let t = n[1] / 100, i = n[2] / 100;
    const s = t + i;
    let o;
    s > 1 && (t /= s, i /= s);
    const r = Math.floor(6 * e), a = 1 - i;
    o = 6 * e - r, r & 1 && (o = 1 - o);
    const l = t + o * (a - t);
    let c, u, d;
    switch (r) {
      default:
      case 6:
      case 0:
        c = a, u = l, d = t;
        break;
      case 1:
        c = l, u = a, d = t;
        break;
      case 2:
        c = t, u = a, d = l;
        break;
      case 3:
        c = t, u = l, d = a;
        break;
      case 4:
        c = l, u = t, d = a;
        break;
      case 5:
        c = a, u = t, d = l;
        break;
    }
    return [c * 255, u * 255, d * 255];
  };
  I.cmyk.rgb = function(n) {
    const e = n[0] / 100, t = n[1] / 100, i = n[2] / 100, s = n[3] / 100, o = 1 - Math.min(1, e * (1 - s) + s), r = 1 - Math.min(1, t * (1 - s) + s), a = 1 - Math.min(1, i * (1 - s) + s);
    return [o * 255, r * 255, a * 255];
  };
  I.xyz.rgb = function(n) {
    const e = n[0] / 100, t = n[1] / 100, i = n[2] / 100;
    let s, o, r;
    return s = e * 3.2406 + t * -1.5372 + i * -0.4986, o = e * -0.9689 + t * 1.8758 + i * 0.0415, r = e * 0.0557 + t * -0.204 + i * 1.057, s = s > 31308e-7 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92, o = o > 31308e-7 ? 1.055 * o ** (1 / 2.4) - 0.055 : o * 12.92, r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92, s = Math.min(Math.max(0, s), 1), o = Math.min(Math.max(0, o), 1), r = Math.min(Math.max(0, r), 1), [s * 255, o * 255, r * 255];
  };
  I.xyz.lab = function(n) {
    let e = n[0], t = n[1], i = n[2];
    e /= 95.047, t /= 100, i /= 108.883, e = e > 8856e-6 ? e ** (1 / 3) : 7.787 * e + 16 / 116, t = t > 8856e-6 ? t ** (1 / 3) : 7.787 * t + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116;
    const s = 116 * t - 16, o = 500 * (e - t), r = 200 * (t - i);
    return [s, o, r];
  };
  I.lab.xyz = function(n) {
    const e = n[0], t = n[1], i = n[2];
    let s, o, r;
    o = (e + 16) / 116, s = t / 500 + o, r = o - i / 200;
    const a = o ** 3, l = s ** 3, c = r ** 3;
    return o = a > 8856e-6 ? a : (o - 16 / 116) / 7.787, s = l > 8856e-6 ? l : (s - 16 / 116) / 7.787, r = c > 8856e-6 ? c : (r - 16 / 116) / 7.787, s *= 95.047, o *= 100, r *= 108.883, [s, o, r];
  };
  I.lab.lch = function(n) {
    const e = n[0], t = n[1], i = n[2];
    let s;
    s = Math.atan2(i, t) * 360 / 2 / Math.PI, s < 0 && (s += 360);
    const r = Math.sqrt(t * t + i * i);
    return [e, r, s];
  };
  I.lch.lab = function(n) {
    const e = n[0], t = n[1], s = n[2] / 360 * 2 * Math.PI, o = t * Math.cos(s), r = t * Math.sin(s);
    return [e, o, r];
  };
  I.rgb.ansi16 = function(n, e = null) {
    const [t, i, s] = n;
    let o = e === null ? I.rgb.hsv(n)[2] : e;
    if (o = Math.round(o / 50), o === 0)
      return 30;
    let r = 30 + (Math.round(s / 255) << 2 | Math.round(i / 255) << 1 | Math.round(t / 255));
    return o === 2 && (r += 60), r;
  };
  I.hsv.ansi16 = function(n) {
    return I.rgb.ansi16(I.hsv.rgb(n), n[2]);
  };
  I.rgb.ansi256 = function(n) {
    const e = n[0], t = n[1], i = n[2];
    return e === t && t === i ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(i / 255 * 5);
  };
  I.ansi16.rgb = function(n) {
    let e = n % 10;
    if (e === 0 || e === 7)
      return n > 50 && (e += 3.5), e = e / 10.5 * 255, [e, e, e];
    const t = (~~(n > 50) + 1) * 0.5, i = (e & 1) * t * 255, s = (e >> 1 & 1) * t * 255, o = (e >> 2 & 1) * t * 255;
    return [i, s, o];
  };
  I.ansi256.rgb = function(n) {
    if (n >= 232) {
      const o = (n - 232) * 10 + 8;
      return [o, o, o];
    }
    n -= 16;
    let e;
    const t = Math.floor(n / 36) / 5 * 255, i = Math.floor((e = n % 36) / 6) / 5 * 255, s = e % 6 / 5 * 255;
    return [t, i, s];
  };
  I.rgb.hex = function(n) {
    const t = (((Math.round(n[0]) & 255) << 16) + ((Math.round(n[1]) & 255) << 8) + (Math.round(n[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(t.length) + t;
  };
  I.hex.rgb = function(n) {
    const e = n.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!e)
      return [0, 0, 0];
    let t = e[0];
    e[0].length === 3 && (t = t.split("").map((a) => a + a).join(""));
    const i = parseInt(t, 16), s = i >> 16 & 255, o = i >> 8 & 255, r = i & 255;
    return [s, o, r];
  };
  I.rgb.hcg = function(n) {
    const e = n[0] / 255, t = n[1] / 255, i = n[2] / 255, s = Math.max(Math.max(e, t), i), o = Math.min(Math.min(e, t), i), r = s - o;
    let a, l;
    return r < 1 ? a = o / (1 - r) : a = 0, r <= 0 ? l = 0 : s === e ? l = (t - i) / r % 6 : s === t ? l = 2 + (i - e) / r : l = 4 + (e - t) / r, l /= 6, l %= 1, [l * 360, r * 100, a * 100];
  };
  I.hsl.hcg = function(n) {
    const e = n[1] / 100, t = n[2] / 100, i = t < 0.5 ? 2 * e * t : 2 * e * (1 - t);
    let s = 0;
    return i < 1 && (s = (t - 0.5 * i) / (1 - i)), [n[0], i * 100, s * 100];
  };
  I.hsv.hcg = function(n) {
    const e = n[1] / 100, t = n[2] / 100, i = e * t;
    let s = 0;
    return i < 1 && (s = (t - i) / (1 - i)), [n[0], i * 100, s * 100];
  };
  I.hcg.rgb = function(n) {
    const e = n[0] / 360, t = n[1] / 100, i = n[2] / 100;
    if (t === 0)
      return [i * 255, i * 255, i * 255];
    const s = [0, 0, 0], o = e % 1 * 6, r = o % 1, a = 1 - r;
    let l = 0;
    switch (Math.floor(o)) {
      case 0:
        s[0] = 1, s[1] = r, s[2] = 0;
        break;
      case 1:
        s[0] = a, s[1] = 1, s[2] = 0;
        break;
      case 2:
        s[0] = 0, s[1] = 1, s[2] = r;
        break;
      case 3:
        s[0] = 0, s[1] = a, s[2] = 1;
        break;
      case 4:
        s[0] = r, s[1] = 0, s[2] = 1;
        break;
      default:
        s[0] = 1, s[1] = 0, s[2] = a;
    }
    return l = (1 - t) * i, [
      (t * s[0] + l) * 255,
      (t * s[1] + l) * 255,
      (t * s[2] + l) * 255
    ];
  };
  I.hcg.hsv = function(n) {
    const e = n[1] / 100, t = n[2] / 100, i = e + t * (1 - e);
    let s = 0;
    return i > 0 && (s = e / i), [n[0], s * 100, i * 100];
  };
  I.hcg.hsl = function(n) {
    const e = n[1] / 100, i = n[2] / 100 * (1 - e) + 0.5 * e;
    let s = 0;
    return i > 0 && i < 0.5 ? s = e / (2 * i) : i >= 0.5 && i < 1 && (s = e / (2 * (1 - i))), [n[0], s * 100, i * 100];
  };
  I.hcg.hwb = function(n) {
    const e = n[1] / 100, t = n[2] / 100, i = e + t * (1 - e);
    return [n[0], (i - e) * 100, (1 - i) * 100];
  };
  I.hwb.hcg = function(n) {
    const e = n[1] / 100, i = 1 - n[2] / 100, s = i - e;
    let o = 0;
    return s < 1 && (o = (i - s) / (1 - s)), [n[0], s * 100, o * 100];
  };
  I.apple.rgb = function(n) {
    return [n[0] / 65535 * 255, n[1] / 65535 * 255, n[2] / 65535 * 255];
  };
  I.rgb.apple = function(n) {
    return [n[0] / 255 * 65535, n[1] / 255 * 65535, n[2] / 255 * 65535];
  };
  I.gray.rgb = function(n) {
    return [n[0] / 100 * 255, n[0] / 100 * 255, n[0] / 100 * 255];
  };
  I.gray.hsl = function(n) {
    return [0, 0, n[0]];
  };
  I.gray.hsv = I.gray.hsl;
  I.gray.hwb = function(n) {
    return [0, 100, n[0]];
  };
  I.gray.cmyk = function(n) {
    return [0, 0, 0, n[0]];
  };
  I.gray.lab = function(n) {
    return [n[0], 0, 0];
  };
  I.gray.hex = function(n) {
    const e = Math.round(n[0] / 100 * 255) & 255, i = ((e << 16) + (e << 8) + e).toString(16).toUpperCase();
    return "000000".substring(i.length) + i;
  };
  I.rgb.gray = function(n) {
    return [(n[0] + n[1] + n[2]) / 3 / 255 * 100];
  };
  const xo = gg;
  function vA() {
    const n = {}, e = Object.keys(xo);
    for (let t = e.length, i = 0; i < t; i++)
      n[e[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return n;
  }
  function yA(n) {
    const e = vA(), t = [n];
    for (e[n].distance = 0; t.length; ) {
      const i = t.pop(), s = Object.keys(xo[i]);
      for (let o = s.length, r = 0; r < o; r++) {
        const a = s[r], l = e[a];
        l.distance === -1 && (l.distance = e[i].distance + 1, l.parent = i, t.unshift(a));
      }
    }
    return e;
  }
  function CA(n, e) {
    return function(t) {
      return e(n(t));
    };
  }
  function kA(n, e) {
    const t = [e[n].parent, n];
    let i = xo[e[n].parent][n], s = e[n].parent;
    for (; e[s].parent; )
      t.unshift(e[s].parent), i = CA(xo[e[s].parent][s], i), s = e[s].parent;
    return i.conversion = t, i;
  }
  var TA = function(n) {
    const e = yA(n), t = {}, i = Object.keys(e);
    for (let s = i.length, o = 0; o < s; o++) {
      const r = i[o];
      e[r].parent !== null && (t[r] = kA(r, e));
    }
    return t;
  };
  const ba = gg, EA = TA, Ui = {}, AA = Object.keys(ba);
  function xA(n) {
    const e = function(...t) {
      const i = t[0];
      return i == null ? i : (i.length > 1 && (t = i), n(t));
    };
    return "conversion" in n && (e.conversion = n.conversion), e;
  }
  function SA(n) {
    const e = function(...t) {
      const i = t[0];
      if (i == null)
        return i;
      i.length > 1 && (t = i);
      const s = n(t);
      if (typeof s == "object")
        for (let o = s.length, r = 0; r < o; r++)
          s[r] = Math.round(s[r]);
      return s;
    };
    return "conversion" in n && (e.conversion = n.conversion), e;
  }
  AA.forEach((n) => {
    Ui[n] = {}, Object.defineProperty(Ui[n], "channels", { value: ba[n].channels }), Object.defineProperty(Ui[n], "labels", { value: ba[n].labels });
    const e = EA(n);
    Object.keys(e).forEach((i) => {
      const s = e[i];
      Ui[n][i] = SA(s), Ui[n][i].raw = xA(s);
    });
  });
  var pg = Ui;
  const IA = /* @__PURE__ */ hg(pg), wg = /* @__PURE__ */ Bw({
    __proto__: null,
    default: IA
  }, [pg]);
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function bg(n, e) {
    if (!n)
      return "";
    const t = _g(n);
    if (!t)
      return "";
    if (t.space === e)
      return n;
    if (!VA(t))
      return "";
    const s = wg[t.space][e];
    if (!s)
      return "";
    const o = s(t.space === "hex" ? t.hexValue : t.values);
    return LA(o, e);
  }
  function PA(n) {
    if (!n)
      return "";
    const e = _g(n);
    return e ? e.space === "hex" ? e.hexValue : bg(n, "hex") : "#000";
  }
  function RA(n, e) {
    customElements.get(n) === void 0 && customElements.define(n, e);
  }
  function LA(n, e) {
    switch (e) {
      case "hex":
        return `#${n}`;
      case "rgb":
        return `rgb( ${n[0]}, ${n[1]}, ${n[2]} )`;
      case "hsl":
        return `hsl( ${n[0]}, ${n[1]}%, ${n[2]}% )`;
      case "hwb":
        return `hwb( ${n[0]}, ${n[1]}, ${n[2]} )`;
      case "lab":
        return `lab( ${n[0]}% ${n[1]} ${n[2]} )`;
      case "lch":
        return `lch( ${n[0]}% ${n[1]} ${n[2]} )`;
      default:
        return "";
    }
  }
  function _g(n) {
    if (n.startsWith("#")) {
      const t = Wu(n);
      return {
        space: "hex",
        values: t.values,
        hexValue: n,
        alpha: t.alpha
      };
    }
    const e = Wu(n);
    return e.space ? e : null;
  }
  function VA(n) {
    return Object.keys(wg).includes(n.space);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class he extends T {
    /**
     * Creates an instance of the labeled field view class using a provided creator function
     * that provides the view to be labeled.
     *
     * @param locale The locale instance.
     * @param viewCreator A function that returns a {@link module:ui/view~View}
     * that will be labeled. The following arguments are passed to the creator function:
     *
     * * an instance of the `LabeledFieldView` to allow binding observable properties,
     * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
     * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
     */
    constructor(e, t) {
      super(e);
      const i = `ck-labeled-field-view-${Ze()}`, s = `ck-labeled-field-view-status-${Ze()}`;
      this.fieldView = t(this, i, s), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(i), this.statusView = this._createStatusView(s), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (r, a) => r || a);
      const o = this.bindTemplate;
      this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-labeled-field-view",
            o.to("class"),
            o.if("isEnabled", "ck-disabled", (r) => !r),
            o.if("isEmpty", "ck-labeled-field-view_empty"),
            o.if("isFocused", "ck-labeled-field-view_focused"),
            o.if("placeholder", "ck-labeled-field-view_placeholder"),
            o.if("errorText", "ck-error")
          ]
        },
        children: [
          {
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view__input-wrapper"
              ]
            },
            children: this.fieldWrapperChildren
          },
          this.statusView
        ]
      });
    }
    /**
     * Creates label view class instance and bind with view.
     *
     * @param id Unique id to set as labelView#for attribute.
     */
    _createLabelView(e) {
      const t = new Fe(this.locale);
      return t.for = e, t.bind("text").to(this, "label"), t;
    }
    /**
     * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
     * next to the {@link #fieldView}. See {@link #_statusText}.
     *
     * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
     * `aria-describedby` attribute.
     */
    _createStatusView(e) {
      const t = new T(this.locale), i = this.bindTemplate;
      return t.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-labeled-field-view__status",
            i.if("errorText", "ck-labeled-field-view__status_error"),
            i.if("_statusText", "ck-hidden", (s) => !s)
          ],
          id: e,
          role: i.if("errorText", "alert")
        },
        children: [
          {
            text: i.to("_statusText")
          }
        ]
      }), t;
    }
    /**
     * Focuses the {@link #fieldView}.
     */
    focus(e) {
      this.fieldView.focus(e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class MA extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("tabIndex", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.set("ariaLabel", void 0), this.focusTracker = new Q(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0);
      const t = this.bindTemplate;
      this.setTemplate({
        tag: "input",
        attributes: {
          class: [
            "ck",
            "ck-input",
            t.if("isFocused", "ck-input_focused"),
            t.if("isEmpty", "ck-input-text_empty"),
            t.if("hasError", "ck-error")
          ],
          id: t.to("id"),
          placeholder: t.to("placeholder"),
          tabindex: t.to("tabIndex"),
          readonly: t.to("isReadOnly"),
          "aria-invalid": t.if("hasError", !0),
          "aria-describedby": t.to("ariaDescribedById"),
          "aria-label": t.to("ariaLabel")
        },
        on: {
          input: t.to((...i) => {
            this.fire("input", ...i), this._updateIsEmpty();
          }),
          change: t.to(this._updateIsEmpty.bind(this))
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e, t, i) => {
        this._setDomElementValue(i), this._updateIsEmpty();
      });
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy();
    }
    /**
     * Moves the focus to the input and selects the value.
     */
    select() {
      this.element.select();
    }
    /**
     * Focuses the input.
     */
    focus() {
      this.element.focus();
    }
    /**
     * Resets the value of the input
     */
    reset() {
      this.value = this.element.value = "", this._updateIsEmpty();
    }
    /**
     * Updates the {@link #isEmpty} property value on demand.
     */
    _updateIsEmpty() {
      this.isEmpty = BA(this.element);
    }
    /**
     * Sets the `value` property of the {@link #element DOM element} on demand.
     */
    _setDomElementValue(e) {
      this.element.value = !e && e !== 0 ? "" : e;
    }
  }
  function BA(n) {
    return !n.value;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class OA extends MA {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.set("inputMode", "text");
      const t = this.bindTemplate;
      this.extendTemplate({
        attributes: {
          inputmode: t.to("inputMode")
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class vg extends OA {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.extendTemplate({
        attributes: {
          type: "text",
          class: [
            "ck-input-text"
          ]
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class NA extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-reset",
            "ck-dropdown__panel",
            t.to("position", (i) => `ck-dropdown__panel_${i}`),
            t.if("isVisible", "ck-dropdown__panel-visible")
          ],
          tabindex: "-1"
        },
        children: this.children,
        on: {
          // Drag and drop in the panel should not break the selection in the editor.
          // https://github.com/ckeditor/ckeditor5-ui/issues/228
          selectstart: t.to((i) => {
            i.target.tagName.toLocaleLowerCase() !== "input" && i.preventDefault();
          })
        }
      });
    }
    /**
     * Focuses the first view in the {@link #children} collection.
     *
     * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
     */
    focus() {
      if (this.children.length) {
        const e = this.children.first;
        typeof e.focus == "function" ? e.focus() : z("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
      }
    }
    /**
     * Focuses the view element or last item in view collection on opening dropdown's panel.
     *
     * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
     */
    focusLast() {
      if (this.children.length) {
        const e = this.children.last;
        typeof e.focusLast == "function" ? e.focusLast() : e.focus();
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Qi extends T {
    /**
     * Creates an instance of the dropdown.
     *
     * Also see {@link #render}.
     *
     * @param locale The localization services instance.
     */
    constructor(e, t, i) {
      super(e);
      const s = this.bindTemplate;
      this.buttonView = t, this.panelView = i, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new ne(), this.focusTracker = new Q(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-dropdown",
            s.to("class"),
            s.if("isEnabled", "ck-disabled", (o) => !o)
          ],
          id: s.to("id"),
          "aria-describedby": s.to("ariaDescribedById")
        },
        children: [
          t,
          i
        ]
      }), t.extendTemplate({
        attributes: {
          class: [
            "ck-dropdown__button"
          ],
          "data-cke-tooltip-disabled": s.to("isOpen")
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
        this.isOpen = !this.isOpen;
      }), this.on("change:isOpen", (t, i, s) => {
        if (s)
          if (this.panelPosition === "auto") {
            const o = Qi._getOptimalPosition({
              element: this.panelView.element,
              target: this.buttonView.element,
              fitInViewport: !0,
              positions: this._panelPositions
            });
            this.panelView.position = o ? o.name : this._panelPositions[0].name;
          } else
            this.panelView.position = this.panelPosition;
      }), this.keystrokes.listenTo(this.element);
      const e = (t, i) => {
        this.isOpen && (this.isOpen = !1, i());
      };
      this.keystrokes.set("arrowdown", (t, i) => {
        this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, i());
      }), this.keystrokes.set("arrowright", (t, i) => {
        this.isOpen && i();
      }), this.keystrokes.set("arrowleft", e), this.keystrokes.set("esc", e);
    }
    /**
     * Focuses the {@link #buttonView}.
     */
    focus() {
      this.buttonView.focus();
    }
    /**
     * Returns {@link #panelView panel} positions to be used by the
     * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
     * utility considering the direction of the language the UI of the editor is displayed in.
     */
    get _panelPositions() {
      const { south: e, north: t, southEast: i, southWest: s, northEast: o, northWest: r, southMiddleEast: a, southMiddleWest: l, northMiddleEast: c, northMiddleWest: u } = Qi.defaultPanelPositions;
      return this.locale.uiLanguageDirection !== "rtl" ? [
        i,
        s,
        a,
        l,
        e,
        o,
        r,
        c,
        u,
        t
      ] : [
        s,
        i,
        l,
        a,
        e,
        r,
        o,
        u,
        c,
        t
      ];
    }
  }
  Qi.defaultPanelPositions = {
    south: (n, e) => ({
      top: n.bottom,
      left: n.left - (e.width - n.width) / 2,
      name: "s"
    }),
    southEast: (n) => ({
      top: n.bottom,
      left: n.left,
      name: "se"
    }),
    southWest: (n, e) => ({
      top: n.bottom,
      left: n.left - e.width + n.width,
      name: "sw"
    }),
    southMiddleEast: (n, e) => ({
      top: n.bottom,
      left: n.left - (e.width - n.width) / 4,
      name: "sme"
    }),
    southMiddleWest: (n, e) => ({
      top: n.bottom,
      left: n.left - (e.width - n.width) * 3 / 4,
      name: "smw"
    }),
    north: (n, e) => ({
      top: n.top - e.height,
      left: n.left - (e.width - n.width) / 2,
      name: "n"
    }),
    northEast: (n, e) => ({
      top: n.top - e.height,
      left: n.left,
      name: "ne"
    }),
    northWest: (n, e) => ({
      top: n.top - e.height,
      left: n.left - e.width + n.width,
      name: "nw"
    }),
    northMiddleEast: (n, e) => ({
      top: n.top - e.height,
      left: n.left - (e.width - n.width) / 4,
      name: "nme"
    }),
    northMiddleWest: (n, e) => ({
      top: n.top - e.height,
      left: n.left - (e.width - n.width) * 3 / 4,
      name: "nmw"
    })
  };
  Qi._getOptimalPosition = Ko;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Sl extends P {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.arrowView = this._createArrowView(), this.extendTemplate({
        attributes: {
          "aria-haspopup": !0,
          "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t))
        }
      }), this.delegate("execute").to(this, "open");
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.children.add(this.arrowView);
    }
    /**
     * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
     */
    _createArrowView() {
      const e = new dt();
      return e.content = nr, e.extendTemplate({
        attributes: {
          class: "ck-dropdown__arrow"
        }
      }), e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class _e extends G() {
    /**
     * Creates an instance of the focus cycler utility.
     *
     * @param options Configuration options.
     */
    constructor(e) {
      if (super(), this.focusables = e.focusables, this.focusTracker = e.focusTracker, this.keystrokeHandler = e.keystrokeHandler, this.actions = e.actions, e.actions && e.keystrokeHandler)
        for (const t in e.actions) {
          let i = e.actions[t];
          typeof i == "string" && (i = [i]);
          for (const s of i)
            e.keystrokeHandler.set(s, (o, r) => {
              this[t](), r();
            });
        }
      this.on("forwardCycle", () => this.focusFirst(), { priority: "low" }), this.on("backwardCycle", () => this.focusLast(), { priority: "low" });
    }
    /**
     * Returns the first focusable view in {@link #focusables}.
     * Returns `null` if there is none.
     *
     * **Note**: Hidden views (e.g. with `display: none`) are ignored.
     */
    get first() {
      return this.focusables.find(Rr) || null;
    }
    /**
     * Returns the last focusable view in {@link #focusables}.
     * Returns `null` if there is none.
     *
     * **Note**: Hidden views (e.g. with `display: none`) are ignored.
     */
    get last() {
      return this.focusables.filter(Rr).slice(-1)[0] || null;
    }
    /**
     * Returns the next focusable view in {@link #focusables} based on {@link #current}.
     * Returns `null` if there is none.
     *
     * **Note**: Hidden views (e.g. with `display: none`) are ignored.
     */
    get next() {
      return this._getDomFocusableItem(1);
    }
    /**
     * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
     * Returns `null` if there is none.
     *
     * **Note**: Hidden views (e.g. with `display: none`) are ignored.
     */
    get previous() {
      return this._getDomFocusableItem(-1);
    }
    /**
     * An index of the view in the {@link #focusables} which is focused according
     * to {@link #focusTracker}. Returns `null` when there is no such view.
     */
    get current() {
      let e = null;
      return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t, i) => {
        const s = t.element === this.focusTracker.focusedElement;
        return s && (e = i), s;
      }), e);
    }
    /**
     * Focuses the {@link #first} item in {@link #focusables}.
     *
     * **Note**: Hidden views (e.g. with `display: none`) are ignored.
     */
    focusFirst() {
      this._focus(this.first, 1);
    }
    /**
     * Focuses the {@link #last} item in {@link #focusables}.
     *
     * **Note**: Hidden views (e.g. with `display: none`) are ignored.
     */
    focusLast() {
      this._focus(this.last, -1);
    }
    /**
     * Focuses the {@link #next} item in {@link #focusables}.
     *
     * **Note**: Hidden views (e.g. with `display: none`) are ignored.
     */
    focusNext() {
      const e = this.next;
      if (e && this.focusables.getIndex(e) === this.current) {
        this.fire("forwardCycle");
        return;
      }
      e === this.first ? this.fire("forwardCycle") : this._focus(e, 1);
    }
    /**
     * Focuses the {@link #previous} item in {@link #focusables}.
     *
     * **Note**: Hidden views (e.g. with `display: none`) are ignored.
     */
    focusPrevious() {
      const e = this.previous;
      if (e && this.focusables.getIndex(e) === this.current) {
        this.fire("backwardCycle");
        return;
      }
      e === this.last ? this.fire("backwardCycle") : this._focus(e, -1);
    }
    /**
     * Focuses the given view if it exists.
     *
     * @param view The view to be focused
     * @param direction The direction of the focus if the view has focusable children.
     * @returns
     */
    _focus(e, t) {
      e && this.focusTracker.focusedElement !== e.element && e.focus(t);
    }
    /**
     * Returns the next or previous focusable view in {@link #focusables} with respect
     * to {@link #current}.
     *
     * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
     */
    _getDomFocusableItem(e) {
      const t = this.focusables.length;
      if (!t)
        return null;
      const i = this.current;
      if (i === null)
        return this[e === 1 ? "first" : "last"];
      let s = this.focusables.get(i), o = (i + t + e) % t;
      do {
        const r = this.focusables.get(o);
        if (Rr(r)) {
          s = r;
          break;
        }
        o = (o + t + e) % t;
      } while (o !== i);
      return s;
    }
  }
  function Rr(n) {
    return ws(n) && mi(n.element);
  }
  function ws(n) {
    return "focus" in n && typeof n.focus == "function";
  }
  function DA(n) {
    return ws(n) && "focusCycler" in n && n.focusCycler instanceof _e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class yg extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-toolbar__separator"
          ]
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class FA extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-toolbar__line-break"
          ]
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function zA(n) {
    return n.bindTemplate.to((e) => {
      e.target === n.element && e.preventDefault();
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Cg(n) {
    if (Array.isArray(n))
      return {
        items: n,
        removeItems: []
      };
    const e = {
      items: [],
      removeItems: []
    };
    return n ? {
      ...e,
      ...n
    } : e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const { threeVerticalDots: kg } = x, UA = {
    alignLeft: x.alignLeft,
    bold: x.bold,
    importExport: x.importExport,
    paragraph: x.paragraph,
    plus: x.plus,
    text: x.text,
    threeVerticalDots: x.threeVerticalDots,
    pilcrow: x.pilcrow,
    dragIndicator: x.dragIndicator
  };
  class en extends T {
    /**
     * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
     *
     * Also see {@link #render}.
     *
     * @param locale The localization services instance.
     * @param options Configuration options of the toolbar.
     */
    constructor(e, t) {
      super(e);
      const i = this.bindTemplate, s = this.t;
      this.options = t || {}, this.set("ariaLabel", s("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Q(), this.keystrokes = new ne(), this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new HA(e), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
      const o = e.uiLanguageDirection === "rtl";
      this._focusCycler = new _e({
        focusables: this.focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate toolbar items backwards using the arrow[left,up] keys.
          focusPrevious: [o ? "arrowright" : "arrowleft", "arrowup"],
          // Navigate toolbar items forwards using the arrow[right,down] keys.
          focusNext: [o ? "arrowleft" : "arrowright", "arrowdown"]
        }
      });
      const r = [
        "ck",
        "ck-toolbar",
        i.to("class"),
        i.if("isCompact", "ck-toolbar_compact")
      ];
      this.options.shouldGroupWhenFull && this.options.isFloating && r.push("ck-toolbar_floating"), this.setTemplate({
        tag: "div",
        attributes: {
          class: r,
          role: "toolbar",
          "aria-label": i.to("ariaLabel"),
          style: {
            maxWidth: i.to("maxWidth")
          },
          tabindex: -1
        },
        children: this.children,
        on: {
          // https://github.com/ckeditor/ckeditor5-ui/issues/206
          mousedown: zA(this)
        }
      }), this._behavior = this.options.shouldGroupWhenFull ? new WA(this) : new $A(this);
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.focusTracker.add(this.element);
      for (const e of this.items)
        this.focusTracker.add(e.element);
      this.items.on("add", (e, t) => {
        this.focusTracker.add(t.element);
      }), this.items.on("remove", (e, t) => {
        this.focusTracker.remove(t.element);
      }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
    }
    /**
     * Focuses the first focusable in {@link #focusables}.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the last focusable in {@link #focusables}.
     */
    focusLast() {
      this._focusCycler.focusLast();
    }
    /**
     * A utility that expands the plain toolbar configuration into
     * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
     *
     * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
     * @param factory A factory producing toolbar items.
     * @param removeItems An array of items names to be removed from the configuration. When present, applies
     * to this toolbar and all nested ones as well.
     */
    fillFromConfig(e, t, i) {
      this.items.addMany(this._buildItemsFromConfig(e, t, i));
    }
    /**
     * A utility that expands the plain toolbar configuration into a list of view items using a given component factory.
     *
     * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
     * @param factory A factory producing toolbar items.
     * @param removeItems An array of items names to be removed from the configuration. When present, applies
     * to this toolbar and all nested ones as well.
     */
    _buildItemsFromConfig(e, t, i) {
      const s = Cg(e), o = i || s.removeItems;
      return this._cleanItemsConfiguration(s.items, t, o).map((a) => J(a) ? this._createNestedToolbarDropdown(a, t, o) : a === "|" ? new yg() : a === "-" ? new FA() : t.create(a)).filter((a) => !!a);
    }
    /**
     * Cleans up the {@link module:ui/toolbar/toolbarview~ToolbarView#items} of the toolbar by removing unwanted items and
     * duplicated (obsolete) separators or line breaks.
     *
     * @param items The toolbar items configuration.
     * @param factory A factory producing toolbar items.
     * @param removeItems An array of items names to be removed from the configuration.
     * @returns Items after the clean-up.
     */
    _cleanItemsConfiguration(e, t, i) {
      const s = e.filter((o, r, a) => o === "|" ? !0 : i.indexOf(o) !== -1 ? !1 : o === "-" ? this.options.shouldGroupWhenFull ? (z("toolbarview-line-break-ignored-when-grouping-items", a), !1) : !0 : !J(o) && !t.has(o) ? (z("toolbarview-item-unavailable", { item: o }), !1) : !0);
      return this._cleanSeparatorsAndLineBreaks(s);
    }
    /**
     * Remove leading, trailing, and duplicated separators (`-` and `|`).
     *
     * @returns Toolbar items after the separator and line break clean-up.
     */
    _cleanSeparatorsAndLineBreaks(e) {
      const t = (r) => r !== "-" && r !== "|", i = e.length, s = e.findIndex(t);
      if (s === -1)
        return [];
      const o = i - e.slice().reverse().findIndex(t);
      return e.slice(s, o).filter((r, a, l) => t(r) ? !0 : !(a > 0 && l[a - 1] === r));
    }
    /**
     * Creates a user-defined dropdown containing a toolbar with items.
     *
     * @param definition A definition of the nested toolbar dropdown.
     * @param definition.label A label of the dropdown.
     * @param definition.icon An icon of the drop-down. One of 'bold', 'plus', 'text', 'importExport', 'alignLeft',
     * 'paragraph' or an SVG string. When `false` is passed, no icon will be used.
     * @param definition.withText When set `true`, the label of the dropdown will be visible. See
     * {@link module:ui/button/buttonview~ButtonView#withText} to learn more.
     * @param definition.tooltip A tooltip of the dropdown button. See
     * {@link module:ui/button/buttonview~ButtonView#tooltip} to learn more. Defaults to `true`.
     * @param componentFactory Component factory used to create items
     * of the nested toolbar.
     */
    _createNestedToolbarDropdown(e, t, i) {
      let { label: s, icon: o, items: r, tooltip: a = !0, withText: l = !1 } = e;
      if (r = this._cleanItemsConfiguration(r, t, i), !r.length)
        return null;
      const c = this.locale, u = we(c);
      return s || z("toolbarview-nested-toolbar-dropdown-missing-label", e), u.class = "ck-toolbar__nested-toolbar-dropdown", u.buttonView.set({
        label: s,
        tooltip: a,
        withText: !!l
      }), o !== !1 ? u.buttonView.icon = UA[o] || o || kg : u.buttonView.withText = !0, or(u, () => u.toolbarView._buildItemsFromConfig(r, t, i)), u;
    }
  }
  class HA extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.children = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-toolbar__items"
          ]
        },
        children: this.children
      });
    }
  }
  class $A {
    /**
     * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
     * behavior.
     *
     * @param view An instance of the toolbar that this behavior is added to.
     */
    constructor(e) {
      const t = e.bindTemplate;
      e.set("isVertical", !1), e.itemsView.children.bindTo(e.items).using((i) => i), e.focusables.bindTo(e.items).using((i) => ws(i) ? i : null), e.extendTemplate({
        attributes: {
          class: [
            // When vertical, the toolbar has an additional CSS class.
            t.if("isVertical", "ck-toolbar_vertical")
          ]
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
    }
    /**
     * @inheritDoc
     */
    destroy() {
    }
  }
  class WA {
    /**
     * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
     * behavior.
     *
     * @param view An instance of the toolbar that this behavior is added to.
     */
    constructor(e) {
      this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, this.view = e, this.viewChildren = e.children, this.viewFocusables = e.focusables, this.viewItemsView = e.itemsView, this.viewFocusTracker = e.focusTracker, this.viewLocale = e.locale, this.ungroupedItems = e.createCollection(), this.groupedItems = e.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), e.itemsView.children.bindTo(this.ungroupedItems).using((t) => t), this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this)), e.children.on("change", this._updateFocusCyclableItems.bind(this)), e.items.on("change", (t, i) => {
        const s = i.index, o = Array.from(i.added);
        for (const r of i.removed)
          s >= this.ungroupedItems.length ? this.groupedItems.remove(r) : this.ungroupedItems.remove(r);
        for (let r = s; r < s + o.length; r++) {
          const a = o[r - s];
          r > this.ungroupedItems.length ? this.groupedItems.add(a, r - this.ungroupedItems.length) : this.ungroupedItems.add(a, r);
        }
        this._updateGrouping();
      }), e.extendTemplate({
        attributes: {
          class: [
            // To group items dynamically, the toolbar needs a dedicated CSS class.
            "ck-toolbar_grouping"
          ]
        }
      });
    }
    /**
     * Enables dynamic items grouping based on the dimensions of the toolbar.
     *
     * @param view An instance of the toolbar that this behavior is added to.
     */
    render(e) {
      this.viewElement = e.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e);
    }
    /**
     * Cleans up the internals used by this behavior.
     */
    destroy() {
      this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
    }
    /**
     * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
     * and it will move them to the {@link #groupedItems} when it happens.
     *
     * At the same time, it will also check if there is enough space in the toolbar for the first of the
     * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
     * without the toolbar wrapping.
     */
    _updateGrouping() {
      if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
        return;
      if (!mi(this.viewElement)) {
        this.shouldUpdateGroupingOnNextResize = !0;
        return;
      }
      const e = this.groupedItems.length;
      let t;
      for (; this._areItemsOverflowing; )
        this._groupLastItem(), t = !0;
      if (!t && this.groupedItems.length) {
        for (; this.groupedItems.length && !this._areItemsOverflowing; )
          this._ungroupFirstItem();
        this._areItemsOverflowing && this._groupLastItem();
      }
      this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate");
    }
    /**
     * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
     * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
     */
    get _areItemsOverflowing() {
      if (!this.ungroupedItems.length)
        return !1;
      const e = this.viewElement, t = this.viewLocale.uiLanguageDirection, i = new O(e.lastChild), s = new O(e);
      if (!this.cachedPadding) {
        const o = E.window.getComputedStyle(e), r = t === "ltr" ? "paddingRight" : "paddingLeft";
        this.cachedPadding = Number.parseInt(o[r]);
      }
      return t === "ltr" ? i.right > s.right - this.cachedPadding : i.left < s.left + this.cachedPadding;
    }
    /**
     * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
     * upon resize when there is little space available. Instead, the toolbar items are moved to the
     * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
     *
     * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
     * them in the dropdown if necessary. It will also observe the browser window for size changes in
     * the future and respond to them by grouping more items or reverting already grouped back, depending
     * on the visual space available.
     */
    _enableGroupingOnResize() {
      let e;
      this.resizeObserver = new Y(this.viewElement, (t) => {
        (!e || e !== t.contentRect.width || this.shouldUpdateGroupingOnNextResize) && (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), e = t.contentRect.width);
      }), this._updateGrouping();
    }
    /**
     * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
     * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
     */
    _enableGroupingOnMaxWidthChange(e) {
      e.on("change:maxWidth", () => {
        this._updateGrouping();
      });
    }
    /**
     * When called, it will remove the last item from {@link #ungroupedItems} and move it back
     * to the {@link #groupedItems} collection.
     *
     * The opposite of {@link #_ungroupFirstItem}.
     */
    _groupLastItem() {
      this.groupedItems.length || (this.viewChildren.add(new yg()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
    }
    /**
     * Moves the very first item belonging to {@link #groupedItems} back
     * to the {@link #ungroupedItems} collection.
     *
     * The opposite of {@link #_groupLastItem}.
     */
    _ungroupFirstItem() {
      this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
    }
    /**
     * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
     * collection when there is not enough space in the toolbar to display all items in a single row.
     */
    _createGroupedItemsDropdown() {
      const e = this.viewLocale, t = e.t, i = we(e);
      return i.class = "ck-toolbar__grouped-dropdown", i.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se", or(i, this.groupedItems), i.buttonView.set({
        label: t("Show more items"),
        tooltip: !0,
        tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw",
        icon: kg
      }), i;
    }
    /**
     * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focus–cyclable items}
     * collection so it represents the up–to–date state of the UI from the perspective of the user.
     *
     * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
     * it must be subject to focus cycling in the toolbar.
     *
     * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
     * to learn more about the purpose of this method.
     */
    _updateFocusCyclableItems() {
      this.viewFocusables.clear(), this.ungroupedItems.map((e) => {
        ws(e) && this.viewFocusables.add(e);
      }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class tn extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({
        tag: "li",
        attributes: {
          class: [
            "ck",
            "ck-list__item",
            t.if("isVisible", "ck-hidden", (i) => !i)
          ],
          role: "presentation"
        },
        children: this.children
      });
    }
    /**
     * Focuses the list item.
     */
    focus() {
      this.children.first && this.children.first.focus();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Il extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.setTemplate({
        tag: "li",
        attributes: {
          class: [
            "ck",
            "ck-list__separator"
          ]
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ao extends T {
    /**
     * Creates an instance of the list item group view class.
     *
     * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
     * @param labelView The instance of the group's label. If not provided, an instance of
     * {@link module:ui/label/labelview~LabelView} is used.
     */
    constructor(e, t = new Fe()) {
      super(e);
      const i = this.bindTemplate, s = new Pl(e);
      this.set({
        label: "",
        isVisible: !0
      }), this.labelView = t, this.labelView.bind("text").to(this, "label"), this.children = this.createCollection(), this.children.addMany([this.labelView, s]), s.set({
        role: "group",
        ariaLabelledBy: t.id
      }), s.focusTracker.destroy(), s.keystrokes.destroy(), this.items = s.items, this.setTemplate({
        tag: "li",
        attributes: {
          role: "presentation",
          class: [
            "ck",
            "ck-list__group",
            i.if("isVisible", "ck-hidden", (o) => !o)
          ]
        },
        children: this.children
      });
    }
    /**
     * Focuses the list item (which is not a separator).
     */
    focus() {
      if (this.items) {
        const e = this.items.find((t) => !(t instanceof Il));
        e && e.focus();
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Pl extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._listItemGroupToChangeListeners = /* @__PURE__ */ new WeakMap();
      const t = this.bindTemplate;
      this.focusables = new ke(), this.items = this.createCollection(), this.focusTracker = new Q(), this.keystrokes = new ne(), this._focusCycler = new _e({
        focusables: this.focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate list items backwards using the arrowup key.
          focusPrevious: "arrowup",
          // Navigate toolbar items forwards using the arrowdown key.
          focusNext: "arrowdown"
        }
      }), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", void 0), this.set("role", void 0), this.setTemplate({
        tag: "ul",
        attributes: {
          class: [
            "ck",
            "ck-reset",
            "ck-list"
          ],
          role: t.to("role"),
          "aria-label": t.to("ariaLabel"),
          "aria-labelledby": t.to("ariaLabelledBy")
        },
        children: this.items
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render();
      for (const e of this.items)
        e instanceof ao ? this._registerFocusableItemsGroup(e) : e instanceof tn && this._registerFocusableListItem(e);
      this.items.on("change", (e, t) => {
        for (const i of t.removed)
          i instanceof ao ? this._deregisterFocusableItemsGroup(i) : i instanceof tn && this._deregisterFocusableListItem(i);
        for (const i of Array.from(t.added).reverse())
          i instanceof ao ? this._registerFocusableItemsGroup(i, t.index) : this._registerFocusableListItem(i, t.index);
      }), this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the first focusable in {@link #items}.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the first focusable in {@link #items}.
     */
    focusFirst() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the last focusable in {@link #items}.
     */
    focusLast() {
      this._focusCycler.focusLast();
    }
    /**
     * Registers a list item view in the focus tracker.
     *
     * @param item The list item view to be registered.
     * @param index Index of the list item view in the {@link #items} collection. If not specified, the item will be added at the end.
     */
    _registerFocusableListItem(e, t) {
      this.focusTracker.add(e.element), this.focusables.add(e, t);
    }
    /**
     * Removes a list item view from the focus tracker.
     *
     * @param item The list item view to be removed.
     */
    _deregisterFocusableListItem(e) {
      this.focusTracker.remove(e.element), this.focusables.remove(e);
    }
    /**
     * Gets a callback that will be called when the `items` collection of a {@link module:ui/list/listitemgroupview~ListItemGroupView}
     * change.
     *
     * @param groupView The group view for which the callback will be created.
     * @returns The callback function to be used for the items `change` event listener in a group.
     */
    _getOnGroupItemsChangeCallback(e) {
      return (t, i) => {
        for (const s of i.removed)
          this._deregisterFocusableListItem(s);
        for (const s of Array.from(i.added).reverse())
          this._registerFocusableListItem(s, this.items.getIndex(e) + i.index);
      };
    }
    /**
     * Registers a list item group view (and its children) in the focus tracker.
     *
     * @param groupView A group view to be registered.
     * @param groupIndex Index of the group view in the {@link #items} collection. If not specified, the group will be added at the end.
     */
    _registerFocusableItemsGroup(e, t) {
      Array.from(e.items).forEach((s, o) => {
        const r = typeof t != "undefined" ? t + o : void 0;
        this._registerFocusableListItem(s, r);
      });
      const i = this._getOnGroupItemsChangeCallback(e);
      this._listItemGroupToChangeListeners.set(e, i), e.items.on("change", i);
    }
    /**
     * Removes a list item group view (and its children) from the focus tracker.
     *
     * @param groupView The group view to be removed.
     */
    _deregisterFocusableItemsGroup(e) {
      for (const t of e.items)
        this._deregisterFocusableListItem(t);
      e.items.off("change", this._listItemGroupToChangeListeners.get(e)), this._listItemGroupToChangeListeners.delete(e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class sr extends T {
    /**
     * @inheritDoc
     */
    constructor(e, t) {
      super(e);
      const i = this.bindTemplate;
      this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(t), this.arrowView = this._createArrowView(), this.keystrokes = new ne(), this.focusTracker = new Q(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-splitbutton",
            i.to("class"),
            i.if("isVisible", "ck-hidden", (s) => !s),
            this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
          ]
        },
        children: this.children
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e, t) => {
        this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t());
      }), this.keystrokes.set("arrowleft", (e, t) => {
        this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t());
      });
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the {@link module:ui/button/buttonview~ButtonView#element} of the action part of split button.
     */
    focus() {
      this.actionView.focus();
    }
    /**
     * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
     * attributes.
     */
    _createActionView(e) {
      const t = e || new P();
      return e || t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t.extendTemplate({
        attributes: {
          class: "ck-splitbutton__action"
        }
      }), t.delegate("execute").to(this), t;
    }
    /**
     * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
     * attributes.
     */
    _createArrowView() {
      const e = new P(), t = e.bindTemplate;
      return e.icon = nr, e.extendTemplate({
        attributes: {
          class: [
            "ck-splitbutton__arrow"
          ],
          "data-cke-tooltip-disabled": t.to("isOn"),
          "aria-haspopup": !0,
          "aria-expanded": t.to("isOn", (i) => String(i))
        }
      }), e.bind("isEnabled").to(this), e.bind("label").to(this), e.bind("tooltip").to(this), e.delegate("execute").to(this, "open"), e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function we(n, e = Sl) {
    const t = typeof e == "function" ? new e(n) : e, i = new NA(n), s = new Qi(n, t, i);
    return t.bind("isEnabled").to(s), t instanceof sr ? t.arrowView.bind("isOn").to(s, "isOpen") : t.bind("isOn").to(s, "isOpen"), qA(s), s;
  }
  function or(n, e, t = {}) {
    n.extendTemplate({
      attributes: {
        class: ["ck-toolbar-dropdown"]
      }
    }), n.isOpen ? qu(n, e, t) : n.once("change:isOpen", () => qu(n, e, t), { priority: "highest" }), t.enableActiveItemFocusOnDropdownOpen && Rl(n, () => n.toolbarView.items.find((i) => i.isOn));
  }
  function qu(n, e, t) {
    const i = n.locale, s = i.t, o = n.toolbarView = new en(i), r = typeof e == "function" ? e() : e;
    o.ariaLabel = t.ariaLabel || s("Dropdown toolbar"), t.maxWidth && (o.maxWidth = t.maxWidth), t.class && (o.class = t.class), t.isCompact && (o.isCompact = t.isCompact), t.isVertical && (o.isVertical = !0), r instanceof ke ? o.items.bindTo(r).using((a) => a) : o.items.addMany(r), n.panelView.children.add(o), o.items.delegate("execute").to(n);
  }
  function Kt(n, e, t = {}) {
    n.isOpen ? Gu(n, e, t) : n.once("change:isOpen", () => Gu(n, e, t), { priority: "highest" }), Rl(n, () => n.listView.items.find((i) => i instanceof tn ? i.children.first.isOn : !1));
  }
  function Gu(n, e, t) {
    const i = n.locale, s = n.listView = new Pl(i), o = typeof e == "function" ? e() : e;
    s.ariaLabel = t.ariaLabel, s.role = t.role, Tg(n, s.items, o, i), n.panelView.children.add(s), s.items.delegate("execute").to(n);
  }
  function Rl(n, e) {
    n.on("change:isOpen", () => {
      if (!n.isOpen)
        return;
      const t = e();
      t && (typeof t.focus == "function" ? t.focus() : z("ui-dropdown-focus-child-on-open-child-missing-focus", { view: t }));
    }, { priority: Ut.low - 10 });
  }
  function qA(n) {
    GA(n), jA(n), KA(n), ZA(n), JA(n), XA(n);
  }
  function GA(n) {
    n.on("render", () => {
      rn({
        emitter: n,
        activator: () => n.isOpen,
        callback: () => {
          n.isOpen = !1;
        },
        contextElements: () => [
          n.element,
          ...n.focusTracker._elements
        ]
      });
    });
  }
  function jA(n) {
    n.on("execute", (e) => {
      e.source instanceof ir || (n.isOpen = !1);
    });
  }
  function KA(n) {
    n.focusTracker.on("change:isFocused", (e, t, i) => {
      n.isOpen && !i && (n.isOpen = !1);
    });
  }
  function ZA(n) {
    n.keystrokes.set("arrowdown", (e, t) => {
      n.isOpen && (n.panelView.focus(), t());
    }), n.keystrokes.set("arrowup", (e, t) => {
      n.isOpen && (n.panelView.focusLast(), t());
    });
  }
  function JA(n) {
    n.on("change:isOpen", (e, t, i) => {
      if (i)
        return;
      const s = n.panelView.element;
      s && s.contains(E.document.activeElement) && n.buttonView.focus();
    });
  }
  function XA(n) {
    n.on("change:isOpen", (e, t, i) => {
      i && n.panelView.focus();
    }, { priority: "low" });
  }
  function Tg(n, e, t, i) {
    e.bindTo(t).using((s) => {
      if (s.type === "separator")
        return new Il(i);
      if (s.type === "group") {
        const o = new ao(i);
        return o.set({ label: s.label }), Tg(n, o.items, s.items, i), o.items.delegate("execute").to(n), o;
      } else if (s.type === "button" || s.type === "switchbutton") {
        const o = new tn(i);
        let r;
        return s.type === "button" ? (r = new P(i), r.bind("ariaChecked").to(r, "isOn")) : r = new ir(i), r.bind(...Object.keys(s.model)).to(s.model), r.delegate("execute").to(o), o.children.add(r), o;
      }
      return null;
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const ze = (n, e, t) => {
    const i = new vg(n.locale);
    return i.set({
      id: e,
      ariaDescribedById: t
    }), i.bind("isReadOnly").to(n, "isEnabled", (s) => !s), i.bind("hasError").to(n, "errorText", (s) => !!s), i.on("input", () => {
      n.errorText = null;
    }), n.bind("isEmpty", "isFocused", "placeholder").to(i), i;
  }, Eg = (n, e, t) => {
    const i = we(n.locale);
    return i.set({
      id: e,
      ariaDescribedById: t
    }), i.bind("isEnabled").to(n), i;
  }, rs = (n, e = 0, t = 1) => n > t ? t : n < e ? e : n, ve = (n, e = 0, t = Math.pow(10, e)) => Math.round(t * n) / t, YA = (n) => nx(_a(n)), _a = (n) => (n[0] === "#" && (n = n.substring(1)), n.length < 6 ? {
    r: parseInt(n[0] + n[0], 16),
    g: parseInt(n[1] + n[1], 16),
    b: parseInt(n[2] + n[2], 16),
    a: n.length === 4 ? ve(parseInt(n[3] + n[3], 16) / 255, 2) : 1
  } : {
    r: parseInt(n.substring(0, 2), 16),
    g: parseInt(n.substring(2, 4), 16),
    b: parseInt(n.substring(4, 6), 16),
    a: n.length === 8 ? ve(parseInt(n.substring(6, 8), 16) / 255, 2) : 1
  }), QA = (n) => ix(tx(n)), ex = ({ h: n, s: e, v: t, a: i }) => {
    const s = (200 - e) * t / 100;
    return {
      h: ve(n),
      s: ve(s > 0 && s < 200 ? e * t / 100 / (s <= 100 ? s : 200 - s) * 100 : 0),
      l: ve(s / 2),
      a: ve(i, 2)
    };
  }, va = (n) => {
    const { h: e, s: t, l: i } = ex(n);
    return `hsl(${e}, ${t}%, ${i}%)`;
  }, tx = ({ h: n, s: e, v: t, a: i }) => {
    n = n / 360 * 6, e = e / 100, t = t / 100;
    const s = Math.floor(n), o = t * (1 - e), r = t * (1 - (n - s) * e), a = t * (1 - (1 - n + s) * e), l = s % 6;
    return {
      r: ve([t, r, o, o, a, t][l] * 255),
      g: ve([a, t, t, r, o, o][l] * 255),
      b: ve([o, o, a, t, t, r][l] * 255),
      a: ve(i, 2)
    };
  }, Ns = (n) => {
    const e = n.toString(16);
    return e.length < 2 ? "0" + e : e;
  }, ix = ({ r: n, g: e, b: t, a: i }) => {
    const s = i < 1 ? Ns(ve(i * 255)) : "";
    return "#" + Ns(n) + Ns(e) + Ns(t) + s;
  }, nx = ({ r: n, g: e, b: t, a: i }) => {
    const s = Math.max(n, e, t), o = s - Math.min(n, e, t), r = o ? s === n ? (e - t) / o : s === e ? 2 + (t - n) / o : 4 + (n - e) / o : 0;
    return {
      h: ve(60 * (r < 0 ? r + 6 : r)),
      s: ve(s ? o / s * 100 : 0),
      v: ve(s / 255 * 100),
      a: i
    };
  }, Ag = (n, e) => {
    if (n === e)
      return !0;
    for (const t in n)
      if (n[t] !== e[t])
        return !1;
    return !0;
  }, sx = (n, e) => n.toLowerCase() === e.toLowerCase() ? !0 : Ag(_a(n), _a(e)), ju = {}, xg = (n) => {
    let e = ju[n];
    return e || (e = document.createElement("template"), e.innerHTML = n, ju[n] = e), e;
  }, Ll = (n, e, t) => {
    n.dispatchEvent(new CustomEvent(e, {
      bubbles: !0,
      detail: t
    }));
  };
  let ji = !1;
  const ya = (n) => "touches" in n, ox = (n) => ji && !ya(n) ? !1 : (ji || (ji = ya(n)), !0), Ku = (n, e) => {
    const t = ya(e) ? e.touches[0] : e, i = n.el.getBoundingClientRect();
    Ll(n.el, "move", n.getMove({
      x: rs((t.pageX - (i.left + window.pageXOffset)) / i.width),
      y: rs((t.pageY - (i.top + window.pageYOffset)) / i.height)
    }));
  }, rx = (n, e) => {
    const t = e.keyCode;
    t > 40 || n.xy && t < 37 || t < 33 || (e.preventDefault(), Ll(n.el, "move", n.getMove({
      x: t === 39 ? 0.01 : t === 37 ? -0.01 : t === 34 ? 0.05 : t === 33 ? -0.05 : t === 35 ? 1 : t === 36 ? -1 : 0,
      y: t === 40 ? 0.01 : t === 38 ? -0.01 : 0
    }, !0)));
  };
  class Sg {
    constructor(e, t, i, s) {
      const o = xg(`<div role="slider" tabindex="0" part="${t}" ${i}><div part="${t}-pointer"></div></div>`);
      e.appendChild(o.content.cloneNode(!0));
      const r = e.querySelector(`[part=${t}]`);
      r.addEventListener("mousedown", this), r.addEventListener("touchstart", this), r.addEventListener("keydown", this), this.el = r, this.xy = s, this.nodes = [r.firstChild, r];
    }
    set dragging(e) {
      const t = e ? document.addEventListener : document.removeEventListener;
      t(ji ? "touchmove" : "mousemove", this), t(ji ? "touchend" : "mouseup", this);
    }
    handleEvent(e) {
      switch (e.type) {
        case "mousedown":
        case "touchstart":
          if (e.preventDefault(), !ox(e) || !ji && e.button != 0)
            return;
          this.el.focus(), Ku(this, e), this.dragging = !0;
          break;
        case "mousemove":
        case "touchmove":
          e.preventDefault(), Ku(this, e);
          break;
        case "mouseup":
        case "touchend":
          this.dragging = !1;
          break;
        case "keydown":
          rx(this, e);
          break;
      }
    }
    style(e) {
      e.forEach((t, i) => {
        for (const s in t)
          this.nodes[i].style.setProperty(s, t[s]);
      });
    }
  }
  class ax extends Sg {
    constructor(e) {
      super(e, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1);
    }
    update({ h: e }) {
      this.h = e, this.style([
        {
          left: `${e / 360 * 100}%`,
          color: va({ h: e, s: 100, v: 100, a: 1 })
        }
      ]), this.el.setAttribute("aria-valuenow", `${ve(e)}`);
    }
    getMove(e, t) {
      return { h: t ? rs(this.h + e.x * 360, 0, 360) : 360 * e.x };
    }
  }
  class lx extends Sg {
    constructor(e) {
      super(e, "saturation", 'aria-label="Color"', !0);
    }
    update(e) {
      this.hsva = e, this.style([
        {
          top: `${100 - e.v}%`,
          left: `${e.s}%`,
          color: va(e)
        },
        {
          "background-color": va({ h: e.h, s: 100, v: 100, a: 1 })
        }
      ]), this.el.setAttribute("aria-valuetext", `Saturation ${ve(e.s)}%, Brightness ${ve(e.v)}%`);
    }
    getMove(e, t) {
      return {
        s: t ? rs(this.hsva.s + e.x * 100, 0, 100) : e.x * 100,
        v: t ? rs(this.hsva.v - e.y * 100, 0, 100) : Math.round(100 - e.y * 100)
      };
    }
  }
  const cx = ':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', ux = "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", dx = "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}", Ds = Symbol("same"), Lr = Symbol("color"), Zu = Symbol("hsva"), Vr = Symbol("update"), Ju = Symbol("parts"), Xu = Symbol("css"), Yu = Symbol("sliders");
  class hx extends HTMLElement {
    static get observedAttributes() {
      return ["color"];
    }
    get [Xu]() {
      return [cx, ux, dx];
    }
    get [Yu]() {
      return [lx, ax];
    }
    get color() {
      return this[Lr];
    }
    set color(e) {
      if (!this[Ds](e)) {
        const t = this.colorModel.toHsva(e);
        this[Vr](t), this[Lr] = e;
      }
    }
    constructor() {
      super();
      const e = xg(`<style>${this[Xu].join("")}</style>`), t = this.attachShadow({ mode: "open" });
      t.appendChild(e.content.cloneNode(!0)), t.addEventListener("move", this), this[Ju] = this[Yu].map((i) => new i(t));
    }
    connectedCallback() {
      if (this.hasOwnProperty("color")) {
        const e = this.color;
        delete this.color, this.color = e;
      } else
        this.color || (this.color = this.colorModel.defaultColor);
    }
    attributeChangedCallback(e, t, i) {
      const s = this.colorModel.fromAttr(i);
      this[Ds](s) || (this.color = s);
    }
    handleEvent(e) {
      const t = this[Zu], i = { ...t, ...e.detail };
      this[Vr](i);
      let s;
      !Ag(i, t) && !this[Ds](s = this.colorModel.fromHsva(i)) && (this[Lr] = s, Ll(this, "color-changed", { value: s }));
    }
    [Ds](e) {
      return this.color && this.colorModel.equal(e, this.color);
    }
    [Vr](e) {
      this[Zu] = e, this[Ju].forEach((t) => t.update(e));
    }
  }
  const fx = {
    defaultColor: "#000",
    toHsva: YA,
    fromHsva: ({ h: n, s: e, v: t }) => QA({ h: n, s: e, v: t, a: 1 }),
    equal: sx,
    fromAttr: (n) => n
  };
  class mx extends hx {
    get colorModel() {
      return fx;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const gx = 150;
  class px extends T {
    /**
     * Creates a view of color picker.
     *
     * @param locale
     * @param config
     */
    constructor(e, t = {}) {
      super(e), this.set({
        color: "",
        _hexColor: ""
      }), this.hexInputRow = this._createInputRow();
      const i = this.createCollection();
      t.hideInput || i.add(this.hexInputRow), this.setTemplate({
        tag: "div",
        attributes: {
          class: ["ck", "ck-color-picker"],
          tabindex: -1
        },
        children: i
      }), this._config = t, this._debounceColorPickerEvent = Rt((s) => {
        this.set("color", s), this.fire("colorSelected", { color: this.color });
      }, gx, {
        leading: !0
      }), this.on("set:color", (s, o, r) => {
        s.return = bg(r, this._config.format || "hsl");
      }), this.on("change:color", () => {
        this._hexColor = Mr(this.color);
      }), this.on("change:_hexColor", () => {
        document.activeElement !== this.picker && this.picker.setAttribute("color", this._hexColor), Mr(this.color) != Mr(this._hexColor) && (this.color = this._hexColor);
      });
    }
    /**
     * Renders color picker in the view.
     */
    render() {
      if (super.render(), RA("hex-color-picker", mx), this.picker = E.document.createElement("hex-color-picker"), this.picker.setAttribute("class", "hex-color-picker"), this.picker.setAttribute("tabindex", "-1"), this._createSlidersView(), this.element) {
        this.hexInputRow.element ? this.element.insertBefore(this.picker, this.hexInputRow.element) : this.element.appendChild(this.picker);
        const e = document.createElement("style");
        e.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}', this.picker.shadowRoot.appendChild(e);
      }
      this.picker.addEventListener("color-changed", (e) => {
        const t = e.detail.value;
        this._debounceColorPickerEvent(t);
      });
    }
    /**
     * Focuses the first pointer in color picker.
     *
     */
    focus() {
      /* istanbul ignore next -- @preserve */
      !this._config.hideInput && (B.isGecko || B.isiOS || B.isSafari) && this.hexInputRow.children.get(1).focus(), this.slidersView.first.focus();
    }
    /**
     * Creates collection of sliders in color picker.
     *
     * @private
     */
    _createSlidersView() {
      const i = [...this.picker.shadowRoot.children].filter((s) => s.getAttribute("role") === "slider").map((s) => new wx(s));
      this.slidersView = this.createCollection(), i.forEach((s) => {
        this.slidersView.add(s);
      });
    }
    /**
     * Creates input row for defining custom colors in color picker.
     *
     * @private
     */
    _createInputRow() {
      const e = new bx(), t = this._createColorInput();
      return new _x(this.locale, [e, t]);
    }
    /**
     * Creates the input where user can type or paste the color in hex format.
     *
     * @private
     */
    _createColorInput() {
      const e = new he(this.locale, ze), { t } = this.locale;
      return e.set({
        label: t("HEX"),
        class: "color-picker-hex-input"
      }), e.fieldView.bind("value").to(this, "_hexColor", (i) => e.isFocused ? e.fieldView.value : i.startsWith("#") ? i.substring(1) : i), e.fieldView.on("input", () => {
        const i = e.fieldView.element.value;
        if (i) {
          const s = i.trim(), o = s.startsWith("#") ? s.substring(1) : s;
          [3, 4, 6, 8].includes(o.length) && /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(o) && this._debounceColorPickerEvent("#" + o);
        }
      }), e;
    }
  }
  function Mr(n) {
    let e = PA(n);
    return e || (e = "#000"), e.length === 4 && (e = "#" + [e[1], e[1], e[2], e[2], e[3], e[3]].join("")), e.toLowerCase();
  }
  class wx extends T {
    /**
     * @param element HTML element of slider in color picker.
     */
    constructor(e) {
      super(), this.element = e;
    }
    /**
     * Focuses element.
     */
    focus() {
      this.element.focus();
    }
  }
  class bx extends T {
    constructor(e) {
      super(e), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-color-picker__hash-view"
          ]
        },
        children: "#"
      });
    }
  }
  class _x extends T {
    /**
     * Creates an instance of the form row class.
     *
     * @param locale The locale instance.
     */
    constructor(e, t) {
      super(e), this.children = this.createCollection(t), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-color-picker__row"
          ]
        },
        children: this.children
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class vx extends $(Ce) {
    constructor(e) {
      super(e), this.set("isEmpty", !0), this.on("change", () => {
        this.set("isEmpty", this.length === 0);
      });
    }
    /**
     * Adds a color to the document color collection.
     *
     * This method ensures that no color duplicates are inserted (compared using
     * the color value of the {@link module:ui/colorgrid/colorgridview~ColorDefinition}).
     *
     * If the item does not have an ID, it will be automatically generated and set on the item.
     *
     * @param index The position of the item in the collection. The item is pushed to the collection when `index` is not specified.
     * @fires add
     * @fires change
     */
    add(e, t) {
      return this.find((i) => i.color === e.color) ? this : super.add(e, t);
    }
    /**
     * Checks if an object with given colors is present in the document color collection.
     */
    hasColor(e) {
      return !!this.find((t) => t.color === e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const { eraser: yx, colorPalette: Cx } = x;
  class kx extends T {
    /**
     * Creates an instance of the view.
     *
     * @param locale The localization services instance.
     * @param colors An array with definitions of colors to be displayed in the table.
     * @param columns The number of columns in the color grid.
     * @param removeButtonLabel The label of the button responsible for removing the color.
     * @param colorPickerLabel The label of the button responsible for color picker appearing.
     * @param documentColorsLabel The label for the section with the document colors.
     * @param documentColorsCount The number of colors in the document colors section inside the color dropdown.
     * @param focusTracker Tracks information about the DOM focus in the list.
     * @param focusables A collection of views that can be focused in the view.
     */
    constructor(e, { colors: t, columns: i, removeButtonLabel: s, documentColorsLabel: o, documentColorsCount: r, colorPickerLabel: a, focusTracker: l, focusables: c }) {
      super(e);
      const u = this.bindTemplate;
      this.set("isVisible", !0), this.focusTracker = l, this.items = this.createCollection(), this.colorDefinitions = t, this.columns = i, this.documentColors = new vx(), this.documentColorsCount = r, this._focusables = c, this._removeButtonLabel = s, this._colorPickerLabel = a, this._documentColorsLabel = o, this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck-color-grids-fragment",
            u.if("isVisible", "ck-hidden", (d) => !d)
          ]
        },
        children: this.items
      }), this.removeColorButtonView = this._createRemoveColorButton(), this.items.add(this.removeColorButtonView);
    }
    /**
     * Scans through the editor model and searches for text node attributes with the given attribute name.
     * Found entries are set as document colors.
     *
     * All the previously stored document colors will be lost in the process.
     *
     * @param model The model used as a source to obtain the document colors.
     * @param attributeName Determines the name of the related model's attribute for a given dropdown.
     */
    updateDocumentColors(e, t) {
      const i = e.document, s = this.documentColorsCount;
      this.documentColors.clear();
      for (const o of i.getRoots()) {
        const r = e.createRangeIn(o);
        for (const a of r.getItems())
          if (a.is("$textProxy") && a.hasAttribute(t) && (this._addColorToDocumentColors(a.getAttribute(t)), this.documentColors.length >= s))
            return;
      }
    }
    /**
     * Refreshes the state of the selected color in one or both {@link module:ui/colorgrid/colorgridview~ColorGridView}s
     * available in the {@link module:ui/colorselector/colorselectorview~ColorSelectorView}. It guarantees that the selection will
     * occur only in one of them.
     */
    updateSelectedColors() {
      const e = this.documentColorsGrid, t = this.staticColorsGrid, i = this.selectedColor;
      t.selectedColor = i, e && (e.selectedColor = i);
    }
    /**
     * @inheritDoc
     */
    render() {
      if (super.render(), this.staticColorsGrid = this._createStaticColorsGrid(), this.items.add(this.staticColorsGrid), this.documentColorsCount) {
        const e = Ve.bind(this.documentColors, this.documentColors), t = new Fe(this.locale);
        t.text = this._documentColorsLabel, t.extendTemplate({
          attributes: {
            class: [
              "ck",
              "ck-color-grid__label",
              e.if("isEmpty", "ck-hidden")
            ]
          }
        }), this.items.add(t), this.documentColorsGrid = this._createDocumentColorsGrid(), this.items.add(this.documentColorsGrid);
      }
      this._createColorPickerButton(), this._addColorSelectorElementsToFocusTracker();
    }
    /**
     * Focuses the component.
     */
    focus() {
      this.removeColorButtonView.focus();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy();
    }
    /**
     * Handles displaying the color picker button (if it was previously created) and making it focusable.
     */
    addColorPickerButton() {
      this.colorPickerButtonView && (this.items.add(this.colorPickerButtonView), this.focusTracker.add(this.colorPickerButtonView.element), this._focusables.add(this.colorPickerButtonView));
    }
    /**
     * Adds color selector elements to focus tracker.
     */
    _addColorSelectorElementsToFocusTracker() {
      this.focusTracker.add(this.removeColorButtonView.element), this._focusables.add(this.removeColorButtonView), this.staticColorsGrid && (this.focusTracker.add(this.staticColorsGrid.element), this._focusables.add(this.staticColorsGrid)), this.documentColorsGrid && (this.focusTracker.add(this.documentColorsGrid.element), this._focusables.add(this.documentColorsGrid));
    }
    /**
     * Creates the button responsible for displaying the color picker component.
     */
    _createColorPickerButton() {
      this.colorPickerButtonView = new P(), this.colorPickerButtonView.set({
        label: this._colorPickerLabel,
        withText: !0,
        icon: Cx,
        class: "ck-color-selector__color-picker"
      }), this.colorPickerButtonView.on("execute", () => {
        this.fire("colorPicker:show");
      });
    }
    /**
     * Adds the remove color button as a child of the current view.
     */
    _createRemoveColorButton() {
      const e = new P();
      return e.set({
        withText: !0,
        icon: yx,
        label: this._removeButtonLabel
      }), e.class = "ck-color-selector__remove-color", e.on("execute", () => {
        this.fire("execute", {
          value: null,
          source: "removeColorButton"
        });
      }), e.render(), e;
    }
    /**
     * Creates a static color grid based on the editor configuration.
     */
    _createStaticColorsGrid() {
      const e = new Uu(this.locale, {
        colorDefinitions: this.colorDefinitions,
        columns: this.columns
      });
      return e.on("execute", (t, i) => {
        this.fire("execute", {
          value: i.value,
          source: "staticColorsGrid"
        });
      }), e;
    }
    /**
     * Creates the document colors section view and binds it to {@link #documentColors}.
     */
    _createDocumentColorsGrid() {
      const e = Ve.bind(this.documentColors, this.documentColors), t = new Uu(this.locale, {
        columns: this.columns
      });
      return t.extendTemplate({
        attributes: {
          class: e.if("isEmpty", "ck-hidden")
        }
      }), t.items.bindTo(this.documentColors).using((i) => {
        const s = new dg();
        return s.set({
          color: i.color,
          hasBorder: i.options && i.options.hasBorder
        }), i.label && s.set({
          label: i.label,
          tooltip: !0
        }), s.on("execute", () => {
          this.fire("execute", {
            value: i.color,
            source: "documentColorsGrid"
          });
        }), s;
      }), this.documentColors.on("change:isEmpty", (i, s, o) => {
        o && (t.selectedColor = null);
      }), t;
    }
    /**
     * Adds a given color to the document colors list. If possible, the method will attempt to use
     * data from the {@link #colorDefinitions} (label, color options).
     *
     * @param color A string that stores the value of the recently applied color.
     */
    _addColorToDocumentColors(e) {
      const t = this.colorDefinitions.find((i) => i.color === e);
      t ? this.documentColors.add(Object.assign({}, t)) : this.documentColors.add({
        color: e,
        label: e,
        options: {
          hasBorder: !1
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Tx extends T {
    /**
     * Creates an instance of the view.
     *
     * @param locale The localization services instance.
     * @param focusTracker Tracks information about the DOM focus in the list.
     * @param focusables A collection of views that can be focused in the view..
     * @param keystrokes An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
     * @param colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker
     * will not be rendered.
     */
    constructor(e, { focusTracker: t, focusables: i, keystrokes: s, colorPickerViewConfig: o }) {
      super(e), this.items = this.createCollection(), this.focusTracker = t, this.keystrokes = s, this.set("isVisible", !1), this.set("selectedColor", void 0), this._focusables = i, this._colorPickerViewConfig = o;
      const r = this.bindTemplate, { saveButtonView: a, cancelButtonView: l } = this._createActionButtons();
      this.saveButtonView = a, this.cancelButtonView = l, this.actionBarView = this._createActionBarView({ saveButtonView: a, cancelButtonView: l }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck-color-picker-fragment",
            r.if("isVisible", "ck-hidden", (c) => !c)
          ]
        },
        children: this.items
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render();
      const e = new px(this.locale, {
        ...this._colorPickerViewConfig
      });
      this.colorPickerView = e, this.colorPickerView.render(), this.selectedColor && (e.color = this.selectedColor), this.listenTo(this, "change:selectedColor", (t, i, s) => {
        e.color = s;
      }), this.items.add(this.colorPickerView), this.items.add(this.actionBarView), this._addColorPickersElementsToFocusTracker(), this._stopPropagationOnArrowsKeys(), this._executeOnEnterPress(), this._executeUponColorChange();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy();
    }
    /**
     * Focuses the color picker.
     */
    focus() {
      this.colorPickerView.focus();
    }
    /**
     * When color picker is focused and "enter" is pressed it executes command.
     */
    _executeOnEnterPress() {
      this.keystrokes.set("enter", (e) => {
        this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element && (this.fire("execute", {
          value: this.selectedColor
        }), e.stopPropagation(), e.preventDefault());
      });
    }
    /**
     * Removes default behavior of arrow keys in dropdown.
     */
    _stopPropagationOnArrowsKeys() {
      const e = (t) => t.stopPropagation();
      this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e);
    }
    /**
     * Adds color picker elements to focus tracker.
     */
    _addColorPickersElementsToFocusTracker() {
      for (const t of this.colorPickerView.slidersView)
        this.focusTracker.add(t.element), this._focusables.add(t);
      const e = this.colorPickerView.hexInputRow.children.get(1);
      e.element && (this.focusTracker.add(e.element), this._focusables.add(e)), this.focusTracker.add(this.saveButtonView.element), this._focusables.add(this.saveButtonView), this.focusTracker.add(this.cancelButtonView.element), this._focusables.add(this.cancelButtonView);
    }
    /**
     * Creates bar containing "Save" and "Cancel" buttons.
     */
    _createActionBarView({ saveButtonView: e, cancelButtonView: t }) {
      const i = new T(), s = this.createCollection();
      return s.add(e), s.add(t), i.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-color-selector_action-bar"
          ]
        },
        children: s
      }), i;
    }
    /**
     * Creates "Save" and "Cancel" buttons.
     */
    _createActionButtons() {
      const e = this.locale, t = e.t, i = new P(e), s = new P(e);
      return i.set({
        icon: x.check,
        class: "ck-button-save",
        type: "button",
        withText: !1,
        label: t("Accept")
      }), s.set({
        icon: x.cancel,
        class: "ck-button-cancel",
        type: "button",
        withText: !1,
        label: t("Cancel")
      }), i.on("execute", () => {
        this.fire("execute", {
          source: "colorPickerSaveButton",
          value: this.selectedColor
        });
      }), s.on("execute", () => {
        this.fire("colorPicker:cancel");
      }), {
        saveButtonView: i,
        cancelButtonView: s
      };
    }
    /**
     * Fires the `execute` event if color in color picker has been changed
     * by the user.
     */
    _executeUponColorChange() {
      this.colorPickerView.on("colorSelected", (e, t) => {
        this.fire("execute", {
          value: t.color,
          source: "colorPicker"
        }), this.set("selectedColor", t.color);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Vl extends T {
    /**
     * Creates a view to be inserted as a child of {@link module:ui/dropdown/dropdownview~DropdownView}.
     *
     * @param locale The localization services instance.
     * @param colors An array with definitions of colors to be displayed in the table.
     * @param columns The number of columns in the color grid.
     * @param removeButtonLabel The label of the button responsible for removing the color.
     * @param colorPickerLabel The label of the button responsible for color picker appearing.
     * @param documentColorsLabel The label for the section with the document colors.
     * @param documentColorsCount The number of colors in the document colors section inside the color dropdown.
     * @param colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker will be hidden.
     */
    constructor(e, { colors: t, columns: i, removeButtonLabel: s, documentColorsLabel: o, documentColorsCount: r, colorPickerLabel: a, colorPickerViewConfig: l }) {
      super(e), this.items = this.createCollection(), this.focusTracker = new Q(), this.keystrokes = new ne(), this._focusables = new ke(), this._colorPickerViewConfig = l, this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate list items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
          focusPrevious: "shift + tab",
          // Navigate list items forwards using the <kbd>Tab</kbd> key.
          focusNext: "tab"
        }
      }), this.colorGridsFragmentView = new kx(e, {
        colors: t,
        columns: i,
        removeButtonLabel: s,
        documentColorsLabel: o,
        documentColorsCount: r,
        colorPickerLabel: a,
        focusTracker: this.focusTracker,
        focusables: this._focusables
      }), this.colorPickerFragmentView = new Tx(e, {
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokes: this.keystrokes,
        colorPickerViewConfig: l
      }), this.set("_isColorGridsFragmentVisible", !0), this.set("_isColorPickerFragmentVisible", !1), this.set("selectedColor", void 0), this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible"), this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible"), this.on("change:selectedColor", (c, u, d) => {
        this.colorGridsFragmentView.set("selectedColor", d), this.colorPickerFragmentView.set("selectedColor", d);
      }), this.colorGridsFragmentView.on("change:selectedColor", (c, u, d) => {
        this.set("selectedColor", d);
      }), this.colorPickerFragmentView.on("change:selectedColor", (c, u, d) => {
        this.set("selectedColor", d);
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-color-selector"
          ]
        },
        children: this.items
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Renders the internals of the component on demand:
     * * {@link #colorPickerFragmentView},
     * * {@link #colorGridsFragmentView}.
     *
     * It allows for deferring component initialization to improve the performance.
     *
     * See {@link #showColorPickerFragment}, {@link #showColorGridsFragment}.
     */
    appendUI() {
      this._appendColorGridsFragment(), this._colorPickerViewConfig && this._appendColorPickerFragment();
    }
    /**
     * Shows the {@link #colorPickerFragmentView} and hides the {@link #colorGridsFragmentView}.
     *
     * **Note**: It requires {@link #appendUI} to be called first.
     *
     * See {@link #showColorGridsFragment}, {@link ~ColorSelectorView#event:colorPicker:show}.
     */
    showColorPickerFragment() {
      !this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible || (this._isColorPickerFragmentVisible = !0, this.colorPickerFragmentView.focus(), this._isColorGridsFragmentVisible = !1);
    }
    /**
     * Shows the {@link #colorGridsFragmentView} and hides the {@link #colorPickerFragmentView}.
     *
     * See {@link #showColorPickerFragment}.
     *
     * **Note**: It requires {@link #appendUI} to be called first.
     */
    showColorGridsFragment() {
      this._isColorGridsFragmentVisible || (this._isColorGridsFragmentVisible = !0, this.colorGridsFragmentView.focus(), this._isColorPickerFragmentVisible = !1);
    }
    /**
     * Focuses the first focusable element in {@link #items}.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the last focusable element in {@link #items}.
     */
    focusLast() {
      this._focusCycler.focusLast();
    }
    /**
     * Scans through the editor model and searches for text node attributes with the given `attributeName`.
     * Found entries are set as document colors in {@link #colorGridsFragmentView}.
     *
     * All the previously stored document colors will be lost in the process.
     *
     * @param model The model used as a source to obtain the document colors.
     * @param attributeName Determines the name of the related model's attribute for a given dropdown.
     */
    updateDocumentColors(e, t) {
      this.colorGridsFragmentView.updateDocumentColors(e, t);
    }
    /**
     * Refreshes the state of the selected color in one or both grids located in {@link #colorGridsFragmentView}.
     *
     * It guarantees that the selection will occur only in one of them.
     */
    updateSelectedColors() {
      this.colorGridsFragmentView.updateSelectedColors();
    }
    /**
     * Appends the view containing static and document color grid views.
     */
    _appendColorGridsFragment() {
      this.items.length || (this.items.add(this.colorGridsFragmentView), this.colorGridsFragmentView.delegate("execute").to(this), this.colorGridsFragmentView.delegate("colorPicker:show").to(this));
    }
    /**
     * Appends the view with the color picker.
     */
    _appendColorPickerFragment() {
      this.items.length !== 2 && (this.items.add(this.colorPickerFragmentView), this.colorGridsFragmentView.colorPickerButtonView && this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
        this.showColorPickerFragment();
      }), this.colorGridsFragmentView.addColorPickerButton(), this.colorPickerFragmentView.delegate("execute").to(this), this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ex {
    /**
     * Creates an instance of the factory.
     *
     * @param editor The editor instance.
     */
    constructor(e) {
      this._components = /* @__PURE__ */ new Map(), this.editor = e;
    }
    /**
     * Returns an iterator of registered component names. Names are returned in lower case.
     */
    *names() {
      for (const e of this._components.values())
        yield e.originalName;
    }
    /**
     * Registers a component factory function that will be used by the
     * {@link #create create} method and called with the
     * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
     * allowing localization of the {@link module:ui/view~View view}.
     *
     * @param name The name of the component.
     * @param callback The callback that returns the component.
     */
    add(e, t) {
      this._components.set(Br(e), { callback: t, originalName: e });
    }
    /**
     * Creates an instance of a component registered in the factory under a specific name.
     *
     * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
     * the previously {@link #add added} factory function, allowing localization of the
     * {@link module:ui/view~View view}.
     *
     * @param name The name of the component.
     * @returns The instantiated component view.
     */
    create(e) {
      if (!this.has(e))
        throw new g("componentfactory-item-missing", this, { name: e });
      return this._components.get(Br(e)).callback(this.editor.locale);
    }
    /**
     * Checks if a component of a given name is registered in the factory.
     *
     * @param name The name of the component.
     */
    has(e) {
      return this._components.has(Br(e));
    }
  }
  function Br(n) {
    return String(n).toLowerCase();
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class rr extends T {
    /**
     * Creates an instance of the form header class.
     *
     * @param locale The locale instance.
     * @param options.label A label.
     * @param options.class An additional class.
     */
    constructor(e, t = {}) {
      super(e);
      const i = this.bindTemplate;
      this.set("label", t.label || ""), this.set("class", t.class || null), this.children = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-form__header",
            i.to("class")
          ]
        },
        children: this.children
      }), t.icon && (this.iconView = new dt(), this.iconView.content = t.icon, this.children.add(this.iconView));
      const s = new T(e);
      s.setTemplate({
        tag: "h2",
        attributes: {
          class: [
            "ck",
            "ck-form__header__label"
          ],
          role: "presentation"
        },
        children: [
          { text: i.to("label") }
        ]
      }), this.children.add(s);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ax(n) {
    class e extends n {
      /**
       * @inheritdoc
       */
      constructor(...i) {
        super(...i), this._onDragBound = this._onDrag.bind(this), this._onDragEndBound = this._onDragEnd.bind(this), this._lastDraggingCoordinates = { x: 0, y: 0 }, this.on("render", () => {
          this._attachListeners();
        }), this.set("isDragging", !1);
      }
      /**
       * Attaches the listeners for the drag start.
       */
      _attachListeners() {
        this.listenTo(this.element, "mousedown", this._onDragStart.bind(this)), this.listenTo(this.element, "touchstart", this._onDragStart.bind(this));
      }
      /**
       * Attaches the listeners for the dragging and drag end.
       */
      _attachDragListeners() {
        this.listenTo(E.document, "mouseup", this._onDragEndBound), this.listenTo(E.document, "touchend", this._onDragEndBound), this.listenTo(E.document, "mousemove", this._onDragBound), this.listenTo(E.document, "touchmove", this._onDragBound);
      }
      /**
       * Detaches the listeners after the drag end.
       */
      _detachDragListeners() {
        this.stopListening(E.document, "mouseup", this._onDragEndBound), this.stopListening(E.document, "touchend", this._onDragEndBound), this.stopListening(E.document, "mousemove", this._onDragBound), this.stopListening(E.document, "touchmove", this._onDragBound);
      }
      /**
       * Starts the dragging listeners and sets the initial view coordinates.
       */
      _onDragStart(i, s) {
        if (!this._isHandleElementPressed(s))
          return;
        this._attachDragListeners();
        let o = 0, r = 0;
        s instanceof MouseEvent ? (o = s.clientX, r = s.clientY) : (o = s.touches[0].clientX, r = s.touches[0].clientY), this._lastDraggingCoordinates = { x: o, y: r }, this.isDragging = !0;
      }
      /**
       * Updates the view coordinates and fires the `drag` event.
       */
      _onDrag(i, s) {
        if (!this.isDragging) {
          this._detachDragListeners();
          return;
        }
        let o = 0, r = 0;
        s instanceof MouseEvent ? (o = s.clientX, r = s.clientY) : (o = s.touches[0].clientX, r = s.touches[0].clientY), s.preventDefault(), this.fire("drag", {
          deltaX: Math.round(o - this._lastDraggingCoordinates.x),
          deltaY: Math.round(r - this._lastDraggingCoordinates.y)
        }), this._lastDraggingCoordinates = { x: o, y: r };
      }
      /**
       * Stops the dragging and detaches the listeners.
       */
      _onDragEnd() {
        this._detachDragListeners(), this.isDragging = !1;
      }
      /**
       * Checks if the drag handle element was pressed.
       */
      _isHandleElementPressed(i) {
        return this.dragHandleElement ? this.dragHandleElement === i.target || i.target instanceof HTMLElement && this.dragHandleElement.contains(i.target) : !1;
      }
    }
    return e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class xx extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.children = this.createCollection(), this.keystrokes = new ne(), this._focusTracker = new Q(), this._focusables = new ke(), this.focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this._focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-dialog__actions"
          ]
        },
        children: this.children
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.keystrokes.listenTo(this.element);
    }
    /**
     * Creates the button views based on the given definitions.
     * Then adds them to the {@link #children} collection and to the focus cycler.
     */
    setButtons(e) {
      for (const t of e) {
        const i = new P(this.locale);
        let s;
        i.on("execute", () => t.onExecute()), t.onCreate && t.onCreate(i);
        for (s in t)
          s != "onExecute" && s != "onCreate" && i.set(s, t[s]);
        this.children.add(i);
      }
      this._updateFocusCyclableItems();
    }
    /**
     * @inheritDoc
     */
    focus(e) {
      e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst();
    }
    /**
     * Adds all elements from the {@link #children} collection to the {@link #_focusables} collection
     * and to the {@link #_focusTracker} instance.
     */
    _updateFocusCyclableItems() {
      Array.from(this.children).forEach((e) => {
        this._focusables.add(e), this._focusTracker.add(e.element);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Sx extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.children = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: ["ck", "ck-dialog__content"]
        },
        children: this.children
      });
    }
    /**
     * Removes all the child views.
     */
    reset() {
      for (; this.children.length; )
        this.children.remove(0);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const et = {
    SCREEN_CENTER: "screen-center",
    EDITOR_CENTER: "editor-center",
    EDITOR_TOP_SIDE: "editor-top-side",
    EDITOR_TOP_CENTER: "editor-top-center",
    EDITOR_BOTTOM_CENTER: "editor-bottom-center",
    EDITOR_ABOVE_CENTER: "editor-above-center",
    EDITOR_BELOW_CENTER: "editor-below-center"
  }, Qu = dn("px");
  class nn extends Ax(T) {
    /**
     * @inheritDoc
     */
    constructor(e, { getCurrentDomRoot: t, getViewportOffset: i }) {
      super(e), this.wasMoved = !1;
      const s = this.bindTemplate, o = e.t;
      this.set("className", ""), this.set("ariaLabel", o("Editor dialog")), this.set("isModal", !1), this.set("position", et.SCREEN_CENTER), this.set("_isVisible", !1), this.set("_isTransparent", !1), this.set("_top", 0), this.set("_left", 0), this._getCurrentDomRoot = t, this._getViewportOffset = i, this.decorate("moveTo"), this.parts = this.createCollection(), this.keystrokes = new ne(), this.focusTracker = new Q(), this._focusables = new ke(), this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-dialog-overlay",
            s.if("isModal", "ck-dialog-overlay__transparent", (r) => !r),
            s.if("_isVisible", "ck-hidden", (r) => !r)
          ],
          // Prevent from editor losing focus when clicking on the modal overlay.
          tabindex: "-1"
        },
        children: [
          {
            tag: "div",
            attributes: {
              tabindex: "-1",
              class: [
                "ck",
                "ck-dialog",
                s.to("className")
              ],
              role: "dialog",
              "aria-label": s.to("ariaLabel"),
              style: {
                top: s.to("_top", (r) => Qu(r)),
                left: s.to("_left", (r) => Qu(r)),
                visibility: s.if("_isTransparent", "hidden")
              }
            },
            children: this.parts
          }
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.keystrokes.set("Esc", (e, t) => {
        this.fire("close", { source: "escKeyPress" }), t();
      }), this.on("drag", (e, { deltaX: t, deltaY: i }) => {
        this.wasMoved = !0, this.moveBy(t, i);
      }), this.listenTo(E.window, "resize", () => {
        this._isVisible && !this.wasMoved && this.updatePosition();
      }), this.listenTo(E.document, "scroll", () => {
        this._isVisible && !this.wasMoved && this.updatePosition();
      }), this.on("change:_isVisible", (e, t, i) => {
        i && (this._isTransparent = !0, setTimeout(() => {
          this.updatePosition(), this._isTransparent = !1, this.focus();
        }, 10));
      }), this.keystrokes.listenTo(this.element);
    }
    /**
     * Returns the element that should be used as a drag handle.
     */
    get dragHandleElement() {
      return this.headerView ? this.headerView.element : null;
    }
    /**
     * Creates the dialog parts. Which of them are created depends on the arguments passed to the method.
     * There are no rules regarding the dialog construction, that is, no part is mandatory.
     * Each part can only be created once.
     *
     * @internal
     */
    setupParts({ icon: e, title: t, hasCloseButton: i = !0, content: s, actionButtons: o }) {
      t && (this.headerView = new rr(this.locale, { icon: e }), i && (this.closeButtonView = this._createCloseButton(), this.headerView.children.add(this.closeButtonView)), this.headerView.label = t, this.ariaLabel = t, this.parts.add(this.headerView, 0)), s && (s instanceof T && (s = [s]), this.contentView = new Sx(this.locale), this.contentView.children.addMany(s), this.parts.add(this.contentView)), o && (this.actionsView = new xx(this.locale), this.actionsView.setButtons(o), this.parts.add(this.actionsView)), this._updateFocusCyclableItems();
    }
    /**
     * Focuses the first focusable element inside the dialog.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Normalizes the passed coordinates to make sure the dialog view
     * is displayed within the visible viewport and moves it there.
     *
     * @internal
     */
    moveTo(e, t) {
      const i = this._getViewportRect(), s = this._getDialogRect();
      e + s.width > i.right && (e = i.right - s.width), e < i.left && (e = i.left), t < i.top && (t = i.top), this._moveTo(e, t);
    }
    /**
     * Moves the dialog to the specified coordinates.
     */
    _moveTo(e, t) {
      this._left = e, this._top = t;
    }
    /**
     * Moves the dialog by the specified offset.
     *
     * @internal
     */
    moveBy(e, t) {
      this.moveTo(this._left + e, this._top + t);
    }
    /**
     * Moves the dialog view to the off-screen position.
     * Used when there is no space to display the dialog.
     */
    _moveOffScreen() {
      this._moveTo(-9999, -9999);
    }
    /**
     * Recalculates the dialog according to the set position and viewport,
     * and moves it to the new position.
     */
    updatePosition() {
      if (!this.element || !this.element.parentNode)
        return;
      const e = this._getViewportRect();
      let t = this.position, i;
      this._getCurrentDomRoot() ? i = this._getVisibleDomRootRect(e) : t = et.SCREEN_CENTER;
      const s = nn.defaultOffset, o = this._getDialogRect();
      switch (t) {
        case et.EDITOR_TOP_SIDE: {
          if (i) {
            const r = this.locale.contentLanguageDirection === "ltr" ? i.right - o.width - s : i.left + s;
            this.moveTo(r, i.top + s);
          } else
            this._moveOffScreen();
          break;
        }
        case et.EDITOR_CENTER: {
          i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), Math.round(i.top + i.height / 2 - o.height / 2)) : this._moveOffScreen();
          break;
        }
        case et.SCREEN_CENTER: {
          this.moveTo(Math.round((e.width - o.width) / 2), Math.round((e.height - o.height) / 2));
          break;
        }
        case et.EDITOR_TOP_CENTER: {
          i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), i.top + s) : this._moveOffScreen();
          break;
        }
        case et.EDITOR_BOTTOM_CENTER: {
          i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), i.bottom - o.height - s) : this._moveOffScreen();
          break;
        }
        case et.EDITOR_ABOVE_CENTER: {
          i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), i.top - o.height - s) : this._moveOffScreen();
          break;
        }
        case et.EDITOR_BELOW_CENTER: {
          i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), i.bottom + s) : this._moveOffScreen();
          break;
        }
      }
    }
    /**
     * Calculates the visible DOM root part.
     */
    _getVisibleDomRootRect(e) {
      let t = new O(this._getCurrentDomRoot()).getVisible();
      if (t) {
        if (t = e.getIntersection(t), !t)
          return null;
      } else
        return null;
      return t;
    }
    /**
     * Calculates the dialog element rect.
     */
    _getDialogRect() {
      return new O(this.element.firstElementChild);
    }
    /**
     * Calculates the viewport rect.
     */
    _getViewportRect() {
      return Ix(this._getViewportOffset());
    }
    /**
     * Collects all focusable elements inside the dialog parts
     * and adds them to the focus tracker and focus cycler.
     */
    _updateFocusCyclableItems() {
      const e = [];
      if (this.contentView)
        for (const t of this.contentView.children)
          ws(t) && e.push(t);
      this.actionsView && e.push(this.actionsView), this.closeButtonView && e.push(this.closeButtonView), e.forEach((t) => {
        this._focusables.add(t), this.focusTracker.add(t.element), DA(t) && (this.listenTo(t.focusCycler, "forwardCycle", (i) => {
          this._focusCycler.focusNext(), this._focusCycler.next !== this._focusCycler.focusables.get(this._focusCycler.current) && i.stop();
        }), this.listenTo(t.focusCycler, "backwardCycle", (i) => {
          this._focusCycler.focusPrevious(), this._focusCycler.previous !== this._focusCycler.focusables.get(this._focusCycler.current) && i.stop();
        }));
      });
    }
    /**
     * Creates the close button view that is displayed in the header view corner.
     */
    _createCloseButton() {
      const e = new P(this.locale), t = this.locale.t;
      return e.set({
        label: t("Close"),
        tooltip: !0,
        icon: x.cancel
      }), e.on("execute", () => this.fire("close", { source: "closeButton" })), e;
    }
  }
  nn.defaultOffset = 15;
  function Ix(n) {
    n = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, n);
    const e = new O(E.window);
    return e.top += n.top, e.height -= n.top, e.bottom -= n.bottom, e.height -= n.bottom, e.left += n.left, e.right -= n.right, e.width -= n.left + n.right, e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Tt extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Dialog";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = e.t;
      this._initShowHideListeners(), this._initFocusToggler(), this._initMultiRootIntegration(), this.set("id", null), e.accessibility.addKeystrokeInfos({
        categoryId: "navigation",
        keystrokes: [{
          label: t("Move focus in and out of an active dialog window"),
          keystroke: "Ctrl+F6",
          mayRequireFn: !0
        }]
      });
    }
    /**
     * Initiates listeners for the `show` and `hide` events emitted by this plugin.
     *
     * We could not simply decorate the {@link #show} and {@link #hide} methods to fire events,
     * because they would be fired in the wrong order &ndash; first would be `show` and then `hide`
     * (because showing the dialog actually starts with hiding the previously visible one).
     * Hence, we added private methods {@link #_show} and {@link #_hide} which are called on events
     * in the desired sequence.
     */
    _initShowHideListeners() {
      this.on("show", (e, t) => {
        this._show(t);
      }), this.on("show", (e, t) => {
        t.onShow && t.onShow(this);
      }, { priority: "low" }), this.on("hide", () => {
        Tt._visibleDialogPlugin && Tt._visibleDialogPlugin._hide();
      }), this.on("hide", () => {
        this._onHide && (this._onHide(this), this._onHide = void 0);
      }, { priority: "low" });
    }
    /**
     * Initiates keystroke handler for toggling the focus between the editor and the dialog view.
     */
    _initFocusToggler() {
      const e = this.editor;
      e.keystrokes.set("Ctrl+F6", (t, i) => {
        !this.isOpen || this.view.isModal || (this.view.focusTracker.isFocused ? e.editing.view.focus() : this.view.focus(), i());
      });
    }
    /**
     * Provides an integration between the root attaching and detaching and positioning of the view.
     */
    _initMultiRootIntegration() {
      const e = this.editor.model;
      e.document.on("change:data", () => {
        if (!this.view)
          return;
        const t = e.document.differ.getChangedRoots();
        for (const i of t)
          i.state && this.view.updatePosition();
      });
    }
    /**
     * Displays a dialog window.
     *
     * This method requires a {@link ~DialogDefinition} that defines the dialog's content, title, icon, action buttons, etc.
     *
     * For example, the following definition will create a dialog with:
     * * A header consisting of an icon, a title, and a "Close" button (it is added by default).
     * * A content consisting of a view with a single paragraph.
     * * A footer consisting of two buttons: "Yes" and "No".
     *
     * ```js
     * // Create the view that will be used as the dialog's content.
     * const textView = new View( locale );
     *
     * textView.setTemplate( {
     * 	tag: 'div',
     * 	attributes: {
     * 		style: {
     * 			padding: 'var(--ck-spacing-large)',
     * 			whiteSpace: 'initial',
     * 			width: '100%',
     * 			maxWidth: '500px'
     * 		},
     * 		tabindex: -1
     * 	},
     * 	children: [
     * 		'Lorem ipsum dolor sit amet...'
     * 	]
     * } );
     *
     * // Show the dialog.
     * editor.plugins.get( 'Dialog' ).show( {
     *	id: 'myDialog',
     * 	icon: 'myIcon', // This should be an SVG string.
     * 	title: 'My dialog',
     * 	content: textView,
     * 	actionButtons: [
     *		{
     *			label: t( 'Yes' ),
     *			class: 'ck-button-action',
     *			withText: true,
     *			onExecute: () => dialog.hide()
     *		},
     *		{
     *			label: t( 'No' ),
     *			withText: true,
     *			onExecute: () => dialog.hide()
     *		}
     *	]
     * } );
     * ```
     *
     * By specifying the {@link ~DialogDefinition#onShow} and {@link ~DialogDefinition#onHide} callbacks
     * it is also possible to add callbacks that will be called when the dialog is shown or hidden.
     *
     * For example, the callbacks in the following definition:
     * * Disable the default behavior of the <kbd>Esc</kbd> key.
     * * Fire a custom event when the dialog gets hidden.
     *
     * ```js
     * editor.plugins.get( 'Dialog' ).show( {
     * 	// ...
     * 	onShow: dialog => {
     * 		dialog.view.on( 'close', ( evt, data ) => {
     * 			// Only prevent the event from the "Esc" key - do not affect the other ways of closing the dialog.
     * 			if ( data.source === 'escKeyPress' ) {
     * 				evt.stop();
     * 			}
     * 		} );
     * 	},
     * 	onHide: dialog => {
     * 		dialog.fire( 'dialogDestroyed' );
     * 	}
     * } );
     * ```
     *
     * Internally, calling this method:
     * 1. Hides the currently visible dialog (if any) calling the {@link #hide} method
     * (fires the {@link ~DialogHideEvent hide event}).
     * 2. Fires the {@link ~DialogShowEvent show event} which allows for adding callbacks that customize the
     * behavior of the dialog.
     * 3. Shows the dialog.
     */
    show(e) {
      this.hide(), this.fire(`show:${e.id}`, e);
    }
    /**
     * Handles creating the {@link module:ui/dialog/dialogview~DialogView} instance and making it visible.
     */
    _show({ id: e, icon: t, title: i, hasCloseButton: s = !0, content: o, actionButtons: r, className: a, isModal: l, position: c, onHide: u }) {
      const d = this.editor;
      this.view = new nn(d.locale, {
        getCurrentDomRoot: () => d.editing.view.getDomRoot(d.model.document.selection.anchor.root.rootName),
        getViewportOffset: () => d.ui.viewportOffset
      });
      const h = this.view;
      h.on("close", () => {
        this.hide();
      }), d.ui.view.body.add(h), d.ui.focusTracker.add(h.element), d.keystrokes.listenTo(h.element), c || (c = l ? et.SCREEN_CENTER : et.EDITOR_CENTER), h.set({
        position: c,
        _isVisible: !0,
        className: a,
        isModal: l
      }), h.setupParts({
        icon: t,
        title: i,
        hasCloseButton: s,
        content: o,
        actionButtons: r
      }), this.id = e, u && (this._onHide = u), this.isOpen = !0, Tt._visibleDialogPlugin = this;
    }
    /**
     * Hides the dialog. This method is decorated to enable interacting on the {@link ~DialogHideEvent hide event}.
     *
     * See {@link #show}.
     */
    hide() {
      Tt._visibleDialogPlugin && Tt._visibleDialogPlugin.fire(`hide:${Tt._visibleDialogPlugin.id}`);
    }
    /**
     * Destroys the {@link module:ui/dialog/dialogview~DialogView} and cleans up the stored dialog state.
     */
    _hide() {
      if (!this.view)
        return;
      const e = this.editor, t = this.view;
      t.contentView && t.contentView.reset(), e.ui.view.body.remove(t), e.ui.focusTracker.remove(t.element), e.keystrokes.stopListening(t.element), t.destroy(), e.editing.view.focus(), this.id = null, this.isOpen = !1, Tt._visibleDialogPlugin = null;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const ed = dn("px"), td = E.document.body, Px = {
    top: -99999,
    left: -99999,
    name: "arrowless",
    config: {
      withArrow: !1
    }
  };
  class ye extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-balloon-panel",
            t.to("position", (i) => `ck-balloon-panel_${i}`),
            t.if("isVisible", "ck-balloon-panel_visible"),
            t.if("withArrow", "ck-balloon-panel_with-arrow"),
            t.to("class")
          ],
          style: {
            top: t.to("top", ed),
            left: t.to("left", ed)
          }
        },
        children: this.content
      });
    }
    /**
     * Shows the panel.
     *
     * See {@link #isVisible}.
     */
    show() {
      this.isVisible = !0;
    }
    /**
     * Hides the panel.
     *
     * See {@link #isVisible}.
     */
    hide() {
      this.isVisible = !1;
    }
    /**
     * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
     * smart positioning heuristics that chooses from available positions to make sure the panel
     * is visible to the user i.e. within the limits of the viewport.
     *
     * This method accepts configuration {@link module:utils/dom/position~Options options}
     * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
     *
     * ```ts
     * const panel = new BalloonPanelView( locale );
     * const positions = BalloonPanelView.defaultPositions;
     *
     * panel.render();
     *
     * // Attach the panel to an element with the "target" id DOM.
     * panel.attachTo( {
     * 	target: document.querySelector( '#target' ),
     * 	positions: [
     * 		positions.northArrowSouth,
     * 		positions.southArrowNorth
     * 	]
     * } );
     * ```
     *
     * **Note**: Attaching the panel will also automatically {@link #show} it.
     *
     * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
     * See the {@link #pin} method for a more permanent positioning strategy.
     *
     * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
     * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
     */
    attachTo(e) {
      this.show();
      const t = ye.defaultPositions, i = Object.assign({}, {
        element: this.element,
        positions: [
          t.southArrowNorth,
          t.southArrowNorthMiddleWest,
          t.southArrowNorthMiddleEast,
          t.southArrowNorthWest,
          t.southArrowNorthEast,
          t.northArrowSouth,
          t.northArrowSouthMiddleWest,
          t.northArrowSouthMiddleEast,
          t.northArrowSouthWest,
          t.northArrowSouthEast,
          t.viewportStickyNorth
        ],
        limiter: td,
        fitInViewport: !0
      }, e), s = ye._getOptimalPosition(i) || Px, o = parseInt(s.left), r = parseInt(s.top), a = s.name, l = s.config || {}, { withArrow: c = !0 } = l;
      this.top = r, this.left = o, this.position = a, this.withArrow = c;
    }
    /**
     * Works the same way as the {@link #attachTo} method except that the position of the panel is
     * continuously updated when:
     *
     * * any ancestor of the {@link module:utils/dom/position~Options#target}
     * or {@link module:utils/dom/position~Options#limiter} is scrolled,
     * * the browser window gets resized or scrolled.
     *
     * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
     * and is immune to the changing environment.
     *
     * ```ts
     * const panel = new BalloonPanelView( locale );
     * const positions = BalloonPanelView.defaultPositions;
     *
     * panel.render();
     *
     * // Pin the panel to an element with the "target" id DOM.
     * panel.pin( {
     * 	target: document.querySelector( '#target' ),
     * 	positions: [
     * 		positions.northArrowSouth,
     * 		positions.southArrowNorth
     * 	]
     * } );
     * ```
     *
     * To leave the pinned state, use the {@link #unpin} method.
     *
     * **Note**: Pinning the panel will also automatically {@link #show} it.
     *
     * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
     * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
     */
    pin(e) {
      this.unpin(), this._pinWhenIsVisibleCallback = () => {
        this.isVisible ? this._startPinning(e) : this._stopPinning();
      }, this._startPinning(e), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
    }
    /**
     * Stops pinning the panel, as set up by {@link #pin}.
     */
    unpin() {
      this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
    }
    /**
     * Starts managing the pinned state of the panel. See {@link #pin}.
     *
     * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
     */
    _startPinning(e) {
      this.attachTo(e);
      const t = Ca(e.target), i = e.limiter ? Ca(e.limiter) : td;
      this.listenTo(E.document, "scroll", (s, o) => {
        const r = o.target, a = t && r.contains(t), l = i && r.contains(i);
        (a || l || !t || !i) && this.attachTo(e);
      }, { useCapture: !0 }), this.listenTo(E.window, "resize", () => {
        this.attachTo(e);
      });
    }
    /**
     * Stops managing the pinned state of the panel. See {@link #pin}.
     */
    _stopPinning() {
      this.stopListening(E.document, "scroll"), this.stopListening(E.window, "resize");
    }
  }
  ye.arrowSideOffset = 25;
  ye.arrowHeightOffset = 10;
  ye.stickyVerticalOffset = 20;
  ye._getOptimalPosition = Ko;
  ye.defaultPositions = Ig();
  function Ca(n) {
    return fi(n) ? n : jo(n) ? n.commonAncestorContainer : typeof n == "function" ? Ca(n()) : null;
  }
  function Ig(n = {}) {
    const { sideOffset: e = ye.arrowSideOffset, heightOffset: t = ye.arrowHeightOffset, stickyVerticalOffset: i = ye.stickyVerticalOffset, config: s } = n;
    return {
      // ------- North west
      northWestArrowSouthWest: (a, l) => ({
        top: o(a, l),
        left: a.left - e,
        name: "arrow_sw",
        ...s && { config: s }
      }),
      northWestArrowSouthMiddleWest: (a, l) => ({
        top: o(a, l),
        left: a.left - l.width * 0.25 - e,
        name: "arrow_smw",
        ...s && { config: s }
      }),
      northWestArrowSouth: (a, l) => ({
        top: o(a, l),
        left: a.left - l.width / 2,
        name: "arrow_s",
        ...s && { config: s }
      }),
      northWestArrowSouthMiddleEast: (a, l) => ({
        top: o(a, l),
        left: a.left - l.width * 0.75 + e,
        name: "arrow_sme",
        ...s && { config: s }
      }),
      northWestArrowSouthEast: (a, l) => ({
        top: o(a, l),
        left: a.left - l.width + e,
        name: "arrow_se",
        ...s && { config: s }
      }),
      // ------- North
      northArrowSouthWest: (a, l) => ({
        top: o(a, l),
        left: a.left + a.width / 2 - e,
        name: "arrow_sw",
        ...s && { config: s }
      }),
      northArrowSouthMiddleWest: (a, l) => ({
        top: o(a, l),
        left: a.left + a.width / 2 - l.width * 0.25 - e,
        name: "arrow_smw",
        ...s && { config: s }
      }),
      northArrowSouth: (a, l) => ({
        top: o(a, l),
        left: a.left + a.width / 2 - l.width / 2,
        name: "arrow_s",
        ...s && { config: s }
      }),
      northArrowSouthMiddleEast: (a, l) => ({
        top: o(a, l),
        left: a.left + a.width / 2 - l.width * 0.75 + e,
        name: "arrow_sme",
        ...s && { config: s }
      }),
      northArrowSouthEast: (a, l) => ({
        top: o(a, l),
        left: a.left + a.width / 2 - l.width + e,
        name: "arrow_se",
        ...s && { config: s }
      }),
      // ------- North east
      northEastArrowSouthWest: (a, l) => ({
        top: o(a, l),
        left: a.right - e,
        name: "arrow_sw",
        ...s && { config: s }
      }),
      northEastArrowSouthMiddleWest: (a, l) => ({
        top: o(a, l),
        left: a.right - l.width * 0.25 - e,
        name: "arrow_smw",
        ...s && { config: s }
      }),
      northEastArrowSouth: (a, l) => ({
        top: o(a, l),
        left: a.right - l.width / 2,
        name: "arrow_s",
        ...s && { config: s }
      }),
      northEastArrowSouthMiddleEast: (a, l) => ({
        top: o(a, l),
        left: a.right - l.width * 0.75 + e,
        name: "arrow_sme",
        ...s && { config: s }
      }),
      northEastArrowSouthEast: (a, l) => ({
        top: o(a, l),
        left: a.right - l.width + e,
        name: "arrow_se",
        ...s && { config: s }
      }),
      // ------- South west
      southWestArrowNorthWest: (a) => ({
        top: r(a),
        left: a.left - e,
        name: "arrow_nw",
        ...s && { config: s }
      }),
      southWestArrowNorthMiddleWest: (a, l) => ({
        top: r(a),
        left: a.left - l.width * 0.25 - e,
        name: "arrow_nmw",
        ...s && { config: s }
      }),
      southWestArrowNorth: (a, l) => ({
        top: r(a),
        left: a.left - l.width / 2,
        name: "arrow_n",
        ...s && { config: s }
      }),
      southWestArrowNorthMiddleEast: (a, l) => ({
        top: r(a),
        left: a.left - l.width * 0.75 + e,
        name: "arrow_nme",
        ...s && { config: s }
      }),
      southWestArrowNorthEast: (a, l) => ({
        top: r(a),
        left: a.left - l.width + e,
        name: "arrow_ne",
        ...s && { config: s }
      }),
      // ------- South
      southArrowNorthWest: (a) => ({
        top: r(a),
        left: a.left + a.width / 2 - e,
        name: "arrow_nw",
        ...s && { config: s }
      }),
      southArrowNorthMiddleWest: (a, l) => ({
        top: r(a),
        left: a.left + a.width / 2 - l.width * 0.25 - e,
        name: "arrow_nmw",
        ...s && { config: s }
      }),
      southArrowNorth: (a, l) => ({
        top: r(a),
        left: a.left + a.width / 2 - l.width / 2,
        name: "arrow_n",
        ...s && { config: s }
      }),
      southArrowNorthMiddleEast: (a, l) => ({
        top: r(a),
        left: a.left + a.width / 2 - l.width * 0.75 + e,
        name: "arrow_nme",
        ...s && { config: s }
      }),
      southArrowNorthEast: (a, l) => ({
        top: r(a),
        left: a.left + a.width / 2 - l.width + e,
        name: "arrow_ne",
        ...s && { config: s }
      }),
      // ------- South east
      southEastArrowNorthWest: (a) => ({
        top: r(a),
        left: a.right - e,
        name: "arrow_nw",
        ...s && { config: s }
      }),
      southEastArrowNorthMiddleWest: (a, l) => ({
        top: r(a),
        left: a.right - l.width * 0.25 - e,
        name: "arrow_nmw",
        ...s && { config: s }
      }),
      southEastArrowNorth: (a, l) => ({
        top: r(a),
        left: a.right - l.width / 2,
        name: "arrow_n",
        ...s && { config: s }
      }),
      southEastArrowNorthMiddleEast: (a, l) => ({
        top: r(a),
        left: a.right - l.width * 0.75 + e,
        name: "arrow_nme",
        ...s && { config: s }
      }),
      southEastArrowNorthEast: (a, l) => ({
        top: r(a),
        left: a.right - l.width + e,
        name: "arrow_ne",
        ...s && { config: s }
      }),
      // ------- West
      westArrowEast: (a, l) => ({
        top: a.top + a.height / 2 - l.height / 2,
        left: a.left - l.width - t,
        name: "arrow_e",
        ...s && { config: s }
      }),
      // ------- East
      eastArrowWest: (a, l) => ({
        top: a.top + a.height / 2 - l.height / 2,
        left: a.right + t,
        name: "arrow_w",
        ...s && { config: s }
      }),
      // ------- Sticky
      viewportStickyNorth: (a, l, c, u) => {
        const d = u || c;
        return !a.getIntersection(d) || d.height - a.height > i ? null : {
          top: d.top + i,
          left: a.left + a.width / 2 - l.width / 2,
          name: "arrowless",
          config: {
            withArrow: !1,
            ...s
          }
        };
      }
    };
    function o(a, l) {
      return a.top - l.height - t;
    }
    function r(a) {
      return a.bottom + t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const id = "ck-tooltip";
  class ge extends Me() {
    /**
     * Creates an instance of the tooltip manager.
     */
    constructor(e) {
      if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, this._mutationObserver = null, ge._editors.add(e), ge._instance)
        return ge._instance;
      ge._instance = this, this.tooltipTextView = new T(e.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-tooltip__text"
          ]
        },
        children: [
          {
            text: this.tooltipTextView.bindTemplate.to("text")
          }
        ]
      }), this.balloonPanelView = new ye(e.locale), this.balloonPanelView.class = id, this.balloonPanelView.content.add(this.tooltipTextView), this._mutationObserver = Rx(() => {
        this._updateTooltipPosition();
      }), this._pinTooltipDebounced = Rt(this._pinTooltip, 600), this._unpinTooltipDebounced = Rt(this._unpinTooltip, 400), this.listenTo(E.document, "keydown", this._onKeyDown.bind(this), { useCapture: !0 }), this.listenTo(E.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(E.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(E.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(E.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(E.document, "scroll", this._onScroll.bind(this), { useCapture: !0 }), this._watchdogExcluded = !0;
    }
    /**
     * Destroys the tooltip manager.
     *
     * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
     *
     * @param editor The editor the manager was created for.
     */
    destroy(e) {
      const t = e.ui.view && e.ui.view.body;
      ge._editors.delete(e), this.stopListening(e.ui), t && t.has(this.balloonPanelView) && t.remove(this.balloonPanelView), ge._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), ge._instance = null);
    }
    /**
     * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
     * name.
     *
     * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
     * @returns Positioning functions to be used by the {@link #balloonPanelView}.
     */
    static getPositioningFunctions(e) {
      const t = ge.defaultBalloonPositions;
      return {
        // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
        s: [
          t.southArrowNorth,
          t.southArrowNorthEast,
          t.southArrowNorthWest
        ],
        n: [t.northArrowSouth],
        e: [t.eastArrowWest],
        w: [t.westArrowEast],
        sw: [t.southArrowNorthEast],
        se: [t.southArrowNorthWest]
      }[e];
    }
    /**
     * Handles hiding tooltips on `keydown` in DOM.
     *
     * @param evt An object containing information about the fired event.
     * @param domEvent The DOM event.
     */
    _onKeyDown(e, t) {
      t.key === "Escape" && this._currentElementWithTooltip && (this._unpinTooltip(), t.stopPropagation());
    }
    /**
     * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
     *
     * @param evt An object containing information about the fired event.
     * @param domEvent The DOM event.
     */
    _onEnterOrFocus(e, { target: t }) {
      const i = Or(t);
      if (!i) {
        e.name === "focus" && this._unpinTooltip();
        return;
      }
      i !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(i, nd(i)));
    }
    /**
     * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
     *
     * @param evt An object containing information about the fired event.
     * @param domEvent The DOM event.
     */
    _onLeaveOrBlur(e, { target: t, relatedTarget: i }) {
      if (e.name === "mouseleave") {
        if (!fi(t))
          return;
        const s = this.balloonPanelView.element, o = s && (s === i || s.contains(i)), r = !o && t === s;
        if (o) {
          this._unpinTooltipDebounced.cancel();
          return;
        }
        if (!r && this._currentElementWithTooltip && t !== this._currentElementWithTooltip)
          return;
        const a = Or(t), l = Or(i);
        (r || a && a !== l) && this._unpinTooltipDebounced();
      } else {
        if (this._currentElementWithTooltip && t !== this._currentElementWithTooltip)
          return;
        this._unpinTooltipDebounced();
      }
    }
    /**
     * Handles hiding tooltips on `scroll` in DOM.
     *
     * @param evt An object containing information about the fired event.
     * @param domEvent The DOM event.
     */
    _onScroll(e, { target: t }) {
      this._currentElementWithTooltip && (t.contains(this.balloonPanelView.element) && t.contains(this._currentElementWithTooltip) || this._unpinTooltip());
    }
    /**
     * Pins the tooltip to a specific DOM element.
     *
     * @param options.text Text of the tooltip to display.
     * @param options.position The position of the tooltip.
     * @param options.cssClass Additional CSS class of the balloon with the tooltip.
     */
    _pinTooltip(e, { text: t, position: i, cssClass: s }) {
      this._unpinTooltip();
      const o = me(ge._editors.values()).ui.view.body;
      o.has(this.balloonPanelView) || o.add(this.balloonPanelView), this.tooltipTextView.text = t, this.balloonPanelView.pin({
        target: e,
        positions: ge.getPositioningFunctions(i)
      }), this._resizeObserver = new Y(e, () => {
        mi(e) || this._unpinTooltip();
      }), this._mutationObserver.attach(e), this.balloonPanelView.class = [id, s].filter((r) => r).join(" ");
      for (const r of ge._editors)
        this.listenTo(r.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
      this._currentElementWithTooltip = e, this._currentTooltipPosition = i;
    }
    /**
     * Unpins the tooltip and cancels all queued pinning.
     */
    _unpinTooltip() {
      this._unpinTooltipDebounced.cancel(), this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
      for (const e of ge._editors)
        this.stopListening(e.ui, "update");
      this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this.tooltipTextView.text = "", this._resizeObserver && this._resizeObserver.destroy(), this._mutationObserver.detach();
    }
    /**
     * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
     *
     * Hides the tooltip when the element is no longer visible in DOM or the tooltip text was removed.
     */
    _updateTooltipPosition() {
      const e = nd(this._currentElementWithTooltip);
      if (!mi(this._currentElementWithTooltip) || !e.text) {
        this._unpinTooltip();
        return;
      }
      this.balloonPanelView.pin({
        target: this._currentElementWithTooltip,
        positions: ge.getPositioningFunctions(e.position)
      });
    }
  }
  ge.defaultBalloonPositions = Ig({
    heightOffset: 5,
    sideOffset: 13
  });
  ge._editors = /* @__PURE__ */ new Set();
  ge._instance = null;
  function Or(n) {
    return fi(n) ? n.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
  }
  function nd(n) {
    return {
      text: n.dataset.ckeTooltipText,
      position: n.dataset.ckeTooltipPosition || "s",
      cssClass: n.dataset.ckeTooltipClass || ""
    };
  }
  function Rx(n) {
    const e = new MutationObserver(() => {
      n();
    });
    return {
      attach(t) {
        e.observe(t, {
          attributes: !0,
          attributeFilter: ["data-cke-tooltip-text", "data-cke-tooltip-position"]
        });
      },
      detach() {
        e.disconnect();
      }
    };
  }
  const Lx = `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>
`;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Vx = 53, Mx = 10, Bx = 50, Ox = 350, Nx = "Powered by";
  class Dx extends Me() {
    /**
     * Creates a "powered by" helper for a given editor. The feature is initialized on Editor#ready
     * event.
     *
     * @param editor
     */
    constructor(e) {
      super(), this.editor = e, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = Zi(this._showBalloon.bind(this), 50, { leading: !0 }), e.on("ready", this._handleEditorReady.bind(this));
    }
    /**
     * Destroys the "powered by" helper along with its view.
     */
    destroy() {
      const e = this._balloonView;
      e && (e.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening();
    }
    /**
     * Enables "powered by" label once the editor (ui) is ready.
     */
    _handleEditorReady() {
      const e = this.editor, t = !!e.config.get("ui.poweredBy.forceVisible");
      /* istanbul ignore next -- @preserve */
      !t && RC(e.config.get("licenseKey")) === "VALID" || e.ui.view && (e.ui.focusTracker.on("change:isFocused", (i, s, o) => {
        this._updateLastFocusedEditableElement(), o ? this._showBalloon() : this._hideBalloon();
      }), e.ui.focusTracker.on("change:focusedElement", (i, s, o) => {
        this._updateLastFocusedEditableElement(), o && this._showBalloon();
      }), e.ui.on("update", () => {
        this._showBalloonThrottled();
      }));
    }
    /**
     * Creates an instance of the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon panel}
     * with the "powered by" view inside ready for positioning.
     */
    _createBalloonView() {
      const e = this.editor, t = this._balloonView = new ye(), i = Rg(e), s = new Fx(e.locale, i.label);
      t.content.add(s), t.set({
        class: "ck-powered-by-balloon"
      }), e.ui.view.body.add(t), e.ui.focusTracker.add(t.element), this._balloonView = t;
    }
    /**
     * Attempts to display the balloon with the "powered by" view.
     */
    _showBalloon() {
      if (!this._lastFocusedEditableElement)
        return;
      const e = zx(this.editor, this._lastFocusedEditableElement);
      e && (this._balloonView || this._createBalloonView(), this._balloonView.pin(e));
    }
    /**
     * Hides the "powered by" balloon if already visible.
     */
    _hideBalloon() {
      this._balloonView && this._balloonView.unpin();
    }
    /**
     * Updates the {@link #_lastFocusedEditableElement} based on the state of the global focus tracker.
     */
    _updateLastFocusedEditableElement() {
      const e = this.editor, t = e.ui.focusTracker.isFocused, i = e.ui.focusTracker.focusedElement;
      if (!t || !i) {
        this._lastFocusedEditableElement = null;
        return;
      }
      const s = Array.from(e.ui.getEditableElementsNames()).map((o) => e.ui.getEditableElement(o));
      s.includes(i) ? this._lastFocusedEditableElement = i : this._lastFocusedEditableElement = s[0];
    }
  }
  class Fx extends T {
    /**
     * Created an instance of the "powered by" view.
     *
     * @param locale The localization services instance.
     * @param label The label text.
     */
    constructor(e, t) {
      super(e);
      const i = new dt(), s = this.bindTemplate;
      i.set({
        content: Lx,
        isColorInherited: !1
      }), i.extendTemplate({
        attributes: {
          style: {
            width: Vx + "px",
            height: Mx + "px"
          }
        }
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: ["ck", "ck-powered-by"],
          "aria-hidden": !0
        },
        children: [
          {
            tag: "a",
            attributes: {
              href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
              target: "_blank",
              tabindex: "-1"
            },
            children: [
              ...t ? [
                {
                  tag: "span",
                  attributes: {
                    class: ["ck", "ck-powered-by__label"]
                  },
                  children: [t]
                }
              ] : [],
              i
            ],
            on: {
              dragstart: s.to((o) => o.preventDefault())
            }
          }
        ]
      });
    }
  }
  function zx(n, e) {
    const t = Rg(n), i = t.side === "right" ? Ux(e, t) : Hx(e, t);
    return {
      target: e,
      positions: [i]
    };
  }
  function Ux(n, e) {
    return Pg(n, e, (t, i) => t.left + t.width - i.width - e.horizontalOffset);
  }
  function Hx(n, e) {
    return Pg(n, e, (t) => t.left + e.horizontalOffset);
  }
  function Pg(n, e, t) {
    return (i, s) => {
      const o = new O(n);
      if (o.width < Ox || o.height < Bx)
        return null;
      let r;
      e.position === "inside" ? r = o.bottom - s.height : r = o.bottom - s.height / 2, r -= e.verticalOffset;
      const a = t(o, s), c = i.clone().moveTo(a, r).getIntersection(s.clone().moveTo(a, r)).getVisible();
      return !c || c.getArea() < s.getArea() ? null : {
        top: r,
        left: a,
        name: `position_${e.position}-side_${e.side}`,
        config: {
          withArrow: !1
        }
      };
    };
  }
  function Rg(n) {
    const e = n.config.get("ui.poweredBy"), t = e && e.position || "border";
    return {
      position: t,
      label: Nx,
      verticalOffset: t === "inside" ? 5 : 0,
      horizontalOffset: 5,
      side: n.locale.contentLanguageDirection === "ltr" ? "right" : "left",
      ...e
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Lg = {
    POLITE: "polite",
    ASSERTIVE: "assertive"
  };
  class $x {
    /**
     * @inheritDoc
     */
    constructor(e) {
      this.editor = e;
    }
    /**
     * Sets an announcement text to an aria region associated with a specific editor feature. The text is then
     * announced by a screen reader to the user.
     *
     * If the aria region of a given name does not exist, it will be created and can be re-used later. The name of the region
     * groups announcements originating from a specific editor feature and does not get announced by a screen reader.
     *
     * Using multiple regions allows for many announcements to be emitted in a short period of time. Changes to ARIA-live announcements
     * are captured by a screen reader and read out in the order they were emitted.
     *
     * The default announcement politeness level is `'polite'`.
     *
     * ```ts
     * // Most screen readers will queue announcements from multiple aria-live regions and read them out in the order they were emitted.
     * editor.ui.ariaLiveAnnouncer.announce( 'image', 'Image uploaded.' );
     * editor.ui.ariaLiveAnnouncer.announce( 'network', 'Connection lost. Reconnecting.' );
     * ```
     */
    announce(e, t, i = Lg.POLITE) {
      const s = this.editor;
      this.view || (this.view = new Wx(s.locale), s.ui.view.body.add(this.view));
      let o = this.view.regionViews.find((r) => r.regionName === e);
      o || (o = new qx(this.view.locale), this.view.regionViews.add(o)), o.set({
        regionName: e,
        text: t,
        politeness: i
      });
    }
  }
  class Wx extends T {
    constructor(e) {
      super(e), this.regionViews = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-aria-live-announcer"
          ]
        },
        children: this.regionViews
      });
    }
  }
  class qx extends T {
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set("regionName", ""), this.set("text", ""), this.set("politeness", Lg.POLITE), this.setTemplate({
        tag: "div",
        attributes: {
          role: "region",
          "data-region": t.to("regionName"),
          "aria-live": t.to("politeness")
        },
        children: [
          { text: t.to("text") }
        ]
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Gx extends $() {
    /**
     * Creates an instance of the editor UI class.
     *
     * @param editor The editor instance.
     */
    constructor(e) {
      super(), this.isReady = !1, this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
      const t = e.editing.view;
      this.editor = e, this.componentFactory = new Ex(e), this.focusTracker = new Q(), this.tooltipManager = new ge(e), this.poweredBy = new Dx(e), this.ariaLiveAnnouncer = new $x(e), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
        this.isReady = !0;
      }), this.listenTo(t.document, "layoutChanged", this.update.bind(this)), this.listenTo(t, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)), this._initFocusTracking();
    }
    /**
     * The main (outermost) DOM element of the editor UI.
     *
     * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
     * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
     * it is the editable element itself (as there is no other wrapper). However, in
     * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
     * come with a single "main" HTML element (its editable element and toolbar are separate).
     *
     * This property can be understood as a shorthand for retrieving the element that a specific editor integration
     * considers to be its main DOM element.
     */
    get element() {
      return null;
    }
    /**
     * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
     *
     * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
     * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
     */
    update() {
      this.fire("update");
    }
    /**
     * Destroys the UI.
     */
    destroy() {
      this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
      for (const e of this._editableElementsMap.values())
        e.ckeditorInstance = null, this.editor.keystrokes.stopListening(e);
      this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
    }
    /**
     * Stores the native DOM editable element used by the editor under a unique name.
     *
     * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
     * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
     *
     * @param rootName The unique name of the editable element.
     * @param domElement The native DOM editable element.
     */
    setEditableElement(e, t) {
      this._editableElementsMap.set(e, t), t.ckeditorInstance || (t.ckeditorInstance = this.editor), this.focusTracker.add(t);
      const i = () => {
        this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t);
      };
      this.isReady ? i() : this.once("ready", i);
    }
    /**
     * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
     *
     * @param rootName The name of the editable element to remove.
     */
    removeEditableElement(e) {
      const t = this._editableElementsMap.get(e);
      t && (this._editableElementsMap.delete(e), this.editor.keystrokes.stopListening(t), this.focusTracker.remove(t), t.ckeditorInstance = null);
    }
    /**
     * Returns the editable editor element with the given name or null if editable does not exist.
     *
     * @param rootName The editable name.
     */
    getEditableElement(e = "main") {
      return this._editableElementsMap.get(e);
    }
    /**
     * Returns array of names of all editor editable elements.
     */
    getEditableElementsNames() {
      return this._editableElementsMap.keys();
    }
    /**
     * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
     *
     * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
     * Successive keystroke presses navigate over available toolbars.
     *
     * @param toolbarView A instance of the toolbar to be registered.
     */
    addToolbar(e, t = {}) {
      e.isRendered ? (this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
        this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element);
      }), this._focusableToolbarDefinitions.push({ toolbarView: e, options: t });
    }
    /**
     * Stores all editable elements used by the editor instance.
     *
     * @deprecated
     */
    get _editableElements() {
      return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
    }
    /**
     * Returns viewport offsets object:
     *
     * ```js
     * {
     * 	top: Number,
     * 	right: Number,
     * 	bottom: Number,
     * 	left: Number
     * }
     * ```
     *
     * Only top property is currently supported.
     */
    _readViewportOffsetFromConfig() {
      const e = this.editor, t = e.config.get("ui.viewportOffset");
      if (t)
        return t;
      const i = e.config.get("toolbar.viewportTopOffset");
      return i ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: i }) : { top: 0 };
    }
    /**
     * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
     * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
     * to allow users navigate across the UI.
     */
    _initFocusTracking() {
      const e = this.editor, t = e.editing.view;
      let i, s;
      e.keystrokes.set("Alt+F10", (o, r) => {
        const a = this.focusTracker.focusedElement;
        Array.from(this._editableElementsMap.values()).includes(a) && !Array.from(t.domRoots.values()).includes(a) && (i = a);
        const l = this._getCurrentFocusedToolbarDefinition();
        (!l || !s) && (s = this._getFocusableCandidateToolbarDefinitions());
        for (let c = 0; c < s.length; c++) {
          const u = s.shift();
          if (s.push(u), u !== l && this._focusFocusableCandidateToolbar(u)) {
            l && l.options.afterBlur && l.options.afterBlur();
            break;
          }
        }
        r();
      }), e.keystrokes.set("Esc", (o, r) => {
        const a = this._getCurrentFocusedToolbarDefinition();
        a && (i ? (i.focus(), i = null) : e.editing.view.focus(), a.options.afterBlur && a.options.afterBlur(), r());
      });
    }
    /**
     * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
     *
     * Focusable toolbars candidates are either:
     * * already visible,
     * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
     * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
     * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
     *
     * **Note**: Contextual toolbars take precedence over regular toolbars.
     */
    _getFocusableCandidateToolbarDefinitions() {
      const e = [];
      for (const t of this._focusableToolbarDefinitions) {
        const { toolbarView: i, options: s } = t;
        (mi(i.element) || s.beforeFocus) && e.push(t);
      }
      return e.sort((t, i) => sd(t) - sd(i)), e;
    }
    /**
     * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
     *
     * `null` is returned when no toolbar is currently focused.
     */
    _getCurrentFocusedToolbarDefinition() {
      for (const e of this._focusableToolbarDefinitions)
        if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement))
          return e;
      return null;
    }
    /**
     * Focuses a focusable toolbar candidate using its definition.
     *
     * @param candidateToolbarDefinition A definition of the toolbar to focus.
     * @returns `true` when the toolbar candidate was focused. `false` otherwise.
     */
    _focusFocusableCandidateToolbar(e) {
      const { toolbarView: t, options: { beforeFocus: i } } = e;
      return i && i(), mi(t.element) ? (t.focus(), !0) : !1;
    }
    /**
     * Provides an integration between {@link #viewportOffset} and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
     * It allows the UI-agnostic engine method to consider user-configured viewport offsets specific for the integration.
     *
     * @param evt The `scrollToTheSelection` event info.
     * @param data The payload carried by the `scrollToTheSelection` event.
     */
    _handleScrollToTheSelection(e, t) {
      const i = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        ...this.viewportOffset
      };
      t.viewportOffset.top += i.top, t.viewportOffset.bottom += i.bottom, t.viewportOffset.left += i.left, t.viewportOffset.right += i.right;
    }
  }
  function sd(n) {
    const { toolbarView: e, options: t } = n;
    let i = 10;
    return mi(e.element) && i--, t.isContextual && i--, i;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class jx extends T {
    /**
     * Creates an instance of the editor UI view class.
     *
     * @param locale The locale instance.
     */
    constructor(e) {
      super(e), this.body = new mA(e);
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.body.attachToDom();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      return this.body.detachFromDom(), super.destroy();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Kx extends jx {
    /**
     * Creates an instance of the boxed editor UI view class.
     *
     * @param locale The locale instance..
     */
    constructor(e) {
      super(e), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-reset",
            "ck-editor",
            "ck-rounded-corners"
          ],
          role: "application",
          dir: e.uiLanguageDirection,
          lang: e.uiLanguage,
          "aria-labelledby": this._voiceLabelView.id
        },
        children: [
          this._voiceLabelView,
          {
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-editor__top",
                "ck-reset_all"
              ],
              role: "presentation"
            },
            children: this.top
          },
          {
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-editor__main"
              ],
              role: "presentation"
            },
            children: this.main
          }
        ]
      });
    }
    /**
     * Creates a voice label view instance.
     */
    _createVoiceLabel() {
      const e = this.t, t = new Fe();
      return t.text = e("Rich Text Editor"), t.extendTemplate({
        attributes: {
          class: "ck-voice-label"
        }
      }), t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Zx extends T {
    /**
     * Creates an instance of EditableUIView class.
     *
     * @param locale The locale instance.
     * @param editingView The editing view instance the editable is related to.
     * @param editableElement The editable element. If not specified, this view
     * should create it. Otherwise, the existing element should be used.
     */
    constructor(e, t, i) {
      super(e), this.name = null, this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-content",
            "ck-editor__editable",
            "ck-rounded-corners"
          ],
          lang: e.contentLanguage,
          dir: e.contentLanguageDirection
        }
      }), this.set("isFocused", !1), this._editableElement = i, this._hasExternalElement = !!this._editableElement, this._editingView = t;
    }
    /**
     * Renders the view by either applying the {@link #template} to the existing
     * {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement} or assigning {@link #element}
     * as {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement}.
     */
    render() {
      super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
    }
    /**
     * Whether an external {@link #_editableElement} was passed into the constructor, which also means
     * the view will not render its {@link #template}.
     */
    get hasExternalElement() {
      return this._hasExternalElement;
    }
    /**
     * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
     * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
     */
    _updateIsFocusedClasses() {
      const e = this._editingView;
      e.isRenderingInProgress ? i(this) : t(this);
      function t(s) {
        e.change((o) => {
          const r = e.document.getRoot(s.name);
          o.addClass(s.isFocused ? "ck-focused" : "ck-blurred", r), o.removeClass(s.isFocused ? "ck-blurred" : "ck-focused", r);
        });
      }
      function i(s) {
        e.once("change:isRenderingInProgress", (o, r, a) => {
          a ? i(s) : t(s);
        });
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Jx extends Zx {
    /**
     * Creates an instance of the InlineEditableUIView class.
     *
     * @param locale The locale instance.
     * @param editingView The editing view instance the editable is related to.
     * @param editableElement The editable element. If not specified, the
     * {@link module:ui/editableui/editableuiview~EditableUIView}
     * will create it. Otherwise, the existing element will be used.
     * @param options Additional configuration of the view.
     * @param options.label A function that gets called with the instance of this view as an argument
     * and should return a string that represents the label of the editable for assistive technologies. If not provided,
     * a default label generator is used.
     */
    constructor(e, t, i, s = {}) {
      super(e, t, i);
      const o = e.t;
      this.extendTemplate({
        attributes: {
          role: "textbox",
          class: "ck-editor__editable_inline"
        }
      }), this._generateLabel = s.label || (() => o("Editor editing area: %0", this.name));
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render();
      const e = this._editingView;
      e.change((t) => {
        const i = e.document.getRoot(this.name);
        t.setAttribute("aria-label", this._generateLabel(this), i);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class od extends Zo {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Notification";
    }
    /**
     * @inheritDoc
     */
    init() {
      this.on("show:warning", (e, t) => {
        window.alert(t.message);
      }, { priority: "lowest" });
    }
    /**
     * Shows a success notification.
     *
     * By default, it fires the {@link #event:show:success `show:success` event} with the given `data`. The event namespace can be extended
     * using the `data.namespace` option. For example:
     *
     * ```ts
     * showSuccess( 'Image is uploaded.', {
     * 	namespace: 'upload:image'
     * } );
     * ```
     *
     * will fire the `show:success:upload:image` event.
     *
     * You can provide the title of the notification:
     *
     * ```ts
     * showSuccess( 'Image is uploaded.', {
     * 	title: 'Image upload success'
     * } );
     * ```
     *
     * @param message The content of the notification.
     * @param data Additional data.
     * @param data.namespace Additional event namespace.
     * @param data.title The title of the notification.
     */
    showSuccess(e, t = {}) {
      this._showNotification({
        message: e,
        type: "success",
        namespace: t.namespace,
        title: t.title
      });
    }
    /**
     * Shows an information notification.
     *
     * By default, it fires the {@link #event:show:info `show:info` event} with the given `data`. The event namespace can be extended
     * using the `data.namespace` option. For example:
     *
     * ```ts
     * showInfo( 'Editor is offline.', {
     * 	namespace: 'editor:status'
     * } );
     * ```
     *
     * will fire the `show:info:editor:status` event.
     *
     * You can provide the title of the notification:
     *
     * ```ts
     * showInfo( 'Editor is offline.', {
     * 	title: 'Network information'
     * } );
     * ```
     *
     * @param message The content of the notification.
     * @param data Additional data.
     * @param data.namespace Additional event namespace.
     * @param data.title The title of the notification.
     */
    showInfo(e, t = {}) {
      this._showNotification({
        message: e,
        type: "info",
        namespace: t.namespace,
        title: t.title
      });
    }
    /**
     * Shows a warning notification.
     *
     * By default, it fires the {@link #event:show:warning `show:warning` event}
     * with the given `data`. The event namespace can be extended using the `data.namespace` option. For example:
     *
     * ```ts
     * showWarning( 'Image upload error.', {
     * 	namespace: 'upload:image'
     * } );
     * ```
     *
     * will fire the `show:warning:upload:image` event.
     *
     * You can provide the title of the notification:
     *
     * ```ts
     * showWarning( 'Image upload error.', {
     * 	title: 'Upload failed'
     * } );
     * ```
     *
     * Note that each unhandled and not stopped `warning` notification will be displayed as a system alert.
     * The plugin responsible for displaying warnings should `stop()` the event to prevent displaying it as an alert:
     *
     * ```ts
     * notifications.on( 'show:warning', ( evt, data ) => {
     * 	// Do something with the data.
     *
     * 	// Stop this event to prevent displaying it as an alert.
     * 	evt.stop();
     * } );
     * ```
     *
     * You can attach many listeners to the same event and `stop()` this event in a listener with a low priority:
     *
     * ```ts
     * notifications.on( 'show:warning', ( evt, data ) => {
     * 	// Show the warning in the UI, but do not stop it.
     * } );
     *
     * notifications.on( 'show:warning', ( evt, data ) => {
     * 	// Log the warning to some error tracker.
     *
     * 	// Stop this event to prevent displaying it as an alert.
     * 	evt.stop();
     * }, { priority: 'low' } );
     * ```
     *
     * @param message The content of the notification.
     * @param data Additional data.
     * @param data.namespace Additional event namespace.
     * @param data.title The title of the notification.
     */
    showWarning(e, t = {}) {
      this._showNotification({
        message: e,
        type: "warning",
        namespace: t.namespace,
        title: t.title
      });
    }
    /**
     * Fires the `show` event with the specified type, namespace and message.
     *
     * @param data The message data.
     * @param data.message The content of the notification.
     * @param data.type The type of the message.
     * @param data.namespace Additional event namespace.
     * @param data.title The title of the notification.
     */
    _showNotification(e) {
      const t = e.namespace ? `show:${e.type}:${e.namespace}` : `show:${e.type}`;
      this.fire(t, {
        message: e.message,
        type: e.type,
        title: e.title || ""
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class yi extends $() {
    /**
     * Creates a new Model instance.
     *
     * @param attributes The model state attributes to be defined during the instance creation.
     * @param properties The (out of state) properties to be appended to the instance during creation.
     */
    constructor(e, t) {
      super(), t && _f(this, t), e && this.set(e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Fs = dn("px");
  class $t extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ContextualBalloon";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
        const t = this.editor.editing.view, s = t.document.selection.editableElement;
        return s ? t.domConverter.mapViewToDom(s.root) : null;
      }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
    }
    /**
     * The common balloon panel view.
     */
    get view() {
      return this._view || this._createPanelView(), this._view;
    }
    /**
     * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.
     */
    hasView(e) {
      return Array.from(this._viewToStack.keys()).includes(e);
    }
    /**
     * Adds a new view to the stack and makes it visible if the current stack is visible
     * or it is the first view in the balloon.
     *
     * @param data The configuration of the view.
     * @param data.stackId The ID of the stack that the view is added to. Defaults to `'main'`.
     * @param data.view The content of the balloon.
     * @param data.position Positioning options.
     * @param data.balloonClassName An additional CSS class added to the {@link #view balloon} when visible.
     * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow. Defaults to `true`.
     * @param data.singleViewMode Whether the view should be the only visible view even if other stacks were added. Defaults to `false`.
     */
    add(e) {
      if (this._view || this._createPanelView(), this.hasView(e.view))
        throw new g("contextualballoon-add-view-exist", [this, e]);
      const t = e.stackId || "main";
      if (!this._idToStack.has(t)) {
        this._idToStack.set(t, /* @__PURE__ */ new Map([[e.view, e]])), this._viewToStack.set(e.view, this._idToStack.get(t)), this._numberOfStacks = this._idToStack.size, (!this._visibleStack || e.singleViewMode) && this.showStack(t);
        return;
      }
      const i = this._idToStack.get(t);
      e.singleViewMode && this.showStack(t), i.set(e.view, e), this._viewToStack.set(e.view, i), i === this._visibleStack && this._showView(e);
    }
    /**
     * Removes the given view from the stack. If the removed view was visible,
     * the view preceding it in the stack will become visible instead.
     * When there is no view in the stack, the next stack will be displayed.
     * When there are no more stacks, the balloon will hide.
     *
     * @param view A view to be removed from the balloon.
     */
    remove(e) {
      if (!this.hasView(e))
        throw new g("contextualballoon-remove-view-not-exist", [this, e]);
      const t = this._viewToStack.get(e);
      this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1), this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])), t.size === 1 ? (this._idToStack.delete(this._getStackId(t)), this._numberOfStacks = this._idToStack.size) : t.delete(e), this._viewToStack.delete(e);
    }
    /**
     * Updates the position of the balloon using the position data of the first visible view in the stack.
     * When new position data is given, the position data of the currently visible view will be updated.
     *
     * @param position Position options.
     */
    updatePosition(e) {
      e && (this._visibleStack.get(this.visibleView).position = e), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
    }
    /**
     * Shows the last view from the stack of a given ID.
     */
    showStack(e) {
      this.visibleStack = e;
      const t = this._idToStack.get(e);
      if (!t)
        throw new g("contextualballoon-showstack-stack-not-exist", this);
      this._visibleStack !== t && this._showView(Array.from(t.values()).pop());
    }
    /**
     * Initializes view instances.
     */
    _createPanelView() {
      this._view = new ye(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
    }
    /**
     * Returns the stack of the currently visible view.
     */
    get _visibleStack() {
      return this._viewToStack.get(this.visibleView);
    }
    /**
     * Returns the ID of the given stack.
     */
    _getStackId(e) {
      return Array.from(this._idToStack.entries()).find((i) => i[1] === e)[0];
    }
    /**
     * Shows the last view from the next stack.
     */
    _showNextStack() {
      const e = Array.from(this._idToStack.values());
      let t = e.indexOf(this._visibleStack) + 1;
      e[t] || (t = 0), this.showStack(this._getStackId(e[t]));
    }
    /**
     * Shows the last view from the previous stack.
     */
    _showPrevStack() {
      const e = Array.from(this._idToStack.values());
      let t = e.indexOf(this._visibleStack) - 1;
      e[t] || (t = e.length - 1), this.showStack(this._getStackId(e[t]));
    }
    /**
     * Creates a rotator view.
     */
    _createRotatorView() {
      const e = new Xx(this.editor.locale), t = this.editor.locale.t;
      return this.view.content.add(e), e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (i, s) => !s && i > 1), e.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (i, s) => {
        if (s < 2)
          return "";
        const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
        return t("%0 of %1", [o, s]);
      }), e.buttonNextView.on("execute", () => {
        e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
      }), e.buttonPrevView.on("execute", () => {
        e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
      }), e;
    }
    /**
     * Creates a fake panels view.
     */
    _createFakePanelsView() {
      const e = new Yx(this.editor.locale, this.view);
      return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, i) => !i && t >= 2 ? Math.min(t - 1, 2) : 0), e.listenTo(this.view, "change:top", () => e.updatePosition()), e.listenTo(this.view, "change:left", () => e.updatePosition()), this.editor.ui.view.body.add(e), e;
    }
    /**
     * Sets the view as the content of the balloon and attaches the balloon using position
     * options of the first view.
     *
     * @param data Configuration.
     * @param data.view The view to show in the balloon.
     * @param data.balloonClassName Additional class name which will be added to the {@link #view balloon}.
     * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow.
     */
    _showView({ view: e, balloonClassName: t = "", withArrow: i = !0, singleViewMode: s = !1 }) {
      this.view.class = t, this.view.withArrow = i, this._rotatorView.showView(e), this.visibleView = e, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), s && (this._singleViewMode = !0);
    }
    /**
     * Returns position options of the last view in the stack.
     * This keeps the balloon in the same position when the view is changed.
     */
    _getBalloonPosition() {
      let e = Array.from(this._visibleStack.values()).pop().position;
      return e && (e.limiter || (e = Object.assign({}, e, {
        limiter: this.positionLimiter
      })), e = Object.assign({}, e, {
        viewportOffsetConfig: this.editor.ui.viewportOffset
      })), e;
    }
  }
  class Xx extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = e.t, i = this.bindTemplate;
      this.set("isNavigationVisible", !0), this.focusTracker = new Q(), this.buttonPrevView = this._createButtonView(t("Previous"), x.previousArrow), this.buttonNextView = this._createButtonView(t("Next"), x.nextArrow), this.content = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-balloon-rotator"
          ],
          "z-index": "-1"
        },
        children: [
          {
            tag: "div",
            attributes: {
              class: [
                "ck-balloon-rotator__navigation",
                i.to("isNavigationVisible", (s) => s ? "" : "ck-hidden")
              ]
            },
            children: [
              this.buttonPrevView,
              {
                tag: "span",
                attributes: {
                  class: [
                    "ck-balloon-rotator__counter"
                  ]
                },
                children: [
                  {
                    text: i.to("counter")
                  }
                ]
              },
              this.buttonNextView
            ]
          },
          {
            tag: "div",
            attributes: {
              class: "ck-balloon-rotator__content"
            },
            children: this.content
          }
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.focusTracker.add(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy();
    }
    /**
     * Shows a given view.
     *
     * @param view The view to show.
     */
    showView(e) {
      this.hideView(), this.content.add(e);
    }
    /**
     * Hides the currently displayed view.
     */
    hideView() {
      this.content.clear();
    }
    /**
     * Creates a navigation button view.
     *
     * @param label The button label.
     * @param icon The button icon.
     */
    _createButtonView(e, t) {
      const i = new P(this.locale);
      return i.set({
        label: e,
        icon: t,
        tooltip: !0
      }), i;
    }
  }
  class Yx extends T {
    /**
     * @inheritDoc
     */
    constructor(e, t) {
      super(e);
      const i = this.bindTemplate;
      this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t, this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck-fake-panel",
            i.to("numberOfPanels", (s) => s ? "" : "ck-hidden")
          ],
          style: {
            top: i.to("top", Fs),
            left: i.to("left", Fs),
            width: i.to("width", Fs),
            height: i.to("height", Fs)
          }
        },
        children: this.content
      }), this.on("change:numberOfPanels", (s, o, r, a) => {
        r > a ? this._addPanels(r - a) : this._removePanels(a - r), this.updatePosition();
      });
    }
    _addPanels(e) {
      for (; e--; ) {
        const t = new T();
        t.setTemplate({ tag: "div" }), this.content.add(t), this.registerChild(t);
      }
    }
    _removePanels(e) {
      for (; e--; ) {
        const t = this.content.last;
        this.content.remove(t), this.deregisterChild(t), t.destroy();
      }
    }
    /**
     * Updates coordinates of fake panels.
     */
    updatePosition() {
      if (this.numberOfPanels) {
        const { top: e, left: t } = this._balloonPanelView, { width: i, height: s } = new O(this._balloonPanelView.element);
        Object.assign(this, { top: e, left: t, width: i, height: s });
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Vi = dn("px");
  class Qx extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheBottomOfLimiter", !1), this.set("_stickyTopOffset", null), this.set("_stickyBottomOffset", null), this.content = this.createCollection(), this._contentPanelPlaceholder = new Ve({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-sticky-panel__placeholder"
          ],
          style: {
            display: t.to("isSticky", (i) => i ? "block" : "none"),
            height: t.to("isSticky", (i) => i ? Vi(this._contentPanelRect.height) : null)
          }
        }
      }).render(), this.contentPanelElement = new Ve({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-sticky-panel__content",
            // Toggle class of the panel when "sticky" state changes in the view.
            t.if("isSticky", "ck-sticky-panel__content_sticky"),
            t.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")
          ],
          style: {
            width: t.to("isSticky", (i) => i ? Vi(this._contentPanelPlaceholder.getBoundingClientRect().width) : null),
            top: t.to("_stickyTopOffset", (i) => i && Vi(i)),
            bottom: t.to("_stickyBottomOffset", (i) => i && Vi(i)),
            marginLeft: t.to("_marginLeft")
          }
        },
        children: this.content
      }).render(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-sticky-panel"
          ]
        },
        children: [
          this._contentPanelPlaceholder,
          this.contentPanelElement
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.checkIfShouldBeSticky(), this.listenTo(E.document, "scroll", () => {
        this.checkIfShouldBeSticky();
      }, { useCapture: !0 }), this.listenTo(this, "change:isActive", () => {
        this.checkIfShouldBeSticky();
      });
    }
    /**
     * Analyzes the environment to decide whether the panel should be sticky or not.
     * Then handles the positioning of the panel.
     */
    checkIfShouldBeSticky() {
      if (!this.limiterElement || !this.isActive) {
        this._unstick();
        return;
      }
      const e = new O(this.limiterElement);
      let t = e.getVisible();
      if (t) {
        const i = new O(E.window);
        i.top += this.viewportTopOffset, i.height -= this.viewportTopOffset, t = t.getIntersection(i);
      }
      if (t && e.top < t.top) {
        const i = t.top;
        if (i + this._contentPanelRect.height + this.limiterBottomOffset > t.bottom) {
          const s = Math.max(e.bottom - t.bottom, 0) + this.limiterBottomOffset;
          e.bottom - s > e.top + this._contentPanelRect.height ? this._stickToBottomOfLimiter(s) : this._unstick();
        } else
          this._contentPanelRect.height + this.limiterBottomOffset < e.height ? this._stickToTopOfAncestors(i) : this._unstick();
      } else
        this._unstick();
    }
    /**
     * Sticks the panel at the given CSS `top` offset.
     *
     * @private
     * @param topOffset
     */
    _stickToTopOfAncestors(e) {
      this.isSticky = !0, this._isStickyToTheBottomOfLimiter = !1, this._stickyTopOffset = e, this._stickyBottomOffset = null, this._marginLeft = Vi(-E.window.scrollX);
    }
    /**
     * Sticks the panel at the bottom of the limiter with a given CSS `bottom` offset.
     *
     * @private
     * @param stickyBottomOffset
     */
    _stickToBottomOfLimiter(e) {
      this.isSticky = !0, this._isStickyToTheBottomOfLimiter = !0, this._stickyTopOffset = null, this._stickyBottomOffset = e, this._marginLeft = Vi(-E.window.scrollX);
    }
    /**
     * Unsticks the panel putting it back to its original position.
     *
     * @private
     */
    _unstick() {
      this.isSticky = !1, this._isStickyToTheBottomOfLimiter = !1, this._stickyTopOffset = null, this._stickyBottomOffset = null, this._marginLeft = null;
    }
    /**
     * Returns the bounding rect of the {@link #contentPanelElement}.
     *
     * @private
     */
    get _contentPanelRect() {
      return new O(this.contentPanelElement);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class eS extends he {
    /**
     * @inheritDoc
     */
    constructor(e, t) {
      const i = e.t, s = Object.assign({}, {
        showResetButton: !0,
        showIcon: !0,
        creator: ze
      }, t);
      super(e, s.creator), this.label = t.label, this._viewConfig = s, this._viewConfig.showIcon && (this.iconView = new dt(), this.iconView.content = x.loupe, this.fieldWrapperChildren.add(this.iconView, 0), this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-icon"
        }
      })), this._viewConfig.showResetButton && (this.resetButtonView = new P(e), this.resetButtonView.set({
        label: i("Clear"),
        icon: x.cancel,
        class: "ck-search__reset",
        isVisible: !1,
        tooltip: !0
      }), this.resetButtonView.on("execute", () => {
        this.reset(), this.focus(), this.fire("reset");
      }), this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (o) => !o), this.fieldWrapperChildren.add(this.resetButtonView), this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-reset"
        }
      }));
    }
    /**
     * Resets the search field to its default state.
     */
    reset() {
      this.fieldView.reset(), this._viewConfig.showResetButton && (this.resetButtonView.isVisible = !1);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class tS extends T {
    /**
     * @inheritDoc
     */
    constructor() {
      super();
      const e = this.bindTemplate;
      this.set({
        isVisible: !1,
        primaryText: "",
        secondaryText: ""
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-search__info",
            e.if("isVisible", "ck-hidden", (t) => !t)
          ],
          tabindex: -1
        },
        children: [
          {
            tag: "span",
            children: [
              {
                text: [e.to("primaryText")]
              }
            ]
          },
          {
            tag: "span",
            children: [
              {
                text: [e.to("secondaryText")]
              }
            ]
          }
        ]
      });
    }
    /**
     * Focuses the view
     */
    focus() {
      this.element.focus();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class iS extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.children = this.createCollection(), this.focusTracker = new Q(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-search__results"
          ],
          tabindex: -1
        },
        children: this.children
      }), this._focusCycler = new _e({
        focusables: this.children,
        focusTracker: this.focusTracker
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render();
      for (const e of this.children)
        this.focusTracker.add(e.element);
    }
    /**
     * Focuses the view.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the first child view.
     */
    focusFirst() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the last child view.
     */
    focusLast() {
      this._focusCycler.focusLast();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class nS extends T {
    /**
     * Creates an instance of the {@link module:ui/search/text/searchtextview~SearchTextView} class.
     *
     * @param locale The localization services instance.
     * @param config Configuration of the view.
     */
    constructor(e, t) {
      super(e), this._config = t, this.filteredView = t.filteredView, this.queryView = this._createSearchTextQueryView(), this.focusTracker = new Q(), this.keystrokes = new ne(), this.resultsView = new iS(e), this.children = this.createCollection(), this.focusableChildren = this.createCollection([this.queryView, this.resultsView]), this.set("isEnabled", !0), this.set("resultsCount", 0), this.set("totalItemsCount", 0), t.infoView && t.infoView.instance ? this.infoView = t.infoView.instance : (this.infoView = new tS(), this._enableDefaultInfoViewBehavior(), this.on("render", () => {
        this.search("");
      })), this.resultsView.children.addMany([this.infoView, this.filteredView]), this.focusCycler = new _e({
        focusables: this.focusableChildren,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      }), this.on("search", (i, { resultsCount: s, totalItemsCount: o }) => {
        this.resultsCount = s, this.totalItemsCount = o;
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-search",
            t.class || null
          ],
          tabindex: "-1"
        },
        children: this.children
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.children.addMany([
        this.queryView,
        this.resultsView
      ]);
      const e = (t) => t.stopPropagation();
      for (const t of this.focusableChildren)
        this.focusTracker.add(t.element);
      this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e);
    }
    /**
     * Focuses the {@link #queryView}.
     */
    focus() {
      this.queryView.focus();
    }
    /**
     * Resets the component to its initial state.
     */
    reset() {
      this.queryView.reset(), this.search("");
    }
    /**
     * Searches the {@link #filteredView} for the given query.
     *
     * @internal
     * @param query The search query string.
     */
    search(e) {
      const t = e ? new RegExp(jf(e), "ig") : null, i = this.filteredView.filter(t);
      this.fire("search", { query: e, ...i });
    }
    /**
     * Creates a search field view based on configured creator..
     */
    _createSearchTextQueryView() {
      const e = new eS(this.locale, this._config.queryView);
      return this.listenTo(e.fieldView, "input", () => {
        this.search(e.fieldView.element.value);
      }), e.on("reset", () => this.reset()), e.bind("isEnabled").to(this), e;
    }
    /**
     * Initializes the default {@link #infoView} behavior with default text labels when no custom info view
     * was specified in the view config.
     */
    _enableDefaultInfoViewBehavior() {
      const e = this.locale.t, t = this.infoView;
      this.on("search", (s, o) => {
        if (o.resultsCount)
          t.set({
            isVisible: !1
          });
        else {
          const r = this._config.infoView && this._config.infoView.text;
          let a, l;
          o.totalItemsCount ? r && r.notFound ? (a = r.notFound.primary, l = r.notFound.secondary) : (a = e("No results found"), l = "") : r && r.noSearchableItems ? (a = r.noSearchableItems.primary, l = r.noSearchableItems.secondary) : (a = e("No searchable items"), l = ""), t.set({
            primaryText: i(a, o),
            secondaryText: i(l, o),
            isVisible: !0
          });
        }
      });
      function i(s, { query: o, resultsCount: r, totalItemsCount: a }) {
        return typeof s == "function" ? s(o, r, a) : s;
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class as extends nS {
    /**
     * @inheritDoc
     */
    constructor(e, t) {
      super(e, t), this._config = t;
      const i = dn("px");
      this.extendTemplate({
        attributes: {
          class: ["ck-autocomplete"]
        }
      });
      const s = this.resultsView.bindTemplate;
      this.resultsView.set("isVisible", !1), this.resultsView.set("_position", "s"), this.resultsView.set("_width", 0), this.resultsView.extendTemplate({
        attributes: {
          class: [
            s.if("isVisible", "ck-hidden", (o) => !o),
            s.to("_position", (o) => `ck-search__results_${o}`)
          ],
          style: {
            width: s.to("_width", i)
          }
        }
      }), this.focusTracker.on("change:isFocused", (o, r, a) => {
        this._updateResultsVisibility(), a ? this.resultsView.element.scrollTop = 0 : t.resetOnBlur && this.queryView.reset();
      }), this.on("search", () => {
        this._updateResultsVisibility(), this._updateResultsViewWidthAndPosition();
      }), this.keystrokes.set("esc", (o, r) => {
        this.resultsView.isVisible && (this.queryView.focus(), this.resultsView.isVisible = !1, r());
      }), this.listenTo(E.document, "scroll", () => {
        this._updateResultsViewWidthAndPosition();
      }), this.on("change:isEnabled", () => {
        this._updateResultsVisibility();
      }), this.filteredView.on("execute", (o, { value: r }) => {
        this.focus(), this.reset(), this.queryView.fieldView.value = this.queryView.fieldView.element.value = r, this.resultsView.isVisible = !1;
      }), this.resultsView.on("change:isVisible", () => {
        this._updateResultsViewWidthAndPosition();
      });
    }
    /**
     * Updates the position of the results view on demand.
     */
    _updateResultsViewWidthAndPosition() {
      if (!this.resultsView.isVisible)
        return;
      this.resultsView._width = new O(this.queryView.fieldView.element).width;
      const e = as._getOptimalPosition({
        element: this.resultsView.element,
        target: this.queryView.element,
        fitInViewport: !0,
        positions: as.defaultResultsPositions
      });
      this.resultsView._position = e ? e.name : "s";
    }
    /**
     * Updates the visibility of the results view on demand.
     */
    _updateResultsVisibility() {
      const e = typeof this._config.queryMinChars == "undefined" ? 0 : this._config.queryMinChars, t = this.queryView.fieldView.element.value.length;
      this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && t >= e;
    }
  }
  as.defaultResultsPositions = [
    (n) => ({
      top: n.bottom,
      left: n.left,
      name: "s"
    }),
    (n, e) => ({
      top: n.top - e.height,
      left: n.left,
      name: "n"
    })
  ];
  as._getOptimalPosition = Ko;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class sS extends P {
    /**
     * Creates an instance of the menu bar button view.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set({
        withText: !0,
        role: "menuitem"
      }), this.arrowView = this._createArrowView(), this.extendTemplate({
        attributes: {
          class: [
            "ck-menu-bar__menu__button"
          ],
          "aria-haspopup": !0,
          "aria-expanded": this.bindTemplate.to("isOn", (i) => String(i)),
          "data-cke-tooltip-disabled": t.to("isOn")
        },
        on: {
          mouseenter: t.to("mouseenter")
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.children.add(this.arrowView);
    }
    /**
     * Creates the {@link #arrowView} instance.
     */
    _createArrowView() {
      const e = new dt();
      return e.content = nr, e.extendTemplate({
        attributes: {
          class: "ck-menu-bar__menu__button__arrow"
        }
      }), e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class fn extends tn {
    /**
     * Creates an instance of the list item view.
     *
     * @param locale The localization services instance.
     */
    constructor(e, t) {
      super(e);
      const i = this.bindTemplate;
      this.extendTemplate({
        attributes: {
          class: [
            "ck-menu-bar__menu__item"
          ]
        },
        on: {
          mouseenter: i.to("mouseenter")
        }
      }), this.delegate("mouseenter").to(t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const zs = 5, yn = {
    /**
     * When the bar is already open:
     * * Opens the menu when the user hovers over its button.
     * * Closes open menu when another menu's button gets hovered.
     */
    toggleMenusAndFocusItemsOnHover(n) {
      n.on("menu:mouseenter", (e) => {
        if (n.isOpen) {
          for (const t of n.menus) {
            const i = e.path[0], s = i instanceof fn && i.children.first === t;
            t.isOpen = (e.path.includes(t) || s) && t.isEnabled;
          }
          e.source.focus();
        }
      });
    },
    /**
     * Moves between top-level menus using the arrow left and right keys.
     *
     * If the menubar has already been open, the arrow keys move focus between top-level menu buttons and open them.
     * If the menubar is closed, the arrow keys only move focus between top-level menu buttons.
     */
    focusCycleMenusOnArrows(n) {
      const e = n.locale.uiLanguageDirection === "rtl";
      n.on("menu:arrowright", (i) => {
        t(i.source, e ? -1 : 1);
      }), n.on("menu:arrowleft", (i) => {
        t(i.source, e ? 1 : -1);
      });
      function t(i, s) {
        const o = n.children.getIndex(i), r = i.isOpen, a = n.children.length, l = n.children.get((o + a + s) % a);
        i.isOpen = !1, r && (l.isOpen = !0), l.buttonView.focus();
      }
    },
    /**
     * Closes the entire sub-menu structure when the bar is closed. This prevents sub-menus from being open if the user
     * closes the entire bar, and then re-opens some top-level menu.
     */
    closeMenusWhenTheBarCloses(n) {
      n.on("change:isOpen", () => {
        n.isOpen || n.menus.forEach((e) => {
          e.isOpen = !1;
        });
      });
    },
    /**
     * Handles the following case:
     * 1. Hover to open a sub-menu (A). The button has focus.
     * 2. Press arrow up/down to move focus to another sub-menu (B) button.
     * 3. Press arrow right to open the sub-menu (B).
     * 4. The sub-menu (A) should close as it would with `toggleMenusAndFocusItemsOnHover()`.
     */
    closeMenuWhenAnotherOnTheSameLevelOpens(n) {
      n.on("menu:change:isOpen", (e, t, i) => {
        i && n.menus.filter((s) => e.source.parentMenuView === s.parentMenuView && e.source !== s && s.isOpen).forEach((s) => {
          s.isOpen = !1;
        });
      });
    },
    /**
     * Closes the bar when the user clicked outside of it (page body, editor root, etc.).
     */
    closeOnClickOutside(n) {
      rn({
        emitter: n,
        activator: () => n.isOpen,
        callback: () => n.close(),
        contextElements: () => n.children.map((e) => e.element)
      });
    }
  }, Qt = {
    /**
     * If the button of the menu is focused, pressing the arrow down key should open the panel and focus it.
     * This is analogous to the {@link module:ui/dropdown/dropdownview~DropdownView}.
     */
    openAndFocusPanelOnArrowDownKey(n) {
      n.keystrokes.set("arrowdown", (e, t) => {
        n.focusTracker.focusedElement === n.buttonView.element && (n.isOpen || (n.isOpen = !0), n.panelView.focus(), t());
      });
    },
    /**
     * Open the menu on the right arrow key press. This allows for navigating to sub-menus using the keyboard.
     */
    openOnArrowRightKey(n) {
      const e = n.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
      n.keystrokes.set(e, (t, i) => {
        n.focusTracker.focusedElement !== n.buttonView.element || !n.isEnabled || (n.isOpen || (n.isOpen = !0), n.panelView.focus(), i());
      });
    },
    /**
     * Opens the menu on its button click. Note that this behavior only opens but never closes the menu (unlike
     * {@link module:ui/dropdown/dropdownview~DropdownView}).
     */
    openOnButtonClick(n) {
      n.buttonView.on("execute", () => {
        n.isOpen = !0, n.panelView.focus();
      });
    },
    /**
     * Toggles the menu on its button click. This behavior is analogous to {@link module:ui/dropdown/dropdownview~DropdownView}.
     */
    toggleOnButtonClick(n) {
      n.buttonView.on("execute", () => {
        n.isOpen = !n.isOpen, n.isOpen && n.panelView.focus();
      });
    },
    /**
     * Closes the menu on the right left key press. This allows for navigating to sub-menus using the keyboard.
     */
    closeOnArrowLeftKey(n) {
      const e = n.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
      n.keystrokes.set(e, (t, i) => {
        n.isOpen && (n.isOpen = !1, n.focus(), i());
      });
    },
    /**
     * Closes the menu on the esc key press. This allows for navigating to sub-menus using the keyboard.
     */
    closeOnEscKey(n) {
      n.keystrokes.set("esc", (e, t) => {
        n.isOpen && (n.isOpen = !1, n.focus(), t());
      });
    },
    /**
     * Closes the menu when its parent menu also closed. This prevents from orphaned open menus when the parent menu re-opens.
     */
    closeOnParentClose(n) {
      n.parentMenuView.on("change:isOpen", (e, t, i) => {
        !i && e.source === n.parentMenuView && (n.isOpen = !1);
      });
    }
  }, oS = {
    southEast: (n) => ({
      top: n.bottom,
      left: n.left,
      name: "se"
    }),
    southWest: (n, e) => ({
      top: n.bottom,
      left: n.left - e.width + n.width,
      name: "sw"
    }),
    northEast: (n, e) => ({
      top: n.top - e.height,
      left: n.left,
      name: "ne"
    }),
    northWest: (n, e) => ({
      top: n.top - e.height,
      left: n.left - e.width + n.width,
      name: "nw"
    }),
    eastSouth: (n) => ({
      top: n.top,
      left: n.right - zs,
      name: "es"
    }),
    eastNorth: (n, e) => ({
      top: n.top - e.height,
      left: n.right - zs,
      name: "en"
    }),
    westSouth: (n, e) => ({
      top: n.top,
      left: n.left - e.width + zs,
      name: "ws"
    }),
    westNorth: (n, e) => ({
      top: n.top - e.height,
      left: n.left - e.width + zs,
      name: "wn"
    })
  }, rS = [
    {
      menuId: "file",
      label: "File",
      groups: [
        {
          groupId: "export",
          items: [
            "menuBar:exportPdf",
            "menuBar:exportWord"
          ]
        },
        {
          groupId: "import",
          items: [
            "menuBar:importWord"
          ]
        },
        {
          groupId: "revisionHistory",
          items: [
            "menuBar:revisionHistory"
          ]
        }
      ]
    },
    {
      menuId: "edit",
      label: "Edit",
      groups: [
        {
          groupId: "undo",
          items: [
            "menuBar:undo",
            "menuBar:redo"
          ]
        },
        {
          groupId: "selectAll",
          items: [
            "menuBar:selectAll"
          ]
        },
        {
          groupId: "findAndReplace",
          items: [
            "menuBar:findAndReplace"
          ]
        }
      ]
    },
    {
      menuId: "view",
      label: "View",
      groups: [
        {
          groupId: "sourceEditing",
          items: [
            "menuBar:sourceEditing"
          ]
        },
        {
          groupId: "showBlocks",
          items: [
            "menuBar:showBlocks"
          ]
        },
        {
          groupId: "restrictedEditingException",
          items: [
            "menuBar:restrictedEditingException"
          ]
        }
      ]
    },
    {
      menuId: "insert",
      label: "Insert",
      groups: [
        {
          groupId: "insertMainWidgets",
          items: [
            "menuBar:uploadImage",
            "menuBar:ckbox",
            "menuBar:ckfinder",
            "menuBar:insertTable"
          ]
        },
        {
          groupId: "insertInline",
          items: [
            "menuBar:link",
            "menuBar:comment"
          ]
        },
        {
          groupId: "insertMinorWidgets",
          items: [
            "menuBar:insertTemplate",
            "menuBar:blockQuote",
            "menuBar:codeBlock",
            "menuBar:htmlEmbed"
          ]
        },
        {
          groupId: "insertStructureWidgets",
          items: [
            "menuBar:horizontalLine",
            "menuBar:pageBreak",
            "menuBar:tableOfContents"
          ]
        },
        {
          groupId: "restrictedEditing",
          items: [
            "menuBar:restrictedEditing"
          ]
        }
      ]
    },
    {
      menuId: "format",
      label: "Format",
      groups: [
        {
          groupId: "textAndFont",
          items: [
            {
              menuId: "text",
              label: "Text",
              groups: [
                {
                  groupId: "basicStyles",
                  items: [
                    "menuBar:bold",
                    "menuBar:italic",
                    "menuBar:underline",
                    "menuBar:strikethrough",
                    "menuBar:superscript",
                    "menuBar:subscript",
                    "menuBar:code"
                  ]
                },
                {
                  groupId: "textPartLanguage",
                  items: [
                    "menuBar:textPartLanguage"
                  ]
                }
              ]
            },
            {
              menuId: "font",
              label: "Font",
              groups: [
                {
                  groupId: "fontProperties",
                  items: [
                    "menuBar:fontSize",
                    "menuBar:fontFamily"
                  ]
                },
                {
                  groupId: "fontColors",
                  items: [
                    "menuBar:fontColor",
                    "menuBar:fontBackgroundColor"
                  ]
                },
                {
                  groupId: "highlight",
                  items: [
                    "menuBar:highlight"
                  ]
                }
              ]
            },
            "menuBar:heading"
          ]
        },
        {
          groupId: "list",
          items: [
            "menuBar:bulletedList",
            "menuBar:numberedList",
            "menuBar:todoList"
          ]
        },
        {
          groupId: "indent",
          items: [
            "menuBar:alignment",
            "menuBar:indent",
            "menuBar:outdent"
          ]
        },
        {
          groupId: "caseChange",
          items: [
            "menuBar:caseChange"
          ]
        },
        {
          groupId: "removeFormat",
          items: [
            "menuBar:removeFormat"
          ]
        }
      ]
    },
    {
      menuId: "tools",
      label: "Tools",
      groups: [
        {
          groupId: "aiTools",
          items: [
            "menuBar:aiAssistant",
            "menuBar:aiCommands"
          ]
        },
        {
          groupId: "tools",
          items: [
            "menuBar:trackChanges",
            "menuBar:commentsArchive"
          ]
        }
      ]
    },
    {
      menuId: "help",
      label: "Help",
      groups: [
        {
          groupId: "help",
          items: [
            "menuBar:accessibilityHelp"
          ]
        }
      ]
    }
  ];
  function aS(n) {
    let e;
    return !("items" in n) || !n.items ? e = {
      items: ut(rS),
      addItems: [],
      removeItems: [],
      isVisible: !0,
      isUsingDefaultConfig: !0,
      ...n
    } : e = {
      items: n.items,
      removeItems: [],
      addItems: [],
      isVisible: !0,
      isUsingDefaultConfig: !1,
      ...n
    }, e;
  }
  function lS({ normalizedConfig: n, locale: e, componentFactory: t }) {
    const i = ut(n);
    return cS(n, i), uS(n, i), dS(n, i, t), Vg(n, i), hS(i, e), i;
  }
  function cS(n, e) {
    const t = e.removeItems, i = [];
    e.items = e.items.filter(({ menuId: s }) => t.includes(s) ? (i.push(s), !1) : !0), mn(e.items, (s) => {
      s.groups = s.groups.filter(({ groupId: o }) => t.includes(o) ? (i.push(o), !1) : !0);
      for (const o of s.groups)
        o.items = o.items.filter((r) => {
          const a = Mg(r);
          return t.includes(a) ? (i.push(a), !1) : !0;
        });
    });
    for (const s of t)
      i.includes(s) || z("menu-bar-item-could-not-be-removed", {
        menuBarConfig: n,
        itemName: s
      });
  }
  function uS(n, e) {
    const t = e.addItems, i = [];
    for (const s of t) {
      const o = gS(s.position), r = pS(s.position);
      if (fS(s))
        if (!r)
          o === "start" ? (e.items.unshift(s.menu), i.push(s)) : o === "end" && (e.items.push(s.menu), i.push(s));
        else {
          const a = e.items.findIndex((l) => l.menuId === r);
          a != -1 ? o === "before" ? (e.items.splice(a, 0, s.menu), i.push(s)) : o === "after" && (e.items.splice(a + 1, 0, s.menu), i.push(s)) : rd(e, s.menu, r, o) && i.push(s);
        }
      else
        mS(s) ? mn(e.items, (a) => {
          if (a.menuId === r)
            o === "start" ? (a.groups.unshift(s.group), i.push(s)) : o === "end" && (a.groups.push(s.group), i.push(s));
          else {
            const l = a.groups.findIndex((c) => c.groupId === r);
            l !== -1 && (o === "before" ? (a.groups.splice(l, 0, s.group), i.push(s)) : o === "after" && (a.groups.splice(l + 1, 0, s.group), i.push(s)));
          }
        }) : rd(e, s.item, r, o) && i.push(s);
    }
    for (const s of t)
      i.includes(s) || z("menu-bar-item-could-not-be-added", {
        menuBarConfig: n,
        addedItemConfig: s
      });
  }
  function rd(n, e, t, i) {
    let s = !1;
    return mn(n.items, (o) => {
      for (const { groupId: r, items: a } of o.groups) {
        if (s)
          return;
        if (r === t)
          i === "start" ? (a.unshift(e), s = !0) : i === "end" && (a.push(e), s = !0);
        else {
          const l = a.findIndex((c) => Mg(c) === t);
          l !== -1 && (i === "before" ? (a.splice(l, 0, e), s = !0) : i === "after" && (a.splice(l + 1, 0, e), s = !0));
        }
      }
    }), s;
  }
  function dS(n, e, t) {
    mn(e.items, (i) => {
      for (const s of i.groups)
        s.items = s.items.filter((o) => {
          const r = typeof o == "string" && !t.has(o);
          return r && !e.isUsingDefaultConfig && z("menu-bar-item-unavailable", {
            menuBarConfig: n,
            parentMenuConfig: ut(i),
            componentName: o
          }), !r;
        });
    });
  }
  function Vg(n, e) {
    const t = e.isUsingDefaultConfig;
    let i = !1;
    if (e.items = e.items.filter((s) => s.groups.length ? !0 : (Nr(n, s, t), !1)), !e.items.length) {
      Nr(n, n, t);
      return;
    }
    mn(e.items, (s) => {
      s.groups = s.groups.filter((o) => o.items.length ? !0 : (i = !0, !1));
      for (const o of s.groups)
        o.items = o.items.filter((r) => Bg(r) && !r.groups.length ? (Nr(n, r, t), i = !0, !1) : !0);
    }), i && Vg(n, e);
  }
  function Nr(n, e, t) {
    t || z("menu-bar-menu-empty", {
      menuBarConfig: n,
      emptyMenuConfig: e
    });
  }
  function hS(n, e) {
    const t = e.t, i = {
      // Top-level categories.
      File: t({
        string: "File",
        id: "MENU_BAR_MENU_FILE"
      }),
      Edit: t({
        string: "Edit",
        id: "MENU_BAR_MENU_EDIT"
      }),
      View: t({
        string: "View",
        id: "MENU_BAR_MENU_VIEW"
      }),
      Insert: t({
        string: "Insert",
        id: "MENU_BAR_MENU_INSERT"
      }),
      Format: t({
        string: "Format",
        id: "MENU_BAR_MENU_FORMAT"
      }),
      Tools: t({
        string: "Tools",
        id: "MENU_BAR_MENU_TOOLS"
      }),
      Help: t({
        string: "Help",
        id: "MENU_BAR_MENU_HELP"
      }),
      // Sub-menus.
      Text: t({
        string: "Text",
        id: "MENU_BAR_MENU_TEXT"
      }),
      Font: t({
        string: "Font",
        id: "MENU_BAR_MENU_FONT"
      })
    };
    mn(n.items, (s) => {
      s.label in i && (s.label = i[s.label]);
    });
  }
  function mn(n, e) {
    if (Array.isArray(n))
      for (const i of n)
        t(i);
    function t(i) {
      e(i);
      for (const s of i.groups)
        for (const o of s.items)
          Bg(o) && t(o);
    }
  }
  function fS(n) {
    return typeof n == "object" && "menu" in n;
  }
  function mS(n) {
    return typeof n == "object" && "group" in n;
  }
  function gS(n) {
    return n.startsWith("start") ? "start" : n.startsWith("end") ? "end" : n.startsWith("after") ? "after" : "before";
  }
  function pS(n) {
    const e = n.match(/^[^:]+:(.+)/);
    return e ? e[1] : null;
  }
  function Mg(n) {
    return typeof n == "string" ? n : n.menuId;
  }
  function Bg(n) {
    return typeof n == "object" && "menuId" in n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class wS extends T {
    /**
     * Creates an instance of the menu panel view.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-reset",
            "ck-menu-bar__menu__panel",
            t.to("position", (i) => `ck-menu-bar__menu__panel_position_${i}`),
            t.if("isVisible", "ck-hidden", (i) => !i)
          ],
          tabindex: "-1"
        },
        children: this.children,
        on: {
          // Drag and drop in the panel should not break the selection in the editor.
          // https://github.com/ckeditor/ckeditor5-ui/issues/228
          selectstart: t.to((i) => {
            i.target.tagName.toLocaleLowerCase() !== "input" && i.preventDefault();
          })
        }
      });
    }
    /**
     * Focuses the first child of the panel (default) or the last one if the `direction` is `-1`.
     */
    focus(e = 1) {
      this.children.length && (e === 1 ? this.children.first.focus() : this.children.last.focus());
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ke extends T {
    /**
     * Creates an instance of the menu view.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.buttonView = new sS(e), this.buttonView.delegate("mouseenter").to(this), this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled"), this.panelView = new wS(e), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new ne(), this.focusTracker = new Q(), this.set("isOpen", !1), this.set("isEnabled", !0), this.set("panelPosition", "w"), this.set("class", void 0), this.set("parentMenuView", null), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-menu-bar__menu",
            t.to("class"),
            t.if("isEnabled", "ck-disabled", (i) => !i),
            t.if("parentMenuView", "ck-menu-bar__menu_top-level", (i) => !i)
          ]
        },
        children: [
          this.buttonView,
          this.panelView
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.keystrokes.listenTo(this.element), Qt.closeOnEscKey(this), this._repositionPanelOnOpen();
    }
    // For now, this method cannot be called in the render process because the `parentMenuView` may be assigned
    // after the rendering process.
    //
    // TODO: We should reconsider the way we handle this logic.
    /**
     * Attach all keyboard behaviors for the menu bar view.
     *
     * @internal
     */
    _attachBehaviors() {
      this.parentMenuView ? (Qt.openOnButtonClick(this), Qt.openOnArrowRightKey(this), Qt.closeOnArrowLeftKey(this), Qt.closeOnParentClose(this)) : (this._propagateArrowKeystrokeEvents(), Qt.openAndFocusPanelOnArrowDownKey(this), Qt.toggleOnButtonClick(this));
    }
    /**
     * Fires `arrowright` and `arrowleft` events when the user pressed corresponding arrow keys.
     */
    _propagateArrowKeystrokeEvents() {
      this.keystrokes.set("arrowright", (e, t) => {
        this.fire("arrowright"), t();
      }), this.keystrokes.set("arrowleft", (e, t) => {
        this.fire("arrowleft"), t();
      });
    }
    /**
     * Sets the position of the panel when the menu opens. The panel is positioned
     * so that it optimally uses the available space in the viewport.
     */
    _repositionPanelOnOpen() {
      this.on("change:isOpen", (e, t, i) => {
        if (!i)
          return;
        const s = Ke._getOptimalPosition({
          element: this.panelView.element,
          target: this.buttonView.element,
          fitInViewport: !0,
          positions: this._panelPositions
        });
        this.panelView.position = s ? s.name : this._panelPositions[0].name;
      });
    }
    /**
     * @inheritDoc
     */
    focus() {
      this.buttonView.focus();
    }
    /**
     * Positioning functions for the {@link #panelView} . They change depending on the role of the menu (top-level vs sub-menu) in
     * the {@link module:ui/menubar/menubarview~MenuBarView menu bar} and the UI language direction.
     */
    get _panelPositions() {
      const { southEast: e, southWest: t, northEast: i, northWest: s, westSouth: o, eastSouth: r, westNorth: a, eastNorth: l } = oS;
      return this.locale.uiLanguageDirection === "ltr" ? this.parentMenuView ? [r, l, o, a] : [e, t, i, s] : this.parentMenuView ? [o, a, r, l] : [t, e, s, i];
    }
  }
  Ke._getOptimalPosition = Ko;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class sn extends Pl {
    /**
     * Creates an instance of the list view.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e), this.role = "menu";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class de extends P {
    /**
     * Creates an instance of the menu bar list button view.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e), this.set({
        withText: !0,
        withKeystroke: !0,
        tooltip: !1,
        role: "menuitem"
      }), this.extendTemplate({
        attributes: {
          class: ["ck-menu-bar__menu__item__button"]
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Og extends cg {
    /**
     * Creates an instance of the menu bar list button view.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e), this.set({
        withText: !0,
        withKeystroke: !0,
        tooltip: !1,
        role: "menuitem"
      }), this.extendTemplate({
        attributes: {
          class: ["ck-menu-bar__menu__item__button"]
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const ad = ["mouseenter", "arrowleft", "arrowright", "change:isOpen"];
  class bS extends T {
    /**
     * Creates an instance of the menu bar view.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e), this.menus = [];
      const t = e.t;
      this.set("isOpen", !1), this._setupIsOpenUpdater(), this.children = this.createCollection(), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-menu-bar"
          ],
          "aria-label": t("Editor menu bar"),
          role: "menubar"
        },
        children: this.children
      });
    }
    /**
     * A utility that expands a plain menu bar configuration into a structure of menus (also: sub-menus)
     * and items using a given {@link module:ui/componentfactory~ComponentFactory component factory}.
     *
     * See the {@link module:core/editor/editorconfig~EditorConfig#menuBar menu bar} in the editor
     * configuration reference to learn how to configure the menu bar.
     */
    fillFromConfig(e, t) {
      const i = this.locale, o = lS({
        normalizedConfig: e,
        locale: i,
        componentFactory: t
      }).items.map((r) => this._createMenu({
        componentFactory: t,
        menuDefinition: r
      }));
      this.children.addMany(o);
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), yn.toggleMenusAndFocusItemsOnHover(this), yn.closeMenusWhenTheBarCloses(this), yn.closeMenuWhenAnotherOnTheSameLevelOpens(this), yn.focusCycleMenusOnArrows(this), yn.closeOnClickOutside(this);
    }
    /**
     * Focuses the menu bar.
     */
    focus() {
      this.children.first && this.children.first.focus();
    }
    /**
     * Closes all menus in the bar.
     */
    close() {
      for (const e of this.children)
        e.isOpen = !1;
    }
    /**
     * Registers a menu view in the menu bar. Every {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instance must be registered
     * in the menu bar to be properly managed.
     */
    registerMenu(e, t = null) {
      t ? (e.delegate(...ad).to(t), e.parentMenuView = t) : e.delegate(...ad).to(this, (i) => "menu:" + i), e._attachBehaviors(), this.menus.push(e);
    }
    /**
     * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} based on the given definition.
     */
    _createMenu({ componentFactory: e, menuDefinition: t, parentMenuView: i }) {
      const s = this.locale, o = new Ke(s);
      return this.registerMenu(o, i), o.buttonView.set({
        label: t.label
      }), o.once("change:isOpen", () => {
        const r = new sn(s);
        r.ariaLabel = t.label, o.panelView.children.add(r), r.items.addMany(this._createMenuItems({ menuDefinition: t, parentMenuView: o, componentFactory: e }));
      }), o;
    }
    /**
     * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} items based on the given definition.
     */
    _createMenuItems({ menuDefinition: e, parentMenuView: t, componentFactory: i }) {
      const s = this.locale, o = [];
      for (const r of e.groups) {
        for (const a of r.items) {
          const l = new fn(s, t);
          if (J(a))
            l.children.add(this._createMenu({
              componentFactory: i,
              menuDefinition: a,
              parentMenuView: t
            }));
          else {
            const c = this._createMenuItemContentFromFactory({
              componentName: a,
              componentFactory: i,
              parentMenuView: t
            });
            if (!c)
              continue;
            l.children.add(c);
          }
          o.push(l);
        }
        r !== e.groups[e.groups.length - 1] && o.push(new Il(s));
      }
      return o;
    }
    /**
     * Uses the component factory to create a content of the menu item (a button or a sub-menu).
     */
    _createMenuItemContentFromFactory({ componentName: e, parentMenuView: t, componentFactory: i }) {
      const s = i.create(e);
      return s instanceof Ke || s instanceof de || s instanceof Og ? (this._registerMenuTree(s, t), s.on("execute", () => {
        this.close();
      }), s) : (z("menu-bar-component-unsupported", {
        componentName: e,
        componentView: s
      }), null);
    }
    /**
     * Checks component and its children recursively and calls {@link #registerMenu}
     * for each item that is {@link module:ui/menubar/menubarmenuview~MenuBarMenuView}.
     *
     * @internal
     */
    _registerMenuTree(e, t) {
      if (!(e instanceof Ke)) {
        e.delegate("mouseenter").to(t);
        return;
      }
      this.registerMenu(e, t);
      const i = e.panelView.children.filter((o) => o instanceof sn)[0];
      if (!i) {
        e.delegate("mouseenter").to(t);
        return;
      }
      const s = i.items.filter((o) => o instanceof tn);
      for (const o of s)
        this._registerMenuTree(o.children.get(0), e);
    }
    /**
     * Manages the state of the {@link #isOpen} property of the menu bar. Because the state is a sum of individual
     * top-level menus' states, it's necessary to listen to their changes and update the state accordingly.
     *
     * Additionally, it prevents from unnecessary changes of `isOpen` when one top-level menu opens and another closes
     * (regardless of in which order), maintaining a stable `isOpen === true` in that situation.
     */
    _setupIsOpenUpdater() {
      let e;
      this.on("menu:change:isOpen", (t, i, s) => {
        clearTimeout(e), s ? this.isOpen = !0 : e = setTimeout(() => {
          this.isOpen = Array.from(this.children).some((o) => o.isOpen);
        }, 0);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class _S extends Gx {
    /**
     * Creates an instance of the classic editor UI class.
     *
     * @param editor The editor instance.
     * @param view The view of the UI.
     */
    constructor(e, t) {
      super(e), this.view = t, this._toolbarConfig = Cg(e.config.get("toolbar")), this._menuBarConfig = aS(e.config.get("menuBar") || {}), this._elementReplacer = new Yy(), this.listenTo(e.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
    }
    /**
     * @inheritDoc
     */
    get element() {
      return this.view.element;
    }
    /**
     * Initializes the UI.
     *
     * @param replacementElement The DOM element that will be the source for the created editor.
     */
    init(e) {
      const t = this.editor, i = this.view, s = t.editing.view, o = i.editable, r = s.document.getRoot();
      o.name = r.rootName, i.render();
      const a = o.element;
      this.setEditableElement(o.name, a), i.editable.bind("isFocused").to(this.focusTracker), s.attachDomRoot(a), e && this._elementReplacer.replace(e, this.element), this._initPlaceholder(), this._initToolbar(), this._initMenuBar(), this._initDialogPluginIntegration(), this.fire("ready");
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy();
      const e = this.view, t = this.editor.editing.view;
      this._elementReplacer.restore(), t.detachDomRoot(e.editable.name), e.destroy();
    }
    /**
     * Initializes the editor toolbar.
     */
    _initToolbar() {
      const e = this.view;
      e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e.stickyPanel.limiterElement = e.element, e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t }) => t || 0), e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(e.toolbar);
    }
    /**
     * Initializes the editor menu bar.
     */
    _initMenuBar() {
      const e = this.view;
      e.menuBarView && (this._setupMenuBarBehaviors(e.menuBarView.element), e.menuBarView.fillFromConfig(this._menuBarConfig, this.componentFactory));
    }
    /**
     * Enable the placeholder text on the editing root.
     */
    _initPlaceholder() {
      const e = this.editor, t = e.editing.view, i = t.document.getRoot(), s = e.sourceElement;
      let o;
      const r = e.config.get("placeholder");
      r && (o = typeof r == "string" ? r : r[this.view.editable.name]), !o && s && s.tagName.toLowerCase() === "textarea" && (o = s.getAttribute("placeholder")), o && (i.placeholder = o), ml({
        view: t,
        element: i,
        isDirectHost: !1,
        keepOnFocus: !0
      });
    }
    /**
     * Provides an integration between the sticky toolbar and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
     * It allows the UI-agnostic engine method to consider the geometry of the
     * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel} that pins to the
     * edge of the viewport and can obscure the user caret after scrolling the window.
     *
     * @param evt The `scrollToTheSelection` event info.
     * @param data The payload carried by the `scrollToTheSelection` event.
     * @param originalArgs The original arguments passed to `scrollViewportToShowTarget()` method (see implementation to learn more).
     */
    _handleScrollToTheSelectionWithStickyPanel(e, t, i) {
      const s = this.view.stickyPanel;
      if (s.isSticky) {
        const o = new O(s.element).height;
        t.viewportOffset.top += o;
      } else {
        const o = () => {
          this.editor.editing.view.scrollToTheSelection(i);
        };
        this.listenTo(s, "change:isSticky", o), setTimeout(() => {
          this.stopListening(s, "change:isSticky", o);
        }, 20);
      }
    }
    /**
     * Provides an integration between the sticky toolbar and {@link module:ui/dialog/dialog the Dialog plugin}.
     *
     * It moves the dialog down to ensure that the
     * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel sticky panel}
     * used by the editor UI will not get obscured by the dialog when the dialog uses one of its automatic positions.
     */
    _initDialogPluginIntegration() {
      if (!this.editor.plugins.has("Dialog"))
        return;
      const e = this.view.stickyPanel, t = this.editor.plugins.get("Dialog");
      t.on("show", () => {
        const i = t.view;
        i.on("moveTo", (s, o) => {
          if (!e.isSticky || i.wasMoved)
            return;
          const r = new O(e.contentPanelElement);
          o[1] < r.bottom + nn.defaultOffset && (o[1] = r.bottom + nn.defaultOffset);
        }, { priority: "high" });
      }, { priority: "low" });
    }
    /**
     * Handles focus and keystrokes for menu bar element.
     */
    _setupMenuBarBehaviors(e) {
      const t = this.editor;
      this.focusTracker.add(e), t.keystrokes.listenTo(e), t.keystrokes.set("Esc", (i, s) => {
        e.contains(this.focusTracker.focusedElement) && (t.editing.view.focus(), s());
      }), t.keystrokes.set("Alt+F9", (i, s) => {
        e.contains(this.focusTracker.focusedElement) || (this.view.menuBarView.focus(), s());
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class vS extends Kx {
    /**
     * Creates an instance of the classic editor UI view.
     *
     * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
     * @param editingView The editing view instance this view is related to.
     * @param options Configuration options for the view instance.
     * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
     * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
     * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
     */
    constructor(e, t, i = {}) {
      super(e), this.stickyPanel = new Qx(e), this.toolbar = new en(e, {
        shouldGroupWhenFull: i.shouldToolbarGroupWhenFull
      }), i.useMenuBar && (this.menuBarView = new bS(e)), this.editable = new Jx(e, t);
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.menuBarView ? this.stickyPanel.content.addMany([this.menuBarView, this.toolbar]) : this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ng {
    /**
     * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
     */
    constructor(e) {
      if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t) => {
        const i = "error" in t ? t.error : t.reason;
        i instanceof Error && this._handleError(i, t);
      }, this._listeners = {}, !this._restart)
        throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
    }
    /**
     * Destroys the watchdog and releases the resources.
     */
    destroy() {
      this._stopErrorHandling(), this._listeners = {};
    }
    /**
     * Starts listening to a specific event name by registering a callback that will be executed
     * whenever an event with a given name fires.
     *
     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
     *
     * @param eventName The event name.
     * @param callback A callback which will be added to event listeners.
     */
    on(e, t) {
      this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t);
    }
    /**
     * Stops listening to the specified event name by removing the callback from event listeners.
     *
     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
     *
     * @param eventName The event name.
     * @param callback A callback which will be removed from event listeners.
     */
    off(e, t) {
      this._listeners[e] = this._listeners[e].filter((i) => i !== t);
    }
    /**
     * Fires an event with a given event name and arguments.
     *
     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
     */
    _fire(e, ...t) {
      const i = this._listeners[e] || [];
      for (const s of i)
        s.apply(this, [null, ...t]);
    }
    /**
     * Starts error handling by attaching global error handlers.
     */
    _startErrorHandling() {
      window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
    }
    /**
     * Stops error handling by detaching global error handlers.
     */
    _stopErrorHandling() {
      window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
    }
    /**
     * Checks if an error comes from the watched item and restarts it.
     * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
     *
     * @fires error
     * @param error Error.
     * @param evt An error event.
     */
    _handleError(e, t) {
      if (this._shouldReactToError(e)) {
        this.crashes.push({
          message: e.message,
          stack: e.stack,
          // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
          filename: t instanceof ErrorEvent ? t.filename : void 0,
          lineno: t instanceof ErrorEvent ? t.lineno : void 0,
          colno: t instanceof ErrorEvent ? t.colno : void 0,
          date: this._now()
        });
        const i = this._shouldRestart();
        this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: e, causesRestart: i }), i ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
      }
    }
    /**
     * Checks whether an error should be handled by the watchdog.
     *
     * @param error An error that was caught by the error handling process.
     */
    _shouldReactToError(e) {
      return e.is && e.is("CKEditorError") && e.context !== void 0 && // In some cases the watched item should not be restarted - e.g. during the item initialization.
      // That's why the `null` was introduced as a correct error context which does cause restarting.
      e.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
      this.state === "ready" && this._isErrorComingFromThisItem(e);
    }
    /**
     * Checks if the watchdog should restart the underlying item.
     */
    _shouldRestart() {
      if (this.crashes.length <= this._crashNumberLimit)
        return !0;
      const e = this.crashes[this.crashes.length - 1].date, t = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
      return (e - t) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function ka(n, e = /* @__PURE__ */ new Set()) {
    const t = [n], i = /* @__PURE__ */ new Set();
    let s = 0;
    for (; t.length > s; ) {
      const o = t[s++];
      if (!(i.has(o) || !yS(o) || e.has(o)))
        if (i.add(o), Symbol.iterator in o)
          try {
            for (const r of o)
              t.push(r);
          } catch (r) {
          }
        else
          for (const r in o)
            r !== "defaultValue" && t.push(o[r]);
    }
    return i;
  }
  function yS(n) {
    const e = Object.prototype.toString.call(n), t = typeof n;
    return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || n === void 0 || n === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
    // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
    // until a better solution is found.
    // More in https://github.com/ckeditor/ckeditor5/issues/12292.
    n._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
    n instanceof EventTarget || n instanceof Event);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Dg(n, e, t = /* @__PURE__ */ new Set()) {
    if (n === e && CS(n))
      return !0;
    const i = ka(n, t), s = ka(e, t);
    for (const o of i)
      if (s.has(o))
        return !0;
    return !1;
  }
  function CS(n) {
    return typeof n == "object" && n !== null;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Fg extends Ng {
    /**
     * @param Editor The editor class.
     * @param watchdogConfig The watchdog plugin configuration.
     */
    constructor(e, t = {}) {
      super(t), this._editor = null, this._lifecyclePromise = null, this._initUsingData = !0, this._editables = {}, this._throttledSave = Zi(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3), e && (this._creator = (i, s) => e.create(i, s)), this._destructor = (i) => i.destroy();
    }
    /**
     * The current editor instance.
     */
    get editor() {
      return this._editor;
    }
    /**
     * @internal
     */
    get _item() {
      return this._editor;
    }
    /**
     * Sets the function that is responsible for the editor creation.
     * It expects a function that should return a promise.
     *
     * ```ts
     * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
     * ```
     */
    setCreator(e) {
      this._creator = e;
    }
    /**
     * Sets the function that is responsible for the editor destruction.
     * Overrides the default destruction function, which destroys only the editor instance.
     * It expects a function that should return a promise or `undefined`.
     *
     * ```ts
     * watchdog.setDestructor( editor => {
     * 	// Do something before the editor is destroyed.
     *
     * 	return editor
     * 		.destroy()
     * 		.then( () => {
     * 			// Do something after the editor is destroyed.
     * 		} );
     * } );
     * ```
     */
    setDestructor(e) {
      this._destructor = e;
    }
    /**
     * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
     * the state to `initializing`.
     *
     * @fires restart
     */
    _restart() {
      return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((e) => {
        console.error("An error happened during the editor destroying.", e);
      }).then(() => {
        const e = {}, t = [], i = this._config.rootsAttributes || {}, s = {};
        for (const [r, a] of Object.entries(this._data.roots))
          a.isLoaded ? (e[r] = "", s[r] = i[r] || {}) : t.push(r);
        const o = {
          ...this._config,
          extraPlugins: this._config.extraPlugins || [],
          lazyRoots: t,
          rootsAttributes: s,
          _watchdogInitialData: this._data
        };
        return delete o.initialData, o.extraPlugins.push(kS), this._initUsingData ? this.create(e, o, o.context) : fi(this._elementOrData) ? this.create(this._elementOrData, o, o.context) : this.create(this._editables, o, o.context);
      }).then(() => {
        this._fire("restart");
      });
    }
    /**
     * Creates the editor instance and keeps it running, using the defined creator and destructor.
     *
     * @param elementOrData The editor source element or the editor data.
     * @param config The editor configuration.
     * @param context A context for the editor.
     */
    create(e = this._elementOrData, t = this._config, i) {
      return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => (super._startErrorHandling(), this._elementOrData = e, this._initUsingData = typeof e == "string" || Object.keys(e).length > 0 && typeof Object.values(e)[0] == "string", this._config = this._cloneEditorConfiguration(t) || {}, this._config.context = i, this._creator(e, this._config))).then((s) => {
        this._editor = s, s.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = s.model.document.version, this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this.state = "ready", this._fire("stateChange");
      }).finally(() => {
        this._lifecyclePromise = null;
      }), this._lifecyclePromise;
    }
    /**
     * Destroys the watchdog and the current editor instance. It fires the callback
     * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
     * It also sets the state to `destroyed`.
     */
    destroy() {
      return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy())).finally(() => {
        this._lifecyclePromise = null;
      }), this._lifecyclePromise;
    }
    _destroy() {
      return Promise.resolve().then(() => {
        this._stopErrorHandling(), this._throttledSave.cancel();
        const e = this._editor;
        return this._editor = null, e.model.document.off("change:data", this._throttledSave), this._destructor(e);
      });
    }
    /**
     * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
     * the moment of the crash.
     */
    _save() {
      const e = this._editor.model.document.version;
      try {
        this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this._lastDocumentVersion = e;
      } catch (t) {
        console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
      }
    }
    /**
     * @internal
     */
    _setExcludedProperties(e) {
      this._excludedProps = e;
    }
    /**
     * Gets all data that is required to reinitialize editor instance.
     */
    _getData() {
      const e = this._editor, t = e.model.document.roots.filter((a) => a.isAttached() && a.rootName != "$graveyard"), { plugins: i } = e, s = i.has("CommentsRepository") && i.get("CommentsRepository"), o = i.has("TrackChanges") && i.get("TrackChanges"), r = {
        roots: {},
        markers: {},
        commentThreads: JSON.stringify([]),
        suggestions: JSON.stringify([])
      };
      t.forEach((a) => {
        r.roots[a.rootName] = {
          content: JSON.stringify(Array.from(a.getChildren())),
          attributes: JSON.stringify(Array.from(a.getAttributes())),
          isLoaded: a._isLoaded
        };
      });
      for (const a of e.model.markers)
        a._affectsData && (r.markers[a.name] = {
          rangeJSON: a.getRange().toJSON(),
          usingOperation: a._managedUsingOperations,
          affectsData: a._affectsData
        });
      return s && (r.commentThreads = JSON.stringify(s.getCommentThreads({ toJSON: !0, skipNotAttached: !0 }))), o && (r.suggestions = JSON.stringify(o.getSuggestions({ toJSON: !0, skipNotAttached: !0 }))), r;
    }
    /**
     * For each attached model root, returns its HTML editable element (if available).
     */
    _getEditables() {
      const e = {};
      for (const t of this.editor.model.document.getRootNames()) {
        const i = this.editor.ui.getEditableElement(t);
        i && (e[t] = i);
      }
      return e;
    }
    /**
     * Traverses the error context and the current editor to find out whether these structures are connected
     * to each other via properties.
     *
     * @internal
     */
    _isErrorComingFromThisItem(e) {
      return Dg(this._editor, e.context, this._excludedProps);
    }
    /**
     * Clones the editor configuration.
     */
    _cloneEditorConfiguration(e) {
      return al(e, (t, i) => {
        if (fi(t) || i === "context")
          return t;
      });
    }
  }
  class kS {
    constructor(e) {
      this.editor = e, this._data = e.config.get("_watchdogInitialData");
    }
    /**
     * @inheritDoc
     */
    init() {
      this.editor.data.on("init", (e) => {
        e.stop(), this.editor.model.enqueueChange({ isUndoable: !1 }, (t) => {
          this._restoreCollaborationData(), this._restoreEditorData(t);
        }), this.editor.data.fire("ready");
      }, { priority: 999 });
    }
    /**
     * Creates a model node (element or text) based on provided JSON.
     */
    _createNode(e, t) {
      if ("name" in t) {
        const i = e.createElement(t.name, t.attributes);
        if (t.children)
          for (const s of t.children)
            i._appendChild(this._createNode(e, s));
        return i;
      } else
        return e.createText(t.data, t.attributes);
    }
    /**
     * Restores the editor by setting the document data, roots attributes and markers.
     */
    _restoreEditorData(e) {
      const t = this.editor;
      Object.entries(this._data.roots).forEach(([i, { content: s, attributes: o }]) => {
        const r = JSON.parse(s), a = JSON.parse(o), l = t.model.document.getRoot(i);
        for (const [c, u] of a)
          e.setAttribute(c, u, l);
        for (const c of r) {
          const u = this._createNode(e, c);
          e.insert(u, l, "end");
        }
      }), Object.entries(this._data.markers).forEach(([i, s]) => {
        const { document: o } = t.model, { rangeJSON: { start: r, end: a }, ...l } = s, c = o.getRoot(r.root), u = e.createPositionFromPath(c, r.path, r.stickiness), d = e.createPositionFromPath(c, a.path, a.stickiness), h = e.createRange(u, d);
        e.addMarker(i, {
          range: h,
          ...l
        });
      });
    }
    /**
     * Restores the editor collaboration data - comment threads and suggestions.
     */
    _restoreCollaborationData() {
      const e = JSON.parse(this._data.commentThreads), t = JSON.parse(this._data.suggestions);
      e.forEach((i) => {
        const s = this.editor.config.get("collaboration.channelId"), o = this.editor.plugins.get("CommentsRepository");
        o.hasCommentThread(i.threadId) && o.getCommentThread(i.threadId).remove(), o.addCommentThread({ channelId: s, ...i });
      }), t.forEach((i) => {
        const s = this.editor.plugins.get("TrackChangesEditing");
        if (s.hasSuggestion(i.id)) {
          const o = s.getSuggestion(i.id);
          o.attributes = i.attributes;
        } else
          s.addSuggestionData(i);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Un = Symbol("MainQueueId");
  class TS extends Ng {
    /**
     * The context watchdog class constructor.
     *
     * ```ts
     * const watchdog = new ContextWatchdog( Context );
     *
     * await watchdog.create( contextConfiguration );
     *
     * await watchdog.add( item );
     * ```
     *
     * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
     *
     * @param Context The {@link module:core/context~Context} class.
     * @param watchdogConfig The watchdog configuration.
     */
    constructor(e, t = {}) {
      super(t), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new ES(), this._watchdogConfig = t, this._creator = (i) => e.create(i), this._destructor = (i) => i.destroy(), this._actionQueues.onEmpty(() => {
        this.state === "initializing" && (this.state = "ready", this._fire("stateChange"));
      });
    }
    /**
     * Sets the function that is responsible for the context creation.
     * It expects a function that should return a promise (or `undefined`).
     *
     * ```ts
     * watchdog.setCreator( config => Context.create( config ) );
     * ```
     */
    setCreator(e) {
      this._creator = e;
    }
    /**
     * Sets the function that is responsible for the context destruction.
     * Overrides the default destruction function, which destroys only the context instance.
     * It expects a function that should return a promise (or `undefined`).
     *
     * ```ts
     * watchdog.setDestructor( context => {
     * 	// Do something before the context is destroyed.
     *
     * 	return context
     * 		.destroy()
     * 		.then( () => {
     * 			// Do something after the context is destroyed.
     * 		} );
     * } );
     * ```
     */
    setDestructor(e) {
      this._destructor = e;
    }
    /**
     * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
     * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
     */
    get context() {
      return this._context;
    }
    /**
     * Initializes the context watchdog. Once it is created, the watchdog takes care about
     * recreating the context and the provided items, and starts the error handling mechanism.
     *
     * ```ts
     * await watchdog.create( {
     * 	plugins: []
     * } );
     * ```
     *
     * @param contextConfig The context configuration. See {@link module:core/context~Context}.
     */
    create(e = {}) {
      return this._actionQueues.enqueue(Un, () => (this._contextConfig = e, this._create()));
    }
    /**
     * Returns an item instance with the given `itemId`.
     *
     * ```ts
     * const editor1 = watchdog.getItem( 'editor1' );
     * ```
     *
     * @param itemId The item ID.
     * @returns The item instance or `undefined` if an item with a given ID has not been found.
     */
    getItem(e) {
      return this._getWatchdog(e)._item;
    }
    /**
     * Gets the state of the given item. See {@link #state} for a list of available states.
     *
     * ```ts
     * const editor1State = watchdog.getItemState( 'editor1' );
     * ```
     *
     * @param itemId Item ID.
     * @returns The state of the item.
     */
    getItemState(e) {
      return this._getWatchdog(e).state;
    }
    /**
     * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
     *
     * Items can be passed together as an array of objects:
     *
     * ```ts
     * await watchdog.add( [ {
     * 	id: 'editor1',
     * 	type: 'editor',
     * 	sourceElementOrData: document.querySelector( '#editor' ),
     * 	config: {
     * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
     * 		toolbar: [ 'bold', 'italic', 'alignment' ]
     * 	},
     * 	creator: ( element, config ) => ClassicEditor.create( element, config )
     * } ] );
     * ```
     *
     * Or one by one as objects:
     *
     * ```ts
     * await watchdog.add( {
     * 	id: 'editor1',
     * 	type: 'editor',
     * 	sourceElementOrData: document.querySelector( '#editor' ),
     * 	config: {
     * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
     * 		toolbar: [ 'bold', 'italic', 'alignment' ]
     * 	},
     * 	creator: ( element, config ) => ClassicEditor.create( element, config )
     * ] );
     * ```
     *
     * Then an instance can be retrieved using the {@link #getItem} method:
     *
     * ```ts
     * const editor1 = watchdog.getItem( 'editor1' );
     * ```
     *
     * Note that this method can be called multiple times, but for performance reasons it is better
     * to pass all items together.
     *
     * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
     */
    add(e) {
      const t = ld(e);
      return Promise.all(t.map((i) => this._actionQueues.enqueue(i.id, () => {
        if (this.state === "destroyed")
          throw new Error("Cannot add items to destroyed watchdog.");
        if (!this._context)
          throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
        let s;
        if (this._watchdogs.has(i.id))
          throw new Error(`Item with the given id is already added: '${i.id}'.`);
        if (i.type === "editor")
          return s = new Fg(null, this._watchdogConfig), s.setCreator(i.creator), s._setExcludedProperties(this._contextProps), i.destructor && s.setDestructor(i.destructor), this._watchdogs.set(i.id, s), s.on("error", (o, { error: r, causesRestart: a }) => {
            this._fire("itemError", { itemId: i.id, error: r }), a && this._actionQueues.enqueue(i.id, () => new Promise((l) => {
              const c = () => {
                s.off("restart", c), this._fire("itemRestart", { itemId: i.id }), l();
              };
              s.on("restart", c);
            }));
          }), s.create(i.sourceElementOrData, i.config, this._context);
        throw new Error(`Not supported item type: '${i.type}'.`);
      })));
    }
    /**
     * Removes and destroys item(s) with given ID(s).
     *
     * ```ts
     * await watchdog.remove( 'editor1' );
     * ```
     *
     * Or
     *
     * ```ts
     * await watchdog.remove( [ 'editor1', 'editor2' ] );
     * ```
     *
     * @param itemIdOrItemIds Item ID or an array of item IDs.
     */
    remove(e) {
      const t = ld(e);
      return Promise.all(t.map((i) => this._actionQueues.enqueue(i, () => {
        const s = this._getWatchdog(i);
        return this._watchdogs.delete(i), s.destroy();
      })));
    }
    /**
     * Destroys the context watchdog and all added items.
     * Once the context watchdog is destroyed, new items cannot be added.
     *
     * ```ts
     * await watchdog.destroy();
     * ```
     */
    destroy() {
      return this._actionQueues.enqueue(Un, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
    }
    /**
     * Restarts the context watchdog.
     */
    _restart() {
      return this._actionQueues.enqueue(Un, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((e) => {
        console.error("An error happened during destroying the context or items.", e);
      }).then(() => this._create()).then(() => this._fire("restart"))));
    }
    /**
     * Initializes the context watchdog.
     */
    _create() {
      return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((e) => (this._context = e, this._contextProps = ka(this._context), Promise.all(Array.from(this._watchdogs.values()).map((t) => (t._setExcludedProperties(this._contextProps), t.create(void 0, void 0, this._context))))));
    }
    /**
     * Destroys the context instance and all added items.
     */
    _destroy() {
      return Promise.resolve().then(() => {
        this._stopErrorHandling();
        const e = this._context;
        return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((t) => t.destroy())).then(() => this._destructor(e));
      });
    }
    /**
     * Returns the watchdog for a given item ID.
     *
     * @param itemId Item ID.
     */
    _getWatchdog(e) {
      const t = this._watchdogs.get(e);
      if (!t)
        throw new Error(`Item with the given id was not registered: ${e}.`);
      return t;
    }
    /**
     * Checks whether an error comes from the context instance and not from the item instances.
     *
     * @internal
     */
    _isErrorComingFromThisItem(e) {
      for (const t of this._watchdogs.values())
        if (t._isErrorComingFromThisItem(e))
          return !1;
      return Dg(this._context, e.context);
    }
  }
  class ES {
    constructor() {
      this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
    }
    /**
     * Used to register callbacks that will be run when the queue becomes empty.
     *
     * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
     */
    onEmpty(e) {
      this._onEmptyCallbacks.push(e);
    }
    /**
     * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
     *
     * @param queueId The action queue ID.
     * @param action A function that should be enqueued.
     */
    enqueue(e, t) {
      const i = e === Un;
      this._activeActions++, this._queues.get(e) || this._queues.set(e, Promise.resolve());
      const o = (i ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Un), this._queues.get(e)])).then(t), r = o.catch(() => {
      });
      return this._queues.set(e, r), o.finally(() => {
        this._activeActions--, this._queues.get(e) === r && this._activeActions === 0 && this._onEmptyCallbacks.forEach((a) => a());
      });
    }
  }
  function ld(n) {
    return Array.isArray(n) ? n : [n];
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class bs extends wa(HE) {
    /**
     * Creates an instance of the classic editor.
     *
     * **Note:** do not use the constructor to create editor instances. Use the static
     * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
     *
     * @param sourceElementOrData The DOM element that will be the source for the created editor
     * or the editor's initial data. For more information see
     * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
     * @param config The editor configuration.
     */
    constructor(e, t = {}) {
      if (!lo(e) && t.initialData !== void 0)
        throw new g("editor-create-initial-data", null);
      super(t), this.config.define("menuBar.isVisible", !1), this.config.get("initialData") === void 0 && this.config.set("initialData", AS(e)), lo(e) && (this.sourceElement = e), this.model.document.createRoot();
      const i = !this.config.get("toolbar.shouldNotGroupWhenFull"), s = this.config.get("menuBar"), o = new vS(this.locale, this.editing.view, {
        shouldToolbarGroupWhenFull: i,
        useMenuBar: s.isVisible
      });
      this.ui = new _S(this, o), $E(this);
    }
    /**
     * Destroys the editor instance, releasing all resources used by it.
     *
     * Updates the original editor element with the data if the
     * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
     * configuration option is set to `true`.
     */
    destroy() {
      return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
    }
    /**
     * Creates a new classic editor instance.
     *
     * There are three ways how the editor can be initialized.
     *
     * # Replacing a DOM element (and loading data from it)
     *
     * You can initialize the editor using an existing DOM element:
     *
     * ```ts
     * ClassicEditor
     * 	.create( document.querySelector( '#editor' ) )
     * 	.then( editor => {
     * 		console.log( 'Editor was initialized', editor );
     * 	} )
     * 	.catch( err => {
     * 		console.error( err.stack );
     * 	} );
     * ```
     *
     * The element's content will be used as the editor data and the element will be replaced by the editor UI.
     *
     * # Creating a detached editor
     *
     * Alternatively, you can initialize the editor by passing the initial data directly as a string.
     * In this case, the editor will render an element that must be inserted into the DOM:
     *
     * ```ts
     * ClassicEditor
     * 	.create( '<p>Hello world!</p>' )
     * 	.then( editor => {
     * 		console.log( 'Editor was initialized', editor );
     *
     * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
     * 		document.body.appendChild( editor.ui.element );
     * 	} )
     * 	.catch( err => {
     * 		console.error( err.stack );
     * 	} );
     * ```
     *
     * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
     * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
     *
     * # Replacing a DOM element (and data provided in `config.initialData`)
     *
     * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
     *
     * ```ts
     * ClassicEditor
     * 	.create( document.querySelector( '#editor' ), {
     * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
     * 	} )
     * 	.then( editor => {
     * 		console.log( 'Editor was initialized', editor );
     * 	} )
     * 	.catch( err => {
     * 		console.error( err.stack );
     * 	} );
     * ```
     *
     * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
     * makes it difficult to set the content of the source element.
     *
     * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
     *
     * # Configuring the editor
     *
     * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
     * customizing plugins, toolbar and more.
     *
     * # Using the editor from source
     *
     * The code samples listed in the previous sections of this documentation assume that you are using an
     * {@glink installation/getting-started/predefined-builds editor build} (for example – `@ckeditor/ckeditor5-build-classic`).
     *
     * If you want to use the classic editor from source (`@ckeditor/ckeditor5-editor-classic/src/classiceditor`),
     * you need to define the list of
     * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
     * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from
     * source in the {@glink installation/advanced/alternative-setups/integrating-from-source-webpack dedicated guide}.
     *
     * @param sourceElementOrData The DOM element that will be the source for the created editor
     * or the editor's initial data.
     *
     * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
     * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
     * in the DOM (the original one will be hidden and the editor will be injected next to it).
     *
     * If the {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
     * option is set to `true`, the editor data will be set back to the original element once the editor is destroyed and when a form,
     * in which this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration
     * with native web forms.
     *
     * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
     * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
     *
     * @param config The editor configuration.
     * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
     */
    static create(e, t = {}) {
      return new Promise((i) => {
        const s = new this(e, t);
        i(s.initPlugins().then(() => s.ui.init(lo(e) ? e : null)).then(() => s.data.init(s.config.get("initialData"))).then(() => s.fire("ready")).then(() => s));
      });
    }
  }
  bs.Context = um;
  bs.EditorWatchdog = Fg;
  bs.ContextWatchdog = TS;
  function AS(n) {
    return lo(n) ? nC(n) : n;
  }
  function lo(n) {
    return fi(n);
  }
  (function(n) {
    const e = n.ko = n.ko || {};
    e.dictionary = Object.assign(e.dictionary || {}, { "(may require <kbd>Fn</kbd>)": "(<kbd>Fn</kbd> 키가 필요할 수 있음)", "%0 of %1": "%0 / %1", Accept: "수락", Accessibility: "접근성", "Accessibility help": "접근성 도움말", "Align cell text to the bottom": "셀 텍스트를 아래로 정렬", "Align cell text to the center": "셀 텍스트를 가로 가운데로 정렬", "Align cell text to the left": "셀 텍스트를 왼쪽으로 정렬", "Align cell text to the middle": "셀 텍스트를 세로 가운데로 정렬", "Align cell text to the right": "셀 텍스트를 오른쪽으로 정렬", "Align cell text to the top": "셀 텍스트를 위로 정렬", "Align center": "가운데 정렬", "Align left": "왼쪽 정렬", "Align right": "오른쪽 정렬", "Align table to the left": "테이블을 왼쪽으로 정렬", "Align table to the right": "테이블을 오른쪽으로 정렬", Alignment: "정렬", All: "전체", "Almost equal to": "거의 같음", Angle: "각", "Approximately equal to": "대략 같음", Aquamarine: "연한 청록색", Arrows: "화살표", "Asterisk operator": "별표 연산자", "Austral sign": "오스트랄 기호", "back with leftwards arrow above": "BACK 위 왼쪽 화살표", Background: "배경색", "Below, you can find a list of keyboard shortcuts that can be used in the editor.": "편집기에서 사용할 수 있는 키보드 단축키 목록을 아래에서 확인할 수 있습니다.", Big: "큰", "Bitcoin sign": "비트코인 기호", Black: "검은색", "Block quote": "인용 단락", Blue: "파랑색", Bold: "굵게", "Bold text": "굵은 텍스트", Border: "테두리", "Break text": "텍스트 분리", "Bulleted List": "불릿 목록", "Bulleted list styles toolbar": "글머리 기호 목록 스타일 도구 모음", Cancel: "취소", "Cannot access default workspace.": "기본 작업 공간에 액세스할 수 없습니다.", "Cannot determine a category for the uploaded file.": "업로드된 파일의 카테고리를 확인할 수 없습니다.", "Cannot upload file:": "파일 업로드할 수 없음: ", "Caption for image: %0": "이미지용 캡션: %0", "Caption for the image": "이미지용 캡션", "Cedi sign": "세디 기호", "Cell properties": "셀 속성", "Cent sign": "센트 기호", "Center table": "테이블을 가운데로 정렬", "Centered image": "가운데 정렬", "Change image text alternative": "대체 문구 변경", "Character categories": "문자 카테고리", "Choose heading": "제목 선택", Circle: "흰 원형", Clear: "지우기", "Click to edit block": "클릭하여 블록 편집", Close: "닫기", "Close contextual balloons, dropdowns, and dialogs": "상황별 풍선, 드롭다운, 대화 상자 닫기", Code: "코드", "Colon sign": "콜론 기호", Color: "색", "Color picker": "다른 색", Column: "열", "Contains as member": "원소로 포함", "Content editing keystrokes": "콘텐츠 편집 키 입력", "Copy selected content": "선택된 콘텐츠 복사", "Copyright sign": "저작권 기호", "Create link": "링크 생성", "Cruzeiro sign": "크루제이루 기호", Currency: "통화", "Currency sign": "통화 기호", Dashed: "파선", Decimal: "십진수", "Decimal with leading zero": "앞에 0이 붙는 십진수", "Decrease indent": "내어쓰기", "Decrease list item indent": "목록 항목 들여쓰기 줄이기", Default: "기본", "Degree sign": "도 기호", "Delete column": "열 삭제", "Delete row": "행 삭제", "Dim grey": "진한 회색", Dimensions: "크기", Disc: "검은 원형", "Division sign": "나누기 기호", "Document colors": "문서 색깔들", "Dollar sign": "달러 기호", "Dong sign": "동 기호", Dotted: "점선", Double: "이중선", "Double dagger": "겹칼표", "Double exclamation mark": "겹느낌표", "Double low-9 quotation mark": "낮은 겹따옴표", "Double question mark": "겹물음표", Downloadable: "다운로드 가능", "downwards arrow to bar": "아래쪽 바를 향한 화살표", "downwards dashed arrow": "아래쪽 대시 화살표", "downwards double arrow": "아래쪽 겹화살표", "downwards simple arrow": "아래쪽 단순 화살표", "Drachma sign": "드라크마 기호", "Drag to move": "드래그하여 이동", "Dropdown toolbar": "드롭다운 툴바", "Edit block": "편집 영역", "Edit image": "이미지 편집", "Edit link": "링크 편집", "Editor block content toolbar": "편집기 영역 내용 툴바", "Editor contextual toolbar": "편집기 문맥 툴바", "Editor dialog": "편집기 대화상자", "Editor editing area: %0": "편집기 편집 영역: %0", "Editor menu bar": "편집기 메뉴 표시줄", "Editor toolbar": "편집기 툴바", "Element of": "원소", "Em dash": "엠 대시", "Empty set": "공집합", "En dash": "엔 대시", "end with leftwards arrow above": "END 위 왼쪽 화살표", "Enter image caption": "사진 설명을 입력하세요", "Enter table caption": "테이블 캡션 입력", "Euro sign": "유로 기호", "Euro-currency sign": "유로화 기호", "Exclamation question mark": "느낌표 물음표", "Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content.": "현재 포커스가 맞춰진 버튼을 실행합니다. 편집기 콘텐츠와 상호 작용하는 버튼을 실행하면 포커스가 다시 콘텐츠로 이동합니다.", "Failed to determine category of edited image.": "편집한 이미지의 카테고리를 결정하지 못했습니다.", "Font Background Color": "글자 배경 색", "Font Color": "글자 색", "Font Family": "글꼴", "Font Size": "글자 크기", "For all": "전칭", "Fraction slash": "분수 슬래시", "French franc sign": "프랑스 프랑 기호", "Full size image": "꽉 찬 크기", "German penny sign": "독일 페니 기호", "Greater-than or equal to": "더 크거나 같음", "Greater-than sign": "더 큼 기호", Green: "초록색", Grey: "회색", Groove: "음각선", "Guarani sign": "과라니 기호", "Header column": "헤더 열", "Header row": "헤더 행", Heading: "제목", "Heading 1": "제목 1", "Heading 2": "제목 2", "Heading 3": "제목 3", "Heading 4": "제목 4", "Heading 5": "제목 5", "Heading 6": "제목 6", Height: "세로", "Help Contents. To close this dialog press ESC.": "도움말 내용입니다. 이 대화 상자를 닫으려면 ESC 키를 누르세요.", HEX: "HEX", "Horizontal ellipsis": "세 점 줄임표", "Horizontal line": "수평선", "Horizontal text alignment toolbar": "가로 텍스트 정렬 도구 모음", "Hryvnia sign": "흐리브냐 기호", Huge: "매우 큰", "Identical to": "합동", "Image from computer": "컴퓨터에서 이미지 가져오기", "Image resize list": "사진 크기 목록", "Image toolbar": "사진 툴바", "image widget": "사진 위젯", "In line": "줄 안에", "Increase indent": "들여쓰기", "Increase list item indent": "목록 항목 들여쓰기 늘리기", "Indian rupee sign": "인도 루피 기호", Infinity: "무한대", Insert: "삽입", "Insert a hard break (a new paragraph)": "단락 바꿈 삽입(새 단락)", "Insert a new paragraph directly after a widget": "위젯 바로 뒤에 새 단락 삽입", "Insert a new paragraph directly before a widget": "위젯 바로 앞에 새 단락 삽입", "Insert a new table row (when in the last cell of a table)": "새 표 행 삽입(표의 마지막 셀에 있을 때)", "Insert a soft break (a <code>&lt;br&gt;</code> element)": "줄 바꿈 삽입(<code>&lt;br&gt;</code> 요소)", "Insert column left": "왼쪽에 열 삽입", "Insert column right": "오른쪽에 열 삽입", "Insert image": "사진 삽입", "Insert image via URL": "URL로 이미지 삽입", "Insert image with file manager": "파일 관리자를 사용하여 이미지 삽입", "Insert media": "미디어 삽입", "Insert paragraph after block": "블록 뒤에 단락 삽입", "Insert paragraph before block": "블록 앞에 단락 삽입", "Insert row above": "위에 행 삽입", "Insert row below": "아래에 행 삽입", "Insert table": "표", "Insert with file manager": "파일 관리자를 사용하여 삽입", Inset: "측면 음각선", Integral: "적분", Intersection: "교집합", "Invalid start index value.": "잘못된 시작 인덱스 값입니다.", "Inverted exclamation mark": "역느낌표", "Inverted question mark": "역물음표", Italic: "기울임꼴", "Italic text": "기울인 텍스트", Justify: "양쪽 정렬", "Justify cell text": "셀 텍스트를 양쪽으로 정렬", "Keystrokes that can be used in a list": "목록에서 사용할 수 있는 키 입력", "Keystrokes that can be used in a table cell": "표 셀에서 사용할 수 있는 키 입력", "Keystrokes that can be used when a widget is selected (for example: image, table, etc.)": "위젯이 선택되었을 때 사용할 수 있는 키 입력(예: 이미지, 표 등)", "Kip sign": "킵 기호", Latin: "라틴", "Latin capital letter a with breve": "반달점 부호가 있는 라틴어 대문자 A", "Latin capital letter a with macron": "장음 부호가 있는 라틴어 대문자 A", "Latin capital letter a with ogonek": "꼬리 부호가 있는 라틴어 대문자 A", "Latin capital letter c with acute": "양음 부호가 있는 라틴어 대문자 C", "Latin capital letter c with caron": "반대 곡절 부호가 있는 라틴어 대문자 C", "Latin capital letter c with circumflex": "곡절 부호가 있는 라틴어 대문자 C", "Latin capital letter c with dot above": "위에 점 부호가 있는 라틴어 대문자 C", "Latin capital letter d with caron": "반대 곡절 부호가 있는 라틴어 대문자 D", "Latin capital letter d with stroke": "획 부호가 있는 라틴어 대문자 D", "Latin capital letter e with breve": "반달점 부호가 있는 라틴어 대문자 E", "Latin capital letter e with caron": "반대 곡절 부호가 있는 라틴어 대문자 E", "Latin capital letter e with dot above": "위에 점 부호가 있는 라틴어 대문자 E", "Latin capital letter e with macron": "장음 부호가 있는 라틴어 대문자 E", "Latin capital letter e with ogonek": "꼬리 부호가 있는 라틴어 대문자 E", "Latin capital letter eng": "라틴어 대문자 엥", "Latin capital letter g with breve": "반달점 부호가 있는 라틴어 대문자 G", "Latin capital letter g with cedilla": "갈고리 부호가 있는 라틴어 대문자 G", "Latin capital letter g with circumflex": "곡절 부호가 있는 라틴어 대문자 G", "Latin capital letter g with dot above": "위에 점 부호가 있는 라틴어 대문자 G", "Latin capital letter h with circumflex": "곡절 부호가 있는 라틴어 대문자 H", "Latin capital letter h with stroke": "획 부호가 있는 라틴어 대문자 H", "Latin capital letter i with breve": "반달점 부호가 있는 라틴어 대문자 I", "Latin capital letter i with dot above": "위에 점 부호가 있는 라틴어 대문자 I", "Latin capital letter i with macron": "장음 부호가 있는 라틴어 대문자 I", "Latin capital letter i with ogonek": "꼬리 부호가 있는 라틴어 대문자 I", "Latin capital letter i with tilde": "물결 부호가 있는 라틴어 대문자 I", "Latin capital letter j with circumflex": "곡절 부호가 있는 라틴어 대문자 J", "Latin capital letter k with cedilla": "갈고리 부호가 있는 라틴어 대문자 K", "Latin capital letter l with acute": "양음 부호가 있는 라틴어 대문자 I", "Latin capital letter l with caron": "반대 곡절 부호가 있는 라틴어 대문자 I", "Latin capital letter l with cedilla": "갈고리 부호가 있는 라틴어 대문자 I", "Latin capital letter l with middle dot": "중간에 점 부호가 있는 라틴어 대문자 I", "Latin capital letter l with stroke": "획 부호가 있는 라틴어 대문자 I", "Latin capital letter n with acute": "양음 부호가 있는 라틴어 대문자 N", "Latin capital letter n with caron": "반대 곡절 부호가 있는 라틴어 대문자 N", "Latin capital letter n with cedilla": "갈고리 부호가 있는 라틴어 대문자 N", "Latin capital letter o with breve": "반달점 부호가 있는 라틴어 대문자 O", "Latin capital letter o with double acute": "이중 양음 부호가 있는 라틴어 대문자 O", "Latin capital letter o with macron": "장음 부호가 있는 라틴어 대문자 O", "Latin capital letter r with acute": "양음 부호가 있는 라틴어 대문자 R", "Latin capital letter r with caron": "반대 곡절 부호가 있는 라틴어 대문자 R", "Latin capital letter r with cedilla": "갈고리 부호가 있는 라틴어 대문자 R", "Latin capital letter s with acute": "양음 부호가 있는 라틴어 대문자 S", "Latin capital letter s with caron": "반대 곡절 부호가 있는 라틴어 대문자 S", "Latin capital letter s with cedilla": "갈고리 부호가 있는 라틴어 대문자 S", "Latin capital letter s with circumflex": "곡절 부호가 있는 라틴어 대문자 S", "Latin capital letter t with caron": "반대 곡절 부호가 있는 라틴어 대문자 T", "Latin capital letter t with cedilla": "갈고리 부호가 있는 라틴어 대문자 T", "Latin capital letter t with stroke": "획 부호가 있는 라틴어 대문자 T", "Latin capital letter u with breve": "반달점 부호가 있는 라틴어 대문자 U", "Latin capital letter u with double acute": "이중 양음 부호가 있는 라틴어 대문자 U", "Latin capital letter u with macron": "장음 부호가 있는 라틴어 대문자 U", "Latin capital letter u with ogonek": "꼬리 부호가 있는 라틴어 대문자 U", "Latin capital letter u with ring above": "위에 고리가 있는 라틴어 대문자 U", "Latin capital letter u with tilde": "물결 부호가 있는 라틴어 대문자 U", "Latin capital letter w with circumflex": "곡절 부호가 있는 라틴어 대문자 W", "Latin capital letter y with circumflex": "곡절 부호가 있는 라틴어 대문자 Y", "Latin capital letter y with diaeresis": "분음 부호가 있는 라틴어 대문자 Y", "Latin capital letter z with acute": "양음 부호가 있는 라틴어 대문자 Z", "Latin capital letter z with caron": "반대 곡절 부호가 있는 라틴어 대문자 Z", "Latin capital letter z with dot above": "위에 점 부호가 있는 라틴어 대문자 Z", "Latin capital ligature ij": "라틴어 대문자 합자 IJ", "Latin capital ligature oe": "라틴어 대문자 합자 OE", "Latin small letter a with breve": "반달점 부호가 있는 라틴어 소문자 a", "Latin small letter a with macron": "장음 부호가 있는 라틴어 소문자 a", "Latin small letter a with ogonek": "꼬리 부호가 있는 라틴어 소문자 a", "Latin small letter c with acute": "양음 부호가 있는 라틴어 소문자 c", "Latin small letter c with caron": "반대 곡절 부호가 있는 라틴어 소문자 c", "Latin small letter c with circumflex": "곡절 부호가 있는 라틴어 소문자 c", "Latin small letter c with dot above": "위에 점 부호가 있는 라틴어 소문자 c", "Latin small letter d with caron": "반대 곡절 부호가 있는 라틴어 소문자 d", "Latin small letter d with stroke": "획 부호가 있는 라틴어 소문자 d", "Latin small letter dotless i": "라틴어 소문자 점 없는 i", "Latin small letter e with breve": "반달점 부호가 있는 라틴어 소문자 e", "Latin small letter e with caron": "반대 곡절 부호가 있는 라틴어 소문자 e", "Latin small letter e with dot above": "위에 점 부호가 있는 라틴어 소문자 e", "Latin small letter e with macron": "장음 부호가 있는 라틴어 소문자 e", "Latin small letter e with ogonek": "꼬리 부호가 있는 라틴어 소문자 e", "Latin small letter eng": "라틴어 소문자 엥", "Latin small letter f with hook": "밑이 구부러진 라틴어 소문자 f", "Latin small letter g with breve": "반달점 부호가 있는 라틴어 소문자 g", "Latin small letter g with cedilla": "갈고리 부호가 있는 라틴어 소문자 g", "Latin small letter g with circumflex": "곡절 부호가 있는 라틴어 소문자 g", "Latin small letter g with dot above": "위에 점 부호가 있는 라틴어 소문자 g", "Latin small letter h with circumflex": "곡절 부호가 있는 라틴어 소문자 h", "Latin small letter h with stroke": "획 부호가 있는 라틴어 소문자 h", "Latin small letter i with breve": "반달점 부호가 있는 라틴어 소문자 i", "Latin small letter i with macron": "장음 부호가 있는 라틴어 소문자 i", "Latin small letter i with ogonek": "꼬리 부호가 있는 라틴어 소문자 i", "Latin small letter i with tilde": "물결 부호가 있는 라틴어 소문자 i", "Latin small letter j with circumflex": "곡절 부호가 있는 라틴어 소문자 j", "Latin small letter k with cedilla": "갈고리 부호가 있는 라틴어 소문자 k", "Latin small letter kra": "라틴어 소문자 크라", "Latin small letter l with acute": "양음 부호가 있는 라틴어 소문자 i", "Latin small letter l with caron": "반대 곡절 부호가 있는 라틴어 소문자 i", "Latin small letter l with cedilla": "갈고리 부호가 있는 라틴어 소문자 i", "Latin small letter l with middle dot": "중간에 점 부호가 있는 라틴어 소문자 i", "Latin small letter l with stroke": "획 부호가 있는 라틴어 소문자 i", "Latin small letter long s": "라틴어 소문자 긴 s", "Latin small letter n preceded by apostrophe": "아포스트로피 다음에 있는 라틴어 소문자 n", "Latin small letter n with acute": "양음 부호가 있는 라틴어 소문자 n", "Latin small letter n with caron": "반대 곡절 부호가 있는 라틴어 소문자 n", "Latin small letter n with cedilla": "갈고리 부호가 있는 라틴어 소문자 n", "Latin small letter o with breve": "반달점 부호가 있는 라틴어 소문자 o", "Latin small letter o with double acute": "이중 양음 부호가 있는 라틴어 소문자 o", "Latin small letter o with macron": "장음 부호가 있는 라틴어 소문자 o", "Latin small letter r with acute": "양음 부호가 있는 라틴어 소문자 r", "Latin small letter r with caron": "반대 곡절 부호가 있는 라틴어 소문자 r", "Latin small letter r with cedilla": "갈고리 부호가 있는 라틴어 소문자 r", "Latin small letter s with acute": "양음 부호가 있는 라틴어 소문자 s", "Latin small letter s with caron": "반대 곡절 부호가 있는 라틴어 소문자 s", "Latin small letter s with cedilla": "갈고리 부호가 있는 라틴어 소문자 s", "Latin small letter s with circumflex": "곡절 부호가 있는 라틴어 소문자 s", "Latin small letter t with caron": "반대 곡절 부호가 있는 라틴어 소문자 t", "Latin small letter t with cedilla": "갈고리 부호가 있는 라틴어 소문자 t", "Latin small letter t with stroke": "획 부호가 있는 라틴어 소문자 t", "Latin small letter u with breve": "반달점 부호가 있는 라틴어 소문자 u", "Latin small letter u with double acute": "이중 양음 부호가 있는 라틴어 소문자 u", "Latin small letter u with macron": "장음 부호가 있는 라틴어 소문자 u", "Latin small letter u with ogonek": "꼬리 부호가 있는 라틴어 소문자 u", "Latin small letter u with ring above": "위에 고리가 있는 라틴어 소문자 u", "Latin small letter u with tilde": "물결 부호가 있는 라틴어 소문자 u", "Latin small letter w with circumflex": "곡절 부호가 있는 라틴어 소문자 w", "Latin small letter y with circumflex": "곡절 부호가 있는 라틴어 소문자 y", "Latin small letter z with acute": "양음 부호가 있는 라틴어 소문자 z", "Latin small letter z with caron": "반대 곡절 부호가 있는 라틴어 소문자 z", "Latin small letter z with dot above": "위에 점 부호가 있는 라틴어 소문자 z", "Latin small ligature ij": "라틴어 소문자 합자 ij", "Latin small ligature oe": "라틴어 소문자 합자 oe", "Left aligned image": "왼쪽 정렬", "Left double quotation mark": "왼쪽 큰따옴표", "Left single quotation mark": "왼쪽 작은따옴표", "Left-pointing double angle quotation mark": "왼쪽 겹화살괄호", "leftwards arrow to bar": "왼쪽 바를 향한 화살표", "leftwards dashed arrow": "왼쪽 대시 화살표", "leftwards double arrow": "왼쪽 겹화살표", "leftwards simple arrow": "왼쪽 단순 화살표", "Less-than or equal to": "더 작거나 같음", "Less-than sign": "더 작음 기호", "Light blue": "연한 파랑색", "Light green": "연한 초록색", "Light grey": "밝은 회색", Link: "링크", "Link image": "사진 링크", "Link URL": "링크 주소", "Lira sign": "리라 기호", "List properties": "목록 속성", "Livre tournois sign": "리브르 트르누아 기호", "Logical and": "논리곱", "Logical or": "논리합", "Lower-latin": "소문자 알파벳", "Lower–roman": "소문자 로마자", Macron: "장음 부호", "Manat sign": "마나트 기호", Mathematical: "수식", "Media toolbar": "미디어 툴바", "Media URL": "미디어 URL", "media widget": "미디어 위젯", MENU_BAR_MENU_EDIT: "수정", MENU_BAR_MENU_FILE: "파일", MENU_BAR_MENU_FONT: "글꼴", MENU_BAR_MENU_FORMAT: "서식", MENU_BAR_MENU_HELP: "도움말", MENU_BAR_MENU_INSERT: "삽입", MENU_BAR_MENU_TEXT: "텍스트", MENU_BAR_MENU_TOOLS: "도구", MENU_BAR_MENU_VIEW: "보기", "Merge cell down": "아래 셀과 병합", "Merge cell left": "왼쪽 셀과 병합", "Merge cell right": "오른쪽 셀과 병합", "Merge cell up": "위 셀과 병합", "Merge cells": "셀 병합", "Mill sign": "밀 기호", "Minus sign": "빼기 기호", "Move focus between form fields (inputs, buttons, etc.)": "양식 필드(입력, 버튼 등) 간에 포커스 이동", "Move focus in and out of an active dialog window": "활성화된 대화 창 안팎으로 포커스 이동", "Move focus to the menu bar, navigate between menu bars": "메뉴 표시줄로 포커스 이동, 메뉴 표시줄 탐색", "Move focus to the toolbar, navigate between toolbars": "도구 모음으로 포커스 이동, 도구 모음 간 탐색", "Move out of a link": "링크 밖으로 이동", "Move out of an inline code style": "인라인 코드 스타일 밖으로 이동", "Move the caret to allow typing directly after a widget": "위젯 바로 뒤에 입력할 수 있도록 삽입 기호 이동", "Move the caret to allow typing directly before a widget": "위젯 바로 앞에 입력할 수 있도록 삽입 기호 이동", "Move the selection to the next cell": "선택 항목을 다음 셀로 이동", "Move the selection to the previous cell": "선택 항목을 이전 셀로 이동", "Multiplication sign": "곱하기 기호", "N-ary product": "중복순열", "N-ary summation": "누계합", Nabla: "나블라", "Naira sign": "나이라 기호", "Navigate through the table": "표 탐색", "Navigate through the toolbar or menu bar": "도구 모음 또는 메뉴 표시줄 탐색", "New sheqel sign": "뉴 세켈 기호", Next: "다음", "No results found": "결과 찾을 수 없음", "No searchable items": "검색 가능한 항목 없음", None: "선 없음", "Nordic mark sign": "노르딕 마크 기호", "Not an element of": "원소가 아님", "Not equal to": "같지 않음", "Not sign": "부정 기호", "Numbered List": "번호 목록", "Numbered list styles toolbar": "번호 목록 스타일 도구 모음", "on with exclamation mark with left right arrow above": "ON! 위 왼쪽 오른쪽 화살표", "Open file manager": "파일 관리자 열기", "Open in a new tab": "새 탭에서 열기", "Open link in new tab": "새 탭에서 링크 열기", "Open media in new tab": "새 탭에서 미디어 열기", "Open the accessibility help dialog": "접근성 도움말 대화 상자 열기", Orange: "주황색", Original: "원본", Outset: "측면 양각선", Overline: "윗줄", Padding: "여백", Paragraph: "기본", "Paragraph sign": "단락 기호", "Partial differential": "편미분", "Paste content": "콘텐츠 붙여넣기", "Paste content as plain text": "콘텐츠를 일반 텍스트로 붙여넣기", "Paste the media URL in the input.": "미디어 URL을 입력해주세요.", "Per mille sign": "퍼 마일 기호", "Per ten thousand sign": "만분율 기호", "Peseta sign": "페세타 기호", "Peso sign": "페소 기호", "Plus-minus sign": "더하기 빼기 기호", "Pound sign": "파운드 기호", "Press %0 for help.": "도움말을 보려면 %0 키를 누르세요.", "Press Enter to type after or press Shift + Enter to type before the widget": "엔터를 눌러서 위젯 뒤에 입력하거나 시프트 + 엔터를 눌러서 위젯 앞에 입력하세요", Previous: "이전", "Processing the edited image.": "편집한 이미지를 처리 중입니다.", "Proportional to": "비례", Purple: "보라색", "Question exclamation mark": "물음표 느낌표", Red: "빨간색", Redo: "다시 실행", "Registered sign": "등록 상표 기호", "Remove color": "색 없음", "Replace from computer": "컴퓨터에서 교체", "Replace image": "이미지 교체", "Replace image from computer": "컴퓨터에서 이미지 교체", "Replace image with file manager": "파일 관리자를 사용하여 이미지 교체", "Replace with file manager": "파일 관리자를 사용하여 교체", "Resize image": "사진 크기 조절", "Resize image to %0": "사진의 크기를 %0으로 조절", "Resize image to the original size": "사진을 원래 크기로 돌려놓기", "Restore default": "기본값 복원", "Reversed order": "역순", "Reversed paragraph sign": "반전된 단락 기호", "Revert autoformatting action": "자동 서식 작업 되돌리기", "Rich Text Editor": "서식 있는 텍스트 편집기", Ridge: "양각선", "Right aligned image": "오른쪽 정렬", "Right double quotation mark": "오른쪽 큰따옴표", "Right single quotation mark": "오른쪽 작은따옴표", "Right-pointing double angle quotation mark": "오른쪽 겹화살괄호", "rightwards arrow to bar": "오른쪽 바를 향한 화살표", "rightwards dashed arrow": "오른쪽 대시 화살표", "rightwards double arrow": "오른쪽 겹화살표", "rightwards simple arrow": "오른쪽 단순 화살표", Row: "행", "Ruble sign": "루블 기호", "Rupee sign": "루피 기호", Save: "저장", "Section sign": "구역 기호", "Select all": "전체 선택", "Select column": "열 선택", "Select row": "행 선택", "Server failed to process the image.": "서버가 이미지를 처리하지 못했습니다.", "Show more items": "더보기", "Side image": "본문 옆에 배치", "Single left-pointing angle quotation mark": "왼쪽 홑화살괄호", "Single low-9 quotation mark": "낮은 홑따옴표", "Single right-pointing angle quotation mark": "오른쪽 홑화살괄호", Small: "작은", Solid: "실선", "soon with rightwards arrow above": "SOON 위 오른쪽 화살표", "Special characters": "특수 기호", "Spesmilo sign": "스페스밀로 기호", "Split cell horizontally": "가로로 셀 분할", "Split cell vertically": "세로로 셀 분할", Square: "검은 사각형", "Square root": "제곱근", "Start at": "시작 번호", "Start index must be greater than 0.": "시작 번호는 0보다 커야 합니다.", Strikethrough: "취소선", "Strikethrough text": "텍스트 취소선", Style: "스타일", Subscript: "아래 첨자", Superscript: "위 첨자", Table: "표", "Table alignment toolbar": "표 정렬 도구 모음", "Table cell text alignment": "표 셀 텍스트 정렬", "Table properties": "표 속성", "Table toolbar": "표 도구 모음", "Tenge sign": "텡게 기호", Text: "텍스트", "Text alignment": "정렬", "Text alignment toolbar": "텍스트 정렬 툴바", "Text alternative": "대체 문구", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': '유효하지 않은 색입니다. "#FF0000"이나 "rgb(255,0,0)", 또는 "red"를 입력해 보세요.', "The URL must not be empty.": "URL이 비어있을 수 없습니다.", 'The value is invalid. Try "10px" or "2em" or simply "2".': '유효하지 않은 값입니다. "10px"나 "2em" 또는 그냥 "2"를 입력해 보세요.', "There exists": "존재", "These keyboard shortcuts allow for quick access to content editing features.": "이러한 키보드 단축키를 사용하면 콘텐츠 편집 기능을 빠르게 사용할 수 있습니다.", "This link has no URL": "이 주소에는 URL이 없습니다.", "This media URL is not supported.": "이 미디어 URL은 지원되지 않습니다.", "Tilde operator": "물결표 연산자", Tiny: "매우 작은", "Tip: Paste the URL into the content to embed faster.": "팁: URL을 붙여넣으면 더 빨리 삽입할 수 있습니다.", "To-do List": "확인 목록", "Toggle caption off": "캡션 지우기", "Toggle caption on": "캡션 넣기", "Toggle the circle list style": "검은 원형 목록 스타일 전환", "Toggle the decimal list style": "십진수 목록 스타일 전환", "Toggle the decimal with leading zero list style": "앞에 0이 붙는 십진수 목록 스타일 전환", "Toggle the disc list style": "흰 원형 목록 스타일 전환", "Toggle the lower–latin list style": "소문자 알파벳 목록 스타일 전환", "Toggle the lower–roman list style": "소문자 로마자 목록 스타일 전환", "Toggle the square list style": "검은 사각형 목록 스타일 전환", "Toggle the upper–latin list style": "대문자 알파벳 목록 스타일 전환", "Toggle the upper–roman list style": "대문자 로마자 목록 스타일 전환", "top with upwards arrow above": "TOP 위 위쪽 화살표", "Trade mark sign": "상표 기호", "Tugrik sign": "투그리크 기호", "Turkish lira sign": "터키 리라 기호", Turquoise: "청록색", "Two dot leader": "두 점 줄임표", "Type or paste your content here.": "여기에 내용을 입력하거나 붙여넣으세요.", "Type your title": "제목을 입력해주세요", Underline: "밑줄", "Underline text": "텍스트 밑줄", Undo: "실행 취소", Union: "합집합", Unlink: "링크 삭제", "up down arrow with base": "받침이 있는 위아래 화살표", Update: "업데이트", "Update image URL": "이미지 URL 업데이트", "Upload failed": "업로드 실패", "Upload from computer": "컴퓨터에서 업로드", "Upload image from computer": "이미지", "Upload in progress": "업로드 진행 중", "Upper-latin": "대문자 알파벳", "Upper-roman": "대문자 로마자", "upwards arrow to bar": "위쪽 바를 향한 화살표", "upwards dashed arrow": "위쪽 대시 화살표", "upwards double arrow": "위쪽 겹화살표", "upwards simple arrow": "위쪽 단순 화살표", "Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface.": "다음 키 입력을 사용하여 CKEditor 5 사용자 인터페이스를 더 효율적으로 탐색하세요.", "User interface and content navigation keystrokes": "사용자 인터페이스 및 콘텐츠 탐색 키 입력", "Vertical text alignment toolbar": "세로 텍스트 정렬 도구 모음", "Vulgar fraction one half": "2분의 1", "Vulgar fraction one quarter": "4분의 1", "Vulgar fraction three quarters": "4분의 3", White: "흰색", "Widget toolbar": "위젯 툴바", Width: "가로", "Won sign": "원 기호", "Wrap text": "텍스트 줄 바꿈", Yellow: "노랑색", "Yen sign": "엔 기호" }), e.getPluralForm = function(t) {
      return 0;
    };
  })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
  (function(n) {
    const e = n.en = n.en || {};
    e.dictionary = Object.assign(e.dictionary || {}, { "(may require <kbd>Fn</kbd>)": "(may require <kbd>Fn</kbd>)", "%0 of %1": "%0 of %1", Accept: "Accept", Accessibility: "Accessibility", "Accessibility help": "Accessibility help", "Align cell text to the bottom": "Align cell text to the bottom", "Align cell text to the center": "Align cell text to the center", "Align cell text to the left": "Align cell text to the left", "Align cell text to the middle": "Align cell text to the middle", "Align cell text to the right": "Align cell text to the right", "Align cell text to the top": "Align cell text to the top", "Align center": "Center", "Align left": "Left", "Align right": "Right", "Align table to the left": "Align table to the left", "Align table to the right": "Align table to the right", Alignment: "Alignment", All: "All", "Almost equal to": "Almost equal to", Angle: "Angle", "Approximately equal to": "Approximately equal to", Aquamarine: "Aquamarine", Arrows: "Arrows", "Asterisk operator": "Asterisk operator", "Austral sign": "Austral sign", "back with leftwards arrow above": "back with leftwards arrow above", Background: "Background", "Below, you can find a list of keyboard shortcuts that can be used in the editor.": "Below, you can find a list of keyboard shortcuts that can be used in the editor.", Big: "Big", "Bitcoin sign": "Bitcoin sign", Black: "Black", "Block quote": "Quote", Blue: "Blue", Bold: "Bold", "Bold text": "Bold text", Border: "Border", "Break text": "Break text", "Bulleted List": "Bullets", "Bulleted list styles toolbar": "Bulleted list styles toolbar", Cancel: "Cancel", "Cannot access default workspace.": "Cannot access default workspace.", "Cannot determine a category for the uploaded file.": "Cannot determine a category for the uploaded file.", "Cannot upload file:": "Cannot upload file:", "Caption for image: %0": "Caption for image: %0", "Caption for the image": "Caption for the image", "Cedi sign": "Cedi sign", "Cell properties": "Cell properties", "Cent sign": "Cent sign", "Center table": "Center table", "Centered image": "Centered image", "Change image text alternative": "Change image text alternative", "Character categories": "Character categories", "Choose heading": "Choose heading", Circle: "Circle", Clear: "Clear", "Click to edit block": "Click to edit block", Close: "Close", "Close contextual balloons, dropdowns, and dialogs": "Close contextual balloons, dropdowns, and dialogs", Code: "Code", "Colon sign": "Colon sign", Color: "Color", "Color picker": "More Colors", Column: "Column", "Contains as member": "Contains as member", "Content editing keystrokes": "Content editing keystrokes", "Copy selected content": "Copy selected content", "Copyright sign": "Copyright sign", "Create link": "Create link", "Cruzeiro sign": "Cruzeiro sign", Currency: "Currency", "Currency sign": "Currency sign", Dashed: "Dashed", Decimal: "Decimal", "Decimal with leading zero": "Decimal with leading zero", "Decrease indent": "Outdent", "Decrease list item indent": "Decrease list item indent", Default: "Default", "Degree sign": "Degree sign", "Delete column": "Delete column", "Delete row": "Delete row", "Dim grey": "Dim grey", Dimensions: "Dimensions", Disc: "Disc", "Division sign": "Division sign", "Document colors": "Document colors", "Dollar sign": "Dollar sign", "Dong sign": "Dong sign", Dotted: "Dotted", Double: "Double", "Double dagger": "Double dagger", "Double exclamation mark": "Double exclamation mark", "Double low-9 quotation mark": "Double low-9 quotation mark", "Double question mark": "Double question mark", Downloadable: "Downloadable", "downwards arrow to bar": "downwards arrow to bar", "downwards dashed arrow": "downwards dashed arrow", "downwards double arrow": "downwards double arrow", "downwards simple arrow": "downwards simple arrow", "Drachma sign": "Drachma sign", "Drag to move": "Drag to move", "Dropdown toolbar": "Dropdown toolbar", "Edit block": "Edit block", "Edit image": "Edit image", "Edit link": "Edit link", "Editor block content toolbar": "Editor block content toolbar", "Editor contextual toolbar": "Editor contextual toolbar", "Editor dialog": "Editor dialog", "Editor editing area: %0": "Editor editing area: %0", "Editor menu bar": "Editor menu bar", "Editor toolbar": "Editor toolbar", "Element of": "Element of", "Em dash": "Em dash", "Empty set": "Empty set", "En dash": "En dash", "end with leftwards arrow above": "end with leftwards arrow above", "Enter image caption": "Enter image caption", "Enter table caption": "Enter table caption", "Euro sign": "Euro sign", "Euro-currency sign": "Euro-currency sign", "Exclamation question mark": "Exclamation question mark", "Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content.": "Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content.", "Failed to determine category of edited image.": "Failed to determine category of edited image.", "Font Background Color": "Text Highlight", "Font Color": "Font Color", "Font Family": "Font", "Font Size": "Font Size", "For all": "For all", "Fraction slash": "Fraction slash", "French franc sign": "French franc sign", "Full size image": "Full size image", "German penny sign": "German penny sign", "Greater-than or equal to": "Greater-than or equal to", "Greater-than sign": "Greater-than sign", Green: "Green", Grey: "Grey", Groove: "Groove", "Guarani sign": "Guarani sign", "Header column": "Header column", "Header row": "Header row", Heading: "Heading", "Heading 1": "Heading 1", "Heading 2": "Heading 2", "Heading 3": "Heading 3", "Heading 4": "Heading 4", "Heading 5": "Heading 5", "Heading 6": "Heading 6", Height: "Height", "Help Contents. To close this dialog press ESC.": "Help Contents. To close this dialog press ESC.", HEX: "HEX", "Horizontal ellipsis": "Horizontal ellipsis", "Horizontal line": "Divider", "Horizontal text alignment toolbar": "Horizontal text alignment toolbar", "Hryvnia sign": "Hryvnia sign", Huge: "Huge", "Identical to": "Identical to", "Image from computer": "Image from computer", "Image resize list": "Image resize list", "Image toolbar": "Image toolbar", "image widget": "image widget", "In line": "In line", "Increase indent": "Indent", "Increase list item indent": "Increase list item indent", "Indian rupee sign": "Indian rupee sign", Infinity: "Infinity", Insert: "Insert", "Insert a hard break (a new paragraph)": "Insert a hard break (a new paragraph)", "Insert a new paragraph directly after a widget": "Insert a new paragraph directly after a widget", "Insert a new paragraph directly before a widget": "Insert a new paragraph directly before a widget", "Insert a new table row (when in the last cell of a table)": "Insert a new table row (when in the last cell of a table)", "Insert a soft break (a <code>&lt;br&gt;</code> element)": "Insert a soft break (a <code>&lt;br&gt;</code> element)", "Insert column left": "Insert column left", "Insert column right": "Insert column right", "Insert image": "Insert image", "Insert image via URL": "Insert image via URL", "Insert image with file manager": "Insert image with file manager", "Insert media": "Insert media", "Insert paragraph after block": "Insert paragraph after block", "Insert paragraph before block": "Insert paragraph before block", "Insert row above": "Insert row above", "Insert row below": "Insert row below", "Insert table": "Table", "Insert with file manager": "Insert with file manager", Inset: "Inset", Integral: "Integral", Intersection: "Intersection", "Invalid start index value.": "Invalid start index value.", "Inverted exclamation mark": "Inverted exclamation mark", "Inverted question mark": "Inverted question mark", Italic: "Italic", "Italic text": "Italic text", Justify: "Justify", "Justify cell text": "Justify cell text", "Keystrokes that can be used in a list": "Keystrokes that can be used in a list", "Keystrokes that can be used in a table cell": "Keystrokes that can be used in a table cell", "Keystrokes that can be used when a widget is selected (for example: image, table, etc.)": "Keystrokes that can be used when a widget is selected (for example: image, table, etc.)", "Kip sign": "Kip sign", Latin: "Latin", "Latin capital letter a with breve": "Latin capital letter a with breve", "Latin capital letter a with macron": "Latin capital letter a with macron", "Latin capital letter a with ogonek": "Latin capital letter a with ogonek", "Latin capital letter c with acute": "Latin capital letter c with acute", "Latin capital letter c with caron": "Latin capital letter c with caron", "Latin capital letter c with circumflex": "Latin capital letter c with circumflex", "Latin capital letter c with dot above": "Latin capital letter c with dot above", "Latin capital letter d with caron": "Latin capital letter d with caron", "Latin capital letter d with stroke": "Latin capital letter d with stroke", "Latin capital letter e with breve": "Latin capital letter e with breve", "Latin capital letter e with caron": "Latin capital letter e with caron", "Latin capital letter e with dot above": "Latin capital letter e with dot above", "Latin capital letter e with macron": "Latin capital letter e with macron", "Latin capital letter e with ogonek": "Latin capital letter e with ogonek", "Latin capital letter eng": "Latin capital letter eng", "Latin capital letter g with breve": "Latin capital letter g with breve", "Latin capital letter g with cedilla": "Latin capital letter g with cedilla", "Latin capital letter g with circumflex": "Latin capital letter g with circumflex", "Latin capital letter g with dot above": "Latin capital letter g with dot above", "Latin capital letter h with circumflex": "Latin capital letter h with circumflex", "Latin capital letter h with stroke": "Latin capital letter h with stroke", "Latin capital letter i with breve": "Latin capital letter i with breve", "Latin capital letter i with dot above": "Latin capital letter i with dot above", "Latin capital letter i with macron": "Latin capital letter i with macron", "Latin capital letter i with ogonek": "Latin capital letter i with ogonek", "Latin capital letter i with tilde": "Latin capital letter i with tilde", "Latin capital letter j with circumflex": "Latin capital letter j with circumflex", "Latin capital letter k with cedilla": "Latin capital letter k with cedilla", "Latin capital letter l with acute": "Latin capital letter l with acute", "Latin capital letter l with caron": "Latin capital letter l with caron", "Latin capital letter l with cedilla": "Latin capital letter l with cedilla", "Latin capital letter l with middle dot": "Latin capital letter l with middle dot", "Latin capital letter l with stroke": "Latin capital letter l with stroke", "Latin capital letter n with acute": "Latin capital letter n with acute", "Latin capital letter n with caron": "Latin capital letter n with caron", "Latin capital letter n with cedilla": "Latin capital letter n with cedilla", "Latin capital letter o with breve": "Latin capital letter o with breve", "Latin capital letter o with double acute": "Latin capital letter o with double acute", "Latin capital letter o with macron": "Latin capital letter o with macron", "Latin capital letter r with acute": "Latin capital letter r with acute", "Latin capital letter r with caron": "Latin capital letter r with caron", "Latin capital letter r with cedilla": "Latin capital letter r with cedilla", "Latin capital letter s with acute": "Latin capital letter s with acute", "Latin capital letter s with caron": "Latin capital letter s with caron", "Latin capital letter s with cedilla": "Latin capital letter s with cedilla", "Latin capital letter s with circumflex": "Latin capital letter s with circumflex", "Latin capital letter t with caron": "Latin capital letter t with caron", "Latin capital letter t with cedilla": "Latin capital letter t with cedilla", "Latin capital letter t with stroke": "Latin capital letter t with stroke", "Latin capital letter u with breve": "Latin capital letter u with breve", "Latin capital letter u with double acute": "Latin capital letter u with double acute", "Latin capital letter u with macron": "Latin capital letter u with macron", "Latin capital letter u with ogonek": "Latin capital letter u with ogonek", "Latin capital letter u with ring above": "Latin capital letter u with ring above", "Latin capital letter u with tilde": "Latin capital letter u with tilde", "Latin capital letter w with circumflex": "Latin capital letter w with circumflex", "Latin capital letter y with circumflex": "Latin capital letter y with circumflex", "Latin capital letter y with diaeresis": "Latin capital letter y with diaeresis", "Latin capital letter z with acute": "Latin capital letter z with acute", "Latin capital letter z with caron": "Latin capital letter z with caron", "Latin capital letter z with dot above": "Latin capital letter z with dot above", "Latin capital ligature ij": "Latin capital ligature ij", "Latin capital ligature oe": "Latin capital ligature oe", "Latin small letter a with breve": "Latin small letter a with breve", "Latin small letter a with macron": "Latin small letter a with macron", "Latin small letter a with ogonek": "Latin small letter a with ogonek", "Latin small letter c with acute": "Latin small letter c with acute", "Latin small letter c with caron": "Latin small letter c with caron", "Latin small letter c with circumflex": "Latin small letter c with circumflex", "Latin small letter c with dot above": "Latin small letter c with dot above", "Latin small letter d with caron": "Latin small letter d with caron", "Latin small letter d with stroke": "Latin small letter d with stroke", "Latin small letter dotless i": "Latin small letter dotless i", "Latin small letter e with breve": "Latin small letter e with breve", "Latin small letter e with caron": "Latin small letter e with caron", "Latin small letter e with dot above": "Latin small letter e with dot above", "Latin small letter e with macron": "Latin small letter e with macron", "Latin small letter e with ogonek": "Latin small letter e with ogonek", "Latin small letter eng": "Latin small letter eng", "Latin small letter f with hook": "Latin small letter f with hook", "Latin small letter g with breve": "Latin small letter g with breve", "Latin small letter g with cedilla": "Latin small letter g with cedilla", "Latin small letter g with circumflex": "Latin small letter g with circumflex", "Latin small letter g with dot above": "Latin small letter g with dot above", "Latin small letter h with circumflex": "Latin small letter h with circumflex", "Latin small letter h with stroke": "Latin small letter h with stroke", "Latin small letter i with breve": "Latin small letter i with breve", "Latin small letter i with macron": "Latin small letter i with macron", "Latin small letter i with ogonek": "Latin small letter i with ogonek", "Latin small letter i with tilde": "Latin small letter i with tilde", "Latin small letter j with circumflex": "Latin small letter j with circumflex", "Latin small letter k with cedilla": "Latin small letter k with cedilla", "Latin small letter kra": "Latin small letter kra", "Latin small letter l with acute": "Latin small letter l with acute", "Latin small letter l with caron": "Latin small letter l with caron", "Latin small letter l with cedilla": "Latin small letter l with cedilla", "Latin small letter l with middle dot": "Latin small letter l with middle dot", "Latin small letter l with stroke": "Latin small letter l with stroke", "Latin small letter long s": "Latin small letter long s", "Latin small letter n preceded by apostrophe": "Latin small letter n preceded by apostrophe", "Latin small letter n with acute": "Latin small letter n with acute", "Latin small letter n with caron": "Latin small letter n with caron", "Latin small letter n with cedilla": "Latin small letter n with cedilla", "Latin small letter o with breve": "Latin small letter o with breve", "Latin small letter o with double acute": "Latin small letter o with double acute", "Latin small letter o with macron": "Latin small letter o with macron", "Latin small letter r with acute": "Latin small letter r with acute", "Latin small letter r with caron": "Latin small letter r with caron", "Latin small letter r with cedilla": "Latin small letter r with cedilla", "Latin small letter s with acute": "Latin small letter s with acute", "Latin small letter s with caron": "Latin small letter s with caron", "Latin small letter s with cedilla": "Latin small letter s with cedilla", "Latin small letter s with circumflex": "Latin small letter s with circumflex", "Latin small letter t with caron": "Latin small letter t with caron", "Latin small letter t with cedilla": "Latin small letter t with cedilla", "Latin small letter t with stroke": "Latin small letter t with stroke", "Latin small letter u with breve": "Latin small letter u with breve", "Latin small letter u with double acute": "Latin small letter u with double acute", "Latin small letter u with macron": "Latin small letter u with macron", "Latin small letter u with ogonek": "Latin small letter u with ogonek", "Latin small letter u with ring above": "Latin small letter u with ring above", "Latin small letter u with tilde": "Latin small letter u with tilde", "Latin small letter w with circumflex": "Latin small letter w with circumflex", "Latin small letter y with circumflex": "Latin small letter y with circumflex", "Latin small letter z with acute": "Latin small letter z with acute", "Latin small letter z with caron": "Latin small letter z with caron", "Latin small letter z with dot above": "Latin small letter z with dot above", "Latin small ligature ij": "Latin small ligature ij", "Latin small ligature oe": "Latin small ligature oe", "Left aligned image": "Left aligned image", "Left double quotation mark": "Left double quotation mark", "Left single quotation mark": "Left single quotation mark", "Left-pointing double angle quotation mark": "Left-pointing double angle quotation mark", "leftwards arrow to bar": "leftwards arrow to bar", "leftwards dashed arrow": "leftwards dashed arrow", "leftwards double arrow": "leftwards double arrow", "leftwards simple arrow": "leftwards simple arrow", "Less-than or equal to": "Less-than or equal to", "Less-than sign": "Less-than sign", "Light blue": "Light blue", "Light green": "Light green", "Light grey": "Light grey", Link: "Link", "Link image": "Link image", "Link URL": "Link URL", "Lira sign": "Lira sign", "List properties": "List properties", "Livre tournois sign": "Livre tournois sign", "Logical and": "Logical and", "Logical or": "Logical or", "Lower-latin": "Lower-latin", "Lower–roman": "Lower–roman", Macron: "Macron", "Manat sign": "Manat sign", Mathematical: "Mathematical", "Media toolbar": "Media toolbar", "Media URL": "Media URL", "media widget": "media widget", MENU_BAR_MENU_EDIT: "Edit", MENU_BAR_MENU_FILE: "File", MENU_BAR_MENU_FONT: "Font", MENU_BAR_MENU_FORMAT: "Format", MENU_BAR_MENU_HELP: "Help", MENU_BAR_MENU_INSERT: "Insert", MENU_BAR_MENU_TEXT: "Text", MENU_BAR_MENU_TOOLS: "Tools", MENU_BAR_MENU_VIEW: "View", "Merge cell down": "Merge cell down", "Merge cell left": "Merge cell left", "Merge cell right": "Merge cell right", "Merge cell up": "Merge cell up", "Merge cells": "Merge cells", "Mill sign": "Mill sign", "Minus sign": "Minus sign", "Move focus between form fields (inputs, buttons, etc.)": "Move focus between form fields (inputs, buttons, etc.)", "Move focus in and out of an active dialog window": "Move focus in and out of an active dialog window", "Move focus to the menu bar, navigate between menu bars": "Move focus to the menu bar, navigate between menu bars", "Move focus to the toolbar, navigate between toolbars": "Move focus to the toolbar, navigate between toolbars", "Move out of a link": "Move out of a link", "Move out of an inline code style": "Move out of an inline code style", "Move the caret to allow typing directly after a widget": "Move the caret to allow typing directly after a widget", "Move the caret to allow typing directly before a widget": "Move the caret to allow typing directly before a widget", "Move the selection to the next cell": "Move the selection to the next cell", "Move the selection to the previous cell": "Move the selection to the previous cell", "Multiplication sign": "Multiplication sign", "N-ary product": "N-ary product", "N-ary summation": "N-ary summation", Nabla: "Nabla", "Naira sign": "Naira sign", "Navigate through the table": "Navigate through the table", "Navigate through the toolbar or menu bar": "Navigate through the toolbar or menu bar", "New sheqel sign": "New sheqel sign", Next: "Next", "No results found": "No results found", "No searchable items": "No searchable items", None: "None", "Nordic mark sign": "Nordic mark sign", "Not an element of": "Not an element of", "Not equal to": "Not equal to", "Not sign": "Not sign", "Numbered List": "Numbering", "Numbered list styles toolbar": "Numbered list styles toolbar", "on with exclamation mark with left right arrow above": "on with exclamation mark with left right arrow above", "Open file manager": "Open file manager", "Open in a new tab": "Open in a new tab", "Open link in new tab": "Open link in new tab", "Open media in new tab": "Open media in new tab", "Open the accessibility help dialog": "Open the accessibility help dialog", Orange: "Orange", Original: "Original", Outset: "Outset", Overline: "Overline", Padding: "Padding", Paragraph: "Default", "Paragraph sign": "Paragraph sign", "Partial differential": "Partial differential", "Paste content": "Paste content", "Paste content as plain text": "Paste content as plain text", "Paste the media URL in the input.": "Paste the media URL in the input.", "Per mille sign": "Per mille sign", "Per ten thousand sign": "Per ten thousand sign", "Peseta sign": "Peseta sign", "Peso sign": "Peso sign", "Plus-minus sign": "Plus-minus sign", "Pound sign": "Pound sign", "Press %0 for help.": "Press %0 for help.", "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget", Previous: "Previous", "Processing the edited image.": "Processing the edited image.", "Proportional to": "Proportional to", Purple: "Purple", "Question exclamation mark": "Question exclamation mark", Red: "Red", Redo: "Redo", "Registered sign": "Registered sign", "Remove color": "No Color", "Replace from computer": "Replace from computer", "Replace image": "Replace image", "Replace image from computer": "Replace image from computer", "Replace image with file manager": "Replace image with file manager", "Replace with file manager": "Replace with file manager", "Resize image": "Resize image", "Resize image to %0": "Resize image to %0", "Resize image to the original size": "Resize image to the original size", "Restore default": "Restore default", "Reversed order": "Reversed order", "Reversed paragraph sign": "Reversed paragraph sign", "Revert autoformatting action": "Revert autoformatting action", "Rich Text Editor": "Rich Text Editor", Ridge: "Ridge", "Right aligned image": "Right aligned image", "Right double quotation mark": "Right double quotation mark", "Right single quotation mark": "Right single quotation mark", "Right-pointing double angle quotation mark": "Right-pointing double angle quotation mark", "rightwards arrow to bar": "rightwards arrow to bar", "rightwards dashed arrow": "rightwards dashed arrow", "rightwards double arrow": "rightwards double arrow", "rightwards simple arrow": "rightwards simple arrow", Row: "Row", "Ruble sign": "Ruble sign", "Rupee sign": "Rupee sign", Save: "Save", "Section sign": "Section sign", "Select all": "Select all", "Select column": "Select column", "Select row": "Select row", "Server failed to process the image.": "Server failed to process the image.", "Show more items": "Show more items", "Side image": "Side image", "Single left-pointing angle quotation mark": "Single left-pointing angle quotation mark", "Single low-9 quotation mark": "Single low-9 quotation mark", "Single right-pointing angle quotation mark": "Single right-pointing angle quotation mark", Small: "Small", Solid: "Solid", "soon with rightwards arrow above": "soon with rightwards arrow above", "Special characters": "Symbol", "Spesmilo sign": "Spesmilo sign", "Split cell horizontally": "Split cell horizontally", "Split cell vertically": "Split cell vertically", Square: "Square", "Square root": "Square root", "Start at": "Start at", "Start index must be greater than 0.": "Start index must be greater than 0.", Strikethrough: "Strikethrough", "Strikethrough text": "Strikethrough text", Style: "Style", Subscript: "Subscript", Superscript: "Superscript", Table: "Table", "Table alignment toolbar": "Table alignment toolbar", "Table cell text alignment": "Table cell text alignment", "Table properties": "Table properties", "Table toolbar": "Table toolbar", "Tenge sign": "Tenge sign", Text: "Text", "Text alignment": "Alignment", "Text alignment toolbar": "Text alignment toolbar", "Text alternative": "Text alternative", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".', "The URL must not be empty.": "The URL must not be empty.", 'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".', "There exists": "There exists", "These keyboard shortcuts allow for quick access to content editing features.": "These keyboard shortcuts allow for quick access to content editing features.", "This link has no URL": "This link has no URL", "This media URL is not supported.": "This media URL is not supported.", "Tilde operator": "Tilde operator", Tiny: "Tiny", "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.", "To-do List": "To-do List", "Toggle caption off": "Toggle caption off", "Toggle caption on": "Toggle caption on", "Toggle the circle list style": "Toggle the circle list style", "Toggle the decimal list style": "Toggle the decimal list style", "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style", "Toggle the disc list style": "Toggle the disc list style", "Toggle the lower–latin list style": "Toggle the lower–latin list style", "Toggle the lower–roman list style": "Toggle the lower–roman list style", "Toggle the square list style": "Toggle the square list style", "Toggle the upper–latin list style": "Toggle the upper–latin list style", "Toggle the upper–roman list style": "Toggle the upper–roman list style", "top with upwards arrow above": "top with upwards arrow above", "Trade mark sign": "Trade mark sign", "Tugrik sign": "Tugrik sign", "Turkish lira sign": "Turkish lira sign", Turquoise: "Turquoise", "Two dot leader": "Two dot leader", "Type or paste your content here.": "Type or paste your content here.", "Type your title": "Type your title", Underline: "Underline", "Underline text": "Underline text", Undo: "Undo", Union: "Union", Unlink: "Unlink", "up down arrow with base": "up down arrow with base", Update: "Update", "Update image URL": "Update image URL", "Upload failed": "Upload failed", "Upload from computer": "Upload from computer", "Upload image from computer": "Image", "Upload in progress": "Upload in progress", "Upper-latin": "Upper-latin", "Upper-roman": "Upper-roman", "upwards arrow to bar": "upwards arrow to bar", "upwards dashed arrow": "upwards dashed arrow", "upwards double arrow": "upwards double arrow", "upwards simple arrow": "upwards simple arrow", "Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface.": "Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface.", "User interface and content navigation keystrokes": "User interface and content navigation keystrokes", "Vertical text alignment toolbar": "Vertical text alignment toolbar", "Vulgar fraction one half": "Vulgar fraction one half", "Vulgar fraction one quarter": "Vulgar fraction one quarter", "Vulgar fraction three quarters": "Vulgar fraction three quarters", White: "White", "Widget toolbar": "Widget toolbar", Width: "Width", "Won sign": "Won sign", "Wrap text": "Wrap text", Yellow: "Yellow", "Yen sign": "Yen sign" });
  })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
  function xS(n, e) {
    let t;
    return function(...i) {
      clearTimeout(t), t = setTimeout(() => {
        n.apply(this, i);
      }, e);
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ls extends Gt {
    constructor(e) {
      super(e), this.domEventType = [
        "paste",
        "copy",
        "cut",
        "drop",
        "dragover",
        "dragstart",
        "dragend",
        "dragenter",
        "dragleave"
      ];
      const t = this.document;
      this.listenTo(t, "paste", i("clipboardInput"), { priority: "low" }), this.listenTo(t, "drop", i("clipboardInput"), { priority: "low" }), this.listenTo(t, "dragover", i("dragging"), { priority: "low" });
      function i(s) {
        return (o, r) => {
          r.preventDefault();
          const a = r.dropRange ? [r.dropRange] : null, l = new Pt(t, s);
          t.fire(l, {
            dataTransfer: r.dataTransfer,
            method: o.name,
            targetRanges: a,
            target: r.target,
            domEvent: r.domEvent
          }), l.stop.called && r.stopPropagation();
        };
      }
    }
    onDomEvent(e) {
      const t = "clipboardData" in e ? e.clipboardData : e.dataTransfer, i = e.type == "drop" || e.type == "paste", s = {
        dataTransfer: new km(t, { cacheFiles: i })
      };
      (e.type == "drop" || e.type == "dragover") && (s.dropRange = SS(this.view, e)), this.fire(e.type, e, s);
    }
  }
  function SS(n, e) {
    const t = e.target.ownerDocument, i = e.clientX, s = e.clientY;
    let o;
    return t.caretRangeFromPoint && t.caretRangeFromPoint(i, s) ? o = t.caretRangeFromPoint(i, s) : e.rangeParent && (o = t.createRange(), o.setStart(e.rangeParent, e.rangeOffset), o.collapse(!0)), o ? n.domConverter.domRangeToView(o) : null;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function IS(n) {
    return n = n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;"), (n.includes("</p><p>") || n.includes("<br>")) && (n = `<p>${n}</p>`), n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function PS(n) {
    return n.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length == 1 ? " " : t).replace(/<!--[\s\S]*?-->/g, "");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const cd = ["figcaption", "li"], ud = ["ol", "ul"];
  function zg(n) {
    if (n.is("$text") || n.is("$textProxy"))
      return n.data;
    if (n.is("element", "img") && n.hasAttribute("alt"))
      return n.getAttribute("alt");
    if (n.is("element", "br"))
      return `
`;
    let e = "", t = null;
    for (const i of n.getChildren())
      e += RS(i, t) + zg(i), t = i;
    return e;
  }
  function RS(n, e) {
    return e ? n.is("element", "li") && !n.isEmpty && n.getChild(0).is("containerElement") || ud.includes(n.name) && ud.includes(e.name) ? `

` : !n.is("containerElement") && !e.is("containerElement") ? "" : cd.includes(n.name) || cd.includes(e.name) ? `
` : `

` : "";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Hn extends w {
    constructor() {
      super(...arguments), this._markersToCopy = /* @__PURE__ */ new Map();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ClipboardMarkersUtils";
    }
    /**
     * Registers marker name as copyable in clipboard pipeline.
     *
     * @param markerName Name of marker that can be copied.
     * @param config Configuration that describes what can be performed on specified marker.
     * @internal
     */
    _registerMarkerToCopy(e, t) {
      this._markersToCopy.set(e, t);
    }
    /**
     * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.
     *
     * 	1. Picks all markers in provided selection.
     * 	2. Inserts fake markers to document.
     * 	3. Gets copied selection fragment from document.
     * 	4. Removes fake elements from fragment and document.
     * 	5. Inserts markers in the place of removed fake markers.
     *
     * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.
     * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.
     *
     * @param action Type of clipboard action.
     * @param writer An instance of the model writer.
     * @param selection Selection to be checked.
     * @param getCopiedFragment	Callback that performs copy of selection and returns it as fragment.
     * @internal
     */
    _copySelectedFragmentWithMarkers(e, t, i = (s) => s.model.getSelectedContent(s.model.document.selection)) {
      return this.editor.model.change((s) => {
        const o = s.model.document.selection;
        s.setSelection(t);
        const r = this._insertFakeMarkersIntoSelection(s, s.model.document.selection, e), a = i(s), l = this._removeFakeMarkersInsideElement(s, a);
        for (const [c, u] of Object.entries(r)) {
          l[c] || (l[c] = s.createRangeIn(a));
          for (const d of u)
            s.remove(d);
        }
        a.markers.clear();
        for (const [c, u] of Object.entries(l))
          a.markers.set(c, u);
        return s.setSelection(o), a;
      });
    }
    /**
     * Performs paste of markers on already pasted element.
     *
     * 	1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).
     * 	2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.
     * 	3. Removes all fake markers present in transformed element.
     * 	4. Inserts new markers with removed fake markers ranges into pasted fragment.
     *
     * There are multiple edge cases that have to be considered before calling this function:
     *
     * 	* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.
     * 	* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.
     * 	* If `duplicateOnPaste` is `true` in marker config then associated marker ID is regenerated before pasting.
     *
     * @param action Type of clipboard action.
     * @param markers Object that maps marker name to corresponding range.
     * @param getPastedDocumentElement Getter used to get target markers element.
     * @internal
     */
    _pasteMarkersIntoTransformedElement(e, t) {
      const i = this._getPasteMarkersFromRangeMap(e);
      return this.editor.model.change((s) => {
        const o = this._insertFakeMarkersElements(s, i), r = t(s), a = this._removeFakeMarkersInsideElement(s, r);
        for (const l of Object.values(o).flat())
          s.remove(l);
        for (const [l, c] of Object.entries(a))
          s.model.markers.has(l) || s.addMarker(l, {
            usingOperation: !0,
            affectsData: !0,
            range: c
          });
        return r;
      });
    }
    /**
     * Pastes document fragment with markers to document.
     * If `duplicateOnPaste` is `true` in marker config then associated markers IDs
     * are regenerated before pasting to avoid markers duplications in content.
     *
     * @param fragment Document fragment that should contain already processed by pipeline markers.
     * @internal
     */
    _pasteFragmentWithMarkers(e) {
      const t = this._getPasteMarkersFromRangeMap(e.markers);
      e.markers.clear();
      for (const i of t)
        e.markers.set(i.name, i.range);
      return this.editor.model.insertContent(e);
    }
    /**
     * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass
     * restrictions on markers that we want to copy.
     *
     * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy
     * content, markers with the specified name will be copied to the clipboard as well.
     *
     * @param markerName Which markers should be copied.
     * @param executor Callback executed.
     * @param config Optional configuration flags used to copy (such like partial copy flag).
     * @internal
     */
    _forceMarkersCopy(e, t, i = {
      allowedActions: "all",
      copyPartiallySelected: !0,
      duplicateOnPaste: !0
    }) {
      const s = this._markersToCopy.get(e);
      this._markersToCopy.set(e, i), t(), s ? this._markersToCopy.set(e, s) : this._markersToCopy.delete(e);
    }
    /**
     * Checks if marker can be copied.
     *
     * @param markerName Name of checked marker.
     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
     * @internal
     */
    _isMarkerCopyable(e, t) {
      const i = this._getMarkerClipboardConfig(e);
      if (!i)
        return !1;
      if (!t)
        return !0;
      const { allowedActions: s } = i;
      return s === "all" || s.includes(t);
    }
    /**
     * Checks if marker has any clipboard copy behavior configuration.
     *
     * @param markerName Name of checked marker.
     */
    _hasMarkerConfiguration(e) {
      return !!this._getMarkerClipboardConfig(e);
    }
    /**
     * Returns marker's configuration flags passed during registration.
     *
     * @param markerName Name of marker that should be returned.
     * @internal
     */
    _getMarkerClipboardConfig(e) {
      const [t] = e.split(":");
      return this._markersToCopy.get(t) || null;
    }
    /**
     * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements
     * at positions where document markers start or end. This way `$marker` elements can be easily copied together with
     * the rest of the content of the selection.
     *
     * @param writer An instance of the model writer.
     * @param selection Selection to be checked.
     * @param action Type of clipboard action.
     */
    _insertFakeMarkersIntoSelection(e, t, i) {
      const s = this._getCopyableMarkersFromSelection(e, t, i);
      return this._insertFakeMarkersElements(e, s);
    }
    /**
     * Returns array of markers that can be copied in specified selection.
     *
     * If marker cannot be copied partially (according to `copyPartiallySelected` configuration flag) and
     * is not present entirely in any selection range then it will be skipped.
     *
     * @param writer An instance of the model writer.
     * @param selection  Selection which will be checked.
     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
     */
    _getCopyableMarkersFromSelection(e, t, i) {
      const s = Array.from(t.getRanges()), o = new Set(s.flatMap((a) => Array.from(e.model.markers.getMarkersIntersectingRange(a)))), r = (a) => {
        if (!this._isMarkerCopyable(a.name, i))
          return !1;
        const { copyPartiallySelected: c } = this._getMarkerClipboardConfig(a.name);
        if (!c) {
          const u = a.getRange();
          return s.some((d) => d.containsRange(u, !0));
        }
        return !0;
      };
      return Array.from(o).filter(r).map((a) => ({
        name: i === "dragstart" ? this._getUniqueMarkerName(a.name) : a.name,
        range: a.getRange()
      }));
    }
    /**
     * Picks all markers from markers map that can be pasted.
     * If `duplicateOnPaste` is `true`, it regenerates their IDs to ensure uniqueness.
     * If marker is not registered, it will be kept in the array anyway.
     *
     * @param markers Object that maps marker name to corresponding range.
     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
     */
    _getPasteMarkersFromRangeMap(e, t = null) {
      const { model: i } = this.editor;
      return (e instanceof Map ? Array.from(e.entries()) : Object.entries(e)).flatMap(([o, r]) => {
        if (!this._hasMarkerConfiguration(o))
          return [
            {
              name: o,
              range: r
            }
          ];
        if (this._isMarkerCopyable(o, t)) {
          const a = this._getMarkerClipboardConfig(o), l = i.markers.has(o) && i.markers.get(o).getRange().root.rootName === "$graveyard";
          return (a.duplicateOnPaste || l) && (o = this._getUniqueMarkerName(o)), [
            {
              name: o,
              range: r
            }
          ];
        }
        return [];
      });
    }
    /**
     * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.
     * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during
     * steps between copy and paste.
     *
     * @param writer An instance of the model writer.
     * @param markers Array of markers that will be inserted.
     */
    _insertFakeMarkersElements(e, t) {
      const i = {}, s = t.flatMap((o) => {
        const { start: r, end: a } = o.range;
        return [
          { position: r, marker: o, type: "start" },
          { position: a, marker: o, type: "end" }
        ];
      }).sort(({ position: o }, { position: r }) => o.isBefore(r) ? 1 : -1);
      for (const { position: o, marker: r, type: a } of s) {
        const l = e.createElement("$marker", {
          "data-name": r.name,
          "data-type": a
        });
        i[r.name] || (i[r.name] = []), i[r.name].push(l), e.insert(l, o);
      }
      return i;
    }
    /**
     * Removes all `$marker` elements from the given document fragment.
     *
     * Returns an object where keys are marker names, and values are ranges corresponding to positions
     * where `$marker` elements were inserted.
     *
     * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically
     * (to the end or start of the document fragment, respectively).
     *
     * @param writer An instance of the model writer.
     * @param rootElement The element to be checked.
     */
    _removeFakeMarkersInsideElement(e, t) {
      const s = this._getAllFakeMarkersFromElement(e, t).reduce((o, r) => {
        const a = r.markerElement && e.createPositionBefore(r.markerElement);
        let l = o[r.name], c = !1;
        return l && l.start && l.end && (this._getMarkerClipboardConfig(r.name).duplicateOnPaste ? o[this._getUniqueMarkerName(r.name)] = o[r.name] : c = !0, l = null), c || (o[r.name] = {
          ...l,
          [r.type]: a
        }), r.markerElement && e.remove(r.markerElement), o;
      }, {});
      return Fy(s, (o) => new _(o.start || e.createPositionFromPath(t, [0]), o.end || e.createPositionAt(t, "end")));
    }
    /**
     * Returns array that contains list of fake markers with corresponding `$marker` elements.
     *
     * For each marker, there can be two `$marker` elements or only one (if the document fragment contained
     * only the beginning or only the end of a marker).
     *
     * @param writer An instance of the model writer.
     * @param rootElement The element to be checked.
     */
    _getAllFakeMarkersFromElement(e, t) {
      const i = Array.from(e.createRangeIn(t)).flatMap(({ item: r }) => {
        if (!r.is("element", "$marker"))
          return [];
        const a = r.getAttribute("data-name"), l = r.getAttribute("data-type");
        return [
          {
            markerElement: r,
            name: a,
            type: l
          }
        ];
      }), s = [], o = [];
      for (const r of i)
        r.type === "end" && (i.some((l) => l.name === r.name && l.type === "start") || s.push({
          markerElement: null,
          name: r.name,
          type: "start"
        })), r.type === "start" && (i.some((l) => l.name === r.name && l.type === "end") || o.unshift({
          markerElement: null,
          name: r.name,
          type: "end"
        }));
      return [
        ...s,
        ...i,
        ...o
      ];
    }
    /**
     * When copy of markers occurs we have to make sure that pasted markers have different names
     * than source markers. This functions helps with assigning unique part to marker name to
     * prevent duplicated markers error.
     *
     * @param name Name of marker
     */
    _getUniqueMarkerName(e) {
      const t = e.split(":"), i = Ze().substring(1, 6);
      return t.length === 3 ? `${t.slice(0, 2).join(":")}:${i}` : `${t.join(":")}:${i}`;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Xe extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ClipboardPipeline";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Hn];
    }
    /**
     * @inheritDoc
     */
    init() {
      this.editor.editing.view.addObserver(ls), this._setupPasteDrop(), this._setupCopyCut();
    }
    /**
     * Fires Clipboard `'outputTransformation'` event for given parameters.
     *
     * @internal
     */
    _fireOutputTransformationEvent(e, t, i) {
      const s = this.editor.plugins.get("ClipboardMarkersUtils");
      this.editor.model.enqueueChange({ isUndoable: i === "cut" }, () => {
        const o = s._copySelectedFragmentWithMarkers(i, t);
        this.fire("outputTransformation", {
          dataTransfer: e,
          content: o,
          method: i
        });
      });
    }
    /**
     * The clipboard paste pipeline.
     */
    _setupPasteDrop() {
      const e = this.editor, t = e.model, i = e.editing.view, s = i.document, o = this.editor.plugins.get("ClipboardMarkersUtils");
      this.listenTo(s, "clipboardInput", (r, a) => {
        a.method == "paste" && !e.model.canEditAt(e.model.document.selection) && r.stop();
      }, { priority: "highest" }), this.listenTo(s, "clipboardInput", (r, a) => {
        const l = a.dataTransfer;
        let c;
        if (a.content)
          c = a.content;
        else {
          let d = "";
          l.getData("text/html") ? d = PS(l.getData("text/html")) : l.getData("text/plain") && (d = IS(l.getData("text/plain"))), c = this.editor.data.htmlProcessor.toView(d);
        }
        const u = new Pt(this, "inputTransformation");
        this.fire(u, {
          content: c,
          dataTransfer: l,
          targetRanges: a.targetRanges,
          method: a.method
        }), u.stop.called && r.stop(), i.scrollToTheSelection();
      }, { priority: "low" }), this.listenTo(this, "inputTransformation", (r, a) => {
        if (a.content.isEmpty)
          return;
        const c = this.editor.data.toModel(a.content, "$clipboardHolder");
        c.childCount != 0 && (r.stop(), t.change(() => {
          this.fire("contentInsertion", {
            content: c,
            method: a.method,
            dataTransfer: a.dataTransfer,
            targetRanges: a.targetRanges
          });
        }));
      }, { priority: "low" }), this.listenTo(this, "contentInsertion", (r, a) => {
        a.resultRange = o._pasteFragmentWithMarkers(a.content);
      }, { priority: "low" });
    }
    /**
     * The clipboard copy/cut pipeline.
     */
    _setupCopyCut() {
      const e = this.editor, t = e.model.document, s = e.editing.view.document, o = (r, a) => {
        const l = a.dataTransfer;
        a.preventDefault(), this._fireOutputTransformationEvent(l, t.selection, r.name);
      };
      this.listenTo(s, "copy", o, { priority: "low" }), this.listenTo(s, "cut", (r, a) => {
        e.model.canEditAt(e.model.document.selection) ? o(r, a) : a.preventDefault();
      }, { priority: "low" }), this.listenTo(this, "outputTransformation", (r, a) => {
        const l = e.data.toView(a.content);
        s.fire("clipboardOutput", {
          dataTransfer: a.dataTransfer,
          content: l,
          method: a.method
        });
      }, { priority: "low" }), this.listenTo(s, "clipboardOutput", (r, a) => {
        a.content.isEmpty || (a.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(a.content)), a.dataTransfer.setData("text/plain", zg(a.content))), a.method == "cut" && e.model.deleteContent(t.selection);
      }, { priority: "low" });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ug {
    /**
     * Creates a new instance of the change buffer.
     *
     * @param limit The maximum number of atomic changes which can be contained in one batch.
     */
    constructor(e, t = 20) {
      this._batch = null, this.model = e, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (i, s) => {
        s.isLocal && s.isUndoable && s !== this._batch && this._reset(!0);
      }, this._selectionChangeCallback = () => {
        this._reset();
      }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
    }
    /**
     * The current batch to which a feature should add its operations. Once the {@link #size}
     * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
     */
    get batch() {
      return this._batch || (this._batch = this.model.createBatch({ isTyping: !0 })), this._batch;
    }
    /**
     * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
     * the {@link #batch batch} is set to a new one.
     */
    get size() {
      return this._size;
    }
    /**
     * The input number of changes into the buffer. Once the {@link #size} is
     * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
     *
     * @param changeCount The number of atomic changes to input.
     */
    input(e) {
      this._size += e, this._size >= this.limit && this._reset(!0);
    }
    /**
     * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
     */
    get isLocked() {
      return this._isLocked;
    }
    /**
     * Locks the buffer.
     */
    lock() {
      this._isLocked = !0;
    }
    /**
     * Unlocks the buffer.
     */
    unlock() {
      this._isLocked = !1;
    }
    /**
     * Destroys the buffer.
     */
    destroy() {
      this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
    }
    /**
     * Resets the change buffer.
     *
     * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
     */
    _reset(e = !1) {
      (!this.isLocked || e) && (this._batch = null, this._size = 0);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class LS extends V {
    /**
     * Creates an instance of the command.
     *
     * @param undoStepSize The maximum number of atomic changes
     * which can be contained in one batch in the command buffer.
     */
    constructor(e, t) {
      super(e), this._buffer = new Ug(e.model, t), this._isEnabledBasedOnSelection = !1;
    }
    /**
     * The current change buffer.
     */
    get buffer() {
      return this._buffer;
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this._buffer.destroy();
    }
    /**
     * Executes the input command. It replaces the content within the given range with the given text.
     * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
     * at the beginning of the range (which after the removal is a collapsed range).
     *
     * @fires execute
     * @param options The command options.
     */
    execute(e = {}) {
      const t = this.editor.model, i = t.document, s = e.text || "", o = s.length;
      let r = i.selection;
      if (e.selection ? r = e.selection : e.range && (r = t.createSelection(e.range)), !t.canEditAt(r))
        return;
      const a = e.resultRange;
      t.enqueueChange(this._buffer.batch, (l) => {
        this._buffer.lock();
        const c = Array.from(i.selection.getAttributes());
        t.deleteContent(r), s && t.insertContent(l.createText(s, c), r), a ? l.setSelection(a) : r.is("documentSelection") || l.setSelection(r), this._buffer.unlock(), this._buffer.input(o);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const dd = [
    // For collapsed range:
    //	- This one is a regular typing (all browsers, all systems).
    //	- This one is used by Chrome when typing accented letter – 2nd step when the user selects the accent (Mac).
    // For non-collapsed range:
    //	- This one is used by Chrome when typing accented letter – when the selection box first appears (Mac).
    //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
    "insertText",
    // This one is used by Safari when typing accented letter (Mac).
    // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
    "insertReplacementText"
  ];
  class VS extends _t {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.focusObserver = e.getObserver(To), B.isAndroid && dd.push("insertCompositionText");
      const t = e.document;
      t.on("beforeinput", (i, s) => {
        if (!this.isEnabled)
          return;
        const { data: o, targetRanges: r, inputType: a, domEvent: l } = s;
        if (!dd.includes(a))
          return;
        this.focusObserver.flush();
        const c = new Pt(t, "insertText");
        t.fire(c, new Xi(e, l, {
          text: o,
          selection: e.createSelection(r)
        })), c.stop.called && i.stop();
      }), t.on("compositionend", (i, { data: s, domEvent: o }) => {
        !this.isEnabled || B.isAndroid || s && t.fire("insertText", new Xi(e, o, {
          text: s,
          selection: t.selection
        }));
      }, { priority: "lowest" });
    }
    /**
     * @inheritDoc
     */
    observe() {
    }
    /**
     * @inheritDoc
     */
    stopObserving() {
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Hg extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Input";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model, i = e.editing.view, s = t.document.selection;
      i.addObserver(VS);
      const o = new LS(e, e.config.get("typing.undoStep") || 20);
      e.commands.add("insertText", o), e.commands.add("input", o), this.listenTo(i.document, "insertText", (r, a) => {
        i.document.isComposing || a.preventDefault();
        const { text: l, selection: c, resultRange: u } = a, d = Array.from(c.getRanges()).map((m) => e.editing.mapper.toModelRange(m));
        let h = l;
        if (B.isAndroid) {
          const m = Array.from(d[0].getItems()).reduce((p, b) => p + (b.is("$textProxy") ? b.data : ""), "");
          m && (m.length <= h.length ? h.startsWith(m) && (h = h.substring(m.length), d[0].start = d[0].start.getShiftedBy(m.length)) : m.startsWith(h) && (d[0].start = d[0].start.getShiftedBy(h.length), h = ""));
        }
        const f = {
          text: h,
          selection: t.createSelection(d)
        };
        u && (f.resultRange = e.editing.mapper.toModelRange(u)), e.execute("insertText", f), i.scrollToTheSelection();
      }), B.isAndroid ? this.listenTo(i.document, "keydown", (r, a) => {
        s.isCollapsed || a.keyCode != 229 || !i.document.isComposing || hd(t, o);
      }) : this.listenTo(i.document, "compositionstart", () => {
        s.isCollapsed || hd(t, o);
      });
    }
  }
  function hd(n, e) {
    if (!e.isEnabled)
      return;
    const t = e.buffer;
    t.lock(), n.enqueueChange(t.batch, () => {
      n.deleteContent(n.document.selection);
    }), t.unlock();
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class fd extends V {
    /**
     * Creates an instance of the command.
     *
     * @param direction The directionality of the delete describing in what direction it
     * should consume the content when the selection is collapsed.
     */
    constructor(e, t) {
      super(e), this.direction = t, this._buffer = new Ug(e.model, e.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1;
    }
    /**
     * The current change buffer.
     */
    get buffer() {
      return this._buffer;
    }
    /**
     * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
     * or a piece of content in the {@link #direction defined direction}.
     *
     * @fires execute
     * @param options The command options.
     * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
     * @param options.sequence A number describing which subsequent delete event it is without the key being released.
     * See the {@link module:engine/view/document~Document#event:delete} event data.
     * @param options.selection Selection to remove. If not set, current model selection will be used.
     */
    execute(e = {}) {
      const t = this.editor.model, i = t.document;
      t.enqueueChange(this._buffer.batch, (s) => {
        this._buffer.lock();
        const o = s.createSelection(e.selection || i.selection);
        if (!t.canEditAt(o))
          return;
        const r = e.sequence || 1, a = o.isCollapsed;
        if (o.isCollapsed && t.modifySelection(o, {
          direction: this.direction,
          unit: e.unit,
          treatEmojiAsSingleUnit: !0
        }), this._shouldEntireContentBeReplacedWithParagraph(r)) {
          this._replaceEntireContentWithParagraph(s);
          return;
        }
        if (this._shouldReplaceFirstBlockWithParagraph(o, r)) {
          this.editor.execute("paragraph", { selection: o });
          return;
        }
        if (o.isCollapsed)
          return;
        let l = 0;
        o.getFirstRange().getMinimalFlatRanges().forEach((c) => {
          l += oa(c.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
        }), t.deleteContent(o, {
          doNotResetEntireContent: a,
          direction: this.direction
        }), this._buffer.input(l), s.setSelection(o), this._buffer.unlock();
      });
    }
    /**
     * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
     * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
     * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
     *
     * But, if the user pressed the key in an empty editable for the first time,
     * we want to replace the entire content with a paragraph if:
     *
     * * the current limit element is empty,
     * * the paragraph is allowed in the limit element,
     * * the limit doesn't already have a paragraph inside.
     *
     * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
     *
     * @param sequence A number describing which subsequent delete event it is without the key being released.
     */
    _shouldEntireContentBeReplacedWithParagraph(e) {
      if (e > 1)
        return !1;
      const t = this.editor.model, s = t.document.selection, o = t.schema.getLimitElement(s);
      if (!(s.isCollapsed && s.containsEntireContent(o)) || !t.schema.checkChild(o, "paragraph"))
        return !1;
      const a = o.getChild(0);
      return !(a && a.is("element", "paragraph"));
    }
    /**
     * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
     *
     * @param writer The model writer.
     */
    _replaceEntireContentWithParagraph(e) {
      const t = this.editor.model, s = t.document.selection, o = t.schema.getLimitElement(s), r = e.createElement("paragraph");
      e.remove(e.createRangeIn(o)), e.insert(r, o), e.setSelection(r, 0);
    }
    /**
     * Checks if the selection is inside an empty element that is the first child of the limit element
     * and should be replaced with a paragraph.
     *
     * @param selection The selection.
     * @param sequence A number describing which subsequent delete event it is without the key being released.
     */
    _shouldReplaceFirstBlockWithParagraph(e, t) {
      const i = this.editor.model;
      if (t > 1 || this.direction != "backward" || !e.isCollapsed)
        return !1;
      const s = e.getFirstPosition(), o = i.schema.getLimitElement(s), r = o.getChild(0);
      return !(s.parent != r || !e.containsEntireContent(r) || !i.schema.checkChild(o, "paragraph") || r.name == "paragraph");
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const MS = "character", md = "word", BS = "codePoint", zt = "selection", Hi = "backward", Rn = "forward", $g = {
    // --------------------------------------- Backward delete types -----------------------------------------------------
    // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
    deleteContent: {
      unit: zt,
      // According to the Input Events Level 2 spec, this delete type has no direction
      // but to keep things simple, let's default to backward.
      direction: Hi
    },
    // Chrome and Safari on Mac: Backspace or Ctrl + H
    deleteContentBackward: {
      // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
      // Take for instance "👨‍👩‍👧‍👧", it equals:
      //
      //	* [ "👨", "ZERO WIDTH JOINER", "👩", "ZERO WIDTH JOINER", "👧", "ZERO WIDTH JOINER", "👧" ]
      //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
      //
      // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
      // intention when deleting backwards ("👨‍👩‍👧‍👧[]", then backspace) is gradual "decomposition" (first to "👨‍👩‍👧‍[]",
      // then to "👨‍👩‍[]", etc.).
      //
      //	* "👨‍👩‍👧‍👧[]" + backward delete (by code point)  -> results in "👨‍👩‍👧[]", removed the last "👧" 👍
      //	* "👨‍👩‍👧‍👧[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme 👎
      //
      // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
      unit: BS,
      direction: Hi
    },
    // On Mac: Option + Backspace.
    // On iOS: Hold the backspace for a while and the whole words will start to disappear.
    deleteWordBackward: {
      unit: md,
      direction: Hi
    },
    // Safari on Mac: Cmd + Backspace
    deleteHardLineBackward: {
      unit: zt,
      direction: Hi
    },
    // Chrome on Mac: Cmd + Backspace.
    deleteSoftLineBackward: {
      unit: zt,
      direction: Hi
    },
    // --------------------------------------- Forward delete types -----------------------------------------------------
    // Chrome on Mac: Fn + Backspace or Ctrl + D
    // Safari on Mac: Ctrl + K or Ctrl + D
    deleteContentForward: {
      // Unlike backward delete, this delete must be performed by character instead of by code point, which
      // provides the best UX for working with accented letters.
      // Take, for example "b̂" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
      //
      //	* "b̂[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark 👍
      //	* "[]b̂" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone 👎
      //	* "[]b̂" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark 👍
      //
      // See: "deleteContentBackward" to learn more.
      unit: MS,
      direction: Rn
    },
    // On Mac: Fn + Option + Backspace.
    deleteWordForward: {
      unit: md,
      direction: Rn
    },
    // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
    // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
    // on Apple's webpage.
    deleteHardLineForward: {
      unit: zt,
      direction: Rn
    },
    // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
    // deleteSoftLineBackward.
    deleteSoftLineForward: {
      unit: zt,
      direction: Rn
    }
  };
  class OS extends _t {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = e.document;
      let i = 0;
      t.on("keydown", () => {
        i++;
      }), t.on("keyup", () => {
        i = 0;
      }), t.on("beforeinput", (s, o) => {
        if (!this.isEnabled)
          return;
        const { targetRanges: r, domEvent: a, inputType: l } = o, c = $g[l];
        if (!c)
          return;
        const u = {
          direction: c.direction,
          unit: c.unit,
          sequence: i
        };
        u.unit == zt && (u.selectionToRemove = e.createSelection(r[0])), l === "deleteContentBackward" && (B.isAndroid && (u.sequence = 1), DS(r) && (u.unit = zt, u.selectionToRemove = e.createSelection(r)));
        const d = new hn(t, "delete", r[0]);
        t.fire(d, new Xi(e, a, u)), d.stop.called && s.stop();
      }), B.isBlink && NS(this);
    }
    /**
     * @inheritDoc
     */
    observe() {
    }
    /**
     * @inheritDoc
     */
    stopObserving() {
    }
  }
  function NS(n) {
    const e = n.view, t = e.document;
    let i = null, s = !1;
    t.on("keydown", (a, { keyCode: l }) => {
      i = l, s = !1;
    }), t.on("keyup", (a, { keyCode: l, domEvent: c }) => {
      const u = t.selection, d = n.isEnabled && l == i && o(l) && !u.isCollapsed && !s;
      if (i = null, d) {
        const h = u.getFirstRange(), f = new hn(t, "delete", h), m = {
          unit: zt,
          direction: r(l),
          selectionToRemove: u
        };
        t.fire(f, new Xi(e, c, m));
      }
    }), t.on("beforeinput", (a, { inputType: l }) => {
      const c = $g[l];
      o(i) && c && c.direction == r(i) && (s = !0);
    }, { priority: "high" }), t.on("beforeinput", (a, { inputType: l, data: c }) => {
      i == F.delete && l == "insertText" && c == "" && a.stop();
    }, { priority: "high" });
    function o(a) {
      return a == F.backspace || a == F.delete;
    }
    function r(a) {
      return a == F.backspace ? Hi : Rn;
    }
  }
  function DS(n) {
    if (n.length != 1 || n[0].isCollapsed)
      return !1;
    const e = n[0].getWalker({
      direction: "backward",
      singleCharacters: !0,
      ignoreElementEnd: !0
    });
    let t = 0;
    for (const { nextPosition: i } of e) {
      if (!i.parent.is("$text"))
        t++;
      else {
        const s = i.parent.data, o = i.offset;
        if (hl(s, o) || fl(s, o) || lm(s, o))
          continue;
        t++;
      }
      if (t > 1)
        return !0;
    }
    return !1;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class bt extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Delete";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.editing.view, i = t.document, s = e.model.document;
      t.addObserver(OS), this._undoOnBackspace = !1;
      const o = new fd(e, "forward");
      e.commands.add("deleteForward", o), e.commands.add("forwardDelete", o), e.commands.add("delete", new fd(e, "backward")), this.listenTo(i, "delete", (r, a) => {
        i.isComposing || a.preventDefault();
        const { direction: l, sequence: c, selectionToRemove: u, unit: d } = a, h = l === "forward" ? "deleteForward" : "delete", f = { sequence: c };
        if (d == "selection") {
          const m = Array.from(u.getRanges()).map((p) => e.editing.mapper.toModelRange(p));
          f.selection = e.model.createSelection(m);
        } else
          f.unit = d;
        e.execute(h, f), t.scrollToTheSelection();
      }, { priority: "low" }), this.editor.plugins.has("UndoEditing") && (this.listenTo(i, "delete", (r, a) => {
        this._undoOnBackspace && a.direction == "backward" && a.sequence == 1 && a.unit == "codePoint" && (this._undoOnBackspace = !1, e.execute("undo"), a.preventDefault(), r.stop());
      }, { context: "$capture" }), this.listenTo(s, "change", () => {
        this._undoOnBackspace = !1;
      }));
    }
    /**
     * If the next user action after calling this method is pressing backspace, it would undo the last change.
     *
     * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
     */
    requestUndoOnBackspace() {
      this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Wg extends w {
    static get requires() {
      return [Hg, bt];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Typing";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function qg(n, e) {
    let t = n.start;
    return { text: Array.from(n.getWalker({ ignoreElementEnd: !1 })).reduce((s, { item: o }) => o.is("$text") || o.is("$textProxy") ? s + o.data : (t = e.createPositionAfter(o), ""), ""), range: e.createRange(t, n.end) };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Gg extends $() {
    /**
     * Creates a text watcher instance.
     *
     * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
     */
    constructor(e, t) {
      super(), this.model = e, this.testCallback = t, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
        this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection), this.stopListening(e.document));
      }), this._startListening();
    }
    /**
     * Flag indicating whether there is a match currently.
     */
    get hasMatch() {
      return this._hasMatch;
    }
    /**
     * Starts listening to the editor for typing and selection events.
     */
    _startListening() {
      const t = this.model.document;
      this.listenTo(t.selection, "change:range", (i, { directChange: s }) => {
        if (s) {
          if (!t.selection.isCollapsed) {
            this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1);
            return;
          }
          this._evaluateTextBeforeSelection("selection");
        }
      }), this.listenTo(t, "change:data", (i, s) => {
        s.isUndo || !s.isLocal || this._evaluateTextBeforeSelection("data", { batch: s });
      });
    }
    /**
     * Checks the editor content for matched text.
     *
     * @fires matched:data
     * @fires matched:selection
     * @fires unmatched
     *
     * @param suffix A suffix used for generating the event name.
     * @param data Data object for event.
     */
    _evaluateTextBeforeSelection(e, t = {}) {
      const i = this.model, o = i.document.selection, r = i.createRange(i.createPositionAt(o.focus.parent, 0), o.focus), { text: a, range: l } = qg(r, i), c = this.testCallback(a);
      if (!c && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!c, c) {
        const u = Object.assign(t, { text: a, range: l });
        typeof c == "object" && Object.assign(u, c), this.fire(`matched:${e}`, u);
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class So extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TwoStepCaretMovement";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._isNextGravityRestorationSkipped = !1, this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model, i = e.editing.view, s = e.locale, o = t.document.selection;
      this.listenTo(i.document, "arrowKey", (r, a) => {
        if (!o.isCollapsed || a.shiftKey || a.altKey || a.ctrlKey)
          return;
        const l = a.keyCode == F.arrowright, c = a.keyCode == F.arrowleft;
        if (!l && !c)
          return;
        const u = s.contentLanguageDirection;
        let d = !1;
        u === "ltr" && l || u === "rtl" && c ? d = this._handleForwardMovement(a) : d = this._handleBackwardMovement(a), d === !0 && r.stop();
      }, { context: "$text", priority: "highest" }), this.listenTo(o, "change:range", (r, a) => {
        if (this._isNextGravityRestorationSkipped) {
          this._isNextGravityRestorationSkipped = !1;
          return;
        }
        this._isGravityOverridden && (!a.directChange && je(o.getFirstPosition(), this.attributes) || this._restoreGravity());
      }), this._enableClickingAfterNode(), this._enableInsertContentSelectionAttributesFixer(), this._handleDeleteContentAfterNode();
    }
    /**
     * Registers a given attribute for the two-step caret movement.
     *
     * @param attribute Name of the attribute to handle.
     */
    registerAttribute(e) {
      this.attributes.add(e);
    }
    /**
     * Updates the document selection and the view according to the two–step caret movement state
     * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
     *
     * @param data Data of the key press.
     * @returns `true` when the handler prevented caret movement.
     */
    _handleForwardMovement(e) {
      const t = this.attributes, i = this.editor.model, s = i.document.selection, o = s.getFirstPosition();
      return this._isGravityOverridden || o.isAtStart && yt(s, t) ? !1 : je(o, t) ? (kn(e), yt(s, t) && je(o, t, !0) ? Cn(i, t) : this._overrideGravity(), !0) : !1;
    }
    /**
     * Updates the document selection and the view according to the two–step caret movement state
     * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
     *
     * @param data Data of the key press.
     * @returns `true` when the handler prevented caret movement
     */
    _handleBackwardMovement(e) {
      const t = this.attributes, i = this.editor.model, s = i.document.selection, o = s.getFirstPosition();
      return this._isGravityOverridden ? (kn(e), this._restoreGravity(), je(o, t, !0) ? Cn(i, t) : Us(i, t, o), !0) : o.isAtStart ? yt(s, t) ? (kn(e), Us(i, t, o), !0) : !1 : !yt(s, t) && je(o, t, !0) ? (kn(e), Us(i, t, o), !0) : gd(o, t) ? o.isAtEnd && !yt(s, t) && je(o, t) ? (kn(e), Us(i, t, o), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1) : !1;
    }
    /**
     * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and
     * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a 2-step node
     * if clicked at the beginning/ending of the 2-step node.
     *
     * The purpose of this action is to allow typing around the 2-step node directly after a click.
     *
     * See https://github.com/ckeditor/ckeditor5/issues/1016.
     */
    _enableClickingAfterNode() {
      const e = this.editor, t = e.model, i = t.document.selection, s = e.editing.view.document;
      e.editing.view.addObserver(er);
      let o = !1;
      this.listenTo(s, "mousedown", () => {
        o = !0;
      }), this.listenTo(s, "selectionChange", () => {
        const r = this.attributes;
        if (!o || (o = !1, !i.isCollapsed) || !yt(i, r))
          return;
        const a = i.getFirstPosition();
        je(a, r) && (a.isAtStart || je(a, r, !0) ? Cn(t, r) : this._isGravityOverridden || this._overrideGravity());
      });
    }
    /**
     * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
     * selection attributes if the selection is at the end of a two-step node after inserting the content.
     *
     * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
     * two-step attribute of the selection, and they can type a "clean" (`linkHref`–less) text right away.
     *
     * See https://github.com/ckeditor/ckeditor5/issues/6053.
     */
    _enableInsertContentSelectionAttributesFixer() {
      const t = this.editor.model, i = t.document.selection, s = this.attributes;
      this.listenTo(t, "insertContent", () => {
        const o = i.getFirstPosition();
        yt(i, s) && je(o, s) && Cn(t, s);
      }, { priority: "low" });
    }
    /**
     * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether
     * removing a content right after the tow-step attribute.
     *
     * If so, the selection should not preserve the two-step attribute. However, if
     * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and
     * the selection has the two-step attribute due to overridden gravity (at the end), the two-step attribute should stay untouched.
     *
     * The purpose of this action is to allow removing the link text and keep the selection outside the link.
     *
     * See https://github.com/ckeditor/ckeditor5/issues/7521.
     */
    _handleDeleteContentAfterNode() {
      const e = this.editor, t = e.model, i = t.document.selection, s = e.editing.view;
      let o = !1, r = !1;
      this.listenTo(s.document, "delete", (a, l) => {
        o = l.direction === "backward";
      }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
        if (!o)
          return;
        const a = i.getFirstPosition();
        r = yt(i, this.attributes) && !gd(a, this.attributes);
      }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
        o && (o = !1, !r && e.model.enqueueChange(() => {
          const a = i.getFirstPosition();
          yt(i, this.attributes) && je(a, this.attributes) && (a.isAtStart || je(a, this.attributes, !0) ? Cn(t, this.attributes) : this._isGravityOverridden || this._overrideGravity());
        }));
      }, { priority: "low" });
    }
    /**
     * `true` when the gravity is overridden for the plugin.
     */
    get _isGravityOverridden() {
      return !!this._overrideUid;
    }
    /**
     * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}
     * and stores the information about this fact in the {@link #_overrideUid}.
     *
     * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
     */
    _overrideGravity() {
      this._overrideUid = this.editor.model.change((e) => e.overrideSelectionGravity());
    }
    /**
     * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.
     *
     * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.
     */
    _restoreGravity() {
      this.editor.model.change((e) => {
        e.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
      });
    }
  }
  function yt(n, e) {
    for (const t of e)
      if (n.hasAttribute(t))
        return !0;
    return !1;
  }
  function Us(n, e, t) {
    const i = t.nodeBefore;
    n.change((s) => {
      if (i) {
        const o = [], r = n.schema.isObject(i) && n.schema.isInline(i);
        for (const [a, l] of i.getAttributes())
          n.schema.checkAttribute("$text", a) && (!r || n.schema.getAttributeProperties(a).copyFromObject !== !1) && o.push([a, l]);
        s.setSelectionAttribute(o);
      } else
        s.removeSelectionAttribute(e);
    });
  }
  function Cn(n, e) {
    n.change((t) => {
      t.removeSelectionAttribute(e);
    });
  }
  function kn(n) {
    n.preventDefault();
  }
  function gd(n, e) {
    const t = n.getShiftedBy(-1);
    return je(t, e);
  }
  function je(n, e, t = !1) {
    const { nodeBefore: i, nodeAfter: s } = n;
    for (const o of e) {
      const r = i ? i.getAttribute(o) : void 0, a = s ? s.getAttribute(o) : void 0;
      if (!(t && (r === void 0 || a === void 0)) && a !== r)
        return !0;
    }
    return !1;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const pd = {
    // Common symbols:
    copyright: { from: "(c)", to: "©" },
    registeredTrademark: { from: "(r)", to: "®" },
    trademark: { from: "(tm)", to: "™" },
    // Mathematical:
    oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] },
    oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] },
    twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] },
    oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] },
    threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] },
    lessThanOrEqual: { from: "<=", to: "≤" },
    greaterThanOrEqual: { from: ">=", to: "≥" },
    notEqual: { from: "!=", to: "≠" },
    arrowLeft: { from: "<-", to: "←" },
    arrowRight: { from: "->", to: "→" },
    // Typography:
    horizontalEllipsis: { from: "...", to: "…" },
    enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] },
    emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] },
    // Quotations:
    // English, US
    quotesPrimary: { from: Mi('"'), to: [null, "“", null, "”"] },
    quotesSecondary: { from: Mi("'"), to: [null, "‘", null, "’"] },
    // English, UK
    quotesPrimaryEnGb: { from: Mi("'"), to: [null, "‘", null, "’"] },
    quotesSecondaryEnGb: { from: Mi('"'), to: [null, "“", null, "”"] },
    // Polish
    quotesPrimaryPl: { from: Mi('"'), to: [null, "„", null, "”"] },
    quotesSecondaryPl: { from: Mi("'"), to: [null, "‚", null, "’"] }
  }, wd = {
    symbols: ["copyright", "registeredTrademark", "trademark"],
    mathematical: [
      "oneHalf",
      "oneThird",
      "twoThirds",
      "oneForth",
      "threeQuarters",
      "lessThanOrEqual",
      "greaterThanOrEqual",
      "notEqual",
      "arrowLeft",
      "arrowRight"
    ],
    typography: ["horizontalEllipsis", "enDash", "emDash"],
    quotes: ["quotesPrimary", "quotesSecondary"]
  }, FS = [
    "symbols",
    "mathematical",
    "typography",
    "quotes"
  ];
  class zS extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return ["Delete", "Input"];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TextTransformation";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("typing", {
        transformations: {
          include: FS
        }
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      const t = this.editor.model.document.selection;
      t.on("change:range", () => {
        this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
      }), this._enableTransformationWatchers();
    }
    /**
     * Create new TextWatcher listening to the editor for typing and selection events.
     */
    _enableTransformationWatchers() {
      const e = this.editor, t = e.model, i = e.plugins.get("Delete"), s = WS(e.config.get("typing.transformations")), o = (a) => {
        for (const l of s)
          if (l.from.test(a))
            return { normalizedTransformation: l };
      }, r = new Gg(e.model, o);
      r.on("matched:data", (a, l) => {
        if (!l.batch.isTyping)
          return;
        const { from: c, to: u } = l.normalizedTransformation, d = c.exec(l.text), h = u(d.slice(1)), f = l.range;
        let m = d.index;
        t.enqueueChange((p) => {
          for (let b = 1; b < d.length; b++) {
            const v = d[b], y = h[b - 1];
            if (y == null) {
              m += v.length;
              continue;
            }
            const L = f.start.getShiftedBy(m), M = t.createRange(L, L.getShiftedBy(v.length)), D = $S(L);
            t.insertContent(p.createText(y, D), M), m += y.length;
          }
          t.enqueueChange(() => {
            i.requestUndoOnBackspace();
          });
        });
      }), r.bind("isEnabled").to(this);
    }
  }
  function US(n) {
    return typeof n == "string" ? new RegExp(`(${jf(n)})$`) : n;
  }
  function HS(n) {
    return typeof n == "string" ? () => [n] : n instanceof Array ? () => n : n;
  }
  function $S(n) {
    return (n.textNode ? n.textNode : n.nodeAfter).getAttributes();
  }
  function Mi(n) {
    return new RegExp(`(^|\\s)(${n})([^${n}]*)(${n})$`);
  }
  function WS(n) {
    const e = n.extra || [], t = n.remove || [], i = (o) => !t.includes(o), s = n.include.concat(e).filter(i);
    return qS(s).filter(i).map((o) => typeof o == "string" && pd[o] ? pd[o] : o).filter((o) => typeof o == "object").map((o) => ({
      from: US(o.from),
      to: HS(o.to)
    }));
  }
  function qS(n) {
    const e = /* @__PURE__ */ new Set();
    for (const t of n)
      if (typeof t == "string" && wd[t])
        for (const i of wd[t])
          e.add(i);
      else
        e.add(t);
    return Array.from(e);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function ar(n, e, t, i) {
    return i.createRange(bd(n, e, t, !0, i), bd(n, e, t, !1, i));
  }
  function bd(n, e, t, i, s) {
    let o = n.textNode || (i ? n.nodeBefore : n.nodeAfter), r = null;
    for (; o && o.getAttribute(e) == t; )
      r = o, o = i ? o.previousSibling : o.nextSibling;
    return r ? s.createPositionAt(r, i ? "before" : "after") : n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function jg(n, e, t, i) {
    const s = n.editing.view, o = /* @__PURE__ */ new Set();
    s.document.registerPostFixer((r) => {
      const a = n.model.document.selection;
      let l = !1;
      if (a.hasAttribute(e)) {
        const c = ar(a.getFirstPosition(), e, a.getAttribute(e), n.model), u = n.editing.mapper.toViewRange(c);
        for (const d of u.getItems())
          d.is("element", t) && !d.hasClass(i) && (r.addClass(i, d), o.add(d), l = !0);
      }
      return l;
    }), n.conversion.for("editingDowncast").add((r) => {
      r.on("insert", a, { priority: "highest" }), r.on("remove", a, { priority: "highest" }), r.on("attribute", a, { priority: "highest" }), r.on("selection", a, { priority: "highest" });
      function a() {
        s.change((l) => {
          for (const c of o.values())
            l.removeClass(i, c), o.delete(c);
        });
      }
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function* Kg(n, e) {
    for (const t of e)
      t && n.getAttributeProperties(t[0]).copyOnEnter && (yield t);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class GS extends V {
    /**
     * @inheritDoc
     */
    execute() {
      this.editor.model.change((e) => {
        this.enterBlock(e), this.fire("afterExecute", { writer: e });
      });
    }
    /**
     * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
     *
     * ```
     * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
     * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
     * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
     * ```
     *
     * In some cases, the split will not happen:
     *
     * ```
     * // The selection parent is a limit element:
     * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
     *
     * // The selection spans over multiple elements:
     * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
     * ```
     *
     * @param writer Writer to use when performing the enter action.
     * @returns Boolean indicating if the block was split.
     */
    enterBlock(e) {
      const t = this.editor.model, i = t.document.selection, s = t.schema, o = i.isCollapsed, r = i.getFirstRange(), a = r.start.parent, l = r.end.parent;
      if (s.isLimit(a) || s.isLimit(l))
        return !o && a == l && t.deleteContent(i), !1;
      if (o) {
        const c = Kg(e.model.schema, i.getAttributes());
        return _d(e, r.start), e.setSelectionAttribute(c), !0;
      } else {
        const c = !(r.start.isAtStart && r.end.isAtEnd), u = a == l;
        if (t.deleteContent(i, { leaveUnmerged: c }), c) {
          if (u)
            return _d(e, i.focus), !0;
          e.setSelection(l, 0);
        }
      }
      return !1;
    }
  }
  function _d(n, e) {
    n.split(e), n.setSelection(e.parent.nextSibling, 0);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const jS = {
    insertParagraph: { isSoft: !1 },
    insertLineBreak: { isSoft: !0 }
  };
  class Zg extends _t {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = this.document;
      let i = !1;
      t.on("keydown", (s, o) => {
        i = o.shiftKey;
      }), t.on("beforeinput", (s, o) => {
        if (!this.isEnabled)
          return;
        let r = o.inputType;
        B.isSafari && i && r == "insertParagraph" && (r = "insertLineBreak");
        const a = o.domEvent, l = jS[r];
        if (!l)
          return;
        const c = new hn(t, "enter", o.targetRanges[0]);
        t.fire(c, new Xi(e, a, {
          isSoft: l.isSoft
        })), c.stop.called && s.stop();
      });
    }
    /**
     * @inheritDoc
     */
    observe() {
    }
    /**
     * @inheritDoc
     */
    stopObserving() {
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class lr extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Enter";
    }
    init() {
      const e = this.editor, t = e.editing.view, i = t.document, s = this.editor.t;
      t.addObserver(Zg), e.commands.add("enter", new GS(e)), this.listenTo(i, "enter", (o, r) => {
        i.isComposing || r.preventDefault(), !r.isSoft && (e.execute("enter"), t.scrollToTheSelection());
      }, { priority: "low" }), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: s("Insert a hard break (a new paragraph)"),
            keystroke: "Enter"
          }
        ]
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class KS extends V {
    /**
     * @inheritDoc
     */
    execute() {
      const e = this.editor.model, t = e.document;
      e.change((i) => {
        JS(e, i, t.selection), this.fire("afterExecute", { writer: i });
      });
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = e.document;
      this.isEnabled = ZS(e.schema, t.selection);
    }
  }
  function ZS(n, e) {
    if (e.rangeCount > 1)
      return !1;
    const t = e.anchor;
    if (!t || !n.checkChild(t, "softBreak"))
      return !1;
    const i = e.getFirstRange(), s = i.start.parent, o = i.end.parent;
    return !((Ta(s, n) || Ta(o, n)) && s !== o);
  }
  function JS(n, e, t) {
    const i = t.isCollapsed, s = t.getFirstRange(), o = s.start.parent, r = s.end.parent, a = o == r;
    if (i) {
      const l = Kg(n.schema, t.getAttributes());
      vd(n, e, s.end), e.removeSelectionAttribute(t.getAttributeKeys()), e.setSelectionAttribute(l);
    } else {
      const l = !(s.start.isAtStart && s.end.isAtEnd);
      n.deleteContent(t, { leaveUnmerged: l }), a ? vd(n, e, t.focus) : l && e.setSelection(r, 0);
    }
  }
  function vd(n, e, t) {
    const i = e.createElement("softBreak");
    n.insertContent(i, t), e.setSelection(i, "after");
  }
  function Ta(n, e) {
    return n.is("rootElement") ? !1 : e.isLimit(n) || Ta(n.parent, e);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class XS extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ShiftEnter";
    }
    init() {
      const e = this.editor, t = e.model.schema, i = e.conversion, s = e.editing.view, o = s.document, r = this.editor.t;
      t.register("softBreak", {
        allowWhere: "$text",
        isInline: !0
      }), i.for("upcast").elementToElement({
        model: "softBreak",
        view: "br"
      }), i.for("downcast").elementToElement({
        model: "softBreak",
        view: (a, { writer: l }) => l.createEmptyElement("br")
      }), s.addObserver(Zg), e.commands.add("shiftEnter", new KS(e)), this.listenTo(o, "enter", (a, l) => {
        o.isComposing || l.preventDefault(), l.isSoft && (e.execute("shiftEnter"), s.scrollToTheSelection());
      }, { priority: "low" }), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: r("Insert a soft break (a <code>&lt;br&gt;</code> element)"),
            keystroke: "Shift+Enter"
          }
        ]
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class YS extends G() {
    constructor() {
      super(...arguments), this._stack = [];
    }
    /**
     * Adds highlight descriptor to the stack.
     *
     * @fires change:top
     */
    add(e, t) {
      const i = this._stack, s = i[0];
      this._insertDescriptor(e);
      const o = i[0];
      s !== o && !Dr(s, o) && this.fire("change:top", {
        oldDescriptor: s,
        newDescriptor: o,
        writer: t
      });
    }
    /**
     * Removes highlight descriptor from the stack.
     *
     * @fires change:top
     * @param id Id of the descriptor to remove.
     */
    remove(e, t) {
      const i = this._stack, s = i[0];
      this._removeDescriptor(e);
      const o = i[0];
      s !== o && !Dr(s, o) && this.fire("change:top", {
        oldDescriptor: s,
        newDescriptor: o,
        writer: t
      });
    }
    /**
     * Inserts a given descriptor in correct place in the stack. It also takes care about updating information
     * when descriptor with same id is already present.
     */
    _insertDescriptor(e) {
      const t = this._stack, i = t.findIndex((o) => o.id === e.id);
      if (Dr(e, t[i]))
        return;
      i > -1 && t.splice(i, 1);
      let s = 0;
      for (; t[s] && QS(t[s], e); )
        s++;
      t.splice(s, 0, e);
    }
    /**
     * Removes descriptor with given id from the stack.
     *
     * @param id Descriptor's id.
     */
    _removeDescriptor(e) {
      const t = this._stack, i = t.findIndex((s) => s.id === e);
      i > -1 && t.splice(i, 1);
    }
  }
  function Dr(n, e) {
    return n && e && n.priority == e.priority && Io(n.classes) == Io(e.classes);
  }
  function QS(n, e) {
    return n.priority > e.priority ? !0 : n.priority < e.priority ? !1 : Io(n.classes) > Io(e.classes);
  }
  function Io(n) {
    return Array.isArray(n) ? n.sort().join(",") : n;
  }
  const eI = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const tI = "ck-widget", yd = "ck-widget_selected";
  function re(n) {
    return n.is("element") ? !!n.getCustomProperty("widget") : !1;
  }
  function cr(n, e, t = {}) {
    if (!n.is("containerElement"))
      throw new g("widget-to-widget-wrong-element-type", null, { element: n });
    return e.setAttribute("contenteditable", "false", n), e.addClass(tI, n), e.setCustomProperty("widget", !0, n), n.getFillerOffset = rI, e.setCustomProperty("widgetLabel", [], n), t.label && sI(n, t.label), t.hasSelectionHandle && aI(n, e), Jg(n, e), n;
  }
  function iI(n, e, t) {
    if (e.classes && t.addClass(Z(e.classes), n), e.attributes)
      for (const i in e.attributes)
        t.setAttribute(i, e.attributes[i], n);
  }
  function nI(n, e, t) {
    if (e.classes && t.removeClass(Z(e.classes), n), e.attributes)
      for (const i in e.attributes)
        t.removeAttribute(i, n);
  }
  function Jg(n, e, t = iI, i = nI) {
    const s = new YS();
    s.on("change:top", (a, l) => {
      l.oldDescriptor && i(n, l.oldDescriptor, l.writer), l.newDescriptor && t(n, l.newDescriptor, l.writer);
    });
    const o = (a, l, c) => s.add(l, c), r = (a, l, c) => s.remove(l, c);
    e.setCustomProperty("addHighlight", o, n), e.setCustomProperty("removeHighlight", r, n);
  }
  function sI(n, e) {
    n.getCustomProperty("widgetLabel").push(e);
  }
  function oI(n) {
    return n.getCustomProperty("widgetLabel").reduce((t, i) => typeof i == "function" ? t ? t + ". " + i() : i() : t ? t + ". " + i : i, "");
  }
  function Ml(n, e, t = {}) {
    return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], n), e.setAttribute("role", "textbox", n), e.setAttribute("tabindex", "-1", n), t.label && e.setAttribute("aria-label", t.label, n), e.setAttribute("contenteditable", n.isReadOnly ? "false" : "true", n), n.on("change:isReadOnly", (i, s, o) => {
      e.setAttribute("contenteditable", o ? "false" : "true", n);
    }), n.on("change:isFocused", (i, s, o) => {
      o ? e.addClass("ck-editor__nested-editable_focused", n) : e.removeClass("ck-editor__nested-editable_focused", n);
    }), Jg(n, e), n;
  }
  function Bl(n, e) {
    const t = n.getSelectedElement();
    if (t) {
      const i = Dt(n);
      if (i)
        return e.createRange(e.createPositionAt(t, i));
    }
    return e.schema.findOptimalInsertionRange(n);
  }
  function rI() {
    return null;
  }
  function aI(n, e) {
    const t = e.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(i) {
      const s = this.toDomElement(i), o = new dt();
      return o.set("content", eI), o.render(), s.appendChild(o.element), s;
    });
    e.insert(e.createPositionAt(n, 0), t), e.addClass(["ck-widget_with-selection-handle"], n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const kt = "widget-type-around";
  function ei(n, e, t) {
    return !!n && re(n) && !t.isInline(e);
  }
  function lI(n) {
    return n.closest(".ck-widget__type-around__button");
  }
  function cI(n) {
    return n.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
  }
  function uI(n, e) {
    const t = n.closest(".ck-widget");
    return e.mapDomToView(t);
  }
  function Dt(n) {
    return n.getAttribute(kt);
  }
  const dI = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Xg = ["before", "after"], hI = new DOMParser().parseFromString(dI, "image/svg+xml").firstChild, Cd = "ck-widget__type-around_disabled";
  class fI extends w {
    constructor() {
      super(...arguments), this._currentFakeCaretModelElement = null;
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "WidgetTypeAround";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [lr, bt];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.editing.view;
      this.on("change:isEnabled", (i, s, o) => {
        t.change((r) => {
          for (const a of t.document.roots)
            o ? r.removeClass(Cd, a) : r.addClass(Cd, a);
        }), o || e.model.change((r) => {
          r.removeSelectionAttribute(kt);
        });
      }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this._currentFakeCaretModelElement = null;
    }
    /**
     * Inserts a new paragraph next to a widget element with the selection anchored in it.
     *
     * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
     * the viewport to the selection in the inserted paragraph.
     *
     * @param widgetModelElement The model widget element next to which a paragraph is inserted.
     * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
     */
    _insertParagraph(e, t) {
      const i = this.editor, s = i.editing.view, o = i.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
      i.execute("insertParagraph", {
        position: i.model.createPositionAt(e, t),
        attributes: o
      }), s.focus(), s.scrollToTheSelection();
    }
    /**
     * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only
     * when the plugin {@link #isEnabled is enabled}.
     *
     * @param emitter The object that fires the event.
     * @param event The name of the event.
     * @param callback The function to be called on event.
     * @param options Additional options.
     * @param options.priority The priority of this event callback. The higher the priority value the sooner
     * the callback will be fired. Events having the same priority are called in the order they were added.
     */
    _listenToIfEnabled(e, t, i, s) {
      this.listenTo(e, t, (...o) => {
        this.isEnabled && i(...o);
      }, s);
    }
    /**
     * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
     * does not expect a position. Instead, it performs the insertion next to a selected widget
     * according to the `widget-type-around` model selection attribute value (fake caret position).
     *
     * Because this method requires the `widget-type-around` attribute to be set,
     * the insertion can only happen when the widget's fake caret is active (e.g. activated
     * using the keyboard).
     *
     * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
     */
    _insertParagraphAccordingToFakeCaretPosition() {
      const i = this.editor.model.document.selection, s = Dt(i);
      if (!s)
        return !1;
      const o = i.getSelectedElement();
      return this._insertParagraph(o, s), !0;
    }
    /**
     * Creates a listener in the editing conversion pipeline that injects the widget type around
     * UI into every single widget instance created in the editor.
     *
     * The UI is delivered as a {@link module:engine/view/uielement~UIElement}
     * wrapper which renders DOM buttons that users can use to insert paragraphs.
     */
    _enableTypeAroundUIInjection() {
      const e = this.editor, t = e.model.schema, i = e.locale.t, s = {
        before: i("Insert paragraph before block"),
        after: i("Insert paragraph after block")
      };
      e.editing.downcastDispatcher.on("insert", (o, r, a) => {
        const l = a.mapper.toViewElement(r.item);
        l && ei(l, r.item, t) && (mI(a.writer, s, l), l.getCustomProperty("widgetLabel").push(() => this.isEnabled ? i("Press Enter to type after or press Shift + Enter to type before the widget") : ""));
      }, { priority: "low" });
    }
    /**
     * Brings support for the fake caret that appears when either:
     *
     * * the selection moves to a widget from a position next to it using arrow keys,
     * * the arrow key is pressed when the widget is already selected.
     *
     * The fake caret lets the user know that they can start typing or just press
     * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.
     *
     * The fake caret disappears when the user changes the selection or the editor
     * gets blurred.
     *
     * The whole idea is as follows:
     *
     * 1. A user does one of the 2 scenarios described at the beginning.
     * 2. The "keydown" listener is executed and the decision is made whether to show or hide the fake caret.
     * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating
     *    on which side of the widget it should appear.
     * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
     *    fake caret on the view widget.
     * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher
     *    does the CSS class clean-up in the view.
     * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection
     *    attribute (the former also removes widget CSS classes).
     */
    _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
      const e = this.editor, t = e.model, i = t.document.selection, s = t.schema, o = e.editing.view;
      this._listenToIfEnabled(o.document, "arrowKey", (a, l) => {
        this._handleArrowKeyPress(a, l);
      }, { context: [re, "$text"], priority: "high" }), this._listenToIfEnabled(i, "change:range", (a, l) => {
        l.directChange && e.model.change((c) => {
          c.removeSelectionAttribute(kt);
        });
      }), this._listenToIfEnabled(t.document, "change:data", () => {
        const a = i.getSelectedElement();
        if (a) {
          const l = e.editing.mapper.toViewElement(a);
          if (ei(l, a, s))
            return;
        }
        e.model.change((l) => {
          l.removeSelectionAttribute(kt);
        });
      }), this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (a, l, c) => {
        const u = c.writer;
        if (this._currentFakeCaretModelElement) {
          const m = c.mapper.toViewElement(this._currentFakeCaretModelElement);
          m && (u.removeClass(Xg.map(r), m), this._currentFakeCaretModelElement = null);
        }
        const d = l.selection.getSelectedElement();
        if (!d)
          return;
        const h = c.mapper.toViewElement(d);
        if (!ei(h, d, s))
          return;
        const f = Dt(l.selection);
        f && (u.addClass(r(f), h), this._currentFakeCaretModelElement = d);
      }), this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (a, l, c) => {
        c || e.model.change((u) => {
          u.removeSelectionAttribute(kt);
        });
      });
      function r(a) {
        return `ck-widget_type-around_show-fake-caret_${a}`;
      }
    }
    /**
     * A listener executed on each "keydown" in the view document, a part of
     * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
     *
     * It decides whether the arrow keypress should activate the fake caret or not (also whether it should
     * be deactivated).
     *
     * The fake caret activation is done by setting the `widget-type-around` model selection attribute
     * in this listener, and stopping and preventing the event that would normally be handled by the widget
     * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
     * includes inline widgets, which are ignored by the widget type around plugin).
     */
    _handleArrowKeyPress(e, t) {
      const i = this.editor, s = i.model, o = s.document.selection, r = s.schema, a = i.editing.view, l = t.keyCode, c = bC(l, i.locale.contentLanguageDirection), u = a.document.selection.getSelectedElement(), d = i.editing.mapper.toModelElement(u);
      let h;
      ei(u, d, r) ? h = this._handleArrowKeyPressOnSelectedWidget(c) : o.isCollapsed ? h = this._handleArrowKeyPressWhenSelectionNextToAWidget(c) : t.shiftKey || (h = this._handleArrowKeyPressWhenNonCollapsedSelection(c)), h && (t.preventDefault(), e.stop());
    }
    /**
     * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
     * the fake caret for that widget, depending on the current value of the `widget-type-around` model
     * selection attribute and the direction of the pressed arrow key.
     *
     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
     * process the event any further. Returns `false` otherwise.
     */
    _handleArrowKeyPressOnSelectedWidget(e) {
      const i = this.editor.model, s = i.document.selection, o = Dt(s);
      return i.change((r) => {
        if (o) {
          if (!(o === (e ? "after" : "before")))
            return r.removeSelectionAttribute(kt), !0;
        } else
          return r.setSelectionAttribute(kt, e ? "after" : "before"), !0;
        return !1;
      });
    }
    /**
     * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
     * to one and upon the fake caret should become active for this widget upon arrow keypress
     * (AKA entering/selecting the widget).
     *
     * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.
     * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the
     * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.
     *
     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
     * process the event any further. Returns `false` otherwise.
     */
    _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
      const t = this.editor, i = t.model, s = i.schema, o = t.plugins.get("Widget"), r = o._getObjectElementNextToSelection(e), a = t.editing.mapper.toViewElement(r);
      return ei(a, r, s) ? (i.change((l) => {
        o._setSelectionOverElement(r), l.setSelectionAttribute(kt, e ? "before" : "after");
      }), !0) : !1;
    }
    /**
     * Handles the keyboard navigation on "keydown" when a widget is currently selected (together with some other content)
     * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.
     *
     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
     * process the event any further. Returns `false` otherwise.
     */
    _handleArrowKeyPressWhenNonCollapsedSelection(e) {
      const t = this.editor, i = t.model, s = i.schema, o = t.editing.mapper, r = i.document.selection, a = e ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter, l = o.toViewElement(a);
      return ei(l, a, s) ? (i.change((c) => {
        c.setSelection(a, "on"), c.setSelectionAttribute(kt, e ? "after" : "before");
      }), !0) : !1;
    }
    /**
     * Registers a `mousedown` listener for the view document which intercepts events
     * coming from the widget type around UI, which happens when a user clicks one of the buttons
     * that insert a paragraph next to a widget.
     */
    _enableInsertingParagraphsOnButtonClick() {
      const e = this.editor, t = e.editing.view;
      this._listenToIfEnabled(t.document, "mousedown", (i, s) => {
        const o = lI(s.domTarget);
        if (!o)
          return;
        const r = cI(o), a = uI(o, t.domConverter), l = e.editing.mapper.toModelElement(a);
        this._insertParagraph(l, r), s.preventDefault(), i.stop();
      });
    }
    /**
     * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph
     * near the widget when either:
     *
     * * The fake caret was first activated using the arrow keys,
     * * The entire widget is selected in the model.
     *
     * In the first case, the new paragraph is inserted according to the `widget-type-around` selection
     * attribute (see {@link #_handleArrowKeyPress}).
     *
     * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke
     * was pressed or not.
     */
    _enableInsertingParagraphsOnEnterKeypress() {
      const e = this.editor, t = e.model.document.selection, i = e.editing.view;
      this._listenToIfEnabled(i.document, "enter", (s, o) => {
        if (s.eventPhase != "atTarget")
          return;
        const r = t.getSelectedElement(), a = e.editing.mapper.toViewElement(r), l = e.model.schema;
        let c;
        this._insertParagraphAccordingToFakeCaretPosition() ? c = !0 : ei(a, r, l) && (this._insertParagraph(r, o.isSoft ? "before" : "after"), c = !0), c && (o.preventDefault(), s.stop());
      }, { context: re });
    }
    /**
     * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
     * to insert a paragraph next to a widget when the fake caret was activated using arrow
     * keys but it responds to typing instead of <kbd>Enter</kbd>.
     *
     * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`
     * model selection attribute as the user simply starts typing, which creates the impression that the fake caret
     * behaves like a real one rendered by the browser (AKA your text appears where the caret was).
     *
     * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command
     * and another one for actual typing. It is not a disaster but this may need to be fixed
     * sooner or later.
     */
    _enableInsertingParagraphsOnTypingKeystroke() {
      const t = this.editor.editing.view.document;
      this._listenToIfEnabled(t, "insertText", (i, s) => {
        this._insertParagraphAccordingToFakeCaretPosition() && (s.selection = t.selection);
      }, { priority: "high" }), B.isAndroid ? this._listenToIfEnabled(t, "keydown", (i, s) => {
        s.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition();
      }) : this._listenToIfEnabled(t, "compositionstart", () => {
        this._insertParagraphAccordingToFakeCaretPosition();
      }, { priority: "high" });
    }
    /**
     * It creates a "delete" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>
     * is pressed and the fake caret is currently active.
     *
     * The fake caret should create an illusion of a real browser caret so that when it appears before or after
     * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content
     * before or after a widget (depending on the content surrounding the widget).
     */
    _enableDeleteIntegration() {
      const e = this.editor, t = e.editing.view, i = e.model, s = i.schema;
      this._listenToIfEnabled(t.document, "delete", (o, r) => {
        if (o.eventPhase != "atTarget")
          return;
        const a = Dt(i.document.selection);
        if (!a)
          return;
        const l = r.direction, c = i.document.selection.getSelectedElement(), u = a === "before", d = l == "forward";
        if (u === d)
          e.execute("delete", {
            selection: i.createSelection(c, "on")
          });
        else {
          const f = s.getNearestSelectionRange(i.createPositionAt(c, a), l);
          if (f)
            if (!f.isCollapsed)
              i.change((m) => {
                m.setSelection(f), e.execute(d ? "deleteForward" : "delete");
              });
            else {
              const m = i.createSelection(f.start);
              if (i.modifySelection(m, { direction: l }), !m.focus.isEqual(f.start))
                i.change((p) => {
                  p.setSelection(f), e.execute(d ? "deleteForward" : "delete");
                });
              else {
                const p = wI(s, f.start.parent);
                i.deleteContent(i.createSelection(p, "on"), {
                  doNotAutoparagraph: !0
                });
              }
            }
        }
        r.preventDefault(), o.stop();
      }, { context: re });
    }
    /**
     * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
     * content near a widget when the fake caret is first activated using the arrow keys.
     *
     * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
     */
    _enableInsertContentIntegration() {
      const e = this.editor, t = this.editor.model, i = t.document.selection;
      this._listenToIfEnabled(e.model, "insertContent", (s, [o, r]) => {
        if (r && !r.is("documentSelection"))
          return;
        const a = Dt(i);
        if (a)
          return s.stop(), t.change((l) => {
            const c = i.getSelectedElement(), u = t.createPositionAt(c, a), d = l.createSelection(u), h = t.insertContent(o, d);
            return l.setSelection(d), h;
          });
      }, { priority: "high" });
    }
    /**
     * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the
     * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element
     * to reflect user's intent of desired insertion position.
     *
     * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
     */
    _enableInsertObjectIntegration() {
      const e = this.editor, i = this.editor.model.document.selection;
      this._listenToIfEnabled(e.model, "insertObject", (s, o) => {
        const [, r, a = {}] = o;
        if (r && !r.is("documentSelection"))
          return;
        const l = Dt(i);
        l && (a.findOptimalPosition = l, o[3] = a);
      }, { priority: "high" });
    }
    /**
     * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake
     * caret is active.
     *
     * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
     * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,
     * plain text pasting.
     */
    _enableDeleteContentIntegration() {
      const e = this.editor, i = this.editor.model.document.selection;
      this._listenToIfEnabled(e.model, "deleteContent", (s, [o]) => {
        if (o && !o.is("documentSelection"))
          return;
        Dt(i) && s.stop();
      }, { priority: "high" });
    }
  }
  function mI(n, e, t) {
    const i = n.createUIElement("div", {
      class: "ck ck-reset_all ck-widget__type-around"
    }, function(s) {
      const o = this.toDomElement(s);
      return gI(o, e), pI(o), o;
    });
    n.insert(n.createPositionAt(t, "end"), i);
  }
  function gI(n, e) {
    for (const t of Xg) {
      const i = new Ve({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-widget__type-around__button",
            `ck-widget__type-around__button_${t}`
          ],
          title: e[t],
          "aria-hidden": "true"
        },
        children: [
          n.ownerDocument.importNode(hI, !0)
        ]
      });
      n.appendChild(i.render());
    }
  }
  function pI(n) {
    const e = new Ve({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-widget__type-around__fake-caret"
        ]
      }
    });
    n.appendChild(e.render());
  }
  function wI(n, e) {
    let t = e;
    for (const i of e.getAncestors({ parentFirst: !0 })) {
      if (i.childCount > 1 || n.isLimit(i))
        break;
      t = i;
    }
    return t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function bI(n) {
    const e = n.model;
    return (t, i) => {
      const s = i.keyCode == F.arrowup, o = i.keyCode == F.arrowdown, r = i.shiftKey, a = e.document.selection;
      if (!s && !o)
        return;
      const l = o;
      if (r && yI(a, l))
        return;
      const c = _I(n, a, l);
      if (c) {
        if (c.isCollapsed) {
          if (a.isCollapsed)
            return;
          if (r)
            return;
        }
        (c.isCollapsed || vI(n, c, l)) && (e.change((u) => {
          const d = l ? c.end : c.start;
          if (r) {
            const h = e.createSelection(a.anchor);
            h.setFocus(d), u.setSelection(h);
          } else
            u.setSelection(d);
        }), t.stop(), i.preventDefault(), i.stopPropagation());
      }
    };
  }
  function _I(n, e, t) {
    const i = n.model;
    if (t) {
      const s = e.isCollapsed ? e.focus : e.getLastPosition(), o = kd(i, s, "forward");
      if (!o)
        return null;
      const r = i.createRange(s, o), a = Td(i.schema, r, "backward");
      return a ? i.createRange(s, a) : null;
    } else {
      const s = e.isCollapsed ? e.focus : e.getFirstPosition(), o = kd(i, s, "backward");
      if (!o)
        return null;
      const r = i.createRange(o, s), a = Td(i.schema, r, "forward");
      return a ? i.createRange(a, s) : null;
    }
  }
  function kd(n, e, t) {
    const i = n.schema, s = n.createRangeIn(e.root), o = t == "forward" ? "elementStart" : "elementEnd";
    for (const { previousPosition: r, item: a, type: l } of s.getWalker({ startPosition: e, direction: t })) {
      if (i.isLimit(a) && !i.isInline(a))
        return r;
      if (l == o && i.isBlock(a))
        return null;
    }
    return null;
  }
  function Td(n, e, t) {
    const i = t == "backward" ? e.end : e.start;
    if (n.checkChild(i, "$text"))
      return i;
    for (const { nextPosition: s } of e.getWalker({ direction: t }))
      if (n.checkChild(s, "$text"))
        return s;
    return null;
  }
  function vI(n, e, t) {
    const i = n.model, s = n.view.domConverter;
    if (t) {
      const c = i.createSelection(e.start);
      i.modifySelection(c), !c.focus.isAtEnd && !e.start.isEqual(c.focus) && (e = i.createRange(c.focus, e.end));
    }
    const o = n.mapper.toViewRange(e), r = s.viewRangeToDom(o), a = O.getDomRangeRects(r);
    let l;
    for (const c of a) {
      if (l === void 0) {
        l = Math.round(c.bottom);
        continue;
      }
      if (Math.round(c.top) >= l)
        return !1;
      l = Math.max(l, Math.round(c.bottom));
    }
    return !0;
  }
  function yI(n, e) {
    return !n.isCollapsed && n.isBackward == e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class gn extends w {
    constructor() {
      super(...arguments), this._previouslySelected = /* @__PURE__ */ new Set();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Widget";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [fI, bt];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.editing.view, i = t.document, s = e.t;
      this.editor.editing.downcastDispatcher.on("selection", (o, r, a) => {
        const l = a.writer, c = r.selection;
        if (c.isCollapsed)
          return;
        const u = c.getSelectedElement();
        if (!u)
          return;
        const d = e.editing.mapper.toViewElement(u);
        re(d) && a.consumable.consume(c, "selection") && l.setSelection(l.createRangeOn(d), {
          fake: !0,
          label: oI(d)
        });
      }), this.editor.editing.downcastDispatcher.on("selection", (o, r, a) => {
        this._clearPreviouslySelectedWidgets(a.writer);
        const l = a.writer, c = l.document.selection;
        let u = null;
        for (const d of c.getRanges())
          for (const h of d) {
            const f = h.item;
            re(f) && !kI(f, u) && (l.addClass(yd, f), this._previouslySelected.add(f), u = f);
          }
      }, { priority: "low" }), t.addObserver(er), this.listenTo(i, "mousedown", (...o) => this._onMousedown(...o)), this.listenTo(i, "arrowKey", (...o) => {
        this._handleSelectionChangeOnArrowKeyPress(...o);
      }, { context: [re, "$text"] }), this.listenTo(i, "arrowKey", (...o) => {
        this._preventDefaultOnArrowKeyPress(...o);
      }, { context: "$root" }), this.listenTo(i, "arrowKey", bI(this.editor.editing), { context: "$text" }), this.listenTo(i, "delete", (o, r) => {
        this._handleDelete(r.direction == "forward") && (r.preventDefault(), o.stop());
      }, { context: "$root" }), this.listenTo(i, "tab", (o, r) => {
        o.eventPhase == "atTarget" && (r.shiftKey || this._selectFirstNestedEditable() && (r.preventDefault(), o.stop()));
      }, { context: re, priority: "low" }), this.listenTo(i, "tab", (o, r) => {
        r.shiftKey && this._selectAncestorWidget() && (r.preventDefault(), o.stop());
      }, { priority: "low" }), this.listenTo(i, "keydown", (o, r) => {
        r.keystroke == F.esc && this._selectAncestorWidget() && (r.preventDefault(), o.stop());
      }, { priority: "low" }), e.accessibility.addKeystrokeInfoGroup({
        id: "widget",
        label: s("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"),
        keystrokes: [
          {
            label: s("Insert a new paragraph directly after a widget"),
            keystroke: "Enter"
          },
          {
            label: s("Insert a new paragraph directly before a widget"),
            keystroke: "Shift+Enter"
          },
          {
            label: s("Move the caret to allow typing directly before a widget"),
            keystroke: [["arrowup"], ["arrowleft"]]
          },
          {
            label: s("Move the caret to allow typing directly after a widget"),
            keystroke: [["arrowdown"], ["arrowright"]]
          }
        ]
      });
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
     */
    _onMousedown(e, t) {
      const i = this.editor, s = i.editing.view, o = s.document;
      let r = t.target;
      if (t.domEvent.detail >= 3) {
        this._selectBlockContent(r) && t.preventDefault();
        return;
      }
      if (CI(r) || !re(r) && (r = r.findAncestor(re), !r))
        return;
      B.isAndroid && t.preventDefault(), o.isFocused || s.focus();
      const a = i.editing.mapper.toModelElement(r);
      this._setSelectionOverElement(a);
    }
    /**
     * Selects entire block content, e.g. on triple click it selects entire paragraph.
     */
    _selectBlockContent(e) {
      const t = this.editor, i = t.model, s = t.editing.mapper, o = i.schema, r = s.findMappedViewAncestor(this.editor.editing.view.createPositionAt(e, 0)), a = TI(s.toModelElement(r), i.schema);
      return a ? (i.change((l) => {
        const c = o.isLimit(a) ? null : EI(l.createPositionAfter(a), o), u = l.createPositionAt(a, 0), d = c ? l.createPositionAt(c, 0) : l.createPositionAt(a, "end");
        l.setSelection(l.createRange(u, d));
      }), !0) : !1;
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes
     * the model selection when:
     *
     * * arrow key is pressed when the widget is selected,
     * * the selection is next to a widget and the widget should become selected upon the arrow key press.
     *
     * See {@link #_preventDefaultOnArrowKeyPress}.
     */
    _handleSelectionChangeOnArrowKeyPress(e, t) {
      const i = t.keyCode, s = this.editor.model, o = s.schema, r = s.document.selection, a = r.getSelectedElement(), l = ul(i, this.editor.locale.contentLanguageDirection), c = l == "down" || l == "right", u = l == "up" || l == "down";
      if (a && o.isObject(a)) {
        const h = c ? r.getLastPosition() : r.getFirstPosition(), f = o.getNearestSelectionRange(h, c ? "forward" : "backward");
        f && (s.change((m) => {
          m.setSelection(f);
        }), t.preventDefault(), e.stop());
        return;
      }
      if (!r.isCollapsed && !t.shiftKey) {
        const h = r.getFirstPosition(), f = r.getLastPosition(), m = h.nodeAfter, p = f.nodeBefore;
        (m && o.isObject(m) || p && o.isObject(p)) && (s.change((b) => {
          b.setSelection(c ? f : h);
        }), t.preventDefault(), e.stop());
        return;
      }
      if (!r.isCollapsed)
        return;
      const d = this._getObjectElementNextToSelection(c);
      if (d && o.isObject(d)) {
        if (o.isInline(d) && u)
          return;
        this._setSelectionOverElement(d), t.preventDefault(), e.stop();
      }
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents
     * the default browser behavior to make sure the fake selection is not being moved from a fake selection
     * container.
     *
     * See {@link #_handleSelectionChangeOnArrowKeyPress}.
     */
    _preventDefaultOnArrowKeyPress(e, t) {
      const i = this.editor.model, s = i.schema, o = i.document.selection.getSelectedElement();
      o && s.isObject(o) && (t.preventDefault(), e.stop());
    }
    /**
     * Handles delete keys: backspace and delete.
     *
     * @param isForward Set to true if delete was performed in forward direction.
     * @returns Returns `true` if keys were handled correctly.
     */
    _handleDelete(e) {
      const i = this.editor.model.document.selection;
      if (!this.editor.model.canEditAt(i) || !i.isCollapsed)
        return;
      const s = this._getObjectElementNextToSelection(e);
      if (s)
        return this.editor.model.change((o) => {
          let r = i.anchor.parent;
          for (; r.isEmpty; ) {
            const a = r;
            r = a.parent, o.remove(a);
          }
          this._setSelectionOverElement(s);
        }), !0;
    }
    /**
     * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
     *
     * @internal
     */
    _setSelectionOverElement(e) {
      this.editor.model.change((t) => {
        t.setSelection(t.createRangeOn(e));
      });
    }
    /**
     * Checks if {@link module:engine/model/element~Element element} placed next to the current
     * {@link module:engine/model/selection~Selection model selection} exists and is marked in
     * {@link module:engine/model/schema~Schema schema} as `object`.
     *
     * @internal
     * @param forward Direction of checking.
     */
    _getObjectElementNextToSelection(e) {
      const t = this.editor.model, i = t.schema, s = t.document.selection, o = t.createSelection(s);
      if (t.modifySelection(o, { direction: e ? "forward" : "backward" }), o.isEqual(s))
        return null;
      const r = e ? o.focus.nodeBefore : o.focus.nodeAfter;
      return r && i.isObject(r) ? r : null;
    }
    /**
     * Removes CSS class from previously selected widgets.
     */
    _clearPreviouslySelectedWidgets(e) {
      for (const t of this._previouslySelected)
        e.removeClass(yd, t);
      this._previouslySelected.clear();
    }
    /**
     * Moves the document selection into the first nested editable.
     */
    _selectFirstNestedEditable() {
      const e = this.editor, i = this.editor.editing.view.document;
      for (const s of i.selection.getFirstRange().getItems())
        if (s.is("editableElement")) {
          const o = e.editing.mapper.toModelElement(s);
          /* istanbul ignore next -- @preserve */
          if (!o)
            continue;
          const r = e.model.createPositionAt(o, 0), a = e.model.schema.getNearestSelectionRange(r, "forward");
          return e.model.change((l) => {
            l.setSelection(a);
          }), !0;
        }
      return !1;
    }
    /**
     * Updates the document selection so that it selects first ancestor widget.
     */
    _selectAncestorWidget() {
      const e = this.editor, t = e.editing.mapper, s = e.editing.view.document.selection.getFirstPosition().parent, r = (s.is("$text") ? s.parent : s).findAncestor(re);
      if (!r)
        return !1;
      const a = t.toModelElement(r);
      /* istanbul ignore next -- @preserve */
      return a ? (e.model.change((l) => {
        l.setSelection(a, "on");
      }), !0) : !1;
    }
  }
  function CI(n) {
    let e = n;
    for (; e; ) {
      if (e.is("editableElement") && !e.is("rootElement"))
        return !0;
      if (re(e))
        return !1;
      e = e.parent;
    }
    return !1;
  }
  function kI(n, e) {
    return e ? Array.from(n.getAncestors()).includes(e) : !1;
  }
  function TI(n, e) {
    for (const t of n.getAncestors({ includeSelf: !0, parentFirst: !0 })) {
      if (e.checkChild(t, "$text"))
        return t;
      if (e.isLimit(t) && !e.isObject(t))
        break;
    }
    return null;
  }
  function EI(n, e) {
    const t = new xt({ startPosition: n });
    for (const { item: i } of t) {
      if (e.isLimit(i) || !i.is("element"))
        return null;
      if (e.checkChild(i, "$text"))
        return i;
    }
    return null;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Po extends w {
    constructor() {
      super(...arguments), this._toolbarDefinitions = /* @__PURE__ */ new Map();
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [$t];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "WidgetToolbarRepository";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      if (e.plugins.has("BalloonToolbar")) {
        const t = e.plugins.get("BalloonToolbar");
        this.listenTo(t, "show", (i) => {
          AI(e.editing.view.document.selection) && i.stop();
        }, { priority: "high" });
      }
      this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
        this._updateToolbarsVisibility();
      }), this.listenTo(e.ui, "update", () => {
        this._updateToolbarsVisibility();
      }), this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
        this._updateToolbarsVisibility();
      }, { priority: "low" });
    }
    destroy() {
      super.destroy();
      for (const e of this._toolbarDefinitions.values())
        e.view.destroy();
    }
    /**
     * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked
     * `getRelatedElement` function. Toolbar items are gathered from `items` array.
     * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.
     *
     * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}
     * callback (or later) to make sure that the given toolbar items were already registered by other plugins.
     *
     * @param toolbarId An id for the toolbar. Used to
     * @param options.ariaLabel Label used by assistive technologies to describe this toolbar element.
     * @param options.items Array of toolbar items.
     * @param options.getRelatedElement Callback which returns an element the toolbar should be attached to.
     * @param options.balloonClassName CSS class for the widget balloon.
     */
    register(e, { ariaLabel: t, items: i, getRelatedElement: s, balloonClassName: o = "ck-toolbar-container" }) {
      if (!i.length) {
        z("widget-toolbar-no-items", { toolbarId: e });
        return;
      }
      const r = this.editor, a = r.t, l = new en(r.locale);
      if (l.ariaLabel = t || a("Widget toolbar"), this._toolbarDefinitions.has(e))
        throw new g("widget-toolbar-duplicated", this, { toolbarId: e });
      const c = {
        view: l,
        getRelatedElement: s,
        balloonClassName: o,
        itemsConfig: i,
        initialized: !1
      };
      r.ui.addToolbar(l, {
        isContextual: !0,
        beforeFocus: () => {
          const u = s(r.editing.view.document.selection);
          u && this._showToolbar(c, u);
        },
        afterBlur: () => {
          this._hideToolbar(c);
        }
      }), this._toolbarDefinitions.set(e, c);
    }
    /**
     * Iterates over stored toolbars and makes them visible or hidden.
     */
    _updateToolbarsVisibility() {
      let e = 0, t = null, i = null;
      for (const s of this._toolbarDefinitions.values()) {
        const o = s.getRelatedElement(this.editor.editing.view.document.selection);
        if (!this.isEnabled || !o)
          this._isToolbarInBalloon(s) && this._hideToolbar(s);
        else if (!this.editor.ui.focusTracker.isFocused)
          this._isToolbarVisible(s) && this._hideToolbar(s);
        else {
          const r = o.getAncestors().length;
          r > e && (e = r, t = o, i = s);
        }
      }
      i && this._showToolbar(i, t);
    }
    /**
     * Hides the given toolbar.
     */
    _hideToolbar(e) {
      this._balloon.remove(e.view), this.stopListening(this._balloon, "change:visibleView");
    }
    /**
     * Shows up the toolbar if the toolbar is not visible.
     * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.
     *
     * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view
     * should be still visible after the {@link module:ui/editorui/editorui~EditorUI#event:update}.
     */
    _showToolbar(e, t) {
      this._isToolbarVisible(e) ? Ed(this.editor, t) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0, e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({
        view: e.view,
        position: Yg(this.editor, t),
        balloonClassName: e.balloonClassName
      }), this.listenTo(this._balloon, "change:visibleView", () => {
        for (const i of this._toolbarDefinitions.values())
          if (this._isToolbarVisible(i)) {
            const s = i.getRelatedElement(this.editor.editing.view.document.selection);
            Ed(this.editor, s);
          }
      }));
    }
    _isToolbarVisible(e) {
      return this._balloon.visibleView === e.view;
    }
    _isToolbarInBalloon(e) {
      return this._balloon.hasView(e.view);
    }
  }
  function Ed(n, e) {
    const t = n.plugins.get("ContextualBalloon"), i = Yg(n, e);
    t.updatePosition(i);
  }
  function Yg(n, e) {
    const t = n.editing.view, i = ye.defaultPositions;
    return {
      target: t.domConverter.mapViewToDom(e),
      positions: [
        i.northArrowSouth,
        i.northArrowSouthWest,
        i.northArrowSouthEast,
        i.southArrowNorth,
        i.southArrowNorthWest,
        i.southArrowNorthEast,
        i.viewportStickyNorth
      ]
    };
  }
  function AI(n) {
    const e = n.getSelectedElement();
    return !!(e && re(e));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class xI extends $() {
    /**
     * @param options Resizer options.
     */
    constructor(e) {
      super(), this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = e, this._referenceCoordinates = null;
    }
    /**
     * The original width (pixels) of the resized object when the resize process was started.
     */
    get originalWidth() {
      return this._originalWidth;
    }
    /**
     * The original height (pixels) of the resized object when the resize process was started.
     */
    get originalHeight() {
      return this._originalHeight;
    }
    /**
     * The original width (percents) of the resized object when the resize process was started.
     */
    get originalWidthPercents() {
      return this._originalWidthPercents;
    }
    /**
     * A width to height ratio of the resized image.
     */
    get aspectRatio() {
      return this._aspectRatio;
    }
    /**
     *
     * @param domResizeHandle The handle used to calculate the reference point.
     */
    begin(e, t, i) {
      const s = new O(t);
      this.activeHandlePosition = RI(e), this._referenceCoordinates = II(t, LI(this.activeHandlePosition)), this._originalWidth = s.width, this._originalHeight = s.height, this._aspectRatio = s.width / s.height;
      const o = i.style.width;
      o && o.match(/^\d+(\.\d*)?%$/) ? this._originalWidthPercents = parseFloat(o) : this._originalWidthPercents = SI(i, s);
    }
    update(e) {
      this.proposedWidth = e.width, this.proposedHeight = e.height, this.proposedWidthPercents = e.widthPercents, this.proposedHandleHostWidth = e.handleHostWidth, this.proposedHandleHostHeight = e.handleHostHeight;
    }
  }
  function SI(n, e) {
    const t = n.parentElement;
    let i = parseFloat(t.ownerDocument.defaultView.getComputedStyle(t).width);
    const s = 5;
    let o = 0, r = t;
    for (; isNaN(i); ) {
      if (r = r.parentElement, ++o > s)
        return 0;
      i = parseFloat(t.ownerDocument.defaultView.getComputedStyle(r).width);
    }
    return e.width / i * 100;
  }
  function II(n, e) {
    const t = new O(n), i = e.split("-"), s = {
      x: i[1] == "right" ? t.right : t.left,
      y: i[0] == "bottom" ? t.bottom : t.top
    };
    return s.x += n.ownerDocument.defaultView.scrollX, s.y += n.ownerDocument.defaultView.scrollY, s;
  }
  function PI(n) {
    return `ck-widget__resizer__handle-${n}`;
  }
  function RI(n) {
    const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
    for (const t of e)
      if (n.classList.contains(PI(t)))
        return t;
  }
  function LI(n) {
    const e = n.split("-"), t = {
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    };
    return `${t[e[0]]}-${t[e[1]]}`;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class VI extends T {
    constructor() {
      super();
      const e = this.bindTemplate;
      this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-size-view",
            e.to("_viewPosition", (t) => t ? `ck-orientation-${t}` : "")
          ],
          style: {
            display: e.if("_isVisible", "none", (t) => !t)
          }
        },
        children: [{
          text: e.to("_label")
        }]
      });
    }
    /**
     * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.
     *
     * @internal
     * @param options An object defining the resizer options, used for setting the proper size label.
     * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.
     */
    _bindToState(e, t) {
      this.bind("_isVisible").to(t, "proposedWidth", t, "proposedHeight", (i, s) => i !== null && s !== null), this.bind("_label").to(t, "proposedHandleHostWidth", t, "proposedHandleHostHeight", t, "proposedWidthPercents", (i, s, o) => e.unit === "px" ? `${i}×${s}` : `${o}%`), this.bind("_viewPosition").to(
        t,
        "activeHandlePosition",
        t,
        "proposedHandleHostWidth",
        t,
        "proposedHandleHostHeight",
        // If the widget is too small to contain the size label, display the label above.
        (i, s, o) => s < 50 || o < 50 ? "above-center" : i
      );
    }
    /**
     * A method used for cleaning up. It removes the bindings and hides the view.
     *
     * @internal
     */
    _dismiss() {
      this.unbind(), this._isVisible = !1;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ad extends $() {
    /**
     * @param options Resizer options.
     */
    constructor(e) {
      super(), this._viewResizerWrapper = null, this._options = e, this.set("isEnabled", !0), this.set("isSelected", !1), this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (t, i) => t && i), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (t) => {
        !this.state.proposedWidth && !this.state.proposedWidthPercents && (this._cleanup(), t.stop());
      }, { priority: "high" });
    }
    /**
     * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.
     *
     * Note that a new state is created for each resize transaction.
     */
    get state() {
      return this._state;
    }
    /**
     * Makes resizer visible in the UI.
     */
    show() {
      this._options.editor.editing.view.change((t) => {
        t.removeClass("ck-hidden", this._viewResizerWrapper);
      });
    }
    /**
     * Hides resizer in the UI.
     */
    hide() {
      this._options.editor.editing.view.change((t) => {
        t.addClass("ck-hidden", this._viewResizerWrapper);
      });
    }
    /**
     * Attaches the resizer to the DOM.
     */
    attach() {
      const e = this, t = this._options.viewElement;
      this._options.editor.editing.view.change((s) => {
        const o = s.createUIElement("div", {
          class: "ck ck-reset_all ck-widget__resizer"
        }, function(r) {
          const a = this.toDomElement(r);
          return e._appendHandles(a), e._appendSizeUI(a), a;
        });
        s.insert(s.createPositionAt(t, "end"), o), s.addClass("ck-widget_with-resizer", t), this._viewResizerWrapper = o, this.isVisible || this.hide();
      }), this.on("change:isVisible", () => {
        this.isVisible ? (this.show(), this.redraw()) : this.hide();
      });
    }
    /**
     * Starts the resizing process.
     *
     * Creates a new {@link #state} for the current process.
     *
     * @fires begin
     * @param domResizeHandle Clicked handle.
     */
    begin(e) {
      this._state = new xI(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(e, this._getHandleHost(), this._getResizeHost());
    }
    /**
     * Updates the proposed size based on `domEventData`.
     *
     * @fires updateSize
     */
    updateSize(e) {
      const t = this._proposeNewSize(e);
      this._options.editor.editing.view.change((c) => {
        const u = this._options.unit || "%", d = (u === "%" ? t.widthPercents : t.width) + u;
        c.setStyle("width", d, this._options.viewElement);
      });
      const s = this._getHandleHost(), o = new O(s), r = Math.round(o.width), a = Math.round(o.height), l = new O(s);
      t.width = Math.round(l.width), t.height = Math.round(l.height), this.redraw(o), this.state.update({
        ...t,
        handleHostWidth: r,
        handleHostHeight: a
      });
    }
    /**
     * Applies the geometry proposed with the resizer.
     *
     * @fires commit
     */
    commit() {
      const e = this._options.unit || "%", t = (e === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + e;
      this._options.editor.editing.view.change(() => {
        this._cleanup(), this._options.onCommit(t);
      });
    }
    /**
     * Cancels and rejects the proposed resize dimensions, hiding the UI.
     *
     * @fires cancel
     */
    cancel() {
      this._cleanup();
    }
    /**
     * Destroys the resizer.
     */
    destroy() {
      this.cancel();
    }
    /**
     * Redraws the resizer.
     *
     * @param handleHostRect Handle host rectangle might be given to improve performance.
     */
    redraw(e) {
      const t = this._domResizerWrapper;
      if (!OI(t))
        return;
      const i = t.parentElement, s = this._getHandleHost(), o = this._viewResizerWrapper, r = [
        o.getStyle("width"),
        o.getStyle("height"),
        o.getStyle("left"),
        o.getStyle("top")
      ];
      let a;
      if (i.isSameNode(s)) {
        const l = e || new O(s);
        a = [
          l.width + "px",
          l.height + "px",
          void 0,
          void 0
        ];
      } else
        a = [
          s.offsetWidth + "px",
          s.offsetHeight + "px",
          s.offsetLeft + "px",
          s.offsetTop + "px"
        ];
      Ee(r, a) !== "same" && this._options.editor.editing.view.change((l) => {
        l.setStyle({
          width: a[0],
          height: a[1],
          left: a[2],
          top: a[3]
        }, o);
      });
    }
    containsHandle(e) {
      return this._domResizerWrapper.contains(e);
    }
    static isResizeHandle(e) {
      return e.classList.contains("ck-widget__resizer__handle");
    }
    /**
     * Cleans up the context state.
     */
    _cleanup() {
      this._sizeView._dismiss(), this._options.editor.editing.view.change((t) => {
        t.setStyle("width", this._initialViewWidth, this._options.viewElement);
      });
    }
    /**
     * Calculates the proposed size as the resize handles are dragged.
     *
     * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.
     */
    _proposeNewSize(e) {
      const t = this.state, i = BI(e), s = this._options.isCentered ? this._options.isCentered(this) : !0, o = {
        x: t._referenceCoordinates.x - (i.x + t.originalWidth),
        y: i.y - t.originalHeight - t._referenceCoordinates.y
      };
      s && t.activeHandlePosition.endsWith("-right") && (o.x = i.x - (t._referenceCoordinates.x + t.originalWidth)), s && (o.x *= 2);
      let r = Math.abs(t.originalWidth + o.x), a = Math.abs(t.originalHeight + o.y);
      return (r / t.aspectRatio > a ? "width" : "height") == "width" ? a = r / t.aspectRatio : r = a * t.aspectRatio, {
        width: Math.round(r),
        height: Math.round(a),
        widthPercents: Math.min(Math.round(t.originalWidthPercents / t.originalWidth * r * 100) / 100, 100)
      };
    }
    /**
     * Obtains the resize host.
     *
     * Resize host is an object that receives dimensions which are the result of resizing.
     */
    _getResizeHost() {
      const e = this._domResizerWrapper.parentElement;
      return this._options.getResizeHost(e);
    }
    /**
     * Obtains the handle host.
     *
     * Handle host is an object that the handles are aligned to.
     *
     * Handle host will not always be an entire widget itself. Take an image as an example. The image widget
     * contains an image and a caption. Only the image should be surrounded with handles.
     */
    _getHandleHost() {
      const e = this._domResizerWrapper.parentElement;
      return this._options.getHandleHost(e);
    }
    /**
     * DOM container of the entire resize UI.
     *
     * Note that this property will have a value only after the element bound with the resizer is rendered
     * (otherwise `null`).
     */
    get _domResizerWrapper() {
      return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
    }
    /**
     * Renders the resize handles in the DOM.
     *
     * @param domElement The resizer wrapper.
     */
    _appendHandles(e) {
      const t = ["top-left", "top-right", "bottom-right", "bottom-left"];
      for (const i of t)
        e.appendChild(new Ve({
          tag: "div",
          attributes: {
            class: `ck-widget__resizer__handle ${MI(i)}`
          }
        }).render());
    }
    /**
     * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.
     */
    _appendSizeUI(e) {
      this._sizeView = new VI(), this._sizeView.render(), e.appendChild(this._sizeView.element);
    }
  }
  function MI(n) {
    return `ck-widget__resizer__handle-${n}`;
  }
  function BI(n) {
    return {
      x: n.pageX,
      y: n.pageY
    };
  }
  function OI(n) {
    return n && n.ownerDocument && n.ownerDocument.contains(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Fr extends w {
    constructor() {
      super(...arguments), this._resizers = /* @__PURE__ */ new Map();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "WidgetResize";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor.editing, t = E.window.document;
      this.set("selectedResizer", null), this.set("_activeResizer", null), e.view.addObserver(er), this._observer = new (Me())(), this.listenTo(e.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }), this._observer.listenTo(t, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(t, "mouseup", this._mouseUpListener.bind(this)), this._redrawSelectedResizerThrottled = Zi(() => this.redrawSelectedResizer(), 200), this.editor.ui.on("update", this._redrawSelectedResizerThrottled), this.editor.model.document.on("change", () => {
        for (const [s, o] of this._resizers)
          s.isAttached() || (this._resizers.delete(s), o.destroy());
      }, { priority: "lowest" }), this._observer.listenTo(E.window, "resize", this._redrawSelectedResizerThrottled);
      const i = this.editor.editing.view.document.selection;
      i.on("change", () => {
        const s = i.getSelectedElement(), o = this.getResizerByViewElement(s) || null;
        o ? this.select(o) : this.deselect();
      });
    }
    /**
     * Redraws the selected resizer if there is any selected resizer and if it is visible.
     */
    redrawSelectedResizer() {
      this.selectedResizer && this.selectedResizer.isVisible && this.selectedResizer.redraw();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this._observer.stopListening();
      for (const e of this._resizers.values())
        e.destroy();
      this._redrawSelectedResizerThrottled.cancel();
    }
    /**
     * Marks resizer as selected.
     */
    select(e) {
      this.deselect(), this.selectedResizer = e, this.selectedResizer.isSelected = !0;
    }
    /**
     * Deselects currently set resizer.
     */
    deselect() {
      this.selectedResizer && (this.selectedResizer.isSelected = !1), this.selectedResizer = null;
    }
    /**
     * @param options Resizer options.
     */
    attachTo(e) {
      const t = new Ad(e), i = this.editor.plugins;
      if (t.attach(), i.has("WidgetToolbarRepository")) {
        const r = i.get("WidgetToolbarRepository");
        t.on("begin", () => {
          r.forceDisabled("resize");
        }, { priority: "lowest" }), t.on("cancel", () => {
          r.clearForceDisabled("resize");
        }, { priority: "highest" }), t.on("commit", () => {
          r.clearForceDisabled("resize");
        }, { priority: "highest" });
      }
      this._resizers.set(e.viewElement, t);
      const o = this.editor.editing.view.document.selection.getSelectedElement();
      return this.getResizerByViewElement(o) == t && this.select(t), t;
    }
    /**
     * Returns a resizer created for a given view element (widget element).
     *
     * @param viewElement View element associated with the resizer.
     */
    getResizerByViewElement(e) {
      return this._resizers.get(e);
    }
    /**
     * Returns a resizer that contains a given resize handle.
     */
    _getResizerByHandle(e) {
      for (const t of this._resizers.values())
        if (t.containsHandle(e))
          return t;
    }
    /**
     * @param domEventData Native DOM event.
     */
    _mouseDownListener(e, t) {
      const i = t.domTarget;
      Ad.isResizeHandle(i) && (this._activeResizer = this._getResizerByHandle(i) || null, this._activeResizer && (this._activeResizer.begin(i), e.stop(), t.preventDefault()));
    }
    /**
     * @param domEventData Native DOM event.
     */
    _mouseMoveListener(e, t) {
      this._activeResizer && this._activeResizer.updateSize(t);
    }
    _mouseUpListener() {
      this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  /* istanbul ignore file -- @preserve */
  const zr = dn("px");
  class NI extends T {
    /**
     * @inheritDoc
     */
    constructor() {
      super();
      const e = this.bindTemplate;
      this.set({
        isVisible: !1,
        left: null,
        top: null,
        width: null
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-clipboard-drop-target-line",
            e.if("isVisible", "ck-hidden", (t) => !t)
          ],
          style: {
            left: e.to("left", (t) => zr(t)),
            top: e.to("top", (t) => zr(t)),
            width: e.to("width", (t) => zr(t))
          }
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Hs extends w {
    constructor() {
      super(...arguments), this.removeDropMarkerDelayed = dl(() => this.removeDropMarker(), 40), this._updateDropMarkerThrottled = Zi((e) => this._updateDropMarker(e), 40), this._reconvertMarkerThrottled = Zi(() => {
        this.editor.model.markers.has("drop-target") && this.editor.editing.reconvertMarker("drop-target");
      }, 0), this._dropTargetLineView = new NI(), this._domEmitter = new (Me())(), this._scrollables = /* @__PURE__ */ new Map();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "DragDropTarget";
    }
    /**
     * @inheritDoc
     */
    init() {
      this._setupDropMarker();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      this._domEmitter.stopListening();
      for (const { resizeObserver: e } of this._scrollables.values())
        e.destroy();
      return this._updateDropMarkerThrottled.cancel(), this.removeDropMarkerDelayed.cancel(), this._reconvertMarkerThrottled.cancel(), super.destroy();
    }
    /**
     * Finds the drop target range and updates the drop marker.
     *
     * @internal
     */
    updateDropMarker(e, t, i, s, o, r) {
      this.removeDropMarkerDelayed.cancel();
      const a = xd(this.editor, e, t, i, s, o, r);
      /* istanbul ignore next -- @preserve */
      if (a) {
        if (r && r.containsRange(a))
          return this.removeDropMarker();
        this._updateDropMarkerThrottled(a);
      }
    }
    /**
     * Finds the final drop target range.
     *
     * @internal
     */
    getFinalDropRange(e, t, i, s, o, r) {
      const a = xd(this.editor, e, t, i, s, o, r);
      return this.removeDropMarker(), a;
    }
    /**
     * Removes the drop target marker.
     *
     * @internal
     */
    removeDropMarker() {
      const e = this.editor.model;
      this.removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), this._dropTargetLineView.isVisible = !1, e.markers.has("drop-target") && e.change((t) => {
        t.removeMarker("drop-target");
      });
    }
    /**
     * Creates downcast conversion for the drop target marker.
     */
    _setupDropMarker() {
      const e = this.editor;
      e.ui.view.body.add(this._dropTargetLineView), e.conversion.for("editingDowncast").markerToHighlight({
        model: "drop-target",
        view: {
          classes: ["ck-clipboard-drop-target-range"]
        }
      }), e.conversion.for("editingDowncast").markerToElement({
        model: "drop-target",
        view: (t, { writer: i }) => {
          if (e.model.schema.checkChild(t.markerRange.start, "$text"))
            return this._dropTargetLineView.isVisible = !1, this._createDropTargetPosition(i);
          t.markerRange.isCollapsed ? this._updateDropTargetLine(t.markerRange) : this._dropTargetLineView.isVisible = !1;
        }
      });
    }
    /**
     * Updates the drop target marker to the provided range.
     *
     * @param targetRange The range to set the marker to.
     */
    _updateDropMarker(e) {
      const t = this.editor, i = t.model.markers;
      t.model.change((s) => {
        i.has("drop-target") ? i.get("drop-target").getRange().isEqual(e) || s.updateMarker("drop-target", { range: e }) : s.addMarker("drop-target", {
          range: e,
          usingOperation: !1,
          affectsData: !1
        });
      });
    }
    /**
     * Creates the UI element for vertical (in-line) drop target.
     */
    _createDropTargetPosition(e) {
      return e.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(t) {
        const i = this.toDomElement(t);
        return i.append("⁠", t.createElement("span"), "⁠"), i;
      });
    }
    /**
     * Updates the horizontal drop target line.
     */
    _updateDropTargetLine(e) {
      const t = this.editor.editing, i = e.start.nodeBefore, s = e.start.nodeAfter, o = e.start.parent, r = i ? t.mapper.toViewElement(i) : null, a = r ? t.view.domConverter.mapViewToDom(r) : null, l = s ? t.mapper.toViewElement(s) : null, c = l ? t.view.domConverter.mapViewToDom(l) : null, u = t.mapper.toViewElement(o);
      if (!u)
        return;
      const d = t.view.domConverter.mapViewToDom(u), h = this._getScrollableRect(u), { scrollX: f, scrollY: m } = E.window, p = a ? new O(a) : null, b = c ? new O(c) : null, v = new O(d).excludeScrollbarsAndBorders(), y = p ? p.bottom : v.top, L = b ? b.top : v.bottom, M = E.window.getComputedStyle(d), D = y <= L ? (y + L) / 2 : L;
      if (h.top < D && D < h.bottom) {
        const A = v.left + parseFloat(M.paddingLeft), R = v.right - parseFloat(M.paddingRight), S = Math.max(A + f, h.left), ee = Math.min(R + f, h.right);
        this._dropTargetLineView.set({
          isVisible: !0,
          left: S,
          top: D + m,
          width: ee - S
        });
      } else
        this._dropTargetLineView.isVisible = !1;
    }
    /**
     * Finds the closest scrollable element rect for the given view element.
     */
    _getScrollableRect(e) {
      const t = e.root.rootName;
      let i;
      if (this._scrollables.has(t))
        i = this._scrollables.get(t).domElement;
      else {
        const s = this.editor.editing.view.domConverter.mapViewToDom(e);
        i = FI(s), this._domEmitter.listenTo(i, "scroll", this._reconvertMarkerThrottled, { usePassive: !0 });
        const o = new Y(i, this._reconvertMarkerThrottled);
        this._scrollables.set(t, {
          domElement: i,
          resizeObserver: o
        });
      }
      return new O(i).excludeScrollbarsAndBorders();
    }
  }
  function xd(n, e, t, i, s, o, r) {
    const a = n.model, l = n.editing.mapper;
    let u = Sd(n, e);
    for (; u; ) {
      if (!o) {
        if (a.schema.checkChild(u, "$text")) {
          if (t) {
            const d = t[0].start, h = l.toModelPosition(d);
            if (!r || Array.from(r.getItems()).every((m) => a.schema.checkChild(h, m))) {
              if (a.schema.checkChild(h, "$text"))
                return a.createRange(h);
              if (d)
                return $s(n, Sd(n, d.parent), i, s);
            }
          }
        } else if (a.schema.isInline(u))
          return $s(n, u, i, s);
      }
      if (a.schema.isBlock(u))
        return $s(n, u, i, s);
      if (a.schema.checkChild(u, "$block")) {
        const d = Array.from(u.getChildren()).filter((m) => m.is("element") && !DI(n, m));
        let h = 0, f = d.length;
        if (f == 0)
          return a.createRange(a.createPositionAt(u, "end"));
        for (; h < f - 1; ) {
          const m = Math.floor((h + f) / 2);
          Qg(n, d[m], i, s) == "before" ? f = m : h = m;
        }
        return $s(n, d[h], i, s);
      }
      u = u.parent;
    }
    return null;
  }
  function DI(n, e) {
    const t = n.editing.mapper, i = n.editing.view.domConverter, s = t.toViewElement(e);
    if (!s)
      return !0;
    const o = i.mapViewToDom(s);
    return E.window.getComputedStyle(o).float != "none";
  }
  function $s(n, e, t, i) {
    const s = n.model;
    return s.createRange(s.createPositionAt(e, Qg(n, e, t, i)));
  }
  function Qg(n, e, t, i) {
    const s = n.editing.mapper, o = n.editing.view.domConverter, r = s.toViewElement(e), a = o.mapViewToDom(r), l = new O(a);
    return n.model.schema.isInline(e) ? t < (l.left + l.right) / 2 ? "before" : "after" : i < (l.top + l.bottom) / 2 ? "before" : "after";
  }
  function Sd(n, e) {
    const t = n.editing.mapper, i = n.editing.view, s = t.toModelElement(e);
    if (s)
      return s;
    const o = i.createPositionBefore(e), r = t.findMappedViewAncestor(o);
    return t.toModelElement(r);
  }
  function FI(n) {
    let e = n;
    do {
      e = e.parentElement;
      const t = E.window.getComputedStyle(e).overflowY;
      if (t == "auto" || t == "scroll")
        break;
    } while (e.tagName != "BODY");
    return e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class zI extends w {
    constructor() {
      super(...arguments), this._isBlockDragging = !1, this._domEmitter = new (Me())();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "DragDropBlockToolbar";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      if (this.listenTo(e, "change:isReadOnly", (t, i, s) => {
        s ? (this.forceDisabled("readOnlyMode"), this._isBlockDragging = !1) : this.clearForceDisabled("readOnlyMode");
      }), B.isAndroid && this.forceDisabled("noAndroidSupport"), e.plugins.has("BlockToolbar")) {
        const i = e.plugins.get("BlockToolbar").buttonView.element;
        this._domEmitter.listenTo(i, "dragstart", (s, o) => this._handleBlockDragStart(o)), this._domEmitter.listenTo(E.document, "dragover", (s, o) => this._handleBlockDragging(o)), this._domEmitter.listenTo(E.document, "drop", (s, o) => this._handleBlockDragging(o)), this._domEmitter.listenTo(E.document, "dragend", () => this._handleBlockDragEnd(), { useCapture: !0 }), this.isEnabled && i.setAttribute("draggable", "true"), this.on("change:isEnabled", (s, o, r) => {
          i.setAttribute("draggable", r ? "true" : "false");
        });
      }
    }
    /**
     * @inheritDoc
     */
    destroy() {
      return this._domEmitter.stopListening(), super.destroy();
    }
    /**
     * The `dragstart` event handler.
     */
    _handleBlockDragStart(e) {
      if (!this.isEnabled)
        return;
      const t = this.editor.model, i = t.document.selection, s = this.editor.editing.view, o = Array.from(i.getSelectedBlocks()), r = t.createRange(t.createPositionBefore(o[0]), t.createPositionAfter(o[o.length - 1]));
      t.change((a) => a.setSelection(r)), this._isBlockDragging = !0, s.focus(), s.getObserver(ls).onDomEvent(e);
    }
    /**
     * The `dragover` and `drop` event handler.
     */
    _handleBlockDragging(e) {
      if (!this.isEnabled || !this._isBlockDragging)
        return;
      const t = e.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100), i = e.clientY, s = document.elementFromPoint(t, i), o = this.editor.editing.view;
      !s || !s.closest(".ck-editor__editable") || o.getObserver(ls).onDomEvent({
        ...e,
        type: e.type,
        dataTransfer: e.dataTransfer,
        target: s,
        clientX: t,
        clientY: i,
        preventDefault: () => e.preventDefault(),
        stopPropagation: () => e.stopPropagation()
      });
    }
    /**
     * The `dragend` event handler.
     */
    _handleBlockDragEnd() {
      this._isBlockDragging = !1;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class UI extends w {
    constructor() {
      super(...arguments), this._clearDraggableAttributesDelayed = dl(() => this._clearDraggableAttributes(), 40), this._blockMode = !1, this._domEmitter = new (Me())();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "DragDrop";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Xe, gn, Hs, zI];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.editing.view;
      this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, t.addObserver(ls), t.addObserver(er), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDraggableAttributeHandling(), this.listenTo(e, "change:isReadOnly", (i, s, o) => {
        o ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
      }), this.on("change:isEnabled", (i, s, o) => {
        o || this._finalizeDragging(!1);
      }), B.isAndroid && this.forceDisabled("noAndroidSupport");
    }
    /**
     * @inheritDoc
     */
    destroy() {
      return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._previewContainer && this._previewContainer.remove(), this._domEmitter.stopListening(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
    }
    /**
     * Drag and drop events handling.
     */
    _setupDragging() {
      const e = this.editor, t = e.model, i = e.editing.view, s = i.document, o = e.plugins.get(Hs);
      this.listenTo(s, "dragstart", (r, a) => {
        if (a.target && a.target.is("editableElement")) {
          a.preventDefault();
          return;
        }
        if (this._prepareDraggedRange(a.target), !this._draggedRange) {
          a.preventDefault();
          return;
        }
        this._draggingUid = Ze(), a.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", a.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
        const l = t.createSelection(this._draggedRange.toRange());
        this.editor.plugins.get("ClipboardPipeline")._fireOutputTransformationEvent(a.dataTransfer, l, "dragstart");
        const { dataTransfer: u, domTarget: d, domEvent: h } = a, { clientX: f } = h;
        this._updatePreview({ dataTransfer: u, domTarget: d, clientX: f }), a.stopPropagation(), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
      }, { priority: "low" }), this.listenTo(s, "dragend", (r, a) => {
        this._finalizeDragging(!a.dataTransfer.isCanceled && a.dataTransfer.dropEffect == "move");
      }, { priority: "low" }), this._domEmitter.listenTo(E.document, "dragend", () => {
        this._blockMode = !1;
      }, { useCapture: !0 }), this.listenTo(s, "dragenter", () => {
        this.isEnabled && i.focus();
      }), this.listenTo(s, "dragleave", () => {
        o.removeDropMarkerDelayed();
      }), this.listenTo(s, "dragging", (r, a) => {
        if (!this.isEnabled) {
          a.dataTransfer.dropEffect = "none";
          return;
        }
        const { clientX: l, clientY: c } = a.domEvent;
        o.updateDropMarker(a.target, a.targetRanges, l, c, this._blockMode, this._draggedRange), this._draggedRange || (a.dataTransfer.dropEffect = "copy"), B.isGecko || (a.dataTransfer.effectAllowed == "copy" ? a.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(a.dataTransfer.effectAllowed) && (a.dataTransfer.dropEffect = "move")), r.stop();
      }, { priority: "low" });
    }
    /**
     * Integration with the `clipboardInput` event.
     */
    _setupClipboardInputIntegration() {
      const e = this.editor, i = e.editing.view.document, s = e.plugins.get(Hs);
      this.listenTo(i, "clipboardInput", (o, r) => {
        if (r.method != "drop")
          return;
        const { clientX: a, clientY: l } = r.domEvent, c = s.getFinalDropRange(r.target, r.targetRanges, a, l, this._blockMode, this._draggedRange);
        if (!c) {
          this._finalizeDragging(!1), o.stop();
          return;
        }
        if (this._draggedRange && this._draggingUid != r.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), Id(r.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(c, !0)) {
          this._finalizeDragging(!1), o.stop();
          return;
        }
        r.targetRanges = [e.editing.mapper.toViewRange(c)];
      }, { priority: "high" });
    }
    /**
     * Integration with the `contentInsertion` event of the clipboard pipeline.
     */
    _setupContentInsertionIntegration() {
      const e = this.editor.plugins.get(Xe);
      e.on("contentInsertion", (t, i) => {
        if (!this.isEnabled || i.method !== "drop")
          return;
        const s = i.targetRanges.map((o) => this.editor.editing.mapper.toModelRange(o));
        this.editor.model.change((o) => o.setSelection(s));
      }, { priority: "high" }), e.on("contentInsertion", (t, i) => {
        if (!this.isEnabled || i.method !== "drop")
          return;
        const s = Id(i.dataTransfer) == "move", o = !i.resultRange || !i.resultRange.isCollapsed;
        this._finalizeDragging(o && s);
      }, { priority: "lowest" });
    }
    /**
     * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
     */
    _setupDraggableAttributeHandling() {
      const e = this.editor, t = e.editing.view, i = t.document;
      this.listenTo(i, "mousedown", (s, o) => {
        if (B.isAndroid || !o)
          return;
        this._clearDraggableAttributesDelayed.cancel();
        let r = Pd(o.target);
        if (B.isBlink && !e.isReadOnly && !r && !i.selection.isCollapsed) {
          const a = i.selection.getSelectedElement();
          (!a || !re(a)) && (r = i.selection.editableElement);
        }
        r && (t.change((a) => {
          a.setAttribute("draggable", "true", r);
        }), this._draggableElement = e.editing.mapper.toModelElement(r));
      }), this.listenTo(i, "mouseup", () => {
        B.isAndroid || this._clearDraggableAttributesDelayed();
      });
    }
    /**
     * Removes the `draggable` attribute from the element that was used for dragging.
     */
    _clearDraggableAttributes() {
      const e = this.editor.editing;
      e.view.change((t) => {
        this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
      });
    }
    /**
     * Deletes the dragged content from its original range and clears the dragging state.
     *
     * @param moved Whether the move succeeded.
     */
    _finalizeDragging(e) {
      const t = this.editor, i = t.model;
      t.plugins.get(Hs).removeDropMarker(), this._clearDraggableAttributes(), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._previewContainer && (this._previewContainer.remove(), this._previewContainer = void 0), this._draggedRange && (e && this.isEnabled && i.change((o) => {
        const r = i.createSelection(this._draggedRange);
        i.deleteContent(r, { doNotAutoparagraph: !0 });
        const a = r.getFirstPosition().parent;
        a.isEmpty && !i.schema.checkChild(a, "$text") && i.schema.checkChild(a, "paragraph") && o.insertElement("paragraph", a, 0);
      }), this._draggedRange.detach(), this._draggedRange = null);
    }
    /**
     * Sets the dragged source range based on event target and document selection.
     */
    _prepareDraggedRange(e) {
      const t = this.editor, i = t.model, s = i.document.selection, o = e ? Pd(e) : null;
      if (o) {
        const c = t.editing.mapper.toModelElement(o);
        this._draggedRange = Pe.fromRange(i.createRangeOn(c)), this._blockMode = i.schema.isBlock(c), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
        return;
      }
      if (s.isCollapsed && !s.getFirstPosition().parent.isEmpty)
        return;
      const r = Array.from(s.getSelectedBlocks()), a = s.getFirstRange();
      if (r.length == 0) {
        this._draggedRange = Pe.fromRange(a);
        return;
      }
      const l = ep(i, r);
      if (r.length > 1)
        this._draggedRange = Pe.fromRange(l), this._blockMode = !0;
      else if (r.length == 1) {
        const c = a.start.isTouching(l.start) && a.end.isTouching(l.end);
        this._draggedRange = Pe.fromRange(c ? l : a), this._blockMode = c;
      }
      i.change((c) => c.setSelection(this._draggedRange.toRange()));
    }
    /**
     * Updates the dragged preview image.
     */
    _updatePreview({ dataTransfer: e, domTarget: t, clientX: i }) {
      const s = this.editor.editing.view, o = s.document.selection.editableElement, r = s.domConverter.mapViewToDom(o), a = E.window.getComputedStyle(r);
      this._previewContainer ? this._previewContainer.firstElementChild && this._previewContainer.removeChild(this._previewContainer.firstElementChild) : (this._previewContainer = tt(E.document, "div", {
        style: "position: fixed; left: -999999px;"
      }), E.document.body.appendChild(this._previewContainer));
      const l = new O(r);
      if (r.contains(t))
        return;
      const c = parseFloat(a.paddingLeft), u = tt(E.document, "div");
      u.className = "ck ck-content", u.style.width = a.width, u.style.paddingLeft = `${l.left - i + c}px`, B.isiOS && (u.style.backgroundColor = "white"), u.innerHTML = e.getData("text/html"), e.setDragImage(u, 0, 0), this._previewContainer.appendChild(u);
    }
  }
  function Id(n) {
    return B.isGecko ? n.dropEffect : ["all", "copyMove"].includes(n.effectAllowed) ? "move" : "copy";
  }
  function Pd(n) {
    if (n.is("editableElement"))
      return null;
    if (n.hasClass("ck-widget__selection-handle"))
      return n.findAncestor(re);
    if (re(n))
      return n;
    const e = n.findAncestor((t) => re(t) || t.is("editableElement"));
    return re(e) ? e : null;
  }
  function ep(n, e) {
    const t = e[0], i = e[e.length - 1], s = t.getCommonAncestor(i), o = n.createPositionBefore(t), r = n.createPositionAfter(i);
    if (s && s.is("element") && !n.schema.isLimit(s)) {
      const a = n.createRangeOn(s), l = o.isTouching(a.start), c = r.isTouching(a.end);
      if (l && c)
        return ep(n, [s]);
    }
    return n.createRange(o, r);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class HI extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "PastePlainText";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Xe];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model, i = e.editing.view, s = i.document, o = t.document.selection;
      let r = !1;
      i.addObserver(ls), this.listenTo(s, "keydown", (a, l) => {
        r = l.shiftKey;
      }), e.plugins.get(Xe).on("contentInsertion", (a, l) => {
        !r && !$I(l.content, t.schema) || t.change((c) => {
          const u = Array.from(o.getAttributes()).filter(([h]) => t.schema.getAttributeProperties(h).isFormatting);
          o.isCollapsed || t.deleteContent(o, { doNotAutoparagraph: !0 }), u.push(...o.getAttributes());
          const d = c.createRangeIn(l.content);
          for (const h of d.getItems())
            h.is("$textProxy") && c.setAttributes(u, h);
        });
      });
    }
  }
  function $I(n, e) {
    if (n.childCount > 1)
      return !1;
    const t = n.getChild(0);
    return e.isObject(t) ? !1 : Array.from(t.getAttributeKeys()).length == 0;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ol extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Clipboard";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Hn, Xe, UI, HI];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.t;
      e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Copy selected content"),
            keystroke: "CTRL+C"
          },
          {
            label: t("Paste content"),
            keystroke: "CTRL+V"
          },
          {
            label: t("Paste content as plain text"),
            keystroke: "CTRL+SHIFT+V"
          }
        ]
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class WI extends V {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.affectsData = !1;
    }
    /**
     * @inheritDoc
     */
    execute() {
      const e = this.editor.model, t = e.document.selection;
      let i = e.schema.getLimitElement(t);
      if (t.containsEntireContent(i) || !Rd(e.schema, i))
        do
          if (i = i.parent, !i)
            return;
        while (!Rd(e.schema, i));
      e.change((s) => {
        s.setSelection(i, "in");
      });
    }
  }
  function Rd(n, e) {
    return n.isLimit(e) && (n.checkChild(e, "$text") || n.checkChild(e, "paragraph"));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const qI = gs("Ctrl+A");
  class GI extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SelectAllEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t, s = e.editing.view.document;
      e.commands.add("selectAll", new WI(e)), this.listenTo(s, "keydown", (o, r) => {
        Ji(r) === qI && (e.execute("selectAll"), r.preventDefault());
      }), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Select all"),
            keystroke: "CTRL+A"
          }
        ]
      });
    }
  }
  const jI = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class KI extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SelectAllUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.ui.componentFactory.add("selectAll", () => {
        const t = this._createButton(P);
        return t.set({
          tooltip: !0
        }), t;
      }), e.ui.componentFactory.add("menuBar:selectAll", () => this._createButton(de));
    }
    /**
     * Creates a button for select all command to use either in toolbar or in menu bar.
     */
    _createButton(e) {
      const t = this.editor, i = t.locale, s = t.commands.get("selectAll"), o = new e(t.locale), r = i.t;
      return o.set({
        label: r("Select all"),
        icon: jI,
        keystroke: "Ctrl+A"
      }), o.bind("isEnabled").to(s, "isEnabled"), this.listenTo(o, "execute", () => {
        t.execute("selectAll"), t.editing.view.focus();
      }), o;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ZI extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [GI, KI];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SelectAll";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class tp extends V {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(e.data, "set", (t, i) => {
        i[1] = { ...i[1] };
        const s = i[1];
        s.batchType || (s.batchType = { isUndoable: !1 });
      }, { priority: "high" }), this.listenTo(e.data, "set", (t, i) => {
        i[1].batchType.isUndoable || this.clearStack();
      });
    }
    /**
     * @inheritDoc
     */
    refresh() {
      this.isEnabled = this._stack.length > 0;
    }
    /**
     * Returns all batches created by this command.
     */
    get createdBatches() {
      return this._createdBatches;
    }
    /**
     * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
     * created by the editor which this command is registered to.
     *
     * @param batch The batch to add.
     */
    addBatch(e) {
      const t = this.editor.model.document.selection, i = {
        ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [],
        isBackward: t.isBackward
      };
      this._stack.push({ batch: e, selection: i }), this.refresh();
    }
    /**
     * Removes all items from the stack.
     */
    clearStack() {
      this._stack = [], this.refresh();
    }
    /**
     * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
     *
     * @param ranges Ranges to be restored.
     * @param isBackward A flag describing whether the restored range was selected forward or backward.
     * @param operations Operations which has been applied since selection has been stored.
     */
    _restoreSelection(e, t, i) {
      const s = this.editor.model, o = s.document, r = [], a = e.map((c) => c.getTransformedByOperations(i)), l = a.flat();
      for (const c of a) {
        const u = c.filter((d) => d.root != o.graveyard).filter((d) => !XI(d, l));
        u.length && (JI(u), r.push(u[0]));
      }
      r.length && s.change((c) => {
        c.setSelection(r, { backward: t });
      });
    }
    /**
     * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
     * This is a helper method for {@link #execute}.
     *
     * @param batchToUndo The batch to be undone.
     * @param undoingBatch The batch that will contain undoing changes.
     */
    _undo(e, t) {
      const i = this.editor.model, s = i.document;
      this._createdBatches.add(t);
      const o = e.operations.slice().filter((r) => r.isDocumentOperation);
      o.reverse();
      for (const r of o) {
        const a = r.baseVersion + 1, l = Array.from(s.history.getOperations(a)), u = E2([r.getReversed()], l, {
          useRelations: !0,
          document: this.editor.model.document,
          padWithNoOps: !1,
          forceWeakRemove: !0
        }).operationsA;
        for (let d of u) {
          const h = d.affectedSelectable;
          h && !i.canEditAt(h) && (d = new ue(d.baseVersion)), t.addOperation(d), i.applyOperation(d), s.history.setOperationAsUndone(r, d);
        }
      }
    }
  }
  function JI(n) {
    n.sort((e, t) => e.start.isBefore(t.start) ? -1 : 1);
    for (let e = 1; e < n.length; e++) {
      const i = n[e - 1].getJoined(n[e], !0);
      i && (e--, n.splice(e, 2, i));
    }
  }
  function XI(n, e) {
    return e.some((t) => t !== n && t.containsRange(n, !0));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class YI extends tp {
    /**
     * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
     * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
     * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
     *
     * @fires execute
     * @fires revert
     * @param batch A batch that should be undone. If not set, the last added batch will be undone.
     */
    execute(e = null) {
      const t = e ? this._stack.findIndex((o) => o.batch == e) : this._stack.length - 1, i = this._stack.splice(t, 1)[0], s = this.editor.model.createBatch({ isUndo: !0 });
      this.editor.model.enqueueChange(s, () => {
        this._undo(i.batch, s);
        const o = this.editor.model.document.history.getOperations(i.batch.baseVersion);
        this._restoreSelection(i.selection.ranges, i.selection.isBackward, o);
      }), this.fire("revert", i.batch, s), this.refresh();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class QI extends tp {
    /**
     * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
     * the command's stack, applies the reverted and transformed version on the
     * {@link module:engine/model/document~Document document} and removes the batch from the stack.
     * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
     *
     * @fires execute
     */
    execute() {
      const e = this._stack.pop(), t = this.editor.model.createBatch({ isUndo: !0 });
      this.editor.model.enqueueChange(t, () => {
        const s = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1, o = this.editor.model.document.history.getOperations(s);
        this._restoreSelection(e.selection.ranges, e.selection.isBackward, o), this._undo(e.batch, t);
      }), this.refresh();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class eP extends w {
    constructor() {
      super(...arguments), this._batchRegistry = /* @__PURE__ */ new WeakSet();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "UndoEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t;
      this._undoCommand = new YI(e), this._redoCommand = new QI(e), e.commands.add("undo", this._undoCommand), e.commands.add("redo", this._redoCommand), this.listenTo(e.model, "applyOperation", (i, s) => {
        const o = s[0];
        if (!o.isDocumentOperation)
          return;
        const r = o.batch, a = this._redoCommand.createdBatches.has(r), l = this._undoCommand.createdBatches.has(r);
        this._batchRegistry.has(r) || (this._batchRegistry.add(r), r.isUndoable && (a ? this._undoCommand.addBatch(r) : l || (this._undoCommand.addBatch(r), this._redoCommand.clearStack())));
      }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (i, s, o) => {
        this._redoCommand.addBatch(o);
      }), e.keystrokes.set("CTRL+Z", "undo"), e.keystrokes.set("CTRL+Y", "redo"), e.keystrokes.set("CTRL+SHIFT+Z", "redo"), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Undo"),
            keystroke: "CTRL+Z"
          },
          {
            label: t("Redo"),
            keystroke: [["CTRL+Y"], ["CTRL+SHIFT+Z"]]
          }
        ]
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class tP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "UndoUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale, i = e.t, s = t.uiLanguageDirection == "ltr" ? x.undo : x.redo, o = t.uiLanguageDirection == "ltr" ? x.redo : x.undo;
      this._addButtonsToFactory("undo", i("Undo"), "CTRL+Z", s), this._addButtonsToFactory("redo", i("Redo"), "CTRL+Y", o);
    }
    /**
     * Creates a button for the specified command.
     *
     * @param name Command name.
     * @param label Button label.
     * @param keystroke Command keystroke.
     * @param Icon Source of the icon.
     */
    _addButtonsToFactory(e, t, i, s) {
      const o = this.editor;
      o.ui.componentFactory.add(e, () => {
        const r = this._createButton(P, e, t, i, s);
        return r.set({
          tooltip: !0
        }), r;
      }), o.ui.componentFactory.add("menuBar:" + e, () => this._createButton(de, e, t, i, s));
    }
    /**
     * TODO
     */
    _createButton(e, t, i, s, o) {
      const r = this.editor, a = r.locale, l = r.commands.get(t), c = new e(a);
      return c.set({
        label: i,
        icon: o,
        keystroke: s
      }), c.bind("isEnabled").to(l, "isEnabled"), this.listenTo(c, "execute", () => {
        r.execute(t), r.editing.view.focus();
      }), c;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Nl extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [eP, tP];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Undo";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class iP extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [fA, Ol, lr, ZI, XS, Wg, Nl];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Essentials";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class nP extends V {
    constructor(e) {
      super(e), this._isEnabledBasedOnSelection = !1;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = e.document, i = me(t.selection.getSelectedBlocks());
      this.value = !!i && i.is("element", "paragraph"), this.isEnabled = !!i && Ld(i, e.schema);
    }
    /**
     * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection
     * will be turned to paragraphs.
     *
     * @fires execute
     * @param options Options for the executed command.
     * @param options.selection The selection that the command should be applied to. By default,
     * if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.
     */
    execute(e = {}) {
      const t = this.editor.model, i = t.document, s = e.selection || i.selection;
      t.canEditAt(s) && t.change((o) => {
        const r = s.getSelectedBlocks();
        for (const a of r)
          !a.is("element", "paragraph") && Ld(a, t.schema) && o.rename(a, "paragraph");
      });
    }
  }
  function Ld(n, e) {
    return e.checkChild(n.parent, "paragraph") && !e.isObject(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class sP extends V {
    constructor(e) {
      super(e), this._isEnabledBasedOnSelection = !1;
    }
    /**
     * Executes the command.
     *
     * @param options Options for the executed command.
     * @param options.position The model position at which the new paragraph will be inserted.
     * @param options.attributes Attributes keys and values to set on a inserted paragraph.
     * @fires execute
     */
    execute(e) {
      const t = this.editor.model, i = e.attributes;
      let s = e.position;
      t.canEditAt(s) && t.change((o) => {
        if (s = this._findPositionToInsertParagraph(s, o), !s)
          return;
        const r = o.createElement("paragraph");
        i && t.schema.setAllowedAttributes(r, i, o), t.insertContent(r, s), o.setSelection(r, "in");
      });
    }
    /**
     * Returns the best position to insert a new paragraph.
     */
    _findPositionToInsertParagraph(e, t) {
      const i = this.editor.model;
      if (i.schema.checkChild(e, "paragraph"))
        return e;
      const s = i.schema.findAllowedParent(e, "paragraph");
      if (!s)
        return null;
      const o = e.parent, r = i.schema.checkChild(o, "$text");
      return o.isEmpty || r && e.isAtEnd ? i.createPositionAfter(o) : !o.isEmpty && r && e.isAtStart ? i.createPositionBefore(o) : t.split(e, s).position;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class _s extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Paragraph";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model;
      e.commands.add("paragraph", new nP(e)), e.commands.add("insertParagraph", new sP(e)), t.schema.register("paragraph", { inheritAllFrom: "$block" }), e.conversion.elementToElement({ model: "paragraph", view: "p" }), e.conversion.for("upcast").elementToElement({
        model: (i, { writer: s }) => !_s.paragraphLikeElements.has(i.name) || i.isEmpty ? null : s.createElement("paragraph"),
        view: /.+/,
        converterPriority: "low"
      });
    }
  }
  _s.paragraphLikeElements = /* @__PURE__ */ new Set([
    "blockquote",
    "dd",
    "div",
    "dt",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "li",
    "p",
    "td",
    "th"
  ]);
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Dl = ["left", "right", "center", "justify"];
  function ip(n) {
    return Dl.includes(n);
  }
  function np(n, e) {
    return e.contentLanguageDirection == "rtl" ? n === "right" : n === "left";
  }
  function sp(n) {
    const e = n.map((i) => {
      let s;
      return typeof i == "string" ? s = { name: i } : s = i, s;
    }).filter((i) => {
      const s = Dl.includes(i.name);
      return s || z("alignment-config-name-not-recognized", { option: i }), s;
    }), t = e.filter((i) => !!i.className).length;
    if (t && t < e.length)
      throw new g("alignment-config-classnames-are-missing", { configuredOptions: n });
    return e.forEach((i, s, o) => {
      const r = o.slice(s + 1);
      if (r.some((l) => l.name == i.name))
        throw new g("alignment-config-name-already-defined", { option: i, configuredOptions: n });
      if (i.className && r.some((c) => c.className == i.className))
        throw new g("alignment-config-classname-already-defined", { option: i, configuredOptions: n });
    }), e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Fl = "alignment";
  class oP extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const t = this.editor.locale, i = me(this.editor.model.document.selection.getSelectedBlocks());
      this.isEnabled = !!i && this._canBeAligned(i), this.isEnabled && i.hasAttribute("alignment") ? this.value = i.getAttribute("alignment") : this.value = t.contentLanguageDirection === "rtl" ? "right" : "left";
    }
    /**
     * Executes the command. Applies the alignment `value` to the selected blocks.
     * If no `value` is passed, the `value` is the default one or it is equal to the currently selected block's alignment attribute,
     * the command will remove the attribute from the selected blocks.
     *
     * @param options Options for the executed command.
     * @param options.value The value to apply.
     * @fires execute
     */
    execute(e = {}) {
      const t = this.editor, i = t.locale, s = t.model, o = s.document, r = e.value;
      s.change((a) => {
        const l = Array.from(o.selection.getSelectedBlocks()).filter((d) => this._canBeAligned(d)), c = l[0].getAttribute("alignment");
        np(r, i) || c === r || !r ? rP(l, a) : aP(l, a, r);
      });
    }
    /**
     * Checks whether a block can have alignment set.
     *
     * @param block The block to be checked.
     */
    _canBeAligned(e) {
      return this.editor.model.schema.checkAttribute(e, Fl);
    }
  }
  function rP(n, e) {
    for (const t of n)
      e.removeAttribute(Fl, t);
  }
  function aP(n, e, t) {
    for (const i of n)
      e.setAttribute(Fl, t, i);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class lP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "AlignmentEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("alignment", {
        options: Dl.map((t) => ({ name: t }))
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale, i = e.model.schema, o = sp(e.config.get("alignment.options")).filter((c) => ip(c.name) && !np(c.name, t)), r = o.some((c) => !!c.className);
      i.extend("$block", { allowAttributes: "alignment" }), e.model.schema.setAttributeProperties("alignment", { isFormatting: !0 }), r ? e.conversion.attributeToAttribute(hP(o)) : e.conversion.for("downcast").attributeToAttribute(cP(o));
      const a = uP(o);
      for (const c of a)
        e.conversion.for("upcast").attributeToAttribute(c);
      const l = dP(o);
      for (const c of l)
        e.conversion.for("upcast").attributeToAttribute(c);
      e.commands.add("alignment", new oP(e));
    }
  }
  function cP(n) {
    const e = {};
    for (const { name: i } of n)
      e[i] = {
        key: "style",
        value: {
          "text-align": i
        }
      };
    return {
      model: {
        key: "alignment",
        values: n.map((i) => i.name)
      },
      view: e
    };
  }
  function uP(n) {
    const e = [];
    for (const { name: t } of n)
      e.push({
        view: {
          key: "style",
          value: {
            "text-align": t
          }
        },
        model: {
          key: "alignment",
          value: t
        }
      });
    return e;
  }
  function dP(n) {
    const e = [];
    for (const { name: t } of n)
      e.push({
        view: {
          key: "align",
          value: t
        },
        model: {
          key: "alignment",
          value: t
        }
      });
    return e;
  }
  function hP(n) {
    const e = {};
    for (const i of n)
      e[i.name] = {
        key: "class",
        value: i.className
      };
    return {
      model: {
        key: "alignment",
        values: n.map((i) => i.name)
      },
      view: e
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Tn = /* @__PURE__ */ new Map([
    ["left", x.alignLeft],
    ["right", x.alignRight],
    ["center", x.alignCenter],
    ["justify", x.alignJustify]
  ]);
  class fP extends w {
    /**
     * Returns the localized option titles provided by the plugin.
     *
     * The following localized titles corresponding with
     * {@link module:alignment/alignmentconfig~AlignmentConfig#options} are available:
     *
     * * `'left'`,
     * * `'right'`,
     * * `'center'`,
     * * `'justify'`.
     *
     * @readonly
     */
    get localizedOptionTitles() {
      const e = this.editor.t;
      return {
        left: e("Align left"),
        right: e("Align right"),
        center: e("Align center"),
        justify: e("Justify")
      };
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "AlignmentUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = sp(e.config.get("alignment.options"));
      t.map((i) => i.name).filter(ip).forEach((i) => this._addButton(i)), this._addToolbarDropdown(t), this._addMenuBarMenu(t);
    }
    /**
     * Helper method for initializing the button and linking it with an appropriate command.
     *
     * @param option The name of the alignment option for which the button is added.
     */
    _addButton(e) {
      this.editor.ui.componentFactory.add(`alignment:${e}`, (i) => this._createButton(i, e));
    }
    /**
     * Helper method for creating the button view element.
     *
     * @param locale Editor locale.
     * @param option The name of the alignment option for which the button is added.
     * @param buttonAttrs Optional parameters passed to button view instance.
     */
    _createButton(e, t, i = {}) {
      const s = this.editor, o = s.commands.get("alignment"), r = new P(e);
      return r.set({
        label: this.localizedOptionTitles[t],
        icon: Tn.get(t),
        tooltip: !0,
        isToggleable: !0,
        ...i
      }), r.bind("isEnabled").to(o), r.bind("isOn").to(o, "value", (a) => a === t), this.listenTo(r, "execute", () => {
        s.execute("alignment", { value: t }), s.editing.view.focus();
      }), r;
    }
    /**
     * Helper method for initializing the toolnar dropdown and linking it with an appropriate command.
     *
     * @param option The name of the alignment option for which the button is added.
     */
    _addToolbarDropdown(e) {
      const t = this.editor;
      t.ui.componentFactory.add("alignment", (s) => {
        const o = we(s), r = s.uiLanguageDirection === "rtl" ? "w" : "e", a = s.t;
        or(o, () => e.map((u) => this._createButton(s, u.name, { tooltipPosition: r })), {
          enableActiveItemFocusOnDropdownOpen: !0,
          isVertical: !0,
          ariaLabel: a("Text alignment toolbar")
        }), o.buttonView.set({
          label: a("Text alignment"),
          tooltip: !0
        }), o.extendTemplate({
          attributes: {
            class: "ck-alignment-dropdown"
          }
        });
        const l = s.contentLanguageDirection === "rtl" ? Tn.get("right") : Tn.get("left"), c = t.commands.get("alignment");
        return o.buttonView.bind("icon").to(c, "value", (u) => Tn.get(u) || l), o.bind("isEnabled").to(c, "isEnabled"), this.listenTo(o, "execute", () => {
          t.editing.view.focus();
        }), o;
      });
    }
    /**
     * Creates a menu for all alignment options to use either in menu bar.
     *
     * @param options Normalized alignment options from config.
     */
    _addMenuBarMenu(e) {
      const t = this.editor;
      t.ui.componentFactory.add("menuBar:alignment", (i) => {
        const s = t.commands.get("alignment"), o = i.t, r = new Ke(i), a = new sn(i);
        r.bind("isEnabled").to(s), a.set({
          ariaLabel: o("Text alignment"),
          role: "menu"
        }), r.buttonView.set({
          label: o("Text alignment")
        });
        for (const l of e) {
          const c = new fn(i, r), u = new de(i);
          u.extendTemplate({
            attributes: {
              "aria-checked": u.bindTemplate.to("isOn")
            }
          }), u.delegate("execute").to(r), u.set({
            label: this.localizedOptionTitles[l.name],
            icon: Tn.get(l.name)
          }), u.on("execute", () => {
            t.execute("alignment", { value: l.name }), t.editing.view.focus();
          }), u.bind("isOn").to(s, "value", (d) => d === l.name), u.bind("isEnabled").to(s, "isEnabled"), c.children.add(u), a.items.add(c);
        }
        return r.panelView.children.add(a), r;
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class mP extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [lP, fP];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Alignment";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ur extends V {
    /**
     * Creates an instance of the command.
     *
     * @param editor Editor instance.
     * @param attributeKey The name of a model attribute on which this command operates.
     */
    constructor(e, t) {
      super(e), this.attributeKey = t;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = e.document;
      this.value = t.selection.getAttribute(this.attributeKey), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey);
    }
    /**
     * Executes the command. Applies the `value` of the {@link #attributeKey} to the selection.
     * If no `value` is passed, it removes the attribute from the selection.
     *
     * @param options Options for the executed command.
     * @param options.value The value to apply.
     * @fires execute
     */
    execute(e = {}) {
      const t = this.editor.model, s = t.document.selection, o = e.value, r = e.batch, a = (l) => {
        if (s.isCollapsed)
          o ? l.setSelectionAttribute(this.attributeKey, o) : l.removeSelectionAttribute(this.attributeKey);
        else {
          const c = t.schema.getValidRanges(s.getRanges(), this.attributeKey);
          for (const u of c)
            o ? l.setAttribute(this.attributeKey, o, u) : l.removeAttribute(this.attributeKey, u);
        }
      };
      r ? t.enqueueChange(r, (l) => {
        a(l);
      }) : t.change((l) => {
        a(l);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const xe = "fontSize", Se = "fontFamily", mt = "fontColor", At = "fontBackgroundColor";
  function op(n, e) {
    const t = {
      model: {
        key: n,
        values: []
      },
      view: {},
      upcastAlso: {}
    };
    for (const i of e)
      t.model.values.push(i.model), t.view[i.model] = i.view, i.upcastAlso && (t.upcastAlso[i.model] = i.upcastAlso);
    return t;
  }
  function rp(n) {
    return (e) => pP(e.getStyle(n));
  }
  function ap(n) {
    return (e, { writer: t }) => t.createAttributeElement("span", {
      style: `${n}:${e}`
    }, { priority: 7 });
  }
  function gP({ dropdownView: n, colors: e, columns: t, removeButtonLabel: i, colorPickerLabel: s, documentColorsLabel: o, documentColorsCount: r, colorPickerViewConfig: a }) {
    const l = n.locale, c = new Vl(l, {
      colors: e,
      columns: t,
      removeButtonLabel: i,
      colorPickerLabel: s,
      documentColorsLabel: o,
      documentColorsCount: r,
      colorPickerViewConfig: a
    });
    return n.colorSelectorView = c, n.panelView.children.add(c), c;
  }
  function pP(n) {
    return n.replace(/\s/g, "");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class wP extends ur {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e, Se);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function lp(n) {
    return n.map(bP).filter((e) => e !== void 0);
  }
  function bP(n) {
    if (typeof n == "object")
      return n;
    if (n === "default")
      return {
        title: "Default",
        model: void 0
      };
    if (typeof n == "string")
      return _P(n);
  }
  function _P(n) {
    const e = n.replace(/"|'/g, "").split(","), t = e[0], i = e.map(vP).join(", ");
    return {
      title: t,
      model: i,
      view: {
        name: "span",
        styles: {
          "font-family": i
        },
        priority: 7
      }
    };
  }
  function vP(n) {
    return n = n.trim(), n.indexOf(" ") > 0 && (n = `'${n}'`), n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class yP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontFamilyEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define(Se, {
        options: [
          "default",
          "Arial, Helvetica, sans-serif",
          "Courier New, Courier, monospace",
          "Georgia, serif",
          "Lucida Sans Unicode, Lucida Grande, sans-serif",
          "Tahoma, Geneva, sans-serif",
          "Times New Roman, Times, serif",
          "Trebuchet MS, Helvetica, sans-serif",
          "Verdana, Geneva, sans-serif"
        ],
        supportAllValues: !1
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.model.schema.extend("$text", { allowAttributes: Se }), e.model.schema.setAttributeProperties(Se, {
        isFormatting: !0,
        copyOnEnter: !0
      });
      const t = lp(e.config.get("fontFamily.options")).filter((s) => s.model), i = op(Se, t);
      e.config.get("fontFamily.supportAllValues") ? (this._prepareAnyValueConverters(), this._prepareCompatibilityConverter()) : e.conversion.attributeToElement(i), e.commands.add(Se, new wP(e));
    }
    /**
     * These converters enable keeping any value found as `style="font-family: *"` as a value of an attribute on a text even
     * if it is not defined in the plugin configuration.
     */
    _prepareAnyValueConverters() {
      const e = this.editor;
      e.conversion.for("downcast").attributeToElement({
        model: Se,
        view: (t, { writer: i }) => i.createAttributeElement("span", { style: "font-family:" + t }, { priority: 7 })
      }), e.conversion.for("upcast").elementToAttribute({
        model: {
          key: Se,
          value: (t) => t.getStyle("font-family")
        },
        view: {
          name: "span",
          styles: {
            "font-family": /.*/
          }
        }
      });
    }
    /**
     * Adds support for legacy `<font face="..">` formatting.
     */
    _prepareCompatibilityConverter() {
      this.editor.conversion.for("upcast").elementToAttribute({
        view: {
          name: "font",
          attributes: {
            face: /.*/
          }
        },
        model: {
          key: Se,
          value: (t) => t.getAttribute("face")
        }
      });
    }
  }
  const Vd = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class CP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontFamilyUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t, i = this._getLocalizedOptions(), s = e.commands.get(Se), o = t("Font Family"), r = kP(i, s);
      e.ui.componentFactory.add(Se, (a) => {
        const l = we(a);
        return Kt(l, r, {
          role: "menu",
          ariaLabel: o
        }), l.buttonView.set({
          label: o,
          icon: Vd,
          tooltip: !0
        }), l.extendTemplate({
          attributes: {
            class: "ck-font-family-dropdown"
          }
        }), l.bind("isEnabled").to(s), this.listenTo(l, "execute", (c) => {
          e.execute(c.source.commandName, { value: c.source.commandParam }), e.editing.view.focus();
        }), l;
      }), e.ui.componentFactory.add(`menuBar:${Se}`, (a) => {
        const l = new Ke(a);
        l.buttonView.set({
          label: o,
          icon: Vd
        }), l.bind("isEnabled").to(s);
        const c = new sn(a);
        for (const u of r) {
          const d = new fn(a, l), h = new de(a);
          h.bind(...Object.keys(u.model)).to(u.model), h.bind("ariaChecked").to(h, "isOn"), h.delegate("execute").to(l), h.on("execute", () => {
            e.execute(u.model.commandName, {
              value: u.model.commandParam
            }), e.editing.view.focus();
          }), d.children.add(h), c.items.add(d);
        }
        return l.panelView.children.add(c), l;
      });
    }
    /**
     * Returns options as defined in `config.fontFamily.options` but processed to account for
     * editor localization, i.e. to display {@link module:font/fontconfig~FontFamilyOption}
     * in the correct language.
     *
     * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
     * when the user configuration is defined because the editor does not exist yet.
     */
    _getLocalizedOptions() {
      const e = this.editor, t = e.t;
      return lp(e.config.get(Se).options).map((s) => (s.title === "Default" && (s.title = t("Default")), s));
    }
  }
  function kP(n, e) {
    const t = new Ce();
    for (const i of n) {
      const s = {
        type: "button",
        model: new yi({
          commandName: Se,
          commandParam: i.model,
          label: i.title,
          role: "menuitemradio",
          withText: !0
        })
      };
      s.model.bind("isOn").to(e, "value", (o) => o === i.model ? !0 : !o || !i.model ? !1 : o.split(",")[0].replace(/'/g, "").toLowerCase() === i.model.toLowerCase()), i.view && typeof i.view != "string" && i.view.styles && s.model.set("labelStyle", `font-family: ${i.view.styles["font-family"]}`), t.add(s);
    }
    return t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class cp extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [yP, CP];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontFamily";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class TP extends ur {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e, xe);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function zl(n) {
    return n.map((e) => EP(e)).filter((e) => e !== void 0);
  }
  const Md = {
    get tiny() {
      return {
        title: "Tiny",
        model: "tiny",
        view: {
          name: "span",
          classes: "text-tiny",
          priority: 7
        }
      };
    },
    get small() {
      return {
        title: "Small",
        model: "small",
        view: {
          name: "span",
          classes: "text-small",
          priority: 7
        }
      };
    },
    get big() {
      return {
        title: "Big",
        model: "big",
        view: {
          name: "span",
          classes: "text-big",
          priority: 7
        }
      };
    },
    get huge() {
      return {
        title: "Huge",
        model: "huge",
        view: {
          name: "span",
          classes: "text-huge",
          priority: 7
        }
      };
    }
  };
  function EP(n) {
    if (typeof n == "number" && (n = String(n)), typeof n == "object" && SP(n))
      return Ea(n);
    const e = xP(n);
    if (e)
      return Ea(e);
    if (n === "default")
      return {
        model: void 0,
        title: "Default"
      };
    if (!IP(n))
      return AP(n);
  }
  function AP(n) {
    return typeof n == "string" && (n = {
      title: n,
      model: `${parseFloat(n)}px`
    }), n.view = {
      name: "span",
      styles: {
        "font-size": n.model
      }
    }, Ea(n);
  }
  function Ea(n) {
    return n.view && typeof n.view != "string" && !n.view.priority && (n.view.priority = 7), n;
  }
  function xP(n) {
    return typeof n == "string" ? Md[n] : Md[n.model];
  }
  function SP(n) {
    return n.title && n.model && n.view;
  }
  function IP(n) {
    let e;
    if (typeof n == "object")
      if (n.model)
        e = parseFloat(n.model);
      else
        throw new g("font-size-invalid-definition", null, n);
    else
      e = parseFloat(n);
    return isNaN(e);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Bd = [
    "x-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "xx-large",
    "xxx-large"
  ];
  class PP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontSizeEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define(xe, {
        options: [
          "tiny",
          "small",
          "default",
          "big",
          "huge"
        ],
        supportAllValues: !1
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.model.schema.extend("$text", { allowAttributes: xe }), e.model.schema.setAttributeProperties(xe, {
        isFormatting: !0,
        copyOnEnter: !0
      });
      const t = e.config.get("fontSize.supportAllValues"), i = zl(this.editor.config.get("fontSize.options")).filter((o) => o.model), s = op(xe, i);
      t ? (this._prepareAnyValueConverters(s), this._prepareCompatibilityConverter()) : e.conversion.attributeToElement(s), e.commands.add(xe, new TP(e));
    }
    /**
     * These converters enable keeping any value found as `style="font-size: *"` as a value of an attribute on a text even
     * if it is not defined in the plugin configuration.
     *
     * @param definition Converter definition out of input data.
     */
    _prepareAnyValueConverters(e) {
      const t = this.editor, i = e.model.values.filter((s) => !tr(String(s)) && !eg(String(s)));
      if (i.length)
        throw new g("font-size-invalid-use-of-named-presets", null, { presets: i });
      t.conversion.for("downcast").attributeToElement({
        model: xe,
        view: (s, { writer: o }) => {
          if (s)
            return o.createAttributeElement("span", { style: "font-size:" + s }, { priority: 7 });
        }
      }), t.conversion.for("upcast").elementToAttribute({
        model: {
          key: xe,
          value: (s) => s.getStyle("font-size")
        },
        view: {
          name: "span",
          styles: {
            "font-size": /.*/
          }
        }
      });
    }
    /**
     * Adds support for legacy `<font size="..">` formatting.
     */
    _prepareCompatibilityConverter() {
      this.editor.conversion.for("upcast").elementToAttribute({
        view: {
          name: "font",
          attributes: {
            // Documentation mentions sizes from 1 to 7. To handle old content we support all values
            // up to 999 but clamp it to the valid range. Why 999? It should cover accidental values
            // similar to percentage, e.g. 100%, 200% which could be the usual mistake for font size.
            size: /^[+-]?\d{1,3}$/
          }
        },
        model: {
          key: xe,
          value: (t) => {
            const i = t.getAttribute("size"), s = i[0] === "-" || i[0] === "+";
            let o = parseInt(i, 10);
            s && (o = 3 + o);
            const r = Bd.length - 1, a = Math.min(Math.max(o, 0), r);
            return Bd[a];
          }
        }
      });
    }
  }
  const Od = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class RP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontSizeUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t, i = this._getLocalizedOptions(), s = e.commands.get(xe), o = t("Font Size"), r = LP(i, s);
      e.ui.componentFactory.add(xe, (a) => {
        const l = we(a);
        return Kt(l, r, {
          role: "menu",
          ariaLabel: o
        }), l.buttonView.set({
          label: o,
          icon: Od,
          tooltip: !0
        }), l.extendTemplate({
          attributes: {
            class: [
              "ck-font-size-dropdown"
            ]
          }
        }), l.bind("isEnabled").to(s), this.listenTo(l, "execute", (c) => {
          e.execute(c.source.commandName, { value: c.source.commandParam }), e.editing.view.focus();
        }), l;
      }), e.ui.componentFactory.add(`menuBar:${xe}`, (a) => {
        const l = new Ke(a);
        l.buttonView.set({
          label: o,
          icon: Od
        }), l.bind("isEnabled").to(s);
        const c = new sn(a);
        for (const u of r) {
          const d = new fn(a, l), h = new de(a);
          h.bind(...Object.keys(u.model)).to(u.model), h.bind("ariaChecked").to(h, "isOn"), h.delegate("execute").to(l), h.on("execute", () => {
            e.execute(u.model.commandName, {
              value: u.model.commandParam
            }), e.editing.view.focus();
          }), d.children.add(h), c.items.add(d);
        }
        return l.panelView.children.add(c), l;
      });
    }
    /**
     * Returns options as defined in `config.fontSize.options` but processed to account for
     * editor localization, i.e. to display {@link module:font/fontconfig~FontSizeOption}
     * in the correct language.
     *
     * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
     * when the user configuration is defined because the editor does not exist yet.
     */
    _getLocalizedOptions() {
      const e = this.editor, t = e.t, i = {
        Default: t("Default"),
        Tiny: t("Tiny"),
        Small: t("Small"),
        Big: t("Big"),
        Huge: t("Huge")
      };
      return zl(e.config.get(xe).options).map((o) => {
        const r = i[o.title];
        return r && r != o.title && (o = Object.assign({}, o, { title: r })), o;
      });
    }
  }
  function LP(n, e) {
    const t = new Ce();
    for (const i of n) {
      const s = {
        type: "button",
        model: new yi({
          commandName: xe,
          commandParam: i.model,
          label: i.title,
          class: "ck-fontsize-option",
          role: "menuitemradio",
          withText: !0
        })
      };
      i.view && typeof i.view != "string" && (i.view.styles && s.model.set("labelStyle", `font-size:${i.view.styles["font-size"]}`), i.view.classes && s.model.set("class", `${s.model.class} ${i.view.classes}`)), s.model.bind("isOn").to(e, "value", (o) => o === i.model), t.add(s);
    }
    return t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class VP extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [PP, RP];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontSize";
    }
    /**
     * Normalizes and translates the {@link module:font/fontconfig~FontSizeConfig#options configuration options}
     * to the {@link module:font/fontconfig~FontSizeOption} format.
     *
     * @param configuredOptions An array of options taken from the configuration.
     */
    normalizeSizeOptions(e) {
      return zl(e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class MP extends ur {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e, mt);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class BP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontColorEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define(mt, {
        colors: [
          {
            color: "hsl(0, 0%, 0%)",
            label: "Black"
          },
          {
            color: "hsl(0, 0%, 30%)",
            label: "Dim grey"
          },
          {
            color: "hsl(0, 0%, 60%)",
            label: "Grey"
          },
          {
            color: "hsl(0, 0%, 90%)",
            label: "Light grey"
          },
          {
            color: "hsl(0, 0%, 100%)",
            label: "White",
            hasBorder: !0
          },
          {
            color: "hsl(0, 75%, 60%)",
            label: "Red"
          },
          {
            color: "hsl(30, 75%, 60%)",
            label: "Orange"
          },
          {
            color: "hsl(60, 75%, 60%)",
            label: "Yellow"
          },
          {
            color: "hsl(90, 75%, 60%)",
            label: "Light green"
          },
          {
            color: "hsl(120, 75%, 60%)",
            label: "Green"
          },
          {
            color: "hsl(150, 75%, 60%)",
            label: "Aquamarine"
          },
          {
            color: "hsl(180, 75%, 60%)",
            label: "Turquoise"
          },
          {
            color: "hsl(210, 75%, 60%)",
            label: "Light blue"
          },
          {
            color: "hsl(240, 75%, 60%)",
            label: "Blue"
          },
          {
            color: "hsl(270, 75%, 60%)",
            label: "Purple"
          }
        ],
        columns: 5
      }), e.conversion.for("upcast").elementToAttribute({
        view: {
          name: "span",
          styles: {
            color: /[\s\S]+/
          }
        },
        model: {
          key: mt,
          value: rp("color")
        }
      }), e.conversion.for("upcast").elementToAttribute({
        view: {
          name: "font",
          attributes: {
            color: /^#?\w+$/
          }
        },
        model: {
          key: mt,
          value: (t) => t.getAttribute("color")
        }
      }), e.conversion.for("downcast").attributeToElement({
        model: mt,
        view: ap("color")
      }), e.commands.add(mt, new MP(e)), e.model.schema.extend("$text", { allowAttributes: mt }), e.model.schema.setAttributeProperties(mt, {
        isFormatting: !0,
        copyOnEnter: !0
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class up extends w {
    /**
     * Creates a plugin which introduces a dropdown with a pre–configured
     * {@link module:ui/colorselector/colorselectorview~ColorSelectorView}.
     *
     * @param config The configuration object.
     * @param config.commandName The name of the command which will be executed when a color tile is clicked.
     * @param config.componentName The name of the dropdown in the {@link module:ui/componentfactory~ComponentFactory}
     * and the configuration scope name in `editor.config`.
     * @param config.icon The SVG icon used by the dropdown.
     * @param config.dropdownLabel The label used by the dropdown.
     */
    constructor(e, { commandName: t, componentName: i, icon: s, dropdownLabel: o }) {
      super(e), this.commandName = t, this.componentName = i, this.icon = s, this.dropdownLabel = o, this.columns = e.config.get(`${this.componentName}.columns`);
    }
    /**
    * @inheritDoc
    */
    init() {
      const e = this.editor, t = e.locale, i = t.t, s = e.commands.get(this.commandName), o = e.config.get(this.componentName), r = ss(o.colors), a = ns(t, r), l = o.documentColors, c = o.colorPicker !== !1;
      e.ui.componentFactory.add(this.componentName, (u) => {
        const d = we(u);
        let h = !1;
        const f = gP({
          dropdownView: d,
          colors: a.map((m) => ({
            label: m.label,
            color: m.model,
            options: {
              hasBorder: m.hasBorder
            }
          })),
          columns: this.columns,
          removeButtonLabel: i("Remove color"),
          colorPickerLabel: i("Color picker"),
          documentColorsLabel: l !== 0 ? i("Document colors") : "",
          documentColorsCount: l === void 0 ? this.columns : l,
          colorPickerViewConfig: c ? o.colorPicker || {} : !1
        });
        return f.bind("selectedColor").to(s, "value"), d.buttonView.set({
          label: this.dropdownLabel,
          icon: this.icon,
          tooltip: !0
        }), d.extendTemplate({
          attributes: {
            class: "ck-color-ui-dropdown"
          }
        }), d.bind("isEnabled").to(s), f.on("execute", (m, p) => {
          d.isOpen && e.execute(this.commandName, {
            value: p.value,
            batch: this._undoStepBatch
          }), p.source !== "colorPicker" && e.editing.view.focus(), p.source === "colorPickerSaveButton" && (d.isOpen = !1);
        }), f.on("colorPicker:show", () => {
          this._undoStepBatch = e.model.createBatch();
        }), f.on("colorPicker:cancel", () => {
          this._undoStepBatch.operations.length && (d.isOpen = !1, e.execute("undo", this._undoStepBatch)), e.editing.view.focus();
        }), d.on("change:isOpen", (m, p, b) => {
          h || (h = !0, d.colorSelectorView.appendUI()), b && (l !== 0 && f.updateDocumentColors(e.model, this.componentName), f.updateSelectedColors(), f.showColorGridsFragment());
        }), Rl(d, () => d.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((m) => m.isOn)), d;
      }), e.ui.componentFactory.add(`menuBar:${this.componentName}`, (u) => {
        const d = new Ke(u);
        d.buttonView.set({
          label: this.dropdownLabel,
          icon: this.icon
        }), d.bind("isEnabled").to(s);
        let h = !1;
        const f = new Vl(u, {
          colors: a.map((m) => ({
            label: m.label,
            color: m.model,
            options: {
              hasBorder: m.hasBorder
            }
          })),
          columns: this.columns,
          removeButtonLabel: i("Remove color"),
          colorPickerLabel: i("Color picker"),
          documentColorsLabel: l !== 0 ? i("Document colors") : "",
          documentColorsCount: l === void 0 ? this.columns : l,
          colorPickerViewConfig: !1
        });
        return f.bind("selectedColor").to(s, "value"), f.delegate("execute").to(d), f.on("execute", (m, p) => {
          e.execute(this.commandName, {
            value: p.value,
            batch: this._undoStepBatch
          }), e.editing.view.focus();
        }), d.on("change:isOpen", (m, p, b) => {
          h || (h = !0, f.appendUI()), b && (l !== 0 && f.updateDocumentColors(e.model, this.componentName), f.updateSelectedColors(), f.showColorGridsFragment());
        }), d.panelView.children.add(f), d;
      });
    }
  }
  const OP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class NP extends up {
    /**
     * @inheritDoc
     */
    constructor(e) {
      const t = e.locale.t;
      super(e, {
        commandName: mt,
        componentName: mt,
        icon: OP,
        dropdownLabel: t("Font Color")
      });
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontColorUI";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class DP extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [BP, NP];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontColor";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class FP extends ur {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e, At);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class zP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontBackgroundColorEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define(At, {
        colors: [
          {
            color: "hsl(0, 0%, 0%)",
            label: "Black"
          },
          {
            color: "hsl(0, 0%, 30%)",
            label: "Dim grey"
          },
          {
            color: "hsl(0, 0%, 60%)",
            label: "Grey"
          },
          {
            color: "hsl(0, 0%, 90%)",
            label: "Light grey"
          },
          {
            color: "hsl(0, 0%, 100%)",
            label: "White",
            hasBorder: !0
          },
          {
            color: "hsl(0, 75%, 60%)",
            label: "Red"
          },
          {
            color: "hsl(30, 75%, 60%)",
            label: "Orange"
          },
          {
            color: "hsl(60, 75%, 60%)",
            label: "Yellow"
          },
          {
            color: "hsl(90, 75%, 60%)",
            label: "Light green"
          },
          {
            color: "hsl(120, 75%, 60%)",
            label: "Green"
          },
          {
            color: "hsl(150, 75%, 60%)",
            label: "Aquamarine"
          },
          {
            color: "hsl(180, 75%, 60%)",
            label: "Turquoise"
          },
          {
            color: "hsl(210, 75%, 60%)",
            label: "Light blue"
          },
          {
            color: "hsl(240, 75%, 60%)",
            label: "Blue"
          },
          {
            color: "hsl(270, 75%, 60%)",
            label: "Purple"
          }
        ],
        columns: 5
      }), e.data.addStyleProcessorRules(El), e.conversion.for("upcast").elementToAttribute({
        view: {
          name: "span",
          styles: {
            "background-color": /[\s\S]+/
          }
        },
        model: {
          key: At,
          value: rp("background-color")
        }
      }), e.conversion.for("downcast").attributeToElement({
        model: At,
        view: ap("background-color")
      }), e.commands.add(At, new FP(e)), e.model.schema.extend("$text", { allowAttributes: At }), e.model.schema.setAttributeProperties(At, {
        isFormatting: !0,
        copyOnEnter: !0
      });
    }
  }
  const UP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class HP extends up {
    /**
     * @inheritDoc
     */
    constructor(e) {
      const t = e.locale.t;
      super(e, {
        commandName: At,
        componentName: At,
        icon: UP,
        dropdownLabel: t("Font Background Color")
      });
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontBackgroundColorUI";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class dp extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [zP, HP];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FontBackgroundColor";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class $P extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [cp, VP, DP, dp];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Font";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ci extends V {
    /**
     * @param attributeKey Attribute that will be set by the command.
     */
    constructor(e, t) {
      super(e), this.attributeKey = t;
    }
    /**
     * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
     */
    refresh() {
      const e = this.editor.model, t = e.document;
      this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey);
    }
    /**
     * Executes the command &ndash; applies the attribute to the selection or removes it from the selection.
     *
     * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
     *
     * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
     *
     * * If the selection is on a range, the command applies the attribute to all nodes in that range
     * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
     * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
     * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
     * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
     * that the selection inherits all attributes from a node if it is in an empty node).
     *
     * @fires execute
     * @param options Command options.
     * @param options.forceValue If set, it will force the command behavior. If `true`,
     * the command will apply the attribute, otherwise the command will remove the attribute.
     * If not set, the command will look for its current value to decide what it should do.
     */
    execute(e = {}) {
      const t = this.editor.model, s = t.document.selection, o = e.forceValue === void 0 ? !this.value : e.forceValue;
      t.change((r) => {
        if (s.isCollapsed)
          o ? r.setSelectionAttribute(this.attributeKey, !0) : r.removeSelectionAttribute(this.attributeKey);
        else {
          const a = t.schema.getValidRanges(s.getRanges(), this.attributeKey);
          for (const l of a)
            o ? r.setAttribute(this.attributeKey, o, l) : r.removeAttribute(this.attributeKey, l);
        }
      });
    }
    /**
     * Checks the attribute value of the first node in the selection that allows the attribute.
     * For the collapsed selection returns the selection attribute.
     *
     * @returns The attribute value.
     */
    _getValueFromFirstAllowedNode() {
      const e = this.editor.model, t = e.schema, i = e.document.selection;
      if (i.isCollapsed)
        return i.hasAttribute(this.attributeKey);
      for (const s of i.getRanges())
        for (const o of s.getItems())
          if (t.checkAttribute(o, this.attributeKey))
            return o.hasAttribute(this.attributeKey);
      return !1;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Bi = "bold";
  class WP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "BoldEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.t;
      e.model.schema.extend("$text", { allowAttributes: Bi }), e.model.schema.setAttributeProperties(Bi, {
        isFormatting: !0,
        copyOnEnter: !0
      }), e.conversion.attributeToElement({
        model: Bi,
        view: "strong",
        upcastAlso: [
          "b",
          (i) => {
            const s = i.getStyle("font-weight");
            return s && (s == "bold" || Number(s) >= 600) ? {
              name: !0,
              styles: ["font-weight"]
            } : null;
          }
        ]
      }), e.commands.add(Bi, new Ci(e, Bi)), e.keystrokes.set("CTRL+B", Bi), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Bold text"),
            keystroke: "CTRL+B"
          }
        ]
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function ki({ editor: n, commandName: e, plugin: t, icon: i, label: s, keystroke: o }) {
    return (r) => {
      const a = n.commands.get(e), l = new r(n.locale);
      return l.set({
        label: s,
        icon: i,
        keystroke: o,
        isToggleable: !0
      }), l.bind("isEnabled").to(a, "isEnabled"), t.listenTo(l, "execute", () => {
        n.execute(e), n.editing.view.focus();
      }), l;
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Ws = "bold";
  class qP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "BoldUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale.t, i = e.commands.get(Ws), s = ki({
        editor: e,
        commandName: Ws,
        plugin: this,
        icon: x.bold,
        label: t("Bold"),
        keystroke: "CTRL+B"
      });
      e.ui.componentFactory.add(Ws, () => {
        const o = s(P);
        return o.set({
          tooltip: !0
        }), o.bind("isOn").to(i, "value"), o;
      }), e.ui.componentFactory.add("menuBar:" + Ws, () => s(de));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class GP extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [WP, qP];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Bold";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const ti = "code", jP = "ck-code_selected";
  class KP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "CodeEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [So];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.t;
      e.model.schema.extend("$text", { allowAttributes: ti }), e.model.schema.setAttributeProperties(ti, {
        isFormatting: !0,
        copyOnEnter: !1
      }), e.conversion.attributeToElement({
        model: ti,
        view: "code",
        upcastAlso: {
          styles: {
            "word-wrap": "break-word"
          }
        }
      }), e.commands.add(ti, new Ci(e, ti)), e.plugins.get(So).registerAttribute(ti), jg(e, ti, "code", jP), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Move out of an inline code style"),
            keystroke: [
              ["arrowleft", "arrowleft"],
              ["arrowright", "arrowright"]
            ]
          }
        ]
      });
    }
  }
  const ZP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const qs = "code";
  class JP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "CodeUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale.t, i = ki({
        editor: e,
        commandName: qs,
        plugin: this,
        icon: ZP,
        label: t("Code")
      });
      e.ui.componentFactory.add(qs, () => {
        const s = i(P), o = e.commands.get(qs);
        return s.set({
          tooltip: !0
        }), s.bind("isOn").to(o, "value"), s;
      }), e.ui.componentFactory.add("menuBar:" + qs, () => i(de));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class XP extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [KP, JP];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Code";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Oi = "italic";
  class YP extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ItalicEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.t;
      e.model.schema.extend("$text", { allowAttributes: Oi }), e.model.schema.setAttributeProperties(Oi, {
        isFormatting: !0,
        copyOnEnter: !0
      }), e.conversion.attributeToElement({
        model: Oi,
        view: "i",
        upcastAlso: [
          "em",
          {
            styles: {
              "font-style": "italic"
            }
          }
        ]
      }), e.commands.add(Oi, new Ci(e, Oi)), e.keystrokes.set("CTRL+I", Oi), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Italic text"),
            keystroke: "CTRL+I"
          }
        ]
      });
    }
  }
  const QP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Gs = "italic";
  class eR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ItalicUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.commands.get(Gs), i = e.locale.t, s = ki({
        editor: e,
        commandName: Gs,
        plugin: this,
        icon: QP,
        keystroke: "CTRL+I",
        label: i("Italic")
      });
      e.ui.componentFactory.add(Gs, () => {
        const o = s(P);
        return o.set({
          tooltip: !0
        }), o.bind("isOn").to(t, "value"), o;
      }), e.ui.componentFactory.add("menuBar:" + Gs, () => s(de));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class tR extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [YP, eR];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Italic";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const En = "strikethrough";
  class iR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "StrikethroughEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.t;
      e.model.schema.extend("$text", { allowAttributes: En }), e.model.schema.setAttributeProperties(En, {
        isFormatting: !0,
        copyOnEnter: !0
      }), e.conversion.attributeToElement({
        model: En,
        view: "s",
        upcastAlso: [
          "del",
          "strike",
          {
            styles: {
              "text-decoration": "line-through"
            }
          }
        ]
      }), e.commands.add(En, new Ci(e, En)), e.keystrokes.set("CTRL+SHIFT+X", "strikethrough"), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Strikethrough text"),
            keystroke: "CTRL+SHIFT+X"
          }
        ]
      });
    }
  }
  const nR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const js = "strikethrough";
  class sR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "StrikethroughUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale.t, i = ki({
        editor: e,
        commandName: js,
        plugin: this,
        icon: nR,
        keystroke: "CTRL+SHIFT+X",
        label: t("Strikethrough")
      });
      e.ui.componentFactory.add(js, () => {
        const s = i(P), o = e.commands.get(js);
        return s.set({
          tooltip: !0
        }), s.bind("isOn").to(o, "value"), s;
      }), e.ui.componentFactory.add("menuBar:" + js, () => i(de));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class oR extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [iR, sR];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Strikethrough";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const An = "subscript";
  class rR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SubscriptEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.model.schema.extend("$text", { allowAttributes: An }), e.model.schema.setAttributeProperties(An, {
        isFormatting: !0,
        copyOnEnter: !0
      }), e.conversion.attributeToElement({
        model: An,
        view: "sub",
        upcastAlso: [
          {
            styles: {
              "vertical-align": "sub"
            }
          }
        ]
      }), e.commands.add(An, new Ci(e, An));
    }
  }
  const aR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Ks = "subscript";
  class lR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SubscriptUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale.t, i = ki({
        editor: e,
        commandName: Ks,
        plugin: this,
        icon: aR,
        label: t("Subscript")
      });
      e.ui.componentFactory.add(Ks, () => {
        const s = i(P), o = e.commands.get(Ks);
        return s.set({
          tooltip: !0
        }), s.bind("isOn").to(o, "value"), s;
      }), e.ui.componentFactory.add("menuBar:" + Ks, () => i(de));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class cR extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [rR, lR];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Subscript";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const xn = "superscript";
  class uR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SuperscriptEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.model.schema.extend("$text", { allowAttributes: xn }), e.model.schema.setAttributeProperties(xn, {
        isFormatting: !0,
        copyOnEnter: !0
      }), e.conversion.attributeToElement({
        model: xn,
        view: "sup",
        upcastAlso: [
          {
            styles: {
              "vertical-align": "super"
            }
          }
        ]
      }), e.commands.add(xn, new Ci(e, xn));
    }
  }
  const dR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Zs = "superscript";
  class hR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SuperscriptUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale.t, i = ki({
        editor: e,
        commandName: Zs,
        plugin: this,
        icon: dR,
        label: t("Superscript")
      });
      e.ui.componentFactory.add(Zs, () => {
        const s = i(P), o = e.commands.get(Zs);
        return s.set({
          tooltip: !0
        }), s.bind("isOn").to(o, "value"), s;
      }), e.ui.componentFactory.add("menuBar:" + Zs, () => i(de));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class fR extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [uR, hR];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Superscript";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Sn = "underline";
  class mR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "UnderlineEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.t;
      e.model.schema.extend("$text", { allowAttributes: Sn }), e.model.schema.setAttributeProperties(Sn, {
        isFormatting: !0,
        copyOnEnter: !0
      }), e.conversion.attributeToElement({
        model: Sn,
        view: "u",
        upcastAlso: {
          styles: {
            "text-decoration": "underline"
          }
        }
      }), e.commands.add(Sn, new Ci(e, Sn)), e.keystrokes.set("CTRL+U", "underline"), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Underline text"),
            keystroke: "CTRL+U"
          }
        ]
      });
    }
  }
  const gR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Js = "underline";
  class pR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "UnderlineUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.commands.get(Js), i = e.locale.t, s = ki({
        editor: e,
        commandName: Js,
        plugin: this,
        icon: gR,
        label: i("Underline"),
        keystroke: "CTRL+U"
      });
      e.ui.componentFactory.add(Js, () => {
        const o = s(P);
        return o.set({
          tooltip: !0
        }), o.bind("isOn").to(t, "value"), o;
      }), e.ui.componentFactory.add("menuBar:" + Js, () => s(de));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class wR extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [mR, pR];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Underline";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class bR extends V {
    /**
     * Creates an instance of the command.
     *
     * @param editor Editor instance.
     * @param modelElements Names of the element which this command can apply in the model.
     */
    constructor(e, t) {
      super(e), this.modelElements = t;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = me(this.editor.model.document.selection.getSelectedBlocks());
      this.value = !!e && this.modelElements.includes(e.name) && e.name, this.isEnabled = !!e && this.modelElements.some((t) => Nd(e, t, this.editor.model.schema));
    }
    /**
     * Executes the command. Applies the heading to the selected blocks or, if the first selected
     * block is a heading already, turns selected headings (of this level only) to paragraphs.
     *
     * @param options.value Name of the element which this command will apply in the model.
     * @fires execute
     */
    execute(e) {
      const t = this.editor.model, i = t.document, s = e.value;
      t.change((o) => {
        const r = Array.from(i.selection.getSelectedBlocks()).filter((a) => Nd(a, s, t.schema));
        for (const a of r)
          a.is("element", s) || o.rename(a, s);
      });
    }
  }
  function Nd(n, e, t) {
    return t.checkChild(n.parent, e) && !t.isObject(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Dd = "paragraph";
  class _R extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "HeadingEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("heading", {
        options: [
          { model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" },
          { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" },
          { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" },
          { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }
        ]
      });
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [_s];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.config.get("heading.options"), i = [];
      for (const s of t)
        s.model !== "paragraph" && (e.model.schema.register(s.model, {
          inheritAllFrom: "$block"
        }), e.conversion.elementToElement(s), i.push(s.model));
      this._addDefaultH1Conversion(e), e.commands.add("heading", new bR(e, i));
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      const e = this.editor, t = e.commands.get("enter"), i = e.config.get("heading.options");
      t && this.listenTo(t, "afterExecute", (s, o) => {
        const r = e.model.document.selection.getFirstPosition().parent;
        i.some((l) => r.is("element", l.model)) && !r.is("element", Dd) && r.childCount === 0 && o.writer.rename(r, Dd);
      });
    }
    /**
     * Adds default conversion for `h1` -> `heading1` with a low priority.
     *
     * @param editor Editor instance on which to add the `h1` conversion.
     */
    _addDefaultH1Conversion(e) {
      e.conversion.for("upcast").elementToElement({
        model: "heading1",
        view: "h1",
        // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure
        // this listener is called before it. If not, `h1` will be transformed into a paragraph.
        converterPriority: Ut.low + 1
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function vR(n) {
    const e = n.t, t = {
      Paragraph: e("Paragraph"),
      "Heading 1": e("Heading 1"),
      "Heading 2": e("Heading 2"),
      "Heading 3": e("Heading 3"),
      "Heading 4": e("Heading 4"),
      "Heading 5": e("Heading 5"),
      "Heading 6": e("Heading 6")
    };
    return n.config.get("heading.options").map((i) => {
      const s = t[i.title];
      return s && s != i.title && (i.title = s), i;
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class yR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "HeadingUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t, i = vR(e), s = t("Choose heading"), o = t("Heading");
      e.ui.componentFactory.add("heading", (r) => {
        const a = {}, l = new Ce(), c = e.commands.get("heading"), u = e.commands.get("paragraph"), d = [c];
        for (const f of i) {
          const m = {
            type: "button",
            model: new yi({
              label: f.title,
              class: f.class,
              role: "menuitemradio",
              withText: !0
            })
          };
          f.model === "paragraph" ? (m.model.bind("isOn").to(u, "value"), m.model.set("commandName", "paragraph"), d.push(u)) : (m.model.bind("isOn").to(c, "value", (p) => p === f.model), m.model.set({
            commandName: "heading",
            commandValue: f.model
          })), l.add(m), a[f.model] = f.title;
        }
        const h = we(r);
        return Kt(h, l, {
          ariaLabel: o,
          role: "menu"
        }), h.buttonView.set({
          ariaLabel: o,
          ariaLabelledBy: void 0,
          isOn: !1,
          withText: !0,
          tooltip: o
        }), h.extendTemplate({
          attributes: {
            class: [
              "ck-heading-dropdown"
            ]
          }
        }), h.bind("isEnabled").toMany(d, "isEnabled", (...f) => f.some((m) => m)), h.buttonView.bind("label").to(c, "value", u, "value", (f, m) => {
          const p = m ? "paragraph" : f;
          return typeof p == "boolean" || !a[p] ? s : a[p];
        }), h.buttonView.bind("ariaLabel").to(c, "value", u, "value", (f, m) => {
          const p = m ? "paragraph" : f;
          return typeof p == "boolean" || !a[p] ? o : `${a[p]}, ${o}`;
        }), this.listenTo(h, "execute", (f) => {
          const { commandName: m, commandValue: p } = f.source;
          e.execute(m, p ? { value: p } : void 0), e.editing.view.focus();
        }), h;
      }), e.ui.componentFactory.add("menuBar:heading", (r) => {
        const a = new Ke(r), l = e.commands.get("heading"), c = e.commands.get("paragraph"), u = [l], d = new sn(r);
        a.set({
          class: "ck-heading-dropdown"
        }), d.set({
          ariaLabel: t("Heading"),
          role: "menu"
        }), a.buttonView.set({
          label: t("Heading")
        }), a.panelView.children.add(d);
        for (const h of i) {
          const f = new fn(r, a), m = new de(r);
          f.children.add(m), d.items.add(f), m.set({
            label: h.title,
            role: "menuitemradio",
            class: h.class
          }), m.bind("ariaChecked").to(m, "isOn"), m.delegate("execute").to(a), m.on("execute", () => {
            const p = h.model === "paragraph" ? "paragraph" : "heading";
            e.execute(p, { value: h.model }), e.editing.view.focus();
          }), h.model === "paragraph" ? (m.bind("isOn").to(c, "value"), u.push(c)) : m.bind("isOn").to(l, "value", (p) => p === h.model);
        }
        return a.bind("isEnabled").toMany(u, "isEnabled", (...h) => h.some((f) => f)), a;
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class CR extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [_R, yR];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Heading";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class kR extends rr {
    /**
     * Creates an instance of the {@link module:special-characters/ui/specialcharactersnavigationview~SpecialCharactersNavigationView}
     * class.
     *
     * @param locale The localization services instance.
     * @param groupNames The names of the character groups and their displayed labels.
     */
    constructor(e, t) {
      super(e);
      const i = e.t;
      this.set("class", "ck-special-characters-navigation"), this.groupDropdownView = this._createGroupDropdown(t), this.groupDropdownView.panelPosition = e.uiLanguageDirection === "rtl" ? "se" : "sw", this.label = i("Special characters"), this.children.add(this.groupDropdownView);
    }
    /**
     * Returns the name of the character group currently selected in the {@link #groupDropdownView}.
     */
    get currentGroupName() {
      return this.groupDropdownView.value;
    }
    /**
     * Focuses the character categories dropdown.
     */
    focus() {
      this.groupDropdownView.focus();
    }
    /**
     * Returns a dropdown that allows selecting character groups.
     *
     * @param groupNames The names of the character groups and their displayed labels.
     */
    _createGroupDropdown(e) {
      const t = this.locale, i = t.t, s = we(t), o = this._getCharacterGroupListItemDefinitions(s, e), r = i("Character categories");
      return s.set("value", o.first.model.name), s.buttonView.bind("label").to(s, "value", (a) => e.get(a)), s.buttonView.set({
        isOn: !1,
        withText: !0,
        tooltip: r,
        class: ["ck-dropdown__button_label-width_auto"],
        ariaLabel: r,
        ariaLabelledBy: void 0
      }), s.on("execute", (a) => {
        s.value = a.source.name;
      }), s.delegate("execute").to(this), Kt(s, o, {
        ariaLabel: r,
        role: "menu"
      }), s;
    }
    /**
     * Returns list item definitions to be used in the character group dropdown
     * representing specific character groups.
     *
     * @param dropdown Dropdown view element
     * @param groupNames The names of the character groups and their displayed labels.
     */
    _getCharacterGroupListItemDefinitions(e, t) {
      const i = new Ce();
      for (const [s, o] of t) {
        const r = new yi({
          name: s,
          label: o,
          withText: !0,
          role: "menuitemradio"
        });
        r.bind("isOn").to(e, "value", (a) => a === r.name), i.add({ type: "button", model: r });
      }
      return i;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class TR extends T {
    /**
     * Creates an instance of a character grid containing tiles representing special characters.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e), this.tiles = this.createCollection(), this.setTemplate({
        tag: "div",
        children: [
          {
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-character-grid__tiles"
              ]
            },
            children: this.tiles
          }
        ],
        attributes: {
          class: [
            "ck",
            "ck-character-grid"
          ]
        }
      }), this.focusTracker = new Q(), this.keystrokes = new ne(), Ka({
        keystrokeHandler: this.keystrokes,
        focusTracker: this.focusTracker,
        gridItems: this.tiles,
        numberOfColumns: () => E.window.getComputedStyle(this.element.firstChild).getPropertyValue("grid-template-columns").split(" ").length,
        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
      });
    }
    /**
     * Creates a new tile for the grid.
     *
     * @param character A human-readable character displayed as the label (e.g. "ε").
     * @param name The name of the character (e.g. "greek small letter epsilon").
     */
    createTile(e, t) {
      const i = new P(this.locale);
      return i.set({
        label: e,
        withText: !0,
        class: "ck-character-grid__tile"
      }), i.extendTemplate({
        attributes: {
          title: t
        },
        on: {
          mouseover: i.bindTemplate.to("mouseover"),
          focus: i.bindTemplate.to("focus")
        }
      }), i.on("mouseover", () => {
        this.fire("tileHover", { name: t, character: e });
      }), i.on("focus", () => {
        this.fire("tileFocus", { name: t, character: e });
      }), i.on("execute", () => {
        this.fire("execute", { name: t, character: e });
      }), i;
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render();
      for (const e of this.tiles)
        this.focusTracker.add(e.element);
      this.tiles.on("change", (e, { added: t, removed: i }) => {
        if (t.length > 0)
          for (const s of t)
            this.focusTracker.add(s.element);
        if (i.length > 0)
          for (const s of i)
            this.focusTracker.remove(s.element);
      }), this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the first focusable in {@link ~CharacterGridView#tiles}.
     */
    focus() {
      this.tiles.first.focus();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ER extends T {
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.set("character", null), this.set("name", null), this.bind("code").to(this, "character", AR), this.setTemplate({
        tag: "div",
        children: [
          {
            tag: "span",
            attributes: {
              class: [
                "ck-character-info__name"
              ]
            },
            children: [
              {
                // Note: ZWSP to prevent vertical collapsing.
                text: t.to("name", (i) => i || "​")
              }
            ]
          },
          {
            tag: "span",
            attributes: {
              class: [
                "ck-character-info__code"
              ]
            },
            children: [
              {
                text: t.to("code")
              }
            ]
          }
        ],
        attributes: {
          class: [
            "ck",
            "ck-character-info"
          ]
        }
      });
    }
  }
  function AR(n) {
    return n === null ? "" : "U+" + ("0000" + n.codePointAt(0).toString(16)).slice(-4);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class xR extends T {
    /**
     * Creates an instance of the `SpecialCharactersView`.
     */
    constructor(e, t, i, s) {
      super(e), this.navigationView = t, this.gridView = i, this.infoView = s, this.items = this.createCollection(), this.focusTracker = new Q(), this.keystrokes = new ne(), this._focusCycler = new _e({
        focusables: this.items,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          focusPrevious: "shift + tab",
          focusNext: "tab"
        }
      }), this.setTemplate({
        tag: "div",
        children: [
          this.navigationView,
          this.gridView,
          this.infoView
        ],
        attributes: {
          // Avoid focus loss when the user clicks the area of the grid that is not a button.
          // https://github.com/ckeditor/ckeditor5/pull/12319#issuecomment-1231779819
          tabindex: "-1"
        }
      }), this.items.add(this.navigationView.groupDropdownView.buttonView), this.items.add(this.gridView);
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.focusTracker.add(this.navigationView.groupDropdownView.buttonView.element), this.focusTracker.add(this.gridView.element), this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the first focusable in {@link #items}.
     */
    focus() {
      this.navigationView.focus();
    }
  }
  const SR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Ur = "All";
  class IR extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Wg];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SpecialCharacters";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = e.t;
      this._characters = /* @__PURE__ */ new Map(), this._groups = /* @__PURE__ */ new Map(), this._allSpecialCharactersGroupLabel = t("All");
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t, i = e.commands.get("insertText");
      e.ui.componentFactory.add("specialCharacters", (s) => {
        const o = we(s);
        let r;
        return o.buttonView.set({
          label: t("Special characters"),
          icon: SR,
          tooltip: !0
        }), o.bind("isEnabled").to(i), o.on("execute", (a, l) => {
          e.execute("insertText", { text: l.character }), e.editing.view.focus();
        }), o.on("change:isOpen", () => {
          if (!r) {
            r = this._createDropdownPanelContent(s, o);
            const a = new xR(s, r.navigationView, r.gridView, r.infoView);
            o.panelView.children.add(a);
          }
          r.infoView.set({
            character: null,
            name: null
          });
        }), o;
      });
    }
    /**
     * Adds a collection of special characters to the specified group. The title of a special character must be unique.
     *
     * **Note:** The "All" category name is reserved by the plugin and cannot be used as a new name for a special
     * characters category.
     */
    addItems(e, t, i = { label: e }) {
      if (e === Ur)
        throw new g("special-character-invalid-group-name", null);
      const s = this._getGroup(e, i.label);
      for (const o of t)
        s.items.add(o.title), this._characters.set(o.title, o.character);
    }
    /**
     * Returns special character groups in an order determined based on configuration and registration sequence.
     */
    getGroups() {
      const e = Array.from(this._groups.keys()), t = this.editor.config.get("specialCharacters.order") || [], i = t.find((s) => !e.includes(s));
      if (i)
        throw new g("special-character-invalid-order-group-name", null, { invalidGroup: i });
      return /* @__PURE__ */ new Set([
        ...t,
        ...e
      ]);
    }
    /**
     * Returns a collection of special characters symbol names (titles).
     */
    getCharactersForGroup(e) {
      if (e === Ur)
        return new Set(this._characters.keys());
      const t = this._groups.get(e);
      if (t)
        return t.items;
    }
    /**
     * Returns the symbol of a special character for the specified name. If the special character could not be found, `undefined`
     * is returned.
     *
     * @param title The title of a special character.
     */
    getCharacter(e) {
      return this._characters.get(e);
    }
    /**
     * Returns a group of special characters. If the group with the specified name does not exist, it will be created.
     *
     * @param groupName The name of the group to create.
     * @param label The label describing the new group.
     */
    _getGroup(e, t) {
      return this._groups.has(e) || this._groups.set(e, {
        items: /* @__PURE__ */ new Set(),
        label: t
      }), this._groups.get(e);
    }
    /**
     * Updates the symbol grid depending on the currently selected character group.
     */
    _updateGrid(e, t) {
      t.tiles.clear();
      const i = this.getCharactersForGroup(e);
      for (const s of i) {
        const o = this.getCharacter(s);
        t.tiles.add(t.createTile(o, s));
      }
    }
    /**
     * Initializes the dropdown, used for lazy loading.
     *
     * @returns An object with `navigationView`, `gridView` and `infoView` properties, containing UI parts.
     */
    _createDropdownPanelContent(e, t) {
      const i = Array.from(this.getGroups()).map((l) => [l, this._groups.get(l).label]), s = new Map([
        // Add a special group that shows all available special characters.
        [Ur, this._allSpecialCharactersGroupLabel],
        ...i
      ]), o = new kR(e, s), r = new TR(e), a = new ER(e);
      return r.delegate("execute").to(t), r.on("tileHover", (l, c) => {
        a.set(c);
      }), r.on("tileFocus", (l, c) => {
        a.set(c);
      }), o.on("execute", () => {
        this._updateGrid(o.currentGroupName, r);
      }), this._updateGrid(o.currentGroupName, r), { navigationView: o, gridView: r, infoView: a };
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class hp extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SpecialCharactersArrows";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t;
      e.plugins.get("SpecialCharacters").addItems("Arrows", [
        { title: t("leftwards simple arrow"), character: "←" },
        { title: t("rightwards simple arrow"), character: "→" },
        { title: t("upwards simple arrow"), character: "↑" },
        { title: t("downwards simple arrow"), character: "↓" },
        { title: t("leftwards double arrow"), character: "⇐" },
        { title: t("rightwards double arrow"), character: "⇒" },
        { title: t("upwards double arrow"), character: "⇑" },
        { title: t("downwards double arrow"), character: "⇓" },
        { title: t("leftwards dashed arrow"), character: "⇠" },
        { title: t("rightwards dashed arrow"), character: "⇢" },
        { title: t("upwards dashed arrow"), character: "⇡" },
        { title: t("downwards dashed arrow"), character: "⇣" },
        { title: t("leftwards arrow to bar"), character: "⇤" },
        { title: t("rightwards arrow to bar"), character: "⇥" },
        { title: t("upwards arrow to bar"), character: "⤒" },
        { title: t("downwards arrow to bar"), character: "⤓" },
        { title: t("up down arrow with base"), character: "↨" },
        { title: t("back with leftwards arrow above"), character: "🔙" },
        { title: t("end with leftwards arrow above"), character: "🔚" },
        { title: t("on with exclamation mark with left right arrow above"), character: "🔛" },
        { title: t("soon with rightwards arrow above"), character: "🔜" },
        { title: t("top with upwards arrow above"), character: "🔝" }
      ], { label: t("Arrows") });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class fp extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SpecialCharactersText";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t;
      e.plugins.get("SpecialCharacters").addItems("Text", [
        { character: "‹", title: t("Single left-pointing angle quotation mark") },
        { character: "›", title: t("Single right-pointing angle quotation mark") },
        { character: "«", title: t("Left-pointing double angle quotation mark") },
        { character: "»", title: t("Right-pointing double angle quotation mark") },
        { character: "‘", title: t("Left single quotation mark") },
        { character: "’", title: t("Right single quotation mark") },
        { character: "“", title: t("Left double quotation mark") },
        { character: "”", title: t("Right double quotation mark") },
        { character: "‚", title: t("Single low-9 quotation mark") },
        { character: "„", title: t("Double low-9 quotation mark") },
        { character: "¡", title: t("Inverted exclamation mark") },
        { character: "¿", title: t("Inverted question mark") },
        { character: "‥", title: t("Two dot leader") },
        { character: "…", title: t("Horizontal ellipsis") },
        { character: "‡", title: t("Double dagger") },
        { character: "‰", title: t("Per mille sign") },
        { character: "‱", title: t("Per ten thousand sign") },
        { character: "‼", title: t("Double exclamation mark") },
        { character: "⁈", title: t("Question exclamation mark") },
        { character: "⁉", title: t("Exclamation question mark") },
        { character: "⁇", title: t("Double question mark") },
        { character: "©", title: t("Copyright sign") },
        { character: "®", title: t("Registered sign") },
        { character: "™", title: t("Trade mark sign") },
        { character: "§", title: t("Section sign") },
        { character: "¶", title: t("Paragraph sign") },
        { character: "⁋", title: t("Reversed paragraph sign") }
      ], { label: t("Text") });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class mp extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SpecialCharactersMathematical";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t;
      e.plugins.get("SpecialCharacters").addItems("Mathematical", [
        { character: "<", title: t("Less-than sign") },
        { character: ">", title: t("Greater-than sign") },
        { character: "≤", title: t("Less-than or equal to") },
        { character: "≥", title: t("Greater-than or equal to") },
        { character: "–", title: t("En dash") },
        { character: "—", title: t("Em dash") },
        { character: "¯", title: t("Macron") },
        { character: "‾", title: t("Overline") },
        { character: "°", title: t("Degree sign") },
        { character: "−", title: t("Minus sign") },
        { character: "±", title: t("Plus-minus sign") },
        { character: "÷", title: t("Division sign") },
        { character: "⁄", title: t("Fraction slash") },
        { character: "×", title: t("Multiplication sign") },
        { character: "ƒ", title: t("Latin small letter f with hook") },
        { character: "∫", title: t("Integral") },
        { character: "∑", title: t("N-ary summation") },
        { character: "∞", title: t("Infinity") },
        { character: "√", title: t("Square root") },
        { character: "∼", title: t("Tilde operator") },
        { character: "≅", title: t("Approximately equal to") },
        { character: "≈", title: t("Almost equal to") },
        { character: "≠", title: t("Not equal to") },
        { character: "≡", title: t("Identical to") },
        { character: "∈", title: t("Element of") },
        { character: "∉", title: t("Not an element of") },
        { character: "∋", title: t("Contains as member") },
        { character: "∏", title: t("N-ary product") },
        { character: "∧", title: t("Logical and") },
        { character: "∨", title: t("Logical or") },
        { character: "¬", title: t("Not sign") },
        { character: "∩", title: t("Intersection") },
        { character: "∪", title: t("Union") },
        { character: "∂", title: t("Partial differential") },
        { character: "∀", title: t("For all") },
        { character: "∃", title: t("There exists") },
        { character: "∅", title: t("Empty set") },
        { character: "∇", title: t("Nabla") },
        { character: "∗", title: t("Asterisk operator") },
        { character: "∝", title: t("Proportional to") },
        { character: "∠", title: t("Angle") },
        { character: "¼", title: t("Vulgar fraction one quarter") },
        { character: "½", title: t("Vulgar fraction one half") },
        { character: "¾", title: t("Vulgar fraction three quarters") }
      ], { label: t("Mathematical") });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class gp extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SpecialCharactersLatin";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t;
      e.plugins.get("SpecialCharacters").addItems("Latin", [
        { character: "Ā", title: t("Latin capital letter a with macron") },
        { character: "ā", title: t("Latin small letter a with macron") },
        { character: "Ă", title: t("Latin capital letter a with breve") },
        { character: "ă", title: t("Latin small letter a with breve") },
        { character: "Ą", title: t("Latin capital letter a with ogonek") },
        { character: "ą", title: t("Latin small letter a with ogonek") },
        { character: "Ć", title: t("Latin capital letter c with acute") },
        { character: "ć", title: t("Latin small letter c with acute") },
        { character: "Ĉ", title: t("Latin capital letter c with circumflex") },
        { character: "ĉ", title: t("Latin small letter c with circumflex") },
        { character: "Ċ", title: t("Latin capital letter c with dot above") },
        { character: "ċ", title: t("Latin small letter c with dot above") },
        { character: "Č", title: t("Latin capital letter c with caron") },
        { character: "č", title: t("Latin small letter c with caron") },
        { character: "Ď", title: t("Latin capital letter d with caron") },
        { character: "ď", title: t("Latin small letter d with caron") },
        { character: "Đ", title: t("Latin capital letter d with stroke") },
        { character: "đ", title: t("Latin small letter d with stroke") },
        { character: "Ē", title: t("Latin capital letter e with macron") },
        { character: "ē", title: t("Latin small letter e with macron") },
        { character: "Ĕ", title: t("Latin capital letter e with breve") },
        { character: "ĕ", title: t("Latin small letter e with breve") },
        { character: "Ė", title: t("Latin capital letter e with dot above") },
        { character: "ė", title: t("Latin small letter e with dot above") },
        { character: "Ę", title: t("Latin capital letter e with ogonek") },
        { character: "ę", title: t("Latin small letter e with ogonek") },
        { character: "Ě", title: t("Latin capital letter e with caron") },
        { character: "ě", title: t("Latin small letter e with caron") },
        { character: "Ĝ", title: t("Latin capital letter g with circumflex") },
        { character: "ĝ", title: t("Latin small letter g with circumflex") },
        { character: "Ğ", title: t("Latin capital letter g with breve") },
        { character: "ğ", title: t("Latin small letter g with breve") },
        { character: "Ġ", title: t("Latin capital letter g with dot above") },
        { character: "ġ", title: t("Latin small letter g with dot above") },
        { character: "Ģ", title: t("Latin capital letter g with cedilla") },
        { character: "ģ", title: t("Latin small letter g with cedilla") },
        { character: "Ĥ", title: t("Latin capital letter h with circumflex") },
        { character: "ĥ", title: t("Latin small letter h with circumflex") },
        { character: "Ħ", title: t("Latin capital letter h with stroke") },
        { character: "ħ", title: t("Latin small letter h with stroke") },
        { character: "Ĩ", title: t("Latin capital letter i with tilde") },
        { character: "ĩ", title: t("Latin small letter i with tilde") },
        { character: "Ī", title: t("Latin capital letter i with macron") },
        { character: "ī", title: t("Latin small letter i with macron") },
        { character: "Ĭ", title: t("Latin capital letter i with breve") },
        { character: "ĭ", title: t("Latin small letter i with breve") },
        { character: "Į", title: t("Latin capital letter i with ogonek") },
        { character: "į", title: t("Latin small letter i with ogonek") },
        { character: "İ", title: t("Latin capital letter i with dot above") },
        { character: "ı", title: t("Latin small letter dotless i") },
        { character: "Ĳ", title: t("Latin capital ligature ij") },
        { character: "ĳ", title: t("Latin small ligature ij") },
        { character: "Ĵ", title: t("Latin capital letter j with circumflex") },
        { character: "ĵ", title: t("Latin small letter j with circumflex") },
        { character: "Ķ", title: t("Latin capital letter k with cedilla") },
        { character: "ķ", title: t("Latin small letter k with cedilla") },
        { character: "ĸ", title: t("Latin small letter kra") },
        { character: "Ĺ", title: t("Latin capital letter l with acute") },
        { character: "ĺ", title: t("Latin small letter l with acute") },
        { character: "Ļ", title: t("Latin capital letter l with cedilla") },
        { character: "ļ", title: t("Latin small letter l with cedilla") },
        { character: "Ľ", title: t("Latin capital letter l with caron") },
        { character: "ľ", title: t("Latin small letter l with caron") },
        { character: "Ŀ", title: t("Latin capital letter l with middle dot") },
        { character: "ŀ", title: t("Latin small letter l with middle dot") },
        { character: "Ł", title: t("Latin capital letter l with stroke") },
        { character: "ł", title: t("Latin small letter l with stroke") },
        { character: "Ń", title: t("Latin capital letter n with acute") },
        { character: "ń", title: t("Latin small letter n with acute") },
        { character: "Ņ", title: t("Latin capital letter n with cedilla") },
        { character: "ņ", title: t("Latin small letter n with cedilla") },
        { character: "Ň", title: t("Latin capital letter n with caron") },
        { character: "ň", title: t("Latin small letter n with caron") },
        { character: "ŉ", title: t("Latin small letter n preceded by apostrophe") },
        { character: "Ŋ", title: t("Latin capital letter eng") },
        { character: "ŋ", title: t("Latin small letter eng") },
        { character: "Ō", title: t("Latin capital letter o with macron") },
        { character: "ō", title: t("Latin small letter o with macron") },
        { character: "Ŏ", title: t("Latin capital letter o with breve") },
        { character: "ŏ", title: t("Latin small letter o with breve") },
        { character: "Ő", title: t("Latin capital letter o with double acute") },
        { character: "ő", title: t("Latin small letter o with double acute") },
        { character: "Œ", title: t("Latin capital ligature oe") },
        { character: "œ", title: t("Latin small ligature oe") },
        { character: "Ŕ", title: t("Latin capital letter r with acute") },
        { character: "ŕ", title: t("Latin small letter r with acute") },
        { character: "Ŗ", title: t("Latin capital letter r with cedilla") },
        { character: "ŗ", title: t("Latin small letter r with cedilla") },
        { character: "Ř", title: t("Latin capital letter r with caron") },
        { character: "ř", title: t("Latin small letter r with caron") },
        { character: "Ś", title: t("Latin capital letter s with acute") },
        { character: "ś", title: t("Latin small letter s with acute") },
        { character: "Ŝ", title: t("Latin capital letter s with circumflex") },
        { character: "ŝ", title: t("Latin small letter s with circumflex") },
        { character: "Ş", title: t("Latin capital letter s with cedilla") },
        { character: "ş", title: t("Latin small letter s with cedilla") },
        { character: "Š", title: t("Latin capital letter s with caron") },
        { character: "š", title: t("Latin small letter s with caron") },
        { character: "Ţ", title: t("Latin capital letter t with cedilla") },
        { character: "ţ", title: t("Latin small letter t with cedilla") },
        { character: "Ť", title: t("Latin capital letter t with caron") },
        { character: "ť", title: t("Latin small letter t with caron") },
        { character: "Ŧ", title: t("Latin capital letter t with stroke") },
        { character: "ŧ", title: t("Latin small letter t with stroke") },
        { character: "Ũ", title: t("Latin capital letter u with tilde") },
        { character: "ũ", title: t("Latin small letter u with tilde") },
        { character: "Ū", title: t("Latin capital letter u with macron") },
        { character: "ū", title: t("Latin small letter u with macron") },
        { character: "Ŭ", title: t("Latin capital letter u with breve") },
        { character: "ŭ", title: t("Latin small letter u with breve") },
        { character: "Ů", title: t("Latin capital letter u with ring above") },
        { character: "ů", title: t("Latin small letter u with ring above") },
        { character: "Ű", title: t("Latin capital letter u with double acute") },
        { character: "ű", title: t("Latin small letter u with double acute") },
        { character: "Ų", title: t("Latin capital letter u with ogonek") },
        { character: "ų", title: t("Latin small letter u with ogonek") },
        { character: "Ŵ", title: t("Latin capital letter w with circumflex") },
        { character: "ŵ", title: t("Latin small letter w with circumflex") },
        { character: "Ŷ", title: t("Latin capital letter y with circumflex") },
        { character: "ŷ", title: t("Latin small letter y with circumflex") },
        { character: "Ÿ", title: t("Latin capital letter y with diaeresis") },
        { character: "Ź", title: t("Latin capital letter z with acute") },
        { character: "ź", title: t("Latin small letter z with acute") },
        { character: "Ż", title: t("Latin capital letter z with dot above") },
        { character: "ż", title: t("Latin small letter z with dot above") },
        { character: "Ž", title: t("Latin capital letter z with caron") },
        { character: "ž", title: t("Latin small letter z with caron") },
        { character: "ſ", title: t("Latin small letter long s") }
      ], { label: t("Latin") });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class pp extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SpecialCharactersCurrency";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t;
      e.plugins.get("SpecialCharacters").addItems("Currency", [
        { character: "$", title: t("Dollar sign") },
        { character: "€", title: t("Euro sign") },
        { character: "¥", title: t("Yen sign") },
        { character: "£", title: t("Pound sign") },
        { character: "¢", title: t("Cent sign") },
        { character: "₠", title: t("Euro-currency sign") },
        { character: "₡", title: t("Colon sign") },
        { character: "₢", title: t("Cruzeiro sign") },
        { character: "₣", title: t("French franc sign") },
        { character: "₤", title: t("Lira sign") },
        { character: "¤", title: t("Currency sign") },
        { character: "₿", title: t("Bitcoin sign") },
        { character: "₥", title: t("Mill sign") },
        { character: "₦", title: t("Naira sign") },
        { character: "₧", title: t("Peseta sign") },
        { character: "₨", title: t("Rupee sign") },
        { character: "₩", title: t("Won sign") },
        { character: "₪", title: t("New sheqel sign") },
        { character: "₫", title: t("Dong sign") },
        { character: "₭", title: t("Kip sign") },
        { character: "₮", title: t("Tugrik sign") },
        { character: "₯", title: t("Drachma sign") },
        { character: "₰", title: t("German penny sign") },
        { character: "₱", title: t("Peso sign") },
        { character: "₲", title: t("Guarani sign") },
        { character: "₳", title: t("Austral sign") },
        { character: "₴", title: t("Hryvnia sign") },
        { character: "₵", title: t("Cedi sign") },
        { character: "₶", title: t("Livre tournois sign") },
        { character: "₷", title: t("Spesmilo sign") },
        { character: "₸", title: t("Tenge sign") },
        { character: "₹", title: t("Indian rupee sign") },
        { character: "₺", title: t("Turkish lira sign") },
        { character: "₻", title: t("Nordic mark sign") },
        { character: "₼", title: t("Manat sign") },
        { character: "₽", title: t("Ruble sign") }
      ], { label: t("Currency") });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class PR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "SpecialCharactersEssentials";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [
        pp,
        fp,
        mp,
        hp,
        gp
      ];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ye {
    /**
     * Creates a document list iterator.
     *
     * @param startElement The start list item block element.
     * @param options.direction The iterating direction.
     * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
     * @param options.sameAttributes Additional attributes that must be the same for each block.
     * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
     * in the result.
     * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
     * in the result.
     * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
     * in the result.
     */
    constructor(e, t) {
      this._startElement = e, this._referenceIndent = e.getAttribute("listIndent"), this._isForward = t.direction == "forward", this._includeSelf = !!t.includeSelf, this._sameAttributes = Z(t.sameAttributes || []), this._sameIndent = !!t.sameIndent, this._lowerIndent = !!t.lowerIndent, this._higherIndent = !!t.higherIndent;
    }
    /**
     * Performs only first step of iteration and returns the result.
     *
     * @param startElement The start list item block element.
     * @param options.direction The iterating direction.
     * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
     * @param options.sameAttributes Additional attributes that must be the same for each block.
     * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
     * in the result.
     * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
     * in the result.
     * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
     * in the result.
     */
    static first(e, t) {
      const s = new this(e, t)[Symbol.iterator]();
      return me(s);
    }
    /**
     * Iterable interface.
     */
    *[Symbol.iterator]() {
      const e = [];
      for (const { node: t } of vs(this._getStartNode(), this._isForward ? "forward" : "backward")) {
        const i = t.getAttribute("listIndent");
        if (i < this._referenceIndent) {
          if (!this._lowerIndent)
            break;
          this._referenceIndent = i;
        } else if (i > this._referenceIndent) {
          if (!this._higherIndent)
            continue;
          if (!this._isForward) {
            e.push(t);
            continue;
          }
        } else {
          if (!this._sameIndent) {
            if (this._higherIndent) {
              e.length && (yield* e, e.length = 0);
              break;
            }
            continue;
          }
          if (this._sameAttributes.some((s) => t.getAttribute(s) !== this._startElement.getAttribute(s)))
            break;
        }
        e.length && (yield* e, e.length = 0), yield t;
      }
    }
    /**
     * Returns the model element to start iterating.
     */
    _getStartNode() {
      return this._includeSelf ? this._startElement : this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling;
    }
  }
  function* vs(n, e = "forward") {
    const t = e == "forward", i = [];
    let s = null;
    for (; fe(n); ) {
      let o = null;
      if (s) {
        const r = n.getAttribute("listIndent"), a = s.getAttribute("listIndent");
        r > a ? i[a] = s : r < a ? (o = i[r], i.length = r) : o = s;
      }
      yield { node: n, previous: s, previousNodeInList: o }, s = n, n = t ? n.nextSibling : n.previousSibling;
    }
  }
  class RR {
    /**
     * @param listHead The head element of a list.
     */
    constructor(e) {
      this._listHead = e;
    }
    /**
     * List blocks iterator.
     *
     * Iterates over all blocks of a list.
     */
    [Symbol.iterator]() {
      return vs(this._listHead, "forward");
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class on {
    /**
     * Returns the next ID.
     *
     * @internal
     */
    /* istanbul ignore next: static function definition -- @preserve */
    static next() {
      return Ze();
    }
  }
  function fe(n) {
    return !!n && n.is("element") && n.hasAttribute("listItemId");
  }
  function Ul(n, e = {}) {
    return [
      ...Wt(n, { ...e, direction: "backward" }),
      ...Wt(n, { ...e, direction: "forward" })
    ];
  }
  function Wt(n, e = {}) {
    const t = e.direction == "forward", i = Array.from(new Ye(n, {
      ...e,
      includeSelf: t,
      sameIndent: !0,
      sameAttributes: "listItemId"
    }));
    return t ? i : i.reverse();
  }
  function LR(n) {
    return Array.from(new Ye(n, {
      direction: "forward",
      higherIndent: !0
    }));
  }
  function wp(n, e) {
    const t = new Ye(n, {
      sameIndent: !0,
      sameAttributes: "listType",
      ...e
    }), i = new Ye(n, {
      sameIndent: !0,
      sameAttributes: "listType",
      includeSelf: !0,
      direction: "forward",
      ...e
    });
    return [
      ...Array.from(t).reverse(),
      ...i
    ];
  }
  function gi(n) {
    return !Ye.first(n, {
      sameIndent: !0,
      sameAttributes: "listItemId"
    });
  }
  function Fd(n) {
    return !Ye.first(n, {
      direction: "forward",
      sameIndent: !0,
      sameAttributes: "listItemId"
    });
  }
  function ys(n, e = {}) {
    n = Z(n);
    const t = e.withNested !== !1, i = /* @__PURE__ */ new Set();
    for (const s of n)
      for (const o of Ul(s, { higherIndent: t }))
        i.add(o);
    return Ti(i);
  }
  function VR(n) {
    n = Z(n);
    const e = /* @__PURE__ */ new Set();
    for (const t of n)
      for (const i of wp(t))
        e.add(i);
    return Ti(e);
  }
  function Hl(n, e) {
    const t = Wt(n, { direction: "forward" }), i = on.next();
    for (const s of t)
      e.setAttribute("listItemId", i, s);
    return t;
  }
  function Aa(n, e, t) {
    const i = {};
    for (const [o, r] of e.getAttributes())
      o.startsWith("list") && (i[o] = r);
    const s = Wt(n, { direction: "forward" });
    for (const o of s)
      t.setAttributes(i, o);
    return s;
  }
  function xa(n, e, { expand: t, indentBy: i = 1 } = {}) {
    n = Z(n);
    const s = t ? ys(n) : n;
    for (const o of s) {
      const r = o.getAttribute("listIndent") + i;
      r < 0 ? dr(o, e) : e.setAttribute("listIndent", r, o);
    }
    return s;
  }
  function MR(n, e) {
    n = Z(n);
    const t = ys(n), i = /* @__PURE__ */ new Set(), s = Math.min(...t.map((r) => r.getAttribute("listIndent"))), o = /* @__PURE__ */ new Map();
    for (const r of t)
      o.set(r, Ye.first(r, { lowerIndent: !0 }));
    for (const r of t) {
      if (i.has(r))
        continue;
      i.add(r);
      const a = r.getAttribute("listIndent") - 1;
      if (a < 0) {
        dr(r, e);
        continue;
      }
      if (r.getAttribute("listIndent") == s) {
        const l = NR(r, o.get(r), e);
        for (const c of l)
          i.add(c);
        if (l.length)
          continue;
      }
      e.setAttribute("listIndent", a, r);
    }
    return Ti(i);
  }
  function dr(n, e) {
    n = Z(n);
    for (const t of n)
      t.is("element", "listItem") && e.rename(t, "paragraph");
    for (const t of n)
      for (const i of t.getAttributeKeys())
        i.startsWith("list") && e.removeAttribute(i, t);
    return n;
  }
  function cs(n) {
    if (!n.length)
      return !1;
    const e = n[0].getAttribute("listItemId");
    return e ? !n.some((t) => t.getAttribute("listItemId") != e) : !1;
  }
  function BR(n, e) {
    const t = [];
    let i = Number.POSITIVE_INFINITY;
    for (const { node: s } of vs(n.nextSibling, "forward")) {
      const o = s.getAttribute("listIndent");
      if (o == 0)
        break;
      o < i && (i = o);
      const r = o - i;
      e.setAttribute("listIndent", r, s), t.push(s);
    }
    return t;
  }
  function Ti(n) {
    return Array.from(n).filter((e) => e.root.rootName !== "$graveyard").sort((e, t) => e.index - t.index);
  }
  function us(n) {
    const e = n.document.selection.getSelectedElement();
    return e && n.schema.isObject(e) && n.schema.isBlock(e) ? e : null;
  }
  function Hr(n, e) {
    return e.checkChild(n.parent, "listItem") && e.checkChild(n, "$text") && !e.isObject(n);
  }
  function OR(n) {
    return n == "numbered" || n == "customNumbered";
  }
  function NR(n, e, t) {
    return Wt(e, { direction: "forward" }).pop().index > n.index ? Aa(n, e, t) : [];
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class zd extends V {
    /**
     * Creates an instance of the command.
     *
     * @param editor The editor instance.
     * @param indentDirection The direction of indent. If it is equal to `backward`, the command
     * will outdent a list item.
     */
    constructor(e, t) {
      super(e), this._direction = t;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      this.isEnabled = this._checkEnabled();
    }
    /**
     * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
     *
     * @fires execute
     * @fires afterExecute
     */
    execute() {
      const e = this.editor.model, t = Ud(e.document.selection);
      e.change((i) => {
        const s = [];
        cs(t) && !gi(t[0]) ? (this._direction == "forward" && s.push(...xa(t, i)), s.push(...Hl(t[0], i))) : this._direction == "forward" ? s.push(...xa(t, i, { expand: !0 })) : s.push(...MR(t, i));
        for (const o of s) {
          if (!o.hasAttribute("listType"))
            continue;
          const r = Ye.first(o, { sameIndent: !0 });
          r && i.setAttribute("listType", r.getAttribute("listType"), o);
        }
        this._fireAfterExecute(s);
      });
    }
    /**
     * Fires the `afterExecute` event.
     *
     * @param changedBlocks The changed list elements.
     */
    _fireAfterExecute(e) {
      this.fire("afterExecute", Ti(new Set(e)));
    }
    /**
     * Checks whether the command can be enabled in the current context.
     *
     * @returns Whether the command should be enabled.
     */
    _checkEnabled() {
      let e = Ud(this.editor.model.document.selection), t = e[0];
      if (!t)
        return !1;
      if (this._direction == "backward" || cs(e) && !gi(e[0]))
        return !0;
      e = ys(e), t = e[0];
      const i = Ye.first(t, { sameIndent: !0 });
      return i ? i.getAttribute("listType") == t.getAttribute("listType") : !1;
    }
  }
  function Ud(n) {
    const e = Array.from(n.getSelectedBlocks()), t = e.findIndex((i) => !fe(i));
    return t != -1 && (e.length = t), e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Xs extends V {
    /**
     * Creates an instance of the command.
     *
     * @param editor The editor instance.
     * @param type List type that will be handled by this command.
     */
    constructor(e, t, i = {}) {
      super(e), this.type = t, this._listWalkerOptions = i.multiLevel ? {
        higherIndent: !0,
        lowerIndent: !0,
        sameAttributes: []
      } : void 0;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      this.value = this._getValue(), this.isEnabled = this._checkEnabled();
    }
    /**
     * Executes the list command.
     *
     * @fires execute
     * @fires afterExecute
     * @param options Command options.
     * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
     * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements
     * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
     * @param options.additionalAttributes Additional attributes that are set for list items when the command is executed.
     */
    execute(e = {}) {
      const t = this.editor.model, i = t.document, s = us(t), o = Array.from(i.selection.getSelectedBlocks()).filter((a) => t.schema.checkAttribute(a, "listType") || Hr(a, t.schema)), r = e.forceValue !== void 0 ? !e.forceValue : this.value;
      t.change((a) => {
        if (r) {
          const l = o[o.length - 1], c = Wt(l, { direction: "forward" }), u = [];
          c.length > 1 && u.push(...Hl(c[1], a)), u.push(...dr(o, a)), u.push(...BR(l, a)), this._fireAfterExecute(u);
        } else if ((s || i.selection.isCollapsed) && fe(o[0])) {
          const l = wp(s || o[0], this._listWalkerOptions);
          for (const c of l)
            a.setAttributes({
              ...e.additionalAttributes,
              listType: this.type
            }, c);
          this._fireAfterExecute(l);
        } else {
          const l = [];
          for (const c of o)
            if (!c.hasAttribute("listType"))
              !c.is("element", "listItem") && Hr(c, t.schema) && a.rename(c, "listItem"), a.setAttributes({
                ...e.additionalAttributes,
                listIndent: 0,
                listItemId: on.next(),
                listType: this.type
              }, c), l.push(c);
            else
              for (const u of ys(c, { withNested: !1 }))
                u.getAttribute("listType") != this.type && (a.setAttributes({
                  ...e.additionalAttributes,
                  listType: this.type
                }, u), l.push(u));
          this._fireAfterExecute(l);
        }
      });
    }
    /**
     * Fires the `afterExecute` event.
     *
     * @param changedBlocks The changed list elements.
     */
    _fireAfterExecute(e) {
      this.fire("afterExecute", Ti(new Set(e)));
    }
    /**
     * Checks the command's {@link #value}.
     *
     * @returns The current value.
     */
    _getValue() {
      const e = this.editor.model.document.selection, t = Array.from(e.getSelectedBlocks());
      if (!t.length)
        return !1;
      for (const i of t)
        if (i.getAttribute("listType") != this.type)
          return !1;
      return !0;
    }
    /**
     * Checks whether the command can be enabled in the current context.
     *
     * @returns Whether the command should be enabled.
     */
    _checkEnabled() {
      const e = this.editor.model, t = e.schema, i = e.document.selection, s = Array.from(i.getSelectedBlocks());
      if (!s.length)
        return !1;
      if (this.value)
        return !0;
      for (const o of s)
        if (t.checkAttribute(o, "listType") || Hr(o, t))
          return !0;
      return !1;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Hd extends V {
    /**
     * Creates an instance of the command.
     *
     * @param editor The editor instance.
     * @param direction Whether list item should be merged before or after the selected block.
     */
    constructor(e, t) {
      super(e), this._direction = t;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      this.isEnabled = this._checkEnabled();
    }
    /**
     * Merges list blocks together (depending on the {@link #constructor}'s `direction` parameter).
     *
     * @fires execute
     * @fires afterExecute
     * @param options Command options.
     * @param options.shouldMergeOnBlocksContentLevel When set `true`, merging will be performed together
     * with {@link module:engine/model/model~Model#deleteContent} to get rid of the inline content in the selection or take advantage
     * of the heuristics in `deleteContent()` that helps convert lists into paragraphs in certain cases.
     */
    execute({ shouldMergeOnBlocksContentLevel: e = !1 } = {}) {
      const t = this.editor.model, i = t.document.selection, s = [];
      t.change((o) => {
        const { firstElement: r, lastElement: a } = this._getMergeSubjectElements(i, e), l = r.getAttribute("listIndent") || 0, c = a.getAttribute("listIndent"), u = a.getAttribute("listItemId");
        if (l != c) {
          const d = LR(a);
          s.push(...xa([a, ...d], o, {
            indentBy: l - c,
            // If outdenting, the entire sub-tree that follows must be included.
            expand: l < c
          }));
        }
        if (e) {
          let d = i;
          i.isCollapsed && (d = o.createSelection(o.createRange(o.createPositionAt(r, "end"), o.createPositionAt(a, 0)))), t.deleteContent(d, { doNotResetEntireContent: i.isCollapsed });
          const h = d.getLastPosition().parent, f = h.nextSibling;
          s.push(h), f && f !== a && f.getAttribute("listItemId") == u && s.push(...Aa(f, h, o));
        } else
          s.push(...Aa(a, r, o));
        this._fireAfterExecute(s);
      });
    }
    /**
     * Fires the `afterExecute` event.
     *
     * @param changedBlocks The changed list elements.
     */
    _fireAfterExecute(e) {
      this.fire("afterExecute", Ti(new Set(e)));
    }
    /**
     * Checks whether the command can be enabled in the current context.
     *
     * @returns Whether the command should be enabled.
     */
    _checkEnabled() {
      const e = this.editor.model, t = e.document.selection, i = us(e);
      if (t.isCollapsed || i) {
        const s = i || t.getFirstPosition().parent;
        if (!fe(s))
          return !1;
        const o = this._direction == "backward" ? s.previousSibling : s.nextSibling;
        if (!o || cs([s, o]))
          return !1;
      } else {
        const s = t.getLastPosition(), o = t.getFirstPosition();
        if (s.parent === o.parent || !fe(s.parent))
          return !1;
      }
      return !0;
    }
    /**
     * Returns the boundary elements the merge should be executed for. These are not necessarily selection's first
     * and last position parents but sometimes sibling or even further blocks depending on the context.
     *
     * @param selection The selection the merge is executed for.
     * @param shouldMergeOnBlocksContentLevel When `true`, merge is performed together with
     * {@link module:engine/model/model~Model#deleteContent} to remove the inline content within the selection.
     */
    _getMergeSubjectElements(e, t) {
      const i = this.editor.model, s = us(i);
      let o, r;
      if (e.isCollapsed || s) {
        const a = s || e.getFirstPosition().parent, l = gi(a);
        this._direction == "backward" ? (r = a, l && !t ? o = Ye.first(a, { sameIndent: !0, lowerIndent: !0 }) : o = a.previousSibling) : (o = a, r = a.nextSibling);
      } else
        o = e.getFirstPosition().parent, r = e.getLastPosition().parent;
      return {
        firstElement: o,
        lastElement: r
      };
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class $d extends V {
    /**
     * Creates an instance of the command.
     *
     * @param editor The editor instance.
     * @param direction Whether list item should be split before or after the selected block.
     */
    constructor(e, t) {
      super(e), this._direction = t;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      this.isEnabled = this._checkEnabled();
    }
    /**
     * Splits the list item at the selection.
     *
     * @fires execute
     * @fires afterExecute
     */
    execute() {
      this.editor.model.change((t) => {
        const i = Hl(this._getStartBlock(), t);
        this._fireAfterExecute(i);
      });
    }
    /**
     * Fires the `afterExecute` event.
     *
     * @param changedBlocks The changed list elements.
     */
    _fireAfterExecute(e) {
      this.fire("afterExecute", Ti(new Set(e)));
    }
    /**
     * Checks whether the command can be enabled in the current context.
     *
     * @returns Whether the command should be enabled.
     */
    _checkEnabled() {
      const e = this.editor.model.document.selection, t = this._getStartBlock();
      return e.isCollapsed && fe(t) && !gi(t);
    }
    /**
     * Returns the model element that is the main focus of the command (according to the current selection and command direction).
     */
    _getStartBlock() {
      const t = this.editor.model.document.selection.getFirstPosition().parent;
      return this._direction == "before" ? t : t.nextSibling;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class DR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ListUtils";
    }
    /**
     * Expands the given list of selected blocks to include all the items of the lists they're in.
     *
     * @param blocks The list of selected blocks.
     */
    expandListBlocksToCompleteList(e) {
      return VR(e);
    }
    /**
     * Check if the given block is the first in the list item.
     *
     * @param listBlock The list block element.
     */
    isFirstBlockOfListItem(e) {
      return gi(e);
    }
    /**
     * Returns true if the given model node is a list item block.
     *
     * @param node A model node.
     */
    isListItemBlock(e) {
      return fe(e);
    }
    /**
     * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.
     *
     * @param blocks The list of selected blocks.
     * @param options.withNested Whether should include nested list items.
     */
    expandListBlocksToCompleteItems(e, t = {}) {
      return ys(e, t);
    }
    /**
     * Returns true if listType is of type `numbered` or `customNumbered`.
     */
    isNumberedListType(e) {
      return OR(e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function bp(n) {
    return n.is("element", "ol") || n.is("element", "ul");
  }
  function Ro(n) {
    return n.is("element", "li");
  }
  function FR(n) {
    let e = 0, t = n.parent;
    for (; t; ) {
      if (Ro(t))
        e++;
      else {
        const i = t.previousSibling;
        i && Ro(i) && e++;
      }
      t = t.parent;
    }
    return e;
  }
  function zR(n, e, t, i = vp(t, e)) {
    return n.createAttributeElement(_p(t), null, {
      priority: 2 * e / 100 - 100,
      id: i
    });
  }
  function UR(n, e, t) {
    return n.createAttributeElement("li", null, {
      priority: (2 * e + 1) / 100 - 100,
      id: t
    });
  }
  function _p(n) {
    return n == "numbered" || n == "customNumbered" ? "ol" : "ul";
  }
  function vp(n, e) {
    return `list-${n}-${e}`;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function it(n, e) {
    const t = n.nodeBefore;
    if (fe(t)) {
      let i = t;
      for (const { node: s } of vs(i, "backward"))
        if (i = s, e.has(i))
          return;
      e.set(t, i);
    } else {
      const i = n.nodeAfter;
      fe(i) && e.set(i, i);
    }
  }
  function HR(n, e) {
    let t = 0, i = -1, s = null, o = !1;
    for (const { node: r } of n) {
      const a = r.getAttribute("listIndent");
      if (a > t) {
        let l;
        s === null ? (s = a - t, l = t) : (s > a && (s = a), l = a - s), l > i + 1 && (l = i + 1), e.setAttribute("listIndent", l, r), o = !0, i = l;
      } else
        s = null, t = a + 1, i = a;
    }
    return o;
  }
  function $R(n, e, t) {
    const i = /* @__PURE__ */ new Set();
    let s = !1;
    for (const { node: o } of n) {
      if (i.has(o))
        continue;
      let r = o.getAttribute("listType"), a = o.getAttribute("listItemId");
      if (e.has(a) && (a = on.next()), e.add(a), o.is("element", "listItem")) {
        o.getAttribute("listItemId") != a && (t.setAttribute("listItemId", a, o), s = !0);
        continue;
      }
      for (const l of Wt(o, { direction: "forward" }))
        i.add(l), l.getAttribute("listType") != r && (a = on.next(), r = l.getAttribute("listType")), l.getAttribute("listItemId") != a && (t.setAttribute("listItemId", a, l), s = !0);
    }
    return s;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function WR() {
    return (n, e, t) => {
      const { writer: i, schema: s } = t;
      if (!e.modelRange)
        return;
      const o = Array.from(e.modelRange.getItems({ shallow: !0 })).filter((d) => s.checkAttribute(d, "listItemId"));
      if (!o.length)
        return;
      const r = on.next(), a = FR(e.viewItem);
      let l = e.viewItem.parent && e.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted";
      const c = o[0].getAttribute("listType");
      c && (l = c);
      const u = {
        listItemId: r,
        listIndent: a,
        listType: l
      };
      for (const d of o)
        d.hasAttribute("listItemId") || i.setAttributes(u, d);
      o.length > 1 && o[1].getAttribute("listItemId") != u.listItemId && t.keepEmptyElement(o[0]);
    };
  }
  function Wd() {
    return (n, e, t) => {
      if (!t.consumable.test(e.viewItem, { name: !0 }))
        return;
      const i = new Mt(e.viewItem.document);
      for (const s of Array.from(e.viewItem.getChildren()))
        !Ro(s) && !bp(s) && i.remove(s);
    };
  }
  function qR(n, e, t, i) {
    return () => {
      const a = n.document.differ.getChanges(), l = [], c = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Set();
      for (const d of a)
        if (d.type == "insert" && d.name != "$text")
          it(d.position, c), d.attributes.has("listItemId") ? u.add(d.position.nodeAfter) : it(d.position.getShiftedBy(d.length), c);
        else if (d.type == "remove" && d.attributes.has("listItemId"))
          it(d.position, c);
        else if (d.type == "attribute") {
          const h = d.range.start.nodeAfter;
          t.includes(d.attributeKey) ? (it(d.range.start, c), d.attributeNewValue === null ? (it(d.range.start.getShiftedBy(1), c), o(h) && l.push(h)) : u.add(h)) : fe(h) && o(h) && l.push(h);
        }
      for (const d of c.values())
        l.push(...s(d, u));
      for (const d of new Set(l))
        e.reconvertItem(d);
    };
    function s(a, l) {
      const c = [], u = /* @__PURE__ */ new Set(), d = [];
      for (const { node: h, previous: f } of vs(a, "forward")) {
        if (u.has(h))
          continue;
        const m = h.getAttribute("listIndent");
        f && m < f.getAttribute("listIndent") && (d.length = m + 1), d[m] = Object.fromEntries(Array.from(h.getAttributes()).filter(([b]) => t.includes(b)));
        const p = Wt(h, { direction: "forward" });
        for (const b of p)
          u.add(b), (o(b, p) || r(b, d, l)) && c.push(b);
      }
      return c;
    }
    function o(a, l) {
      const c = e.mapper.toViewElement(a);
      if (!c)
        return !1;
      if (i.fire("checkElement", {
        modelElement: a,
        viewElement: c
      }))
        return !0;
      if (!a.is("element", "paragraph") && !a.is("element", "listItem"))
        return !1;
      const d = Cp(a, t, l);
      return d && c.is("element", "p") ? !0 : !!(!d && c.is("element", "span"));
    }
    function r(a, l, c) {
      if (c.has(a))
        return !1;
      const u = e.mapper.toViewElement(a);
      let d = l.length - 1;
      for (let h = u.parent; !h.is("editableElement"); h = h.parent) {
        const f = Ro(h), m = bp(h);
        if (!m && !f)
          continue;
        const p = `checkAttributes:${f ? "item" : "list"}`;
        if (i.fire(p, {
          viewElement: h,
          modelAttributes: l[d]
        }))
          break;
        if (m && (d--, d < 0))
          return !1;
      }
      return !0;
    }
  }
  function qd(n, e, t, { dataPipeline: i } = {}) {
    const s = YR(n);
    return (o, r, a) => {
      const { writer: l, mapper: c, consumable: u } = a, d = r.item;
      if (!n.includes(r.attributeKey) || !s(d, u))
        return;
      const h = jR(d, c, t);
      yp(h, l, c), JR(h, l);
      const f = ZR(d, h, e, l, { dataPipeline: i });
      XR(d, f, e, l);
    };
  }
  function GR(n) {
    return (e, t, i) => {
      const { writer: s, mapper: o } = i, r = e.name.split(":")[1];
      if (!n.checkAttribute(r, "listItemId"))
        return;
      const a = o.toViewPosition(t.position), l = t.position.getShiftedBy(t.length), c = o.toViewPosition(l, { isPhantom: !0 }), d = s.createRange(a, c).getTrimmed().end.nodeBefore;
      /* istanbul ignore next -- @preserve */
      d && yp(d, s, o);
    };
  }
  function Gd(n, { dataPipeline: e } = {}) {
    return (t, { writer: i }) => {
      if (!Cp(t, n))
        return null;
      if (!e)
        return i.createContainerElement("span", { class: "ck-list-bogus-paragraph" });
      const s = i.createContainerElement("p");
      return i.setCustomProperty("dataPipeline:transparentRendering", !0, s), s;
    };
  }
  function jR(n, e, t) {
    const i = t.createRangeOn(n);
    return e.toViewRange(i).getTrimmed().end.nodeBefore;
  }
  function KR(n, e) {
    return (t, i) => {
      if (i.modelPosition.offset > 0)
        return;
      const s = i.modelPosition.parent;
      if (!fe(s) || !n.some((c) => c.scope == "itemMarker" && c.canInjectMarkerIntoElement && c.canInjectMarkerIntoElement(s)))
        return;
      const o = i.mapper.toViewElement(s), r = e.createRangeIn(o), a = r.getWalker();
      let l = r.start;
      for (const { item: c } of a) {
        if (c.is("element") && i.mapper.toModelElement(c) || c.is("$textProxy"))
          break;
        c.is("element") && c.getCustomProperty("listItemMarker") && (l = e.createPositionAfter(c), a.skip(({ previousPosition: u }) => !u.isEqual(l)));
      }
      i.viewPosition = l;
    };
  }
  function yp(n, e, t) {
    for (; n.parent.is("attributeElement") && n.parent.getCustomProperty("listItemWrapper"); )
      e.unwrap(e.createRangeOn(n), n.parent);
    const i = [];
    s(e.createPositionBefore(n).getWalker({ direction: "backward" })), s(e.createRangeIn(n).getWalker());
    for (const o of i)
      e.remove(o);
    function s(o) {
      for (const { item: r } of o) {
        if (r.is("element") && t.toModelElement(r))
          break;
        r.is("element") && r.getCustomProperty("listItemMarker") && i.push(r);
      }
    }
  }
  function ZR(n, e, t, i, { dataPipeline: s }) {
    let o = i.createRangeOn(e);
    if (!gi(n))
      return o;
    for (const r of t) {
      if (r.scope != "itemMarker")
        continue;
      const a = r.createElement(i, n, { dataPipeline: s });
      if (!a || (i.setCustomProperty("listItemMarker", !0, a), r.canInjectMarkerIntoElement && r.canInjectMarkerIntoElement(n) ? i.insert(i.createPositionAt(e, 0), a) : (i.insert(o.start, a), o = i.createRange(i.createPositionBefore(a), i.createPositionAfter(e))), !r.createWrapperElement || !r.canWrapElement))
        continue;
      const l = r.createWrapperElement(i, n, { dataPipeline: s });
      i.setCustomProperty("listItemWrapper", !0, l), r.canWrapElement(n) ? o = i.wrap(o, l) : (o = i.wrap(i.createRangeOn(a), l), o = i.createRange(o.start, i.createPositionAfter(e)));
    }
    return o;
  }
  function JR(n, e) {
    let t = n.parent;
    for (; t.is("attributeElement") && ["ul", "ol", "li"].includes(t.name); ) {
      const i = t.parent;
      e.unwrap(e.createRangeOn(n), t), t = i;
    }
  }
  function XR(n, e, t, i) {
    if (!n.hasAttribute("listIndent"))
      return;
    const s = n.getAttribute("listIndent");
    let o = n;
    for (let r = s; r >= 0; r--) {
      const a = UR(i, r, o.getAttribute("listItemId")), l = zR(i, r, o.getAttribute("listType"));
      for (const c of t)
        (c.scope == "list" || c.scope == "item") && o.hasAttribute(c.attributeName) && c.setAttributeOnDowncast(i, o.getAttribute(c.attributeName), c.scope == "list" ? l : a);
      if (e = i.wrap(e, a), e = i.wrap(e, l), r == 0 || (o = Ye.first(o, { lowerIndent: !0 }), !o))
        break;
    }
  }
  function YR(n) {
    return (e, t) => {
      const i = [];
      for (const s of n)
        e.hasAttribute(s) && i.push(`attribute:${s}`);
      return i.every((s) => t.test(e, s) !== !1) ? (i.forEach((s) => t.consume(e, s)), !0) : !1;
    };
  }
  function Cp(n, e, t = Ul(n)) {
    if (!fe(n))
      return !1;
    for (const i of n.getAttributeKeys())
      if (!i.startsWith("selection:") && !e.includes(i))
        return !1;
    return t.length < 2;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const co = ["listType", "listIndent", "listItemId"];
  class QR extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ListEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [lr, bt, DR, Xe];
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._downcastStrategies = [], e.config.define("list.multiBlock", !0);
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model, i = e.config.get("list.multiBlock");
      if (e.plugins.has("LegacyListEditing"))
        throw new g("list-feature-conflict", this, { conflictPlugin: "LegacyListEditing" });
      t.schema.register("$listItem", { allowAttributes: co }), i ? (t.schema.extend("$container", { allowAttributesOf: "$listItem" }), t.schema.extend("$block", { allowAttributesOf: "$listItem" }), t.schema.extend("$blockObject", { allowAttributesOf: "$listItem" })) : t.schema.register("listItem", {
        inheritAllFrom: "$block",
        allowAttributesOf: "$listItem"
      });
      for (const s of co)
        t.schema.setAttributeProperties(s, {
          copyOnReplace: !0
        });
      e.commands.add("numberedList", new Xs(e, "numbered")), e.commands.add("bulletedList", new Xs(e, "bulleted")), e.commands.add("customNumberedList", new Xs(e, "customNumbered", { multiLevel: !0 })), e.commands.add("customBulletedList", new Xs(e, "customBulleted", { multiLevel: !0 })), e.commands.add("indentList", new zd(e, "forward")), e.commands.add("outdentList", new zd(e, "backward")), e.commands.add("splitListItemBefore", new $d(e, "before")), e.commands.add("splitListItemAfter", new $d(e, "after")), i && (e.commands.add("mergeListItemBackward", new Hd(e, "backward")), e.commands.add("mergeListItemForward", new Hd(e, "forward"))), this._setupDeleteIntegration(), this._setupEnterIntegration(), this._setupTabIntegration(), this._setupClipboardIntegration(), this._setupAccessibilityIntegration();
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      const t = this.editor.commands, i = t.get("indent"), s = t.get("outdent");
      i && i.registerChildCommand(t.get("indentList"), { priority: "high" }), s && s.registerChildCommand(t.get("outdentList"), { priority: "lowest" }), this._setupModelPostFixing(), this._setupConversion();
    }
    /**
     * Registers a downcast strategy.
     *
     * **Note**: Strategies must be registered in the `Plugin#init()` phase so that it can be applied
     * in the `ListEditing#afterInit()`.
     *
     * @param strategy The downcast strategy to register.
     */
    registerDowncastStrategy(e) {
      this._downcastStrategies.push(e);
    }
    /**
     * Returns list of model attribute names that should affect downcast conversion.
     */
    getListAttributeNames() {
      return [
        ...co,
        ...this._downcastStrategies.map((e) => e.attributeName)
      ];
    }
    /**
     * Attaches the listener to the {@link module:engine/view/document~Document#event:delete} event and handles backspace/delete
     * keys in and around document lists.
     */
    _setupDeleteIntegration() {
      const e = this.editor, t = e.commands.get("mergeListItemBackward"), i = e.commands.get("mergeListItemForward");
      this.listenTo(e.editing.view.document, "delete", (s, o) => {
        const r = e.model.document.selection;
        us(e.model) || e.model.change(() => {
          const a = r.getFirstPosition();
          if (r.isCollapsed && o.direction == "backward") {
            if (!a.isAtStart)
              return;
            const l = a.parent;
            if (!fe(l))
              return;
            if (!Ye.first(l, {
              sameAttributes: "listType",
              sameIndent: !0
            }) && l.getAttribute("listIndent") === 0)
              Fd(l) || e.execute("splitListItemAfter"), e.execute("outdentList");
            else {
              if (!t || !t.isEnabled)
                return;
              t.execute({
                shouldMergeOnBlocksContentLevel: jd(e.model, "backward")
              });
            }
            o.preventDefault(), s.stop();
          } else {
            if (r.isCollapsed && !r.getLastPosition().isAtEnd || !i || !i.isEnabled)
              return;
            i.execute({
              shouldMergeOnBlocksContentLevel: jd(e.model, "forward")
            }), o.preventDefault(), s.stop();
          }
        });
      }, { context: "li" });
    }
    /**
     * Attaches a listener to the {@link module:engine/view/document~Document#event:enter} event and handles enter key press
     * in document lists.
     */
    _setupEnterIntegration() {
      const e = this.editor, t = e.model, i = e.commands, s = i.get("enter");
      this.listenTo(e.editing.view.document, "enter", (o, r) => {
        const a = t.document, l = a.selection.getFirstPosition().parent;
        if (a.selection.isCollapsed && fe(l) && l.isEmpty && !r.isSoft) {
          const c = gi(l), u = Fd(l);
          c && u ? (e.execute("outdentList"), r.preventDefault(), o.stop()) : c && !u ? (e.execute("splitListItemAfter"), r.preventDefault(), o.stop()) : u && (e.execute("splitListItemBefore"), r.preventDefault(), o.stop());
        }
      }, { context: "li" }), this.listenTo(s, "afterExecute", () => {
        const o = i.get("splitListItemBefore");
        if (o.refresh(), !o.isEnabled)
          return;
        const a = e.model.document.selection.getLastPosition().parent;
        Ul(a).length === 2 && o.execute();
      });
    }
    /**
     * Attaches a listener to the {@link module:engine/view/document~Document#event:tab} event and handles tab key and tab+shift keys
     * presses in document lists.
     */
    _setupTabIntegration() {
      const e = this.editor;
      this.listenTo(e.editing.view.document, "tab", (t, i) => {
        const s = i.shiftKey ? "outdentList" : "indentList";
        this.editor.commands.get(s).isEnabled && (e.execute(s), i.stopPropagation(), i.preventDefault(), t.stop());
      }, { context: "li" });
    }
    /**
     * Registers the conversion helpers for the document-list feature.
     */
    _setupConversion() {
      const e = this.editor, t = e.model, i = this.getListAttributeNames(), s = e.config.get("list.multiBlock"), o = s ? "paragraph" : "listItem";
      e.conversion.for("upcast").elementToElement({
        view: "li",
        model: (a, { writer: l }) => l.createElement(o, { listType: "" })
      }).elementToElement({
        view: "p",
        model: (a, { writer: l }) => a.parent && a.parent.is("element", "li") ? l.createElement(o, { listType: "" }) : null,
        converterPriority: "high"
      }).add((a) => {
        a.on("element:li", WR()), a.on("element:ul", Wd(), { priority: "high" }), a.on("element:ol", Wd(), { priority: "high" });
      }), s || e.conversion.for("downcast").elementToElement({
        model: "listItem",
        view: "p"
      }), e.conversion.for("editingDowncast").elementToElement({
        model: o,
        view: Gd(i),
        converterPriority: "high"
      }).add((a) => {
        a.on("attribute", qd(i, this._downcastStrategies, t)), a.on("remove", GR(t.schema));
      }), e.conversion.for("dataDowncast").elementToElement({
        model: o,
        view: Gd(i, { dataPipeline: !0 }),
        converterPriority: "high"
      }).add((a) => {
        a.on("attribute", qd(i, this._downcastStrategies, t, { dataPipeline: !0 }));
      });
      const r = KR(this._downcastStrategies, e.editing.view);
      e.editing.mapper.on("modelToViewPosition", r), e.data.mapper.on("modelToViewPosition", r), this.listenTo(t.document, "change:data", qR(t, e.editing, i, this), { priority: "high" }), this.on("checkAttributes:item", (a, { viewElement: l, modelAttributes: c }) => {
        l.id != c.listItemId && (a.return = !0, a.stop());
      }), this.on("checkAttributes:list", (a, { viewElement: l, modelAttributes: c }) => {
        (l.name != _p(c.listType) || l.id != vp(c.listType, c.listIndent)) && (a.return = !0, a.stop());
      });
    }
    /**
     * Registers model post-fixers.
     */
    _setupModelPostFixing() {
      const e = this.editor.model, t = this.getListAttributeNames();
      e.document.registerPostFixer((i) => eL(e, i, t, this)), this.on("postFixer", (i, { listNodes: s, writer: o }) => {
        i.return = HR(s, o) || i.return;
      }, { priority: "high" }), this.on("postFixer", (i, { listNodes: s, writer: o, seenIds: r }) => {
        i.return = $R(s, r, o) || i.return;
      }, { priority: "high" });
    }
    /**
     * Integrates the feature with the clipboard via {@link module:engine/model/model~Model#insertContent} and
     * {@link module:engine/model/model~Model#getSelectedContent}.
     */
    _setupClipboardIntegration() {
      const e = this.editor.model, t = this.editor.plugins.get("ClipboardPipeline");
      this.listenTo(e, "insertContent", tL(e), { priority: "high" }), this.listenTo(t, "outputTransformation", (i, s) => {
        e.change((o) => {
          const r = Array.from(s.content.getChildren()), a = r[r.length - 1];
          if (r.length > 1 && a.is("element") && a.isEmpty && r.slice(0, -1).every(fe) && o.remove(a), s.method == "copy" || s.method == "cut") {
            const l = Array.from(s.content.getChildren());
            cs(l) && dr(l, o);
          }
        });
      });
    }
    /**
     * Informs editor accessibility features about keystrokes brought by the plugin.
     */
    _setupAccessibilityIntegration() {
      const e = this.editor, t = e.t;
      e.accessibility.addKeystrokeInfoGroup({
        id: "list",
        label: t("Keystrokes that can be used in a list"),
        keystrokes: [
          {
            label: t("Increase list item indent"),
            keystroke: "Tab"
          },
          {
            label: t("Decrease list item indent"),
            keystroke: "Shift+Tab"
          }
        ]
      });
    }
  }
  function eL(n, e, t, i) {
    const s = n.document.differ.getChanges(), o = /* @__PURE__ */ new Map(), r = i.editor.config.get("list.multiBlock");
    let a = !1;
    for (const c of s) {
      if (c.type == "insert" && c.name != "$text") {
        const u = c.position.nodeAfter;
        if (!n.schema.checkAttribute(u, "listItemId"))
          for (const d of Array.from(u.getAttributeKeys()))
            t.includes(d) && (e.removeAttribute(d, u), a = !0);
        it(c.position, o), c.attributes.has("listItemId") || it(c.position.getShiftedBy(c.length), o);
        for (const { item: d, previousPosition: h } of n.createRangeIn(u))
          fe(d) && it(h, o);
      } else
        c.type == "remove" ? it(c.position, o) : c.type == "attribute" && t.includes(c.attributeKey) && (it(c.range.start, o), c.attributeNewValue === null && it(c.range.start.getShiftedBy(1), o));
      if (!r && c.type == "attribute" && co.includes(c.attributeKey)) {
        const u = c.range.start.nodeAfter;
        c.attributeNewValue === null && u && u.is("element", "listItem") ? (e.rename(u, "paragraph"), a = !0) : c.attributeOldValue === null && u && u.is("element") && u.name != "listItem" && (e.rename(u, "listItem"), a = !0);
      }
    }
    const l = /* @__PURE__ */ new Set();
    for (const c of o.values())
      a = i.fire("postFixer", {
        listNodes: new RR(c),
        listHead: c,
        writer: e,
        seenIds: l
      }) || a;
    return a;
  }
  function tL(n) {
    return (e, [t, i]) => {
      const s = t.is("documentFragment") ? Array.from(t.getChildren()) : [t];
      if (!s.length)
        return;
      const r = (i ? n.createSelection(i) : n.document.selection).getFirstPosition();
      let a;
      if (fe(r.parent))
        a = r.parent;
      else if (fe(r.nodeBefore))
        a = r.nodeBefore;
      else
        return;
      n.change((l) => {
        const c = a.getAttribute("listType"), u = a.getAttribute("listIndent"), d = s[0].getAttribute("listIndent") || 0, h = Math.max(u - d, 0);
        for (const f of s) {
          const m = fe(f);
          a.is("element", "listItem") && f.is("element", "paragraph") && l.rename(f, "listItem"), l.setAttributes({
            listIndent: (m ? f.getAttribute("listIndent") : 0) + h,
            listItemId: m ? f.getAttribute("listItemId") : on.next(),
            listType: c
          }, f);
        }
      });
    };
  }
  function jd(n, e) {
    const t = n.document.selection;
    if (!t.isCollapsed)
      return !us(n);
    if (e === "forward")
      return !0;
    const s = t.getFirstPosition().parent, o = s.previousSibling;
    return n.schema.isObject(o) ? !1 : o.isEmpty ? !0 : cs([s, o]);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Kd(n, e, t, i) {
    n.ui.componentFactory.add(e, () => {
      const s = Zd(P, n, e, t, i);
      return s.set({
        tooltip: !0,
        isToggleable: !0
      }), s;
    }), n.ui.componentFactory.add(`menuBar:${e}`, () => Zd(de, n, e, t, i));
  }
  function Zd(n, e, t, i, s) {
    const o = e.commands.get(t), r = new n(e.locale);
    return r.set({
      label: i,
      icon: s
    }), r.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), r.on("execute", () => {
      e.execute(t), e.editing.view.focus();
    }), r;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class iL extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ListUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor.t;
      Kd(this.editor, "numberedList", e("Numbered List"), x.numberedList), Kd(this.editor, "bulletedList", e("Bulleted List"), x.bulletedList);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class nL extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [QR, iL];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "List";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const sL = [
    { listStyle: "disc", typeAttribute: "disc", listType: "bulleted" },
    { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" },
    { listStyle: "square", typeAttribute: "square", listType: "bulleted" },
    { listStyle: "decimal", typeAttribute: "1", listType: "numbered" },
    { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" },
    { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" },
    { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" },
    { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" },
    { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" },
    { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" },
    { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }
  ];
  for (const { listStyle: n, typeAttribute: e, listType: t } of sL)
    ;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  gs("Ctrl+Enter");
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  gs("Ctrl+Enter");
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class oL extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "IndentEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.commands.add("indent", new Kc(e)), e.commands.add("outdent", new Kc(e));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class rL extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "IndentUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.locale, i = e.t, s = t.uiLanguageDirection == "ltr" ? x.indent : x.outdent, o = t.uiLanguageDirection == "ltr" ? x.outdent : x.indent;
      this._defineButton("indent", i("Increase indent"), s), this._defineButton("outdent", i("Decrease indent"), o);
    }
    /**
     * Defines UI buttons for both toolbar and menu bar.
     */
    _defineButton(e, t, i) {
      const s = this.editor;
      s.ui.componentFactory.add(e, () => {
        const o = this._createButton(P, e, t, i);
        return o.set({
          tooltip: !0
        }), o;
      }), s.ui.componentFactory.add("menuBar:" + e, () => this._createButton(de, e, t, i));
    }
    /**
     * Creates a button to use either in toolbar or in menu bar.
     */
    _createButton(e, t, i, s) {
      const o = this.editor, r = o.commands.get(t), a = new e(o.locale);
      return a.set({
        label: i,
        icon: s
      }), a.bind("isEnabled").to(r, "isEnabled"), this.listenTo(a, "execute", () => {
        o.execute(t), o.editing.view.focus();
      }), a;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class aL extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Indent";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [oL, rL];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ys extends V {
    /**
     * Creates an instance of the command.
     */
    constructor(e, t) {
      super(e), this._indentBehavior = t;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const t = this.editor.model, i = me(t.document.selection.getSelectedBlocks());
      if (!i || !this._isIndentationChangeAllowed(i)) {
        this.isEnabled = !1;
        return;
      }
      this.isEnabled = this._indentBehavior.checkEnabled(i.getAttribute("blockIndent"));
    }
    /**
     * @inheritDoc
     */
    execute() {
      const e = this.editor.model, t = this._getBlocksToChange();
      e.change((i) => {
        for (const s of t) {
          const o = s.getAttribute("blockIndent"), r = this._indentBehavior.getNextIndent(o);
          r ? i.setAttribute("blockIndent", r, s) : i.removeAttribute("blockIndent", s);
        }
      });
    }
    /**
     * Returns blocks from selection that should have blockIndent selection set.
     */
    _getBlocksToChange() {
      const t = this.editor.model.document.selection;
      return Array.from(t.getSelectedBlocks()).filter((s) => this._isIndentationChangeAllowed(s));
    }
    /**
     * Returns false if indentation cannot be applied, i.e.:
     * - for blocks disallowed by schema declaration
     * - for blocks in Document Lists (disallowed forward indentation only). See https://github.com/ckeditor/ckeditor5/issues/14155.
     * Otherwise returns true.
     */
    _isIndentationChangeAllowed(e) {
      const t = this.editor;
      return t.model.schema.checkAttribute(e, "blockIndent") ? !t.plugins.has("ListUtils") || !this._indentBehavior.isForward ? !0 : !t.plugins.get("ListUtils").isListItemBlock(e) : !1;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Jd {
    /**
     * Creates an instance of the indentation behavior.
     *
     * @param config.direction The direction of indentation.
     * @param config.offset The offset of the next indentation step.
     * @param config.unit Indentation unit.
     */
    constructor(e) {
      this.isForward = e.direction === "forward", this.offset = e.offset, this.unit = e.unit;
    }
    /**
     * @inheritDoc
     */
    checkEnabled(e) {
      const t = parseFloat(e || "0");
      return this.isForward || t > 0;
    }
    /**
     * @inheritDoc
     */
    getNextIndent(e) {
      const t = parseFloat(e || "0");
      if (!(!e || e.endsWith(this.unit)))
        return this.isForward ? this.offset + this.unit : void 0;
      const s = this.isForward ? this.offset : -this.offset, o = t + s;
      return o > 0 ? o + this.unit : void 0;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Xd {
    /**
     * Creates an instance of the indentation behavior.
     *
     * @param config.direction The direction of indentation.
     * @param config.classes A list of classes used for indentation.
     */
    constructor(e) {
      this.isForward = e.direction === "forward", this.classes = e.classes;
    }
    /**
     * @inheritDoc
     */
    checkEnabled(e) {
      const t = this.classes.indexOf(e);
      return this.isForward ? t < this.classes.length - 1 : t >= 0;
    }
    /**
     * @inheritDoc
     */
    getNextIndent(e) {
      const t = this.classes.indexOf(e), i = this.isForward ? 1 : -1;
      return this.classes[t + i];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const lL = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
  class cL extends w {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("indentBlock", {
        offset: 40,
        unit: "px"
      });
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "IndentBlock";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.config.get("indentBlock");
      t.classes && t.classes.length ? (this._setupConversionUsingClasses(t.classes), e.commands.add("indentBlock", new Ys(e, new Xd({
        direction: "forward",
        classes: t.classes
      }))), e.commands.add("outdentBlock", new Ys(e, new Xd({
        direction: "backward",
        classes: t.classes
      })))) : (e.data.addStyleProcessorRules(NE), this._setupConversionUsingOffset(), e.commands.add("indentBlock", new Ys(e, new Jd({
        direction: "forward",
        offset: t.offset,
        unit: t.unit
      }))), e.commands.add("outdentBlock", new Ys(e, new Jd({
        direction: "backward",
        offset: t.offset,
        unit: t.unit
      }))));
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      const e = this.editor, t = e.model.schema, i = e.commands.get("indent"), s = e.commands.get("outdent"), o = e.config.get("heading.options");
      (o && o.map((l) => l.model) || lL).forEach((l) => {
        t.isRegistered(l) && t.extend(l, { allowAttributes: "blockIndent" });
      }), t.setAttributeProperties("blockIndent", { isFormatting: !0 }), i.registerChildCommand(e.commands.get("indentBlock")), s.registerChildCommand(e.commands.get("outdentBlock"));
    }
    /**
     * Setups conversion for using offset indents.
     */
    _setupConversionUsingOffset() {
      const e = this.editor.conversion, i = this.editor.locale.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
      e.for("upcast").attributeToAttribute({
        view: {
          styles: {
            [i]: /[\s\S]+/
          }
        },
        model: {
          key: "blockIndent",
          value: (s) => {
            if (!s.is("element", "li"))
              return s.getStyle(i);
          }
        }
      }), e.for("downcast").attributeToAttribute({
        model: "blockIndent",
        view: (s) => ({
          key: "style",
          value: {
            [i]: s
          }
        })
      });
    }
    /**
     * Setups conversion for using classes.
     */
    _setupConversionUsingClasses(e) {
      const t = {
        model: {
          key: "blockIndent",
          values: []
        },
        view: {}
      };
      for (const i of e)
        t.model.values.push(i), t.view[i] = {
          key: "class",
          value: [i]
        };
      this.editor.conversion.attributeToAttribute(t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class uL extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = e.schema, i = e.document.selection;
      this.isEnabled = dL(i, t, e);
    }
    /**
     * Executes the command.
     *
     * @fires execute
     */
    execute() {
      const e = this.editor.model;
      e.change((t) => {
        const i = t.createElement("horizontalLine");
        e.insertObject(i, null, null, { setSelection: "after" });
      });
    }
  }
  function dL(n, e, t) {
    const i = hL(n, t);
    return e.checkChild(i, "horizontalLine");
  }
  function hL(n, e) {
    const i = Bl(n, e).start.parent;
    return i.isEmpty && !i.is("element", "$root") ? i.parent : i;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class fL extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "HorizontalLineEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.schema, i = e.t, s = e.conversion;
      t.register("horizontalLine", {
        inheritAllFrom: "$blockObject"
      }), s.for("dataDowncast").elementToElement({
        model: "horizontalLine",
        view: (o, { writer: r }) => r.createEmptyElement("hr")
      }), s.for("editingDowncast").elementToStructure({
        model: "horizontalLine",
        view: (o, { writer: r }) => {
          const a = i("Horizontal line"), l = r.createContainerElement("div", null, r.createEmptyElement("hr"));
          return r.addClass("ck-horizontal-line", l), r.setCustomProperty("hr", !0, l), mL(l, r, a);
        }
      }), s.for("upcast").elementToElement({ view: "hr", model: "horizontalLine" }), e.commands.add("horizontalLine", new uL(e));
    }
  }
  function mL(n, e, t) {
    return e.setCustomProperty("horizontalLine", !0, n), cr(n, e, { label: t });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class gL extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "HorizontalLineUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.ui.componentFactory.add("horizontalLine", () => {
        const t = this._createButton(P);
        return t.set({
          tooltip: !0
        }), t;
      }), e.ui.componentFactory.add("menuBar:horizontalLine", () => this._createButton(de));
    }
    /**
     * Creates a button for horizontal line command to use either in toolbar or in menu bar.
     */
    _createButton(e) {
      const t = this.editor, i = t.locale, s = t.commands.get("horizontalLine"), o = new e(t.locale), r = i.t;
      return o.set({
        label: r("Horizontal line"),
        icon: x.horizontalLine
      }), o.bind("isEnabled").to(s, "isEnabled"), this.listenTo(o, "execute", () => {
        t.execute("horizontalLine"), t.editing.view.focus();
      }), o;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class pL extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [fL, gL, gn];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "HorizontalLine";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class wL extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      this.value = this._getValue(), this.isEnabled = this._checkEnabled();
    }
    /**
     * Executes the command. When the command {@link #value is on}, all top-most block quotes within
     * the selection will be removed. If it is off, all selected blocks will be wrapped with
     * a block quote.
     *
     * @fires execute
     * @param options Command options.
     * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a block quote,
     * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.
     */
    execute(e = {}) {
      const t = this.editor.model, i = t.schema, s = t.document.selection, o = Array.from(s.getSelectedBlocks()), r = e.forceValue === void 0 ? !this.value : e.forceValue;
      t.change((a) => {
        if (!r)
          this._removeQuote(a, o.filter(Qs));
        else {
          const l = o.filter((c) => Qs(c) || Qd(i, c));
          this._applyQuote(a, l);
        }
      });
    }
    /**
     * Checks the command's {@link #value}.
     */
    _getValue() {
      const e = this.editor.model.document.selection, t = me(e.getSelectedBlocks());
      return !!(t && Qs(t));
    }
    /**
     * Checks whether the command can be enabled in the current context.
     *
     * @returns Whether the command should be enabled.
     */
    _checkEnabled() {
      if (this.value)
        return !0;
      const e = this.editor.model.document.selection, t = this.editor.model.schema, i = me(e.getSelectedBlocks());
      return i ? Qd(t, i) : !1;
    }
    /**
     * Removes the quote from given blocks.
     *
     * If blocks which are supposed to be "unquoted" are in the middle of a quote,
     * start it or end it, then the quote will be split (if needed) and the blocks
     * will be moved out of it, so other quoted blocks remained quoted.
     */
    _removeQuote(e, t) {
      Yd(e, t).reverse().forEach((i) => {
        if (i.start.isAtStart && i.end.isAtEnd) {
          e.unwrap(i.start.parent);
          return;
        }
        if (i.start.isAtStart) {
          const o = e.createPositionBefore(i.start.parent);
          e.move(i, o);
          return;
        }
        i.end.isAtEnd || e.split(i.end);
        const s = e.createPositionAfter(i.end.parent);
        e.move(i, s);
      });
    }
    /**
     * Applies the quote to given blocks.
     */
    _applyQuote(e, t) {
      const i = [];
      Yd(e, t).reverse().forEach((s) => {
        let o = Qs(s.start);
        o || (o = e.createElement("blockQuote"), e.wrap(s, o)), i.push(o);
      }), i.reverse().reduce((s, o) => s.nextSibling == o ? (e.merge(e.createPositionAfter(s)), s) : o);
    }
  }
  function Qs(n) {
    return n.parent.name == "blockQuote" ? n.parent : null;
  }
  function Yd(n, e) {
    let t, i = 0;
    const s = [];
    for (; i < e.length; ) {
      const o = e[i], r = e[i + 1];
      t || (t = n.createPositionBefore(o)), (!r || o.nextSibling != r) && (s.push(n.createRange(t, n.createPositionAfter(o))), t = null), i++;
    }
    return s;
  }
  function Qd(n, e) {
    const t = n.checkChild(e.parent, "blockQuote"), i = n.checkChild(["$root", "blockQuote"], e);
    return t && i;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class bL extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "BlockQuoteEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [lr, bt];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.schema;
      e.commands.add("blockQuote", new wL(e)), t.register("blockQuote", {
        inheritAllFrom: "$container"
      }), e.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), e.model.document.registerPostFixer((r) => {
        const a = e.model.document.differ.getChanges();
        for (const l of a)
          if (l.type == "insert") {
            const c = l.position.nodeAfter;
            if (!c)
              continue;
            if (c.is("element", "blockQuote") && c.isEmpty)
              return r.remove(c), !0;
            if (c.is("element", "blockQuote") && !t.checkChild(l.position, c))
              return r.unwrap(c), !0;
            if (c.is("element")) {
              const u = r.createRangeIn(c);
              for (const d of u.getItems())
                if (d.is("element", "blockQuote") && !t.checkChild(r.createPositionBefore(d), d))
                  return r.unwrap(d), !0;
            }
          } else if (l.type == "remove") {
            const c = l.position.parent;
            if (c.is("element", "blockQuote") && c.isEmpty)
              return r.remove(c), !0;
          }
        return !1;
      });
      const i = this.editor.editing.view.document, s = e.model.document.selection, o = e.commands.get("blockQuote");
      this.listenTo(i, "enter", (r, a) => {
        if (!s.isCollapsed || !o.value)
          return;
        s.getLastPosition().parent.isEmpty && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), r.stop());
      }, { context: "blockquote" }), this.listenTo(i, "delete", (r, a) => {
        if (a.direction != "backward" || !s.isCollapsed || !o.value)
          return;
        const l = s.getLastPosition().parent;
        l.isEmpty && !l.previousSibling && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), r.stop());
      }, { context: "blockquote" });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class _L extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "BlockQuoteUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.commands.get("blockQuote");
      e.ui.componentFactory.add("blockQuote", () => {
        const i = this._createButton(P);
        return i.set({
          tooltip: !0
        }), i.bind("isOn").to(t, "value"), i;
      }), e.ui.componentFactory.add("menuBar:blockQuote", () => this._createButton(de));
    }
    /**
     * Creates a button for block quote command to use either in toolbar or in menu bar.
     */
    _createButton(e) {
      const t = this.editor, i = t.locale, s = t.commands.get("blockQuote"), o = new e(t.locale), r = i.t;
      return o.set({
        label: r("Block quote"),
        icon: x.quote,
        isToggleable: !0
      }), o.bind("isEnabled").to(s, "isEnabled"), this.listenTo(o, "execute", () => {
        t.execute("blockQuote"), t.editing.view.focus();
      }), o;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class vL extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [bL, _L];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "BlockQuote";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class yL {
    constructor() {
      this._definitions = /* @__PURE__ */ new Set();
    }
    /**
     * Gives information about the number of decorators stored in the {@link module:link/utils/automaticdecorators~AutomaticDecorators}
     * instance.
     */
    get length() {
      return this._definitions.size;
    }
    /**
     * Adds automatic decorator objects or an array with them to be used during downcasting.
     *
     * @param item A configuration object of automatic rules for decorating links. It might also be an array of such objects.
     */
    add(e) {
      Array.isArray(e) ? e.forEach((t) => this._definitions.add(t)) : this._definitions.add(e);
    }
    /**
     * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
     *
     * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
     */
    getDispatcher() {
      return (e) => {
        e.on("attribute:linkHref", (t, i, s) => {
          if (!s.consumable.test(i.item, "attribute:linkHref") || !(i.item.is("selection") || s.schema.isInline(i.item)))
            return;
          const o = s.writer, r = o.document.selection;
          for (const a of this._definitions) {
            const l = o.createAttributeElement("a", a.attributes, {
              priority: 5
            });
            a.classes && o.addClass(a.classes, l);
            for (const c in a.styles)
              o.setStyle(c, a.styles[c], l);
            o.setCustomProperty("link", !0, l), a.callback(i.attributeNewValue) ? i.item.is("selection") ? o.wrap(r.getFirstRange(), l) : o.wrap(s.mapper.toViewRange(i.range), l) : o.unwrap(s.mapper.toViewRange(i.range), l);
          }
        }, { priority: "high" });
      };
    }
    /**
     * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method
     * when linking images.
     *
     * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
     */
    getDispatcherForLinkedImage() {
      return (e) => {
        e.on("attribute:linkHref:imageBlock", (t, i, { writer: s, mapper: o }) => {
          const r = o.toViewElement(i.item), a = Array.from(r.getChildren()).find((l) => l.is("element", "a"));
          for (const l of this._definitions) {
            const c = wt(l.attributes);
            if (l.callback(i.attributeNewValue)) {
              for (const [u, d] of c)
                u === "class" ? s.addClass(d, a) : s.setAttribute(u, d, a);
              l.classes && s.addClass(l.classes, a);
              for (const u in l.styles)
                s.setStyle(u, l.styles[u], a);
            } else {
              for (const [u, d] of c)
                u === "class" ? s.removeClass(d, a) : s.removeAttribute(u, a);
              l.classes && s.removeClass(l.classes, a);
              for (const u in l.styles)
                s.removeStyle(u, a);
            }
          }
        });
      };
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const CL = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, kL = "^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))", TL = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, EL = /^((\w+:(\/{2,})?)|(\W))/i, AL = [
    "https?",
    "ftps?",
    "mailto"
  ], Ln = "Ctrl+K";
  function xL(n) {
    return n.is("attributeElement") && !!n.getCustomProperty("link");
  }
  function eh(n, { writer: e }) {
    const t = e.createAttributeElement("a", { href: n }, { priority: 5 });
    return e.setCustomProperty("link", !0, t), t;
  }
  function kp(n, e = AL) {
    const t = String(n), i = e.join("|"), s = new RegExp(`${kL.replace("<protocols>", i)}`, "i");
    return SL(t, s) ? t : "#";
  }
  function SL(n, e) {
    return !!n.replace(CL, "").match(e);
  }
  function IL(n, e) {
    const t = {
      "Open in a new tab": n("Open in a new tab"),
      Downloadable: n("Downloadable")
    };
    return e.forEach((i) => ("label" in i && t[i.label] && (i.label = t[i.label]), i)), e;
  }
  function PL(n) {
    const e = [];
    if (n)
      for (const [t, i] of Object.entries(n)) {
        const s = Object.assign({}, i, { id: `link${i_(t)}` });
        e.push(s);
      }
    return e;
  }
  function Sa(n, e) {
    return n ? e.checkAttribute(n.name, "linkHref") : !1;
  }
  function RL(n) {
    return TL.test(n);
  }
  function $l(n, e) {
    const t = RL(n) ? "mailto:" : e, i = !!t && !Tp(n);
    return n && i ? t + n : n;
  }
  function Tp(n) {
    return EL.test(n);
  }
  function th(n) {
    window.open(n, "_blank", "noopener");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class LL extends V {
    constructor() {
      super(...arguments), this.manualDecorators = new Ce(), this.automaticDecorators = new yL();
    }
    /**
     * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
     */
    restoreManualDecoratorStates() {
      for (const e of this.manualDecorators)
        e.value = this._getDecoratorStateFromModel(e.id);
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = e.document.selection, i = t.getSelectedElement() || me(t.getSelectedBlocks());
      Sa(i, e.schema) ? (this.value = i.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttribute(i, "linkHref")) : (this.value = t.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
      for (const s of this.manualDecorators)
        s.value = this._getDecoratorStateFromModel(s.id);
    }
    /**
     * Executes the command.
     *
     * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
     * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
     *
     * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
     * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
     * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
     * The selection will be updated to wrap the just inserted text node.
     *
     * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
     *
     * # Decorators and model attribute management
     *
     * There is an optional argument to this command that applies or removes model
     * {@glink framework/architecture/editing-engine#text-attributes text attributes} brought by
     * {@link module:link/utils/manualdecorator~ManualDecorator manual link decorators}.
     *
     * Text attribute names in the model correspond to the entries in the {@link module:link/linkconfig~LinkConfig#decorators
     * configuration}.
     * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
     * corresponds to `'myDecorator'` in the configuration.
     *
     * To learn more about link decorators, check out the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`}
     * documentation.
     *
     * Here is how to manage decorator attributes with the link command:
     *
     * ```ts
     * const linkCommand = editor.commands.get( 'link' );
     *
     * // Adding a new decorator attribute.
     * linkCommand.execute( 'http://example.com', {
     * 	linkIsExternal: true
     * } );
     *
     * // Removing a decorator attribute from the selection.
     * linkCommand.execute( 'http://example.com', {
     * 	linkIsExternal: false
     * } );
     *
     * // Adding multiple decorator attributes at the same time.
     * linkCommand.execute( 'http://example.com', {
     * 	linkIsExternal: true,
     * 	linkIsDownloadable: true,
     * } );
     *
     * // Removing and adding decorator attributes at the same time.
     * linkCommand.execute( 'http://example.com', {
     * 	linkIsExternal: false,
     * 	linkFoo: true,
     * 	linkIsDownloadable: false,
     * } );
     * ```
     *
     * **Note**: If the decorator attribute name is not specified, its state remains untouched.
     *
     * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
     * decorator attributes.
     *
     * @fires execute
     * @param href Link destination.
     * @param manualDecoratorIds The information about manual decorator attributes to be applied or removed upon execution.
     */
    execute(e, t = {}) {
      const i = this.editor.model, s = i.document.selection, o = [], r = [];
      for (const a in t)
        t[a] ? o.push(a) : r.push(a);
      i.change((a) => {
        if (s.isCollapsed) {
          const l = s.getFirstPosition();
          if (s.hasAttribute("linkHref")) {
            const c = ih(s);
            let u = ar(l, "linkHref", s.getAttribute("linkHref"), i);
            s.getAttribute("linkHref") === c && (u = this._updateLinkContent(i, a, u, e)), a.setAttribute("linkHref", e, u), o.forEach((d) => {
              a.setAttribute(d, !0, u);
            }), r.forEach((d) => {
              a.removeAttribute(d, u);
            }), a.setSelection(a.createPositionAfter(u.end.nodeBefore));
          } else if (e !== "") {
            const c = wt(s.getAttributes());
            c.set("linkHref", e), o.forEach((d) => {
              c.set(d, !0);
            });
            const { end: u } = i.insertContent(a.createText(e, c), l);
            a.setSelection(u);
          }
          ["linkHref", ...o, ...r].forEach((c) => {
            a.removeSelectionAttribute(c);
          });
        } else {
          const l = i.schema.getValidRanges(s.getRanges(), "linkHref"), c = [];
          for (const d of s.getSelectedBlocks())
            i.schema.checkAttribute(d, "linkHref") && c.push(a.createRangeOn(d));
          const u = c.slice();
          for (const d of l)
            this._isRangeToUpdate(d, c) && u.push(d);
          for (const d of u) {
            let h = d;
            if (u.length === 1) {
              const f = ih(s);
              s.getAttribute("linkHref") === f && (h = this._updateLinkContent(i, a, d, e), a.setSelection(a.createSelection(h)));
            }
            a.setAttribute("linkHref", e, h), o.forEach((f) => {
              a.setAttribute(f, !0, h);
            }), r.forEach((f) => {
              a.removeAttribute(f, h);
            });
          }
        }
      });
    }
    /**
     * Provides information whether a decorator with a given name is present in the currently processed selection.
     *
     * @param decoratorName The name of the manual decorator used in the model
     * @returns The information whether a given decorator is currently present in the selection.
     */
    _getDecoratorStateFromModel(e) {
      const t = this.editor.model, i = t.document.selection, s = i.getSelectedElement();
      return Sa(s, t.schema) ? s.getAttribute(e) : i.getAttribute(e);
    }
    /**
     * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
     *
     * @param range A range to check.
     * @param allowedRanges An array of ranges created on elements where the attribute is accepted.
     */
    _isRangeToUpdate(e, t) {
      for (const i of t)
        if (i.containsRange(e))
          return !1;
      return !0;
    }
    /**
     * Updates selected link with a new value as its content and as its href attribute.
     *
     * @param model Model is need to insert content.
     * @param writer Writer is need to create text element in model.
     * @param range A range where should be inserted content.
     * @param href A link value which should be in the href attribute and in the content.
     */
    _updateLinkContent(e, t, i, s) {
      const o = t.createText(s, { linkHref: s });
      return e.insertContent(o, i);
    }
  }
  function ih(n) {
    if (n.isCollapsed) {
      const e = n.getFirstPosition();
      return e.textNode && e.textNode.data;
    } else {
      const e = Array.from(n.getFirstRange().getItems());
      if (e.length > 1)
        return null;
      const t = e[0];
      return t.is("$text") || t.is("$textProxy") ? t.data : null;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class VL extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = e.document.selection, i = t.getSelectedElement();
      Sa(i, e.schema) ? this.isEnabled = e.schema.checkAttribute(i, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref");
    }
    /**
     * Executes the command.
     *
     * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
     * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
     *
     * # Decorators
     *
     * If {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} is specified,
     * all configured decorators are removed together with the `linkHref` attribute.
     *
     * @fires execute
     */
    execute() {
      const e = this.editor, t = this.editor.model, i = t.document.selection, s = e.commands.get("link");
      t.change((o) => {
        const r = i.isCollapsed ? [ar(i.getFirstPosition(), "linkHref", i.getAttribute("linkHref"), t)] : t.schema.getValidRanges(i.getRanges(), "linkHref");
        for (const a of r)
          if (o.removeAttribute("linkHref", a), s)
            for (const l of s.manualDecorators)
              o.removeAttribute(l.id, a);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ML extends $() {
    /**
     * Creates a new instance of {@link module:link/utils/manualdecorator~ManualDecorator}.
     *
     * @param config.id The name of the attribute used in the model that represents a given manual decorator.
     * For example: `'linkIsExternal'`.
     * @param config.label The label used in the user interface to toggle the manual decorator.
     * @param config.attributes A set of attributes added to output data when the decorator is active for a specific link.
     * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
     * @param [config.defaultValue] Controls whether the decorator is "on" by default.
     */
    constructor({ id: e, label: t, attributes: i, classes: s, styles: o, defaultValue: r }) {
      super(), this.id = e, this.set("value", void 0), this.defaultValue = r, this.label = t, this.attributes = i, this.classes = s, this.styles = o;
    }
    /**
     * Returns {@link module:engine/view/matcher~MatcherPattern} with decorator attributes.
     *
     * @internal
     */
    _createPattern() {
      return {
        attributes: this.attributes,
        classes: this.classes,
        styles: this.styles
      };
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const BL = "ck-link_selected", nh = "automatic", OL = "manual", NL = /^(https?:)?\/\//;
  class hr extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "LinkEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [So, Hg, Xe];
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("link", {
        allowCreatingEmptyLinks: !1,
        addTargetToExternalLinks: !1
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.config.get("link.allowedProtocols");
      e.model.schema.extend("$text", { allowAttributes: "linkHref" }), e.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: eh }), e.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (o, r) => eh(kp(o, t), r) }), e.conversion.for("upcast").elementToAttribute({
        view: {
          name: "a",
          attributes: {
            href: !0
          }
        },
        model: {
          key: "linkHref",
          value: (o) => o.getAttribute("href")
        }
      }), e.commands.add("link", new LL(e)), e.commands.add("unlink", new VL(e));
      const i = IL(e.t, PL(e.config.get("link.decorators")));
      this._enableAutomaticDecorators(i.filter((o) => o.mode === nh)), this._enableManualDecorators(i.filter((o) => o.mode === OL)), e.plugins.get(So).registerAttribute("linkHref"), jg(e, "linkHref", "a", BL), this._enableLinkOpen(), this._enableSelectionAttributesFixer(), this._enableClipboardIntegration();
    }
    /**
     * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}
     * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
     * for each one of them. Downcast dispatchers are obtained using the
     * {@link module:link/utils/automaticdecorators~AutomaticDecorators#getDispatcher} method.
     *
     * **Note**: This method also activates the automatic external link decorator if enabled with
     * {@link module:link/linkconfig~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
     */
    _enableAutomaticDecorators(e) {
      const t = this.editor, s = t.commands.get("link").automaticDecorators;
      t.config.get("link.addTargetToExternalLinks") && s.add({
        id: "linkIsExternal",
        mode: nh,
        callback: (o) => !!o && NL.test(o),
        attributes: {
          target: "_blank",
          rel: "noopener noreferrer"
        }
      }), s.add(e), s.length && t.conversion.for("downcast").add(s.getDispatcher());
    }
    /**
     * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorManualDefinition manual decorators},
     * transforms them into {@link module:link/utils/manualdecorator~ManualDecorator} instances and stores them in the
     * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
     *
     * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
     * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
     * with adequate model attributes.
     */
    _enableManualDecorators(e) {
      if (!e.length)
        return;
      const t = this.editor, s = t.commands.get("link").manualDecorators;
      e.forEach((o) => {
        t.model.schema.extend("$text", { allowAttributes: o.id });
        const r = new ML(o);
        s.add(r), t.conversion.for("downcast").attributeToElement({
          model: r.id,
          view: (a, { writer: l, schema: c }, { item: u }) => {
            if ((u.is("selection") || c.isInline(u)) && a) {
              const d = l.createAttributeElement("a", r.attributes, { priority: 5 });
              r.classes && l.addClass(r.classes, d);
              for (const h in r.styles)
                l.setStyle(h, r.styles[h], d);
              return l.setCustomProperty("link", !0, d), d;
            }
          }
        }), t.conversion.for("upcast").elementToAttribute({
          view: {
            name: "a",
            ...r._createPattern()
          },
          model: {
            key: r.id
          }
        });
      });
    }
    /**
     * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and
     * {@link module:engine/view/document~Document#event:click} to enable link following.
     */
    _enableLinkOpen() {
      const e = this.editor, i = e.editing.view.document;
      this.listenTo(i, "click", (s, o) => {
        if (!(B.isMac ? o.domEvent.metaKey : o.domEvent.ctrlKey))
          return;
        let a = o.domTarget;
        if (a.tagName.toLowerCase() != "a" && (a = a.closest("a")), !a)
          return;
        const l = a.getAttribute("href");
        l && (s.stop(), o.preventDefault(), th(l));
      }, { context: "$capture" }), this.listenTo(i, "keydown", (s, o) => {
        const a = e.commands.get("link").value;
        a && o.keyCode === F.enter && o.altKey && (s.stop(), th(a));
      });
    }
    /**
     * Watches the DocumentSelection attribute changes and removes link decorator attributes when the linkHref attribute is removed.
     *
     * This is to ensure that there is no left-over link decorator attributes on the document selection that is no longer in a link.
     */
    _enableSelectionAttributesFixer() {
      const t = this.editor.model, i = t.document.selection;
      this.listenTo(i, "change:attribute", (s, { attributeKeys: o }) => {
        !o.includes("linkHref") || i.hasAttribute("linkHref") || t.change((r) => {
          DL(r, FL(t.schema));
        });
      });
    }
    /**
     * Enables URL fixing on pasting.
     */
    _enableClipboardIntegration() {
      const e = this.editor, t = e.model, i = this.editor.config.get("link.defaultProtocol");
      i && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (s, o) => {
        t.change((r) => {
          const a = r.createRangeIn(o.content);
          for (const l of a.getItems())
            if (l.hasAttribute("linkHref")) {
              const c = $l(l.getAttribute("linkHref"), i);
              r.setAttribute("linkHref", c, l);
            }
        });
      });
    }
  }
  function DL(n, e) {
    n.removeSelectionAttribute("linkHref");
    for (const t of e)
      n.removeSelectionAttribute(t);
  }
  function FL(n) {
    return n.getDefinition("$text").allowAttributes.filter((t) => t.startsWith("link"));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class zL extends T {
    /**
     * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
     *
     * Also see {@link #render}.
     *
     * @param locale The localization services instance.
     * @param linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
     */
    constructor(e, t) {
      super(e), this.focusTracker = new Q(), this.keystrokes = new ne(), this._focusables = new ke();
      const i = e.t;
      this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(i("Save"), x.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(i("Cancel"), x.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t), this.children = this._createFormChildren(t.manualDecorators), this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      });
      const s = ["ck", "ck-link-form", "ck-responsive-form"];
      t.manualDecorators.length && s.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({
        tag: "form",
        attributes: {
          class: s,
          // https://github.com/ckeditor/ckeditor5-link/issues/90
          tabindex: "-1"
        },
        children: this.children
      });
    }
    /**
     * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
     * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
     * in the {@link module:link/ui/linkformview~LinkFormView}.
     *
     * @returns Key-value pairs, where the key is the name of the decorator and the value is its state.
     */
    getDecoratorSwitchesState() {
      return Array.from(this._manualDecoratorSwitches).reduce((e, t) => (e[t.name] = t.isOn, e), {});
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), an({
        view: this
      }), [
        this.urlInputView,
        ...this._manualDecoratorSwitches,
        this.saveButtonView,
        this.cancelButtonView
      ].forEach((t) => {
        this._focusables.add(t), this.focusTracker.add(t.element);
      }), this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the fist {@link #_focusables} in the form.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Creates a labeled input view.
     *
     * @returns Labeled field view instance.
     */
    _createUrlInput() {
      const e = this.locale.t, t = new he(this.locale, ze);
      return t.label = e("Link URL"), t;
    }
    /**
     * Creates a button view.
     *
     * @param label The button label.
     * @param icon The button icon.
     * @param className The additional button CSS class name.
     * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
     * @returns The button view instance.
     */
    _createButton(e, t, i, s) {
      const o = new P(this.locale);
      return o.set({
        label: e,
        icon: t,
        tooltip: !0
      }), o.extendTemplate({
        attributes: {
          class: i
        }
      }), s && o.delegate("execute").to(this, s), o;
    }
    /**
     * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
     * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
     *
     * @param linkCommand A reference to the link command.
     * @returns ViewCollection of switch buttons.
     */
    _createManualDecoratorSwitches(e) {
      const t = this.createCollection();
      for (const i of e.manualDecorators) {
        const s = new ir(this.locale);
        s.set({
          name: i.id,
          label: i.label,
          withText: !0
        }), s.bind("isOn").toMany([i, e], "value", (o, r) => r === void 0 && o === void 0 ? !!i.defaultValue : !!o), s.on("execute", () => {
          i.set("value", !s.isOn);
        }), t.add(s);
      }
      return t;
    }
    /**
     * Populates the {@link #children} collection of the form.
     *
     * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
     * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
     * to these decorators.
     *
     * @param manualDecorators A reference to
     * the collection of manual decorators stored in the link command.
     * @returns The children of link form view.
     */
    _createFormChildren(e) {
      const t = this.createCollection();
      if (t.add(this.urlInputView), e.length) {
        const i = new T();
        i.setTemplate({
          tag: "ul",
          children: this._manualDecoratorSwitches.map((s) => ({
            tag: "li",
            children: [s],
            attributes: {
              class: [
                "ck",
                "ck-list__item"
              ]
            }
          })),
          attributes: {
            class: [
              "ck",
              "ck-reset",
              "ck-list"
            ]
          }
        }), t.add(i);
      }
      return t.add(this.saveButtonView), t.add(this.cancelButtonView), t;
    }
  }
  const UL = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class HL extends T {
    /**
     * @inheritDoc
     */
    constructor(e, t = {}) {
      super(e), this.focusTracker = new Q(), this.keystrokes = new ne(), this._focusables = new ke();
      const i = e.t;
      this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(i("Unlink"), UL, "unlink"), this.editButtonView = this._createButton(i("Edit link"), x.pencil, "edit"), this.set("href", void 0), this._linkConfig = t, this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate fields forwards using the Tab key.
          focusNext: "tab"
        }
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-link-actions",
            "ck-responsive-form"
          ],
          // https://github.com/ckeditor/ckeditor5-link/issues/90
          tabindex: "-1"
        },
        children: [
          this.previewButtonView,
          this.editButtonView,
          this.unlinkButtonView
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), [
        this.previewButtonView,
        this.editButtonView,
        this.unlinkButtonView
      ].forEach((t) => {
        this._focusables.add(t), this.focusTracker.add(t.element);
      }), this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the fist {@link #_focusables} in the actions.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Creates a button view.
     *
     * @param label The button label.
     * @param icon The button icon.
     * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
     * @returns The button view instance.
     */
    _createButton(e, t, i) {
      const s = new P(this.locale);
      return s.set({
        label: e,
        icon: t,
        tooltip: !0
      }), s.delegate("execute").to(this, i), s;
    }
    /**
     * Creates a link href preview button.
     *
     * @returns The button view instance.
     */
    _createPreviewButton() {
      const e = new P(this.locale), t = this.bindTemplate, i = this.t;
      return e.set({
        withText: !0,
        tooltip: i("Open link in new tab")
      }), e.extendTemplate({
        attributes: {
          class: [
            "ck",
            "ck-link-actions__preview"
          ],
          href: t.to("href", (s) => s && kp(s, this._linkConfig.allowedProtocols)),
          target: "_blank",
          rel: "noopener noreferrer"
        }
      }), e.bind("label").to(this, "href", (s) => s || i("This link has no URL")), e.bind("isEnabled").to(this, "href", (s) => !!s), e.template.tag = "a", e.template.eventListeners = {}, e;
    }
  }
  const Ep = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const ht = "link-ui";
  class Ap extends w {
    constructor() {
      super(...arguments), this.actionsView = null, this.formView = null;
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [$t];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "LinkUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.t;
      e.editing.view.addObserver(uE), this._balloon = e.plugins.get($t), this._createToolbarLinkButton(), this._enableBalloonActivators(), e.conversion.for("editingDowncast").markerToHighlight({
        model: ht,
        view: {
          classes: ["ck-fake-link-selection"]
        }
      }), e.conversion.for("editingDowncast").markerToElement({
        model: ht,
        view: {
          name: "span",
          classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]
        }
      }), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Create link"),
            keystroke: Ln
          },
          {
            label: t("Move out of a link"),
            keystroke: [
              ["arrowleft", "arrowleft"],
              ["arrowright", "arrowright"]
            ]
          }
        ]
      });
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy();
    }
    /**
     * Creates views.
     */
    _createViews() {
      this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions();
    }
    /**
     * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
     */
    _createActionsView() {
      const e = this.editor, t = new HL(e.locale, e.config.get("link")), i = e.commands.get("link"), s = e.commands.get("unlink");
      return t.bind("href").to(i, "value"), t.editButtonView.bind("isEnabled").to(i), t.unlinkButtonView.bind("isEnabled").to(s), this.listenTo(t, "edit", () => {
        this._addFormView();
      }), this.listenTo(t, "unlink", () => {
        e.execute("unlink"), this._hideUI();
      }), t.keystrokes.set("Esc", (o, r) => {
        this._hideUI(), r();
      }), t.keystrokes.set(Ln, (o, r) => {
        this._addFormView(), r();
      }), t;
    }
    /**
     * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
     */
    _createFormView() {
      const e = this.editor, t = e.commands.get("link"), i = e.config.get("link.defaultProtocol"), s = e.config.get("link.allowCreatingEmptyLinks"), o = new (ja(zL))(e.locale, t);
      return o.urlInputView.fieldView.bind("value").to(t, "value"), o.urlInputView.bind("isEnabled").to(t, "isEnabled"), o.saveButtonView.bind("isEnabled").to(t, "isEnabled", o.urlInputView, "isEmpty", (r, a) => r && (s || !a)), this.listenTo(o, "submit", () => {
        const { value: r } = o.urlInputView.fieldView.element, a = $l(r, i);
        e.execute("link", a, o.getDecoratorSwitchesState()), this._closeFormView();
      }), this.listenTo(o, "cancel", () => {
        this._closeFormView();
      }), o.keystrokes.set("Esc", (r, a) => {
        this._closeFormView(), a();
      }), o;
    }
    /**
     * Creates a toolbar Link button. Clicking this button will show
     * a {@link #_balloon} attached to the selection.
     */
    _createToolbarLinkButton() {
      const e = this.editor, t = e.commands.get("link");
      e.ui.componentFactory.add("link", () => {
        const i = this._createButton(P);
        return i.set({
          tooltip: !0,
          isToggleable: !0
        }), i.bind("isOn").to(t, "value", (s) => !!s), i;
      }), e.ui.componentFactory.add("menuBar:link", () => this._createButton(de));
    }
    /**
     * Creates a button for link command to use either in toolbar or in menu bar.
     */
    _createButton(e) {
      const t = this.editor, i = t.locale, s = t.commands.get("link"), o = new e(t.locale), r = i.t;
      return o.set({
        label: r("Link"),
        icon: Ep,
        keystroke: Ln
      }), o.bind("isEnabled").to(s, "isEnabled"), this.listenTo(o, "execute", () => this._showUI(!0)), o;
    }
    /**
     * Attaches actions that control whether the balloon panel containing the
     * {@link #formView} should be displayed.
     */
    _enableBalloonActivators() {
      const e = this.editor, t = e.editing.view.document;
      this.listenTo(t, "click", () => {
        this._getSelectedLinkElement() && this._showUI();
      }), e.keystrokes.set(Ln, (i, s) => {
        s(), e.commands.get("link").isEnabled && this._showUI(!0);
      });
    }
    /**
     * Attaches actions that control whether the balloon panel containing the
     * {@link #formView} is visible or not.
     */
    _enableUserBalloonInteractions() {
      this.editor.keystrokes.set("Tab", (e, t) => {
        this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), t());
      }, {
        // Use the high priority because the link UI navigation is more important
        // than other feature's actions, e.g. list indentation.
        // https://github.com/ckeditor/ckeditor5-link/issues/146
        priority: "high"
      }), this.editor.keystrokes.set("Esc", (e, t) => {
        this._isUIVisible && (this._hideUI(), t());
      }), rn({
        emitter: this.formView,
        activator: () => this._isUIInPanel,
        contextElements: () => [this._balloon.view.element],
        callback: () => this._hideUI()
      });
    }
    /**
     * Adds the {@link #actionsView} to the {@link #_balloon}.
     *
     * @internal
     */
    _addActionsView() {
      this.actionsView || this._createViews(), !this._areActionsInPanel && this._balloon.add({
        view: this.actionsView,
        position: this._getBalloonPositionData()
      });
    }
    /**
     * Adds the {@link #formView} to the {@link #_balloon}.
     */
    _addFormView() {
      if (this.formView || this._createViews(), this._isFormInPanel)
        return;
      const t = this.editor.commands.get("link");
      this.formView.disableCssTransitions(), this._balloon.add({
        view: this.formView,
        position: this._getBalloonPositionData()
      }), this.formView.urlInputView.fieldView.value = t.value || "", this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions();
    }
    /**
     * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
     * decided upon the link command value (which has a value if the document selection is in the link).
     *
     * Additionally, if any {@link module:link/linkconfig~LinkConfig#decorators} are defined in the editor configuration, the state of
     * switch buttons responsible for manual decorator handling is restored.
     */
    _closeFormView() {
      const e = this.editor.commands.get("link");
      e.restoreManualDecoratorStates(), e.value !== void 0 ? this._removeFormView() : this._hideUI();
    }
    /**
     * Removes the {@link #formView} from the {@link #_balloon}.
     */
    _removeFormView() {
      this._isFormInPanel && (this.formView.saveButtonView.focus(), this.formView.urlInputView.fieldView.reset(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
    }
    /**
     * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
     *
     * @internal
     */
    _showUI(e = !1) {
      this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), e && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
    }
    /**
     * Removes the {@link #formView} from the {@link #_balloon}.
     *
     * See {@link #_addFormView}, {@link #_addActionsView}.
     */
    _hideUI() {
      if (!this._isUIInPanel)
        return;
      const e = this.editor;
      this.stopListening(e.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
    }
    /**
     * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
     * reposition itself when the editor UI should be refreshed.
     *
     * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
     */
    _startUpdatingUI() {
      const e = this.editor, t = e.editing.view.document;
      let i = this._getSelectedLinkElement(), s = r();
      const o = () => {
        const a = this._getSelectedLinkElement(), l = r();
        i && !a || !i && l !== s ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), i = a, s = l;
      };
      function r() {
        return t.selection.focus.getAncestors().reverse().find((a) => a.is("element"));
      }
      this.listenTo(e.ui, "update", o), this.listenTo(this._balloon, "change:visibleView", o);
    }
    /**
     * Returns `true` when {@link #formView} is in the {@link #_balloon}.
     */
    get _isFormInPanel() {
      return !!this.formView && this._balloon.hasView(this.formView);
    }
    /**
     * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
     */
    get _areActionsInPanel() {
      return !!this.actionsView && this._balloon.hasView(this.actionsView);
    }
    /**
     * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
     * currently visible.
     */
    get _areActionsVisible() {
      return !!this.actionsView && this._balloon.visibleView === this.actionsView;
    }
    /**
     * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
     */
    get _isUIInPanel() {
      return this._isFormInPanel || this._areActionsInPanel;
    }
    /**
     * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
     * currently visible.
     */
    get _isUIVisible() {
      const e = this._balloon.visibleView;
      return !!this.formView && e == this.formView || this._areActionsVisible;
    }
    /**
     * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
     * to the target element or selection.
     *
     * If the selection is collapsed and inside a link element, the panel will be attached to the
     * entire link element. Otherwise, it will be attached to the selection.
     */
    _getBalloonPositionData() {
      const e = this.editor.editing.view, t = this.editor.model, i = e.document;
      let s;
      if (t.markers.has(ht)) {
        const o = Array.from(this.editor.editing.mapper.markerNameToElements(ht)), r = e.createRange(e.createPositionBefore(o[0]), e.createPositionAfter(o[o.length - 1]));
        s = e.domConverter.viewRangeToDom(r);
      } else
        s = () => {
          const o = this._getSelectedLinkElement();
          return o ? (
            // When selection is inside link element, then attach panel to this element.
            e.domConverter.mapViewToDom(o)
          ) : (
            // Otherwise attach panel to the selection.
            e.domConverter.viewRangeToDom(i.selection.getFirstRange())
          );
        };
      return { target: s };
    }
    /**
     * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
     * the {@link module:engine/view/document~Document editing view's} selection or `null`
     * if there is none.
     *
     * **Note**: For a non–collapsed selection, the link element is returned when **fully**
     * selected and the **only** element within the selection boundaries, or when
     * a linked widget is selected.
     */
    _getSelectedLinkElement() {
      const e = this.editor.editing.view, t = e.document.selection, i = t.getSelectedElement();
      if (t.isCollapsed || i && re(i))
        return $r(t.getFirstPosition());
      {
        const s = t.getFirstRange().getTrimmed(), o = $r(s.start), r = $r(s.end);
        return !o || o != r ? null : e.createRangeIn(o).getTrimmed().isEqual(s) ? o : null;
      }
    }
    /**
     * Displays a fake visual selection when the contextual balloon is displayed.
     *
     * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
     */
    _showFakeVisualSelection() {
      const e = this.editor.model;
      e.change((t) => {
        const i = e.document.selection.getFirstRange();
        if (e.markers.has(ht))
          t.updateMarker(ht, { range: i });
        else if (i.start.isAtEnd) {
          const s = i.start.getLastMatchingPosition(({ item: o }) => !e.schema.isContent(o), { boundaries: i });
          t.addMarker(ht, {
            usingOperation: !1,
            affectsData: !1,
            range: t.createRange(s, i.end)
          });
        } else
          t.addMarker(ht, {
            usingOperation: !1,
            affectsData: !1,
            range: i
          });
      });
    }
    /**
     * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
     */
    _hideFakeVisualSelection() {
      const e = this.editor.model;
      e.markers.has(ht) && e.change((t) => {
        t.removeMarker(ht);
      });
    }
  }
  function $r(n) {
    return n.getAncestors().find((e) => xL(e)) || null;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const $L = 4, xp = new RegExp(
    // Group 1: Line start or after a space.
    "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
    "i"
  ), WL = 2;
  class qL extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [bt, hr];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "AutoLink";
    }
    /**
     * @inheritDoc
     */
    init() {
      const t = this.editor.model.document.selection;
      t.on("change:range", () => {
        this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
      }), this._enableTypingHandling();
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      this._enableEnterHandling(), this._enableShiftEnterHandling(), this._enablePasteLinking();
    }
    /**
     * For given position, returns a range that includes the whole link that contains the position.
     *
     * If position is not inside a link, returns `null`.
     */
    _expandLinkRange(e, t) {
      return t.textNode && t.textNode.hasAttribute("linkHref") ? ar(t, "linkHref", t.textNode.getAttribute("linkHref"), e) : null;
    }
    /**
     * Extends the document selection to includes all links that intersects with given `selectedRange`.
     */
    _selectEntireLinks(e, t) {
      const s = this.editor.model, o = s.document.selection, r = o.getFirstPosition(), a = o.getLastPosition();
      let l = t.getJoined(this._expandLinkRange(s, r) || t);
      l && (l = l.getJoined(this._expandLinkRange(s, a) || t)), l && (l.start.isBefore(r) || l.end.isAfter(a)) && e.setSelection(l);
    }
    /**
     * Enables autolinking on pasting a URL when some content is selected.
     */
    _enablePasteLinking() {
      const e = this.editor, t = e.model, i = t.document.selection, s = e.plugins.get("ClipboardPipeline"), o = e.commands.get("link");
      s.on("inputTransformation", (r, a) => {
        if (!this.isEnabled || !o.isEnabled || i.isCollapsed || a.method !== "paste" || i.rangeCount > 1)
          return;
        const l = i.getFirstRange(), c = a.dataTransfer.getData("text/plain");
        if (!c)
          return;
        const u = c.match(xp);
        u && u[2] === c && (t.change((d) => {
          this._selectEntireLinks(d, l), o.execute(c);
        }), r.stop());
      }, { priority: "high" });
    }
    /**
     * Enables autolinking on typing.
     */
    _enableTypingHandling() {
      const e = this.editor, t = new Gg(e.model, (i) => {
        if (!GL(i))
          return;
        const s = sh(i.substr(0, i.length - 1));
        if (s)
          return { url: s };
      });
      t.on("matched:data", (i, s) => {
        const { batch: o, range: r, url: a } = s;
        if (!o.isTyping)
          return;
        const l = r.end.getShiftedBy(-1), c = l.getShiftedBy(-a.length), u = e.model.createRange(c, l);
        this._applyAutoLink(a, u);
      }), t.bind("isEnabled").to(this);
    }
    /**
     * Enables autolinking on the <kbd>Enter</kbd> key.
     */
    _enableEnterHandling() {
      const e = this.editor, t = e.model, i = e.commands.get("enter");
      i && i.on("execute", () => {
        const s = t.document.selection.getFirstPosition();
        if (!s.parent.previousSibling)
          return;
        const o = t.createRangeIn(s.parent.previousSibling);
        this._checkAndApplyAutoLinkOnRange(o);
      });
    }
    /**
     * Enables autolinking on the <kbd>Shift</kbd>+<kbd>Enter</kbd> keyboard shortcut.
     */
    _enableShiftEnterHandling() {
      const e = this.editor, t = e.model, i = e.commands.get("shiftEnter");
      i && i.on("execute", () => {
        const s = t.document.selection.getFirstPosition(), o = t.createRange(t.createPositionAt(s.parent, 0), s.getShiftedBy(-1));
        this._checkAndApplyAutoLinkOnRange(o);
      });
    }
    /**
     * Checks if the passed range contains a linkable text.
     */
    _checkAndApplyAutoLinkOnRange(e) {
      const t = this.editor.model, { text: i, range: s } = qg(e, t), o = sh(i);
      if (o) {
        const r = t.createRange(s.end.getShiftedBy(-o.length), s.end);
        this._applyAutoLink(o, r);
      }
    }
    /**
     * Applies a link on a given range if the link should be applied.
     *
     * @param url The URL to link.
     * @param range The text range to apply the link attribute to.
     */
    _applyAutoLink(e, t) {
      const i = this.editor.model, s = this.editor.config.get("link.defaultProtocol"), o = $l(e, s);
      !this.isEnabled || !jL(t, i) || !Tp(o) || KL(t) || this._persistAutoLink(o, t);
    }
    /**
     * Enqueues autolink changes in the model.
     *
     * @param url The URL to link.
     * @param range The text range to apply the link attribute to.
     */
    _persistAutoLink(e, t) {
      const i = this.editor.model, s = this.editor.plugins.get("Delete");
      i.enqueueChange((o) => {
        o.setAttribute("linkHref", e, t), i.enqueueChange(() => {
          s.requestUndoOnBackspace();
        });
      });
    }
  }
  function GL(n) {
    return n.length > $L && n[n.length - 1] === " " && n[n.length - 2] !== " ";
  }
  function sh(n) {
    const e = xp.exec(n);
    return e ? e[WL] : null;
  }
  function jL(n, e) {
    return e.schema.checkAttributeInSelection(e.createSelection(n), "linkHref");
  }
  function KL(n) {
    const e = n.start.nodeAfter;
    return !!e && e.hasAttribute("linkHref");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ZL extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [hr, Ap, qL];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Link";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class JL extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return ["ImageEditing", "ImageUtils", hr];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "LinkImageEditing";
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      const e = this.editor, t = e.model.schema;
      e.plugins.has("ImageBlockEditing") && t.extend("imageBlock", { allowAttributes: ["linkHref"] }), e.conversion.for("upcast").add(XL(e)), e.conversion.for("downcast").add(YL(e)), this._enableAutomaticDecorators(), this._enableManualDecorators();
    }
    /**
     * Processes {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators} definitions and
     * attaches proper converters that will work when linking an image.`
     */
    _enableAutomaticDecorators() {
      const e = this.editor, i = e.commands.get("link").automaticDecorators;
      i.length && e.conversion.for("downcast").add(i.getDispatcherForLinkedImage());
    }
    /**
     * Processes transformed {@link module:link/utils/manualdecorator~ManualDecorator} instances and attaches proper converters
     * that will work when linking an image.
     */
    _enableManualDecorators() {
      const e = this.editor, t = e.commands.get("link");
      for (const i of t.manualDecorators)
        e.plugins.has("ImageBlockEditing") && e.model.schema.extend("imageBlock", { allowAttributes: i.id }), e.plugins.has("ImageInlineEditing") && e.model.schema.extend("imageInline", { allowAttributes: i.id }), e.conversion.for("downcast").add(QL(i)), e.conversion.for("upcast").add(e3(e, i));
    }
  }
  function XL(n) {
    const e = n.plugins.has("ImageInlineEditing"), t = n.plugins.get("ImageUtils");
    return (i) => {
      i.on("element:a", (s, o, r) => {
        const a = o.viewItem, l = t.findViewImgElement(a);
        if (!l)
          return;
        const c = l.findAncestor((f) => t.isBlockImageView(f));
        if (e && !c)
          return;
        const u = { attributes: ["href"] };
        if (!r.consumable.consume(a, u))
          return;
        const d = a.getAttribute("href");
        if (!d)
          return;
        let h = o.modelCursor.parent;
        if (!h.is("element", "imageBlock")) {
          const f = r.convertItem(l, o.modelCursor);
          o.modelRange = f.modelRange, o.modelCursor = f.modelCursor, h = o.modelCursor.nodeBefore;
        }
        h && h.is("element", "imageBlock") && r.writer.setAttribute("linkHref", d, h);
      }, { priority: "high" });
    };
  }
  function YL(n) {
    const e = n.plugins.get("ImageUtils");
    return (t) => {
      t.on("attribute:linkHref:imageBlock", (i, s, o) => {
        if (!o.consumable.consume(s.item, i.name))
          return;
        const r = o.mapper.toViewElement(s.item), a = o.writer, l = Array.from(r.getChildren()).find((d) => d.is("element", "a")), c = e.findViewImgElement(r), u = c.parent.is("element", "picture") ? c.parent : c;
        if (l)
          s.attributeNewValue ? a.setAttribute("href", s.attributeNewValue, l) : (a.move(a.createRangeOn(u), a.createPositionAt(r, 0)), a.remove(l));
        else {
          const d = a.createContainerElement("a", { href: s.attributeNewValue });
          a.insert(a.createPositionAt(r, 0), d), a.move(a.createRangeOn(u), a.createPositionAt(d, 0));
        }
      }, { priority: "high" });
    };
  }
  function QL(n) {
    return (e) => {
      e.on(`attribute:${n.id}:imageBlock`, (t, i, s) => {
        const o = s.mapper.toViewElement(i.item), r = Array.from(o.getChildren()).find((a) => a.is("element", "a"));
        if (r) {
          for (const [a, l] of wt(n.attributes))
            s.writer.setAttribute(a, l, r);
          n.classes && s.writer.addClass(n.classes, r);
          for (const a in n.styles)
            s.writer.setStyle(a, n.styles[a], r);
        }
      });
    };
  }
  function e3(n, e) {
    const t = n.plugins.has("ImageInlineEditing"), i = n.plugins.get("ImageUtils");
    return (s) => {
      s.on("element:a", (o, r, a) => {
        const l = r.viewItem, c = i.findViewImgElement(l);
        if (!c)
          return;
        const u = c.findAncestor((m) => i.isBlockImageView(m));
        if (t && !u)
          return;
        const h = new rt(e._createPattern()).match(l);
        if (!h || !a.consumable.consume(l, h.match))
          return;
        const f = r.modelCursor.nodeBefore || r.modelCursor.parent;
        a.writer.setAttribute(e.id, !0, f);
      }, { priority: "high" });
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class t3 extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [hr, Ap, "ImageBlockEditing"];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "LinkImageUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.editing.view.document;
      this.listenTo(t, "click", (i, s) => {
        this._isSelectedLinkedImage(e.model.document.selection) && (s.preventDefault(), i.stop());
      }, { priority: "high" }), this._createToolbarLinkImageButton();
    }
    /**
     * Creates a `LinkImageUI` button view.
     *
     * Clicking this button shows a {@link module:link/linkui~LinkUI#_balloon} attached to the selection.
     * When an image is already linked, the view shows {@link module:link/linkui~LinkUI#actionsView} or
     * {@link module:link/linkui~LinkUI#formView} if it is not.
     */
    _createToolbarLinkImageButton() {
      const e = this.editor, t = e.t;
      e.ui.componentFactory.add("linkImage", (i) => {
        const s = new P(i), o = e.plugins.get("LinkUI"), r = e.commands.get("link");
        return s.set({
          isEnabled: !0,
          label: t("Link image"),
          icon: Ep,
          keystroke: Ln,
          tooltip: !0,
          isToggleable: !0
        }), s.bind("isEnabled").to(r, "isEnabled"), s.bind("isOn").to(r, "value", (a) => !!a), this.listenTo(s, "execute", () => {
          this._isSelectedLinkedImage(e.model.document.selection) ? o._addActionsView() : o._showUI(!0);
        }), s;
      });
    }
    /**
     * Returns true if a linked image (either block or inline) is the only selected element
     * in the model document.
     */
    _isSelectedLinkedImage(e) {
      const t = e.getSelectedElement();
      return this.editor.plugins.get("ImageUtils").isImage(t) && t.hasAttribute("linkHref");
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class i3 extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [JL, t3];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "LinkImage";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function oh(n, e) {
    const t = (i, s, o) => {
      if (!o.consumable.consume(s.item, i.name))
        return;
      const r = s.attributeNewValue, a = o.writer, l = o.mapper.toViewElement(s.item), c = [...l.getChildren()].find((d) => d.getCustomProperty("media-content"));
      a.remove(c);
      const u = n.getMediaViewElement(a, r, e);
      a.insert(a.createPositionAt(l, 0), u);
    };
    return (i) => {
      i.on("attribute:url:media", t);
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function n3(n, e, t) {
    return e.setCustomProperty("media", !0, n), cr(n, e, { label: t });
  }
  function rh(n, e, t, i) {
    return n.createContainerElement("figure", { class: "media" }, [
      e.getMediaViewElement(n, t, i),
      n.createSlot()
    ]);
  }
  function ah(n) {
    const e = n.getSelectedElement();
    return e && e.is("element", "media") ? e : null;
  }
  function Sp(n, e, t, i) {
    n.change((s) => {
      const o = s.createElement("media", { url: e });
      n.insertObject(o, t, null, {
        setSelection: "on",
        findOptimalPosition: i ? "auto" : void 0
      });
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class s3 extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = e.document.selection, i = ah(t);
      this.value = i ? i.getAttribute("url") : void 0, this.isEnabled = r3(t) || o3(t, e);
    }
    /**
     * Executes the command, which either:
     *
     * * updates the URL of the selected media,
     * * inserts the new media into the editor and puts the selection around it.
     *
     * @fires execute
     * @param url The URL of the media.
     */
    execute(e) {
      const t = this.editor.model, i = t.document.selection, s = ah(i);
      s ? t.change((o) => {
        o.setAttribute("url", e, s);
      }) : Sp(t, e, i, !0);
    }
  }
  function o3(n, e) {
    let i = Bl(n, e).start.parent;
    return i.isEmpty && !e.schema.isLimit(i) && (i = i.parent), e.schema.checkChild(i, "media");
  }
  function r3(n) {
    const e = n.getSelectedElement();
    return !!e && e.name === "media";
  }
  const a3 = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const l3 = "0 0 64 42";
  class c3 {
    /**
     * Creates an instance of the {@link module:media-embed/mediaregistry~MediaRegistry} class.
     *
     * @param locale The localization services instance.
     * @param config The configuration of the media embed feature.
     */
    constructor(e, t) {
      const i = t.providers, s = t.extraProviders || [], o = new Set(t.removeProviders), r = i.concat(s).filter((a) => {
        const l = a.name;
        return l ? !o.has(l) : (z("media-embed-no-provider-name", { provider: a }), !1);
      });
      this.locale = e, this.providerDefinitions = r;
    }
    /**
     * Checks whether the passed URL is representing a certain media type allowed in the editor.
     *
     * @param url The URL to be checked
     */
    hasMedia(e) {
      return !!this._getMedia(e);
    }
    /**
     * For the given media URL string and options, it returns the {@link module:engine/view/element~Element view element}
     * representing that media.
     *
     * **Note:** If no URL is specified, an empty view element is returned.
     *
     * @param writer The view writer used to produce a view element.
     * @param url The URL to be translated into a view element.
     */
    getMediaViewElement(e, t, i) {
      return this._getMedia(t).getViewElement(e, i);
    }
    /**
     * Returns a `Media` instance for the given URL.
     *
     * @param url The URL of the media.
     * @returns The `Media` instance or `null` when there is none.
     */
    _getMedia(e) {
      if (!e)
        return new lh(this.locale);
      e = e.trim();
      for (const t of this.providerDefinitions) {
        const i = t.html, s = Z(t.url);
        for (const o of s) {
          const r = this._getUrlMatches(e, o);
          if (r)
            return new lh(this.locale, e, r, i);
        }
      }
      return null;
    }
    /**
     * Tries to match `url` to `pattern`.
     *
     * @param url The URL of the media.
     * @param pattern The pattern that should accept the media URL.
     */
    _getUrlMatches(e, t) {
      let i = e.match(t);
      if (i)
        return i;
      let s = e.replace(/^https?:\/\//, "");
      return i = s.match(t), i || (s = s.replace(/^www\./, ""), i = s.match(t), i) ? i : null;
    }
  }
  class lh {
    constructor(e, t, i, s) {
      this.url = this._getValidUrl(t), this._locale = e, this._match = i, this._previewRenderer = s;
    }
    /**
     * Returns the view element representation of the media.
     *
     * @param writer The view writer used to produce a view element.
     */
    getViewElement(e, t) {
      const i = {};
      let s;
      if (t.renderForEditingView || t.renderMediaPreview && this.url && this._previewRenderer) {
        this.url && (i["data-oembed-url"] = this.url), t.renderForEditingView && (i.class = "ck-media__wrapper");
        const o = this._getPreviewHtml(t);
        s = e.createRawElement("div", i, (r, a) => {
          a.setContentOf(r, o);
        });
      } else
        this.url && (i.url = this.url), s = e.createEmptyElement(t.elementName, i);
      return e.setCustomProperty("media-content", !0, s), s;
    }
    /**
     * Returns the HTML string of the media content preview.
     */
    _getPreviewHtml(e) {
      return this._previewRenderer ? this._previewRenderer(this._match) : this.url && e.renderForEditingView ? this._getPlaceholderHtml() : "";
    }
    /**
     * Returns the placeholder HTML when the media has no content preview.
     */
    _getPlaceholderHtml() {
      const e = new dt(), t = this._locale.t;
      return e.content = a3, e.viewBox = l3, new Ve({
        tag: "div",
        attributes: {
          class: "ck ck-reset_all ck-media__placeholder"
        },
        children: [
          {
            tag: "div",
            attributes: {
              class: "ck-media__placeholder__icon"
            },
            children: [e]
          },
          {
            tag: "a",
            attributes: {
              class: "ck-media__placeholder__url",
              target: "_blank",
              rel: "noopener noreferrer",
              href: this.url,
              "data-cke-tooltip-text": t("Open media in new tab")
            },
            children: [
              {
                tag: "span",
                attributes: {
                  class: "ck-media__placeholder__url__text"
                },
                children: [this.url]
              }
            ]
          }
        ]
      }).render().outerHTML;
    }
    /**
     * Returns the full URL to the specified media.
     *
     * @param url The URL of the media.
     */
    _getValidUrl(e) {
      return e ? e.match(/^https?/) ? e : "https://" + e : null;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Lo extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "MediaEmbedEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("mediaEmbed", {
        elementName: "oembed",
        providers: [
          {
            name: "dailymotion",
            url: [
              /^dailymotion\.com\/video\/(\w+)/,
              /^dai.ly\/(\w+)/
            ],
            html: (t) => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`
          },
          {
            name: "spotify",
            url: [
              /^open\.spotify\.com\/(artist\/\w+)/,
              /^open\.spotify\.com\/(album\/\w+)/,
              /^open\.spotify\.com\/(track\/\w+)/
            ],
            html: (t) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`
          },
          {
            name: "youtube",
            url: [
              /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/,
              /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/,
              /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/,
              /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/
            ],
            html: (t) => {
              const i = t[1], s = t[2];
              return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${i}${s ? `?start=${s}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`;
            }
          },
          {
            name: "vimeo",
            url: [
              /^vimeo\.com\/(\d+)/,
              /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
              /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
              /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
              /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
              /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
              /^player\.vimeo\.com\/video\/(\d+)/
            ],
            html: (t) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`
          },
          {
            name: "instagram",
            url: /^instagram\.com\/p\/(\w+)/
          },
          {
            name: "twitter",
            url: /^twitter\.com/
          },
          {
            name: "googleMaps",
            url: [
              /^google\.com\/maps/,
              /^goo\.gl\/maps/,
              /^maps\.google\.com/,
              /^maps\.app\.goo\.gl/
            ]
          },
          {
            name: "flickr",
            url: /^flickr\.com/
          },
          {
            name: "facebook",
            url: /^facebook\.com/
          }
        ]
      }), this.registry = new c3(e.locale, e.config.get("mediaEmbed"));
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.schema, i = e.t, s = e.conversion, o = e.config.get("mediaEmbed.previewsInData"), r = e.config.get("mediaEmbed.elementName"), a = this.registry;
      e.commands.add("mediaEmbed", new s3(e)), t.register("media", {
        inheritAllFrom: "$blockObject",
        allowAttributes: ["url"]
      }), s.for("dataDowncast").elementToStructure({
        model: "media",
        view: (l, { writer: c }) => {
          const u = l.getAttribute("url");
          return rh(c, a, u, {
            elementName: r,
            renderMediaPreview: !!u && o
          });
        }
      }), s.for("dataDowncast").add(oh(a, {
        elementName: r,
        renderMediaPreview: o
      })), s.for("editingDowncast").elementToStructure({
        model: "media",
        view: (l, { writer: c }) => {
          const u = l.getAttribute("url"), d = rh(c, a, u, {
            elementName: r,
            renderForEditingView: !0
          });
          return n3(d, c, i("media widget"));
        }
      }), s.for("editingDowncast").add(oh(a, {
        elementName: r,
        renderForEditingView: !0
      })), s.for("upcast").elementToElement({
        view: (l) => ["oembed", r].includes(l.name) && l.getAttribute("url") ? { name: !0 } : null,
        model: (l, { writer: c }) => {
          const u = l.getAttribute("url");
          return a.hasMedia(u) ? c.createElement("media", { url: u }) : null;
        }
      }).elementToElement({
        view: {
          name: "div",
          attributes: {
            "data-oembed-url": !0
          }
        },
        model: (l, { writer: c }) => {
          const u = l.getAttribute("data-oembed-url");
          return a.hasMedia(u) ? c.createElement("media", { url: u }) : null;
        }
      }).add((l) => {
        const c = (u, d, h) => {
          if (!h.consumable.consume(d.viewItem, { name: !0, classes: "media" }))
            return;
          const { modelRange: f, modelCursor: m } = h.convertChildren(d.viewItem, d.modelCursor);
          d.modelRange = f, d.modelCursor = m, me(f.getItems()) || h.consumable.revert(d.viewItem, { name: !0, classes: "media" });
        };
        l.on("element:figure", c);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const u3 = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
  class d3 extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ol, bt, Nl];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "AutoMediaEmbed";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._timeoutId = null, this._positionToInsert = null;
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.document, i = e.plugins.get("ClipboardPipeline");
      this.listenTo(i, "inputTransformation", () => {
        const o = t.selection.getFirstRange(), r = le.fromPosition(o.start);
        r.stickiness = "toPrevious";
        const a = le.fromPosition(o.end);
        a.stickiness = "toNext", t.once("change:data", () => {
          this._embedMediaBetweenPositions(r, a), r.detach(), a.detach();
        }, { priority: "high" });
      }), e.commands.get("undo").on("execute", () => {
        this._timeoutId && (E.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
      }, { priority: "high" });
    }
    /**
     * Analyzes the part of the document between provided positions in search for a URL representing media.
     * When the URL is found, it is automatically converted into media.
     *
     * @param leftPosition Left position of the selection.
     * @param rightPosition Right position of the selection.
     */
    _embedMediaBetweenPositions(e, t) {
      const i = this.editor, s = i.plugins.get(Lo).registry, o = new Pe(e, t), r = o.getWalker({ ignoreElementEnd: !0 });
      let a = "";
      for (const c of r)
        c.item.is("$textProxy") && (a += c.item.data);
      if (a = a.trim(), !a.match(u3)) {
        o.detach();
        return;
      }
      if (!s.hasMedia(a)) {
        o.detach();
        return;
      }
      if (!i.commands.get("mediaEmbed").isEnabled) {
        o.detach();
        return;
      }
      this._positionToInsert = le.fromPosition(e), this._timeoutId = E.window.setTimeout(() => {
        i.model.change((c) => {
          this._timeoutId = null, c.remove(o), o.detach();
          let u = null;
          this._positionToInsert.root.rootName !== "$graveyard" && (u = this._positionToInsert), Sp(i.model, a, u, !1), this._positionToInsert.detach(), this._positionToInsert = null;
        }), i.plugins.get(bt).requestUndoOnBackspace();
      }, 100);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class h3 extends T {
    /**
     * @param validators Form validators used by {@link #isValid}.
     * @param locale The localization services instance.
     */
    constructor(e, t) {
      super(t);
      const i = t.t;
      this.focusTracker = new Q(), this.keystrokes = new ne(), this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(i("Save"), x.check, "ck-button-save"), this.saveButtonView.type = "submit", this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (s) => !!s), this.cancelButtonView = this._createButton(i("Cancel"), x.cancel, "ck-button-cancel", "cancel"), this._focusables = new ke(), this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the <kbd>Tab</kbd> key.
          focusNext: "tab"
        }
      }), this._validators = e, this.setTemplate({
        tag: "form",
        attributes: {
          class: [
            "ck",
            "ck-media-form",
            "ck-responsive-form"
          ],
          tabindex: "-1"
        },
        children: [
          this.urlInputView,
          this.saveButtonView,
          this.cancelButtonView
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), an({
        view: this
      }), [
        this.urlInputView,
        this.saveButtonView,
        this.cancelButtonView
      ].forEach((i) => {
        this._focusables.add(i), this.focusTracker.add(i.element);
      }), this.keystrokes.listenTo(this.element);
      const t = (i) => i.stopPropagation();
      this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the fist {@link #_focusables} in the form.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * The native DOM `value` of the {@link #urlInputView} element.
     *
     * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
     * which works one way only and may not represent the actual state of the component in the DOM.
     */
    get url() {
      return this.urlInputView.fieldView.element.value.trim();
    }
    set url(e) {
      this.urlInputView.fieldView.element.value = e.trim();
    }
    /**
     * Validates the form and returns `false` when some fields are invalid.
     */
    isValid() {
      this.resetFormStatus();
      for (const e of this._validators) {
        const t = e(this);
        if (t)
          return this.urlInputView.errorText = t, !1;
      }
      return !0;
    }
    /**
     * Cleans up the supplementary error and information text of the {@link #urlInputView}
     * bringing them back to the state when the form has been displayed for the first time.
     *
     * See {@link #isValid}.
     */
    resetFormStatus() {
      this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault;
    }
    /**
     * Creates a labeled input view.
     *
     * @returns Labeled input view instance.
     */
    _createUrlInput() {
      const e = this.locale.t, t = new he(this.locale, ze), i = t.fieldView;
      return this._urlInputViewInfoDefault = e("Paste the media URL in the input."), this._urlInputViewInfoTip = e("Tip: Paste the URL into the content to embed faster."), t.label = e("Media URL"), t.infoText = this._urlInputViewInfoDefault, i.on("input", () => {
        t.infoText = i.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = i.element.value.trim();
      }), t;
    }
    /**
     * Creates a button view.
     *
     * @param label The button label.
     * @param icon The button icon.
     * @param className The additional button CSS class name.
     * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
     * @returns The button view instance.
     */
    _createButton(e, t, i, s) {
      const o = new P(this.locale);
      return o.set({
        label: e,
        icon: t,
        tooltip: !0
      }), o.extendTemplate({
        attributes: {
          class: i
        }
      }), s && o.delegate("execute").to(this, s), o;
    }
  }
  const f3 = '<svg viewBox="0 0 22 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.587 1.5c-.612 0-.601-.029-.601.551v14.84c0 .59-.01.559.591.559h18.846c.602 0 .591.03.591-.56V2.052c0-.58.01-.55-.591-.55H1.587Zm.701.971h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-14.24 1h13.008v12H4.467l.029-12Zm-2.208 1h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003l-.029 1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h.974v1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Z"/><path d="M8.374 6.648a.399.399 0 0 1 .395-.4.402.402 0 0 1 .2.049l5.148 2.824a.4.4 0 0 1 0 .7l-5.148 2.824a.403.403 0 0 1-.595-.35V6.648Z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class m3 extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Lo];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "MediaEmbedUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.commands.get("mediaEmbed");
      e.ui.componentFactory.add("mediaEmbed", (i) => {
        const s = we(i);
        return this._setUpDropdown(s, t), s;
      });
    }
    _setUpDropdown(e, t) {
      const i = this.editor, s = i.t, o = e.buttonView, r = i.plugins.get(Lo).registry;
      e.once("change:isOpen", () => {
        const a = new (ja(h3))(g3(i.t, r), i.locale);
        e.panelView.children.add(a), o.on("open", () => {
          a.disableCssTransitions(), a.url = t.value || "", a.urlInputView.fieldView.select(), a.enableCssTransitions();
        }, { priority: "low" }), e.on("submit", () => {
          a.isValid() && (i.execute("mediaEmbed", a.url), i.editing.view.focus());
        }), e.on("change:isOpen", () => a.resetFormStatus()), e.on("cancel", () => {
          i.editing.view.focus();
        }), a.delegate("submit", "cancel").to(e), a.urlInputView.fieldView.bind("value").to(t, "value"), a.urlInputView.bind("isEnabled").to(t, "isEnabled");
      }), e.bind("isEnabled").to(t), o.set({
        label: s("Insert media"),
        icon: f3,
        tooltip: !0
      });
    }
  }
  function g3(n, e) {
    return [
      (t) => {
        if (!t.url.length)
          return n("The URL must not be empty.");
      },
      (t) => {
        if (!e.hasMedia(t.url))
          return n("This media URL is not supported.");
      }
    ];
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class p3 extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Lo, m3, d3, gn];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "MediaEmbed";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function w3(n) {
    const e = parseFloat(n);
    return n.endsWith("pt") ? $i(e * 96 / 72) : n.endsWith("pc") ? $i(e * 12 * 96 / 72) : n.endsWith("in") ? $i(e * 96) : n.endsWith("cm") ? $i(e * 96 / 2.54) : n.endsWith("mm") ? $i(e / 10 * 96 / 2.54) : n;
  }
  function ch(n) {
    return n !== void 0 && n.endsWith("px");
  }
  function $i(n) {
    return n.toFixed(2).replace(/\.?0+$/, "") + "px";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function b3(n, e, t) {
    if (!n.childCount)
      return;
    const i = new Mt(n.document), s = v3(n, i);
    if (!s.length)
      return;
    const o = {}, r = [];
    for (const a of s)
      if (a.indent !== void 0) {
        y3(a) || (r.length = 0);
        const l = `${a.id}:${a.indent}`, c = Math.min(a.indent - 1, r.length);
        if (c < r.length && r[c].id !== a.id && (r.length = c), c < r.length - 1)
          r.length = c + 1;
        else {
          const d = C3(a, e);
          if (c > r.length - 1 || r[c].listElement.name != d.type) {
            c == 0 && d.type == "ol" && a.id !== void 0 && o[l] && (d.startIndex = o[l]);
            const h = A3(d, i, t);
            if (ch(a.marginLeft) && (c == 0 || ch(r[c - 1].marginLeft))) {
              let f = a.marginLeft;
              c > 0 && (f = $i(parseFloat(f) - parseFloat(r[c - 1].marginLeft))), i.setStyle("padding-left", f, h);
            }
            if (r.length == 0) {
              const f = a.element.parent, m = f.getChildIndex(a.element) + 1;
              i.insertChild(m, h, f);
            } else {
              const f = r[c - 1].listItemElements;
              i.appendChild(h, f[f.length - 1]);
            }
            r[c] = {
              ...a,
              listElement: h,
              listItemElements: []
            }, c == 0 && a.id !== void 0 && (o[l] = d.startIndex || 1);
          }
        }
        const u = a.element.name == "li" ? a.element : i.createElement("li");
        i.appendChild(u, r[c].listElement), r[c].listItemElements.push(u), c == 0 && a.id !== void 0 && o[l]++, a.element != u && i.appendChild(a.element, u), S3(a.element, i), i.removeStyle("text-indent", a.element), i.removeStyle("margin-left", a.element);
      } else {
        const l = r.find((c) => c.marginLeft == a.marginLeft);
        if (l) {
          const c = l.listItemElements;
          i.appendChild(a.element, c[c.length - 1]), i.removeStyle("margin-left", a.element);
        } else
          r.length = 0;
      }
  }
  function _3(n, e) {
    for (const t of e.createRangeIn(n)) {
      const i = t.item;
      if (i.is("element", "li")) {
        const s = i.getChild(0);
        s && s.is("element", "p") && e.unwrapElement(s);
      }
    }
  }
  function v3(n, e) {
    const t = e.createRangeIn(n), i = [], s = /* @__PURE__ */ new Set();
    for (const o of t.getItems()) {
      if (!o.is("element") || !o.name.match(/^(p|h\d+|li|div)$/))
        continue;
      let r = I3(o);
      if (r !== void 0 && parseFloat(r) == 0 && !Array.from(o.getClassNames()).find((a) => a.startsWith("MsoList")) && (r = void 0), o.hasStyle("mso-list") || r !== void 0 && s.has(r)) {
        const a = x3(o);
        i.push({
          element: o,
          id: a.id,
          order: a.order,
          indent: a.indent,
          marginLeft: r
        }), r !== void 0 && s.add(r);
      } else
        s.clear();
    }
    return i;
  }
  function y3(n) {
    const e = n.element.previousSibling;
    return uh(e || n.element.parent);
  }
  function uh(n) {
    return n.is("element", "ol") || n.is("element", "ul");
  }
  function C3(n, e) {
    const t = new RegExp(`@list l${n.id}:level${n.indent}\\s*({[^}]*)`, "gi"), i = /mso-level-number-format:([^;]{0,100});/gi, s = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi, o = new RegExp(`@list\\s+l${n.id}:level\\d\\s*{[^{]*mso-level-text:"%\\d\\\\.`, "gi"), r = new RegExp(`@list l${n.id}:level\\d\\s*{[^{]*mso-level-number-format:`, "gi"), a = o.exec(e), l = r.exec(e), c = a && !l, u = t.exec(e);
    let d = "decimal", h = "ol", f = null;
    if (u && u[1]) {
      const m = i.exec(u[1]);
      if (m && m[1] && (d = m[1].trim(), h = d !== "bullet" && d !== "image" ? "ol" : "ul"), d === "bullet") {
        const p = k3(n.element);
        p && (d = p);
      } else {
        const p = s.exec(u[1]);
        p && p[1] && (f = parseInt(p[1]));
      }
      c && (h = "ol");
    }
    return {
      type: h,
      startIndex: f,
      style: E3(d),
      isLegalStyleList: c
    };
  }
  function k3(n) {
    if (n.name == "li" && n.parent.name == "ul" && n.parent.hasAttribute("type"))
      return n.parent.getAttribute("type");
    const e = T3(n);
    if (!e)
      return null;
    const t = e._data;
    return t === "o" ? "circle" : t === "·" ? "disc" : t === "§" ? "square" : null;
  }
  function T3(n) {
    if (n.getChild(0).is("$text"))
      return null;
    for (const e of n.getChildren()) {
      if (!e.is("element", "span"))
        continue;
      const t = e.getChild(0);
      if (t)
        return t.is("$text") ? t : t.getChild(0);
    }
    /* istanbul ignore next -- @preserve */
    return null;
  }
  function E3(n) {
    if (n.startsWith("arabic-leading-zero"))
      return "decimal-leading-zero";
    switch (n) {
      case "alpha-upper":
        return "upper-alpha";
      case "alpha-lower":
        return "lower-alpha";
      case "roman-upper":
        return "upper-roman";
      case "roman-lower":
        return "lower-roman";
      case "circle":
      case "disc":
      case "square":
        return n;
      default:
        return null;
    }
  }
  function A3(n, e, t) {
    const i = e.createElement(n.type);
    return n.style && e.setStyle("list-style-type", n.style, i), n.startIndex && n.startIndex > 1 && e.setAttribute("start", n.startIndex, i), n.isLegalStyleList && t && e.addClass("legal-list", i), i;
  }
  function x3(n) {
    const e = n.getStyle("mso-list");
    if (e === void 0)
      return {};
    const t = e.match(/(^|\s{1,100})l(\d+)/i), i = e.match(/\s{0,100}lfo(\d+)/i), s = e.match(/\s{0,100}level(\d+)/i);
    return t && i && s ? {
      id: t[2],
      order: i[1],
      indent: parseInt(s[1])
    } : {
      indent: 1
      // Handle empty mso-list style as a marked for default list item.
    };
  }
  function S3(n, e) {
    const t = new rt({
      name: "span",
      styles: {
        "mso-list": "Ignore"
      }
    }), i = e.createRangeIn(n);
    for (const s of i)
      s.type === "elementStart" && t.match(s.item) && e.remove(s.item);
  }
  function I3(n) {
    const e = n.getStyle("margin-left");
    return e === void 0 || e.endsWith("px") ? e : w3(e);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function P3(n, e) {
    if (!n.childCount)
      return;
    const t = new Mt(n.document), i = L3(n, t);
    V3(i, n, t), B3(i, n, t), M3(n, t);
    const s = O3(n, t);
    s.length && D3(s, N3(e), t);
  }
  function R3(n) {
    return btoa(n.match(/\w{2}/g).map((e) => String.fromCharCode(parseInt(e, 16))).join(""));
  }
  function L3(n, e) {
    const t = e.createRangeIn(n), i = new rt({
      name: /v:(.+)/
    }), s = [];
    for (const o of t) {
      if (o.type != "elementStart")
        continue;
      const r = o.item, a = r.previousSibling, l = a && a.is("element") ? a.name : null, c = ["Chart"], u = i.match(r), d = r.getAttribute("o:gfxdata"), h = l === "v:shapetype", f = d && c.some((m) => r.getAttribute("id").includes(m));
      u && d && !h && !f && s.push(o.item.getAttribute("id"));
    }
    return s;
  }
  function V3(n, e, t) {
    const i = t.createRangeIn(e), s = new rt({
      name: "img"
    }), o = [];
    for (const r of i)
      if (r.item.is("element") && s.match(r.item)) {
        const a = r.item, l = a.getAttribute("v:shapes") ? a.getAttribute("v:shapes").split(" ") : [];
        l.length && l.every((c) => n.indexOf(c) > -1) ? o.push(a) : a.getAttribute("src") || o.push(a);
      }
    for (const r of o)
      t.remove(r);
  }
  function M3(n, e) {
    const t = e.createRangeIn(n), i = new rt({
      name: /v:(.+)/
    }), s = [];
    for (const o of t)
      o.type == "elementStart" && i.match(o.item) && s.push(o.item);
    for (const o of s)
      e.remove(o);
  }
  function B3(n, e, t) {
    const i = t.createRangeIn(e), s = [];
    for (const a of i)
      if (a.type == "elementStart" && a.item.is("element", "v:shape")) {
        const l = a.item.getAttribute("id");
        if (n.includes(l))
          continue;
        o(a.item.parent.getChildren(), l) || s.push(a.item);
      }
    for (const a of s) {
      const l = {
        src: r(a)
      };
      a.hasAttribute("alt") && (l.alt = a.getAttribute("alt"));
      const c = t.createElement("img", l);
      t.insertChild(a.index + 1, c, a.parent);
    }
    function o(a, l) {
      for (const c of a) {
        /* istanbul ignore else -- @preserve */
        if (c.is("element") && (c.name == "img" && c.getAttribute("v:shapes") == l || o(c.getChildren(), l)))
          return !0;
      }
      return !1;
    }
    function r(a) {
      for (const l of a.getChildren()) {
        /* istanbul ignore else -- @preserve */
        if (l.is("element") && l.getAttribute("src"))
          return l.getAttribute("src");
      }
    }
  }
  function O3(n, e) {
    const t = e.createRangeIn(n), i = new rt({
      name: "img"
    }), s = [];
    for (const o of t)
      o.item.is("element") && i.match(o.item) && o.item.getAttribute("src").startsWith("file://") && s.push(o.item);
    return s;
  }
  function N3(n) {
    if (!n)
      return [];
    const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, t = new RegExp("(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}", "g"), i = n.match(t), s = [];
    if (i)
      for (const o of i) {
        let r = !1;
        o.includes("\\pngblip") ? r = "image/png" : o.includes("\\jpegblip") && (r = "image/jpeg"), r && s.push({
          hex: o.replace(e, "").replace(/[^\da-fA-F]/g, ""),
          type: r
        });
      }
    return s;
  }
  function D3(n, e, t) {
    if (n.length === e.length)
      for (let i = 0; i < n.length; i++) {
        const s = `data:${e[i].type};base64,${R3(e[i].hex)}`;
        t.setAttribute("src", s, n[i]);
      }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function F3(n) {
    const e = [], t = new Mt(n.document);
    for (const { item: i } of t.createRangeIn(n))
      if (i.is("element")) {
        for (const s of i.getClassNames())
          /\bmso/gi.exec(s) && t.removeClass(s, i);
        for (const s of i.getStyleNames())
          /\bmso/gi.exec(s) && t.removeStyle(s, i);
        (i.is("element", "w:sdt") || i.is("element", "w:sdtpr") && i.isEmpty || i.is("element", "o:p") && i.isEmpty) && e.push(i);
      }
    for (const i of e) {
      const s = i.parent, o = s.getChildIndex(i);
      t.insertChild(o, i.getChildren(), s), t.remove(i);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const z3 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i, U3 = /xmlns:o="urn:schemas-microsoft-com/i;
  class H3 {
    /**
     * Creates a new `MSWordNormalizer` instance.
     *
     * @param document View document.
     */
    constructor(e, t = !1) {
      this.document = e, this.hasMultiLevelListPlugin = t;
    }
    /**
     * @inheritDoc
     */
    isActive(e) {
      return z3.test(e) || U3.test(e);
    }
    /**
     * @inheritDoc
     */
    execute(e) {
      const { body: t, stylesString: i } = e._parsedData;
      b3(t, i, this.hasMultiLevelListPlugin), P3(t, e.dataTransfer.getData("text/rtf")), F3(t), e.content = t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function $3(n, e) {
    for (const t of n.getChildren())
      if (t.is("element", "b") && t.getStyle("font-weight") === "normal") {
        const i = n.getChildIndex(t);
        e.remove(t), e.insertChild(i, t.getChildren(), n);
      }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function W3(n, e) {
    const t = new Xo(e.document.stylesProcessor), i = new Qo(t, { renderingMode: "data" }), s = i.blockElements, o = i.inlineObjectElements, r = [];
    for (const a of e.createRangeIn(n)) {
      const l = a.item;
      if (l.is("element", "br")) {
        const c = dh(l, "forward", e, { blockElements: s, inlineObjectElements: o }), u = dh(l, "backward", e, { blockElements: s, inlineObjectElements: o }), d = hh(c, s);
        (hh(u, s) || d) && r.push(l);
      }
    }
    for (const a of r)
      a.hasClass("Apple-interchange-newline") ? e.remove(a) : e.replace(a, e.createElement("p"));
  }
  function dh(n, e, t, { blockElements: i, inlineObjectElements: s }) {
    let o = t.createPositionAt(n, e == "forward" ? "after" : "before");
    return o = o.getLastMatchingPosition(({ item: r }) => r.is("element") && !i.includes(r.name) && !s.includes(r.name), { direction: e }), e == "forward" ? o.nodeAfter : o.nodeBefore;
  }
  function hh(n, e) {
    return !!n && n.is("element") && e.includes(n.name);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const q3 = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
  class G3 {
    /**
     * Creates a new `GoogleDocsNormalizer` instance.
     *
     * @param document View document.
     */
    constructor(e) {
      this.document = e;
    }
    /**
     * @inheritDoc
     */
    isActive(e) {
      return q3.test(e);
    }
    /**
     * @inheritDoc
     */
    execute(e) {
      const t = new Mt(this.document), { body: i } = e._parsedData;
      $3(i, t), _3(i, t), W3(i, t), e.content = i;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function j3(n, e) {
    for (const t of n.getChildren())
      t.is("element", "table") && t.hasAttribute("xmlns") && e.removeAttribute("xmlns", t);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function K3(n, e) {
    for (const t of n.getChildren())
      if (t.is("element", "google-sheets-html-origin")) {
        const i = n.getChildIndex(t);
        e.remove(t), e.insertChild(i, t.getChildren(), n);
      }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Z3(n, e) {
    for (const t of n.getChildren())
      t.is("element", "table") && t.getStyle("width") === "0px" && e.removeStyle("width", t);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function J3(n, e) {
    for (const t of Array.from(n.getChildren()))
      t.is("element", "style") && e.remove(t);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const X3 = /<google-sheets-html-origin/i;
  class Y3 {
    /**
     * Creates a new `GoogleSheetsNormalizer` instance.
     *
     * @param document View document.
     */
    constructor(e) {
      this.document = e;
    }
    /**
     * @inheritDoc
     */
    isActive(e) {
      return X3.test(e);
    }
    /**
     * @inheritDoc
     */
    execute(e) {
      const t = new Mt(this.document), { body: i } = e._parsedData;
      K3(i, t), j3(i, t), Z3(i, t), J3(i, t), e.content = i;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Q3(n) {
    return fh(fh(n)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
  }
  function e7(n) {
    n.querySelectorAll("span[style*=spacerun]").forEach((e) => {
      const t = e, i = t.innerText.length || 0;
      t.innerText = Array(i + 1).join("  ").substr(0, i);
    });
  }
  function fh(n) {
    return n.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length === 1 ? " " : Array(t.length + 1).join("  ").substr(0, t.length));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function t7(n, e) {
    const t = new DOMParser();
    n = n.replace(/<!--\[if gte vml 1]>/g, ""), n = n.replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, "");
    const i = Q3(s7(n)), s = t.parseFromString(i, "text/html");
    e7(s);
    const o = s.body.innerHTML, r = i7(s, e), a = n7(s);
    return {
      body: r,
      bodyString: o,
      styles: a.styles,
      stylesString: a.stylesString
    };
  }
  function i7(n, e) {
    const t = new Xo(e), i = new Qo(t, { renderingMode: "data" }), s = n.createDocumentFragment(), o = n.body.childNodes;
    for (; o.length > 0; )
      s.appendChild(o[0]);
    return i.domToView(s, { skipComments: !0 });
  }
  function n7(n) {
    const e = [], t = [], i = Array.from(n.getElementsByTagName("style"));
    for (const s of i)
      s.sheet && s.sheet.cssRules && s.sheet.cssRules.length && (e.push(s.sheet), t.push(s.innerHTML));
    return {
      styles: e,
      stylesString: t.join(" ")
    };
  }
  function s7(n) {
    const e = "</body>", t = "</html>", i = n.indexOf(e);
    if (i < 0)
      return n;
    const s = n.indexOf(t, i + e.length);
    return n.substring(0, i + e.length) + (s >= 0 ? n.substring(s) : "");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class o7 extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "PasteFromOffice";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Xe];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.plugins.get("ClipboardPipeline"), i = e.editing.view.document, s = [], o = this.editor.plugins.has("MultiLevelList");
      s.push(new H3(i, o)), s.push(new G3(i)), s.push(new Y3(i)), t.on("inputTransformation", (r, a) => {
        if (a._isTransformedWithPasteFromOffice || e.model.document.selection.getFirstPosition().parent.is("element", "codeBlock"))
          return;
        const c = a.dataTransfer.getData("text/html"), u = s.find((d) => d.isActive(c));
        u && (a._parsedData || (a._parsedData = t7(c, i.stylesProcessor)), u.execute(a), a._isTransformedWithPasteFromOffice = !0);
      }, { priority: "high" });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Wl(n, e) {
    const { modelAttribute: t, styleName: i, viewElement: s, defaultValue: o, reduceBoxSides: r = !1, shouldUpcast: a = () => !0 } = e;
    n.for("upcast").attributeToAttribute({
      view: {
        name: s,
        styles: {
          [i]: /[\s\S]+/
        }
      },
      model: {
        key: t,
        value: (l) => {
          if (!a(l))
            return;
          const c = l.getNormalizedStyle(i), u = r ? ho(c) : c;
          if (o !== u)
            return u;
        }
      }
    });
  }
  function Ia(n, e, t, i) {
    n.for("upcast").add((s) => s.on("element:" + e, (o, r, a) => {
      if (!r.modelRange)
        return;
      const l = [
        "border-top-width",
        "border-top-color",
        "border-top-style",
        "border-bottom-width",
        "border-bottom-color",
        "border-bottom-style",
        "border-right-width",
        "border-right-color",
        "border-right-style",
        "border-left-width",
        "border-left-color",
        "border-left-style"
      ].filter((f) => r.viewItem.hasStyle(f));
      if (!l.length)
        return;
      const c = {
        styles: l
      };
      if (!a.consumable.test(r.viewItem, c))
        return;
      const u = [...r.modelRange.getItems({ shallow: !0 })].pop();
      a.consumable.consume(r.viewItem, c);
      const d = {
        style: r.viewItem.getNormalizedStyle("border-style"),
        color: r.viewItem.getNormalizedStyle("border-color"),
        width: r.viewItem.getNormalizedStyle("border-width")
      }, h = {
        style: ho(d.style),
        color: ho(d.color),
        width: ho(d.width)
      };
      h.style !== i.style && a.writer.setAttribute(t.style, h.style, u), h.color !== i.color && a.writer.setAttribute(t.color, h.color, u), h.width !== i.width && a.writer.setAttribute(t.width, h.width, u);
    }));
  }
  function $n(n, e) {
    const { modelElement: t, modelAttribute: i, styleName: s } = e;
    n.for("downcast").attributeToAttribute({
      model: {
        name: t,
        key: i
      },
      view: (o) => ({
        key: "style",
        value: {
          [s]: o
        }
      })
    });
  }
  function uo(n, e) {
    const { modelAttribute: t, styleName: i } = e;
    n.for("downcast").add((s) => s.on(`attribute:${t}:table`, (o, r, a) => {
      const { item: l, attributeNewValue: c } = r, { mapper: u, writer: d } = a;
      if (!a.consumable.consume(r.item, o.name))
        return;
      const h = [...u.toViewElement(l).getChildren()].find((f) => f.is("element", "table"));
      c ? d.setStyle(i, c, h) : d.removeStyle(i, h);
    }));
  }
  function ho(n) {
    if (!n)
      return;
    const e = ["top", "right", "bottom", "left"];
    if (!e.every((o) => n[o]))
      return n;
    const i = n.top;
    return e.every((o) => n[o] === i) ? i : n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function se(n, e, t, i, s = 1) {
    e != null && s !== void 0 && s !== null && e > s ? i.setAttribute(n, e, t) : i.removeAttribute(n, t);
  }
  function Ei(n, e, t = {}) {
    const i = n.createElement("tableCell", t);
    return n.insertElement("paragraph", i), n.insert(i, e), i;
  }
  function Pa(n, e) {
    const t = e.parent.parent, i = parseInt(t.getAttribute("headingColumns") || "0"), { column: s } = n.getCellLocation(e);
    return !!i && s < i;
  }
  function fo(n, e, t) {
    const { modelAttribute: i } = t;
    n.extend("tableCell", {
      allowAttributes: [i]
    }), Wl(e, { viewElement: /^(td|th)$/, ...t }), $n(e, { modelElement: "tableCell", ...t });
  }
  function li(n) {
    const e = n.getSelectedElement();
    return e && e.is("element", "table") ? e : n.getFirstPosition().findAncestor("table");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function r7() {
    return (n) => {
      n.on("element:figure", (e, t, i) => {
        if (!i.consumable.test(t.viewItem, { name: !0, classes: "table" }))
          return;
        const s = c7(t.viewItem);
        if (!s || !i.consumable.test(s, { name: !0 }))
          return;
        i.consumable.consume(t.viewItem, { name: !0, classes: "table" });
        const o = i.convertItem(s, t.modelCursor), r = me(o.modelRange.getItems());
        if (!r) {
          i.consumable.revert(t.viewItem, { name: !0, classes: "table" });
          return;
        }
        i.convertChildren(t.viewItem, i.writer.createPositionAt(r, "end")), i.updateConversionResult(r, t);
      });
    };
  }
  function a7() {
    return (n) => {
      n.on("element:table", (e, t, i) => {
        const s = t.viewItem;
        if (!i.consumable.test(s, { name: !0 }))
          return;
        const { rows: o, headingRows: r, headingColumns: a } = u7(s), l = {};
        a && (l.headingColumns = a), r && (l.headingRows = r);
        const c = i.writer.createElement("table", l);
        if (i.safeInsert(c, t.modelCursor)) {
          if (i.consumable.consume(s, { name: !0 }), o.forEach((u) => i.convertItem(u, i.writer.createPositionAt(c, "end"))), i.convertChildren(s, i.writer.createPositionAt(c, "end")), c.isEmpty) {
            const u = i.writer.createElement("tableRow");
            i.writer.insert(u, i.writer.createPositionAt(c, "end")), Ei(i.writer, i.writer.createPositionAt(u, "end"));
          }
          i.updateConversionResult(c, t);
        }
      });
    };
  }
  function l7() {
    return (n) => {
      n.on("element:tr", (e, t) => {
        t.viewItem.isEmpty && t.modelCursor.index == 0 && e.stop();
      }, { priority: "high" });
    };
  }
  function mh(n) {
    return (e) => {
      e.on(`element:${n}`, (t, i, { writer: s }) => {
        if (!i.modelRange)
          return;
        const o = i.modelRange.start.nodeAfter, r = s.createPositionAt(o, 0);
        if (i.viewItem.isEmpty) {
          s.insertElement("paragraph", r);
          return;
        }
        const a = Array.from(o.getChildren());
        if (a.every((l) => l.is("element", "$marker"))) {
          const l = s.createElement("paragraph");
          s.insert(l, s.createPositionAt(o, 0));
          for (const c of a)
            s.move(s.createRangeOn(c), s.createPositionAt(l, "end"));
        }
      }, { priority: "low" });
    };
  }
  function c7(n) {
    for (const e of n.getChildren())
      if (e.is("element", "table"))
        return e;
  }
  function u7(n) {
    let e = 0, t;
    const i = [], s = [];
    let o;
    for (const r of Array.from(n.getChildren())) {
      if (r.name !== "tbody" && r.name !== "thead" && r.name !== "tfoot")
        continue;
      r.name === "thead" && !o && (o = r);
      const a = Array.from(r.getChildren()).filter((l) => l.is("element", "tr"));
      for (const l of a)
        if (o && r === o || r.name === "tbody" && Array.from(l.getChildren()).length && Array.from(l.getChildren()).every((c) => c.is("element", "th")))
          e++, i.push(l);
        else {
          s.push(l);
          const c = d7(l);
          (!t || c < t) && (t = c);
        }
    }
    return {
      headingRows: e,
      headingColumns: t || 0,
      rows: [...i, ...s]
    };
  }
  function d7(n) {
    let e = 0, t = 0;
    const i = Array.from(n.getChildren()).filter((s) => s.name === "th" || s.name === "td");
    for (; t < i.length && i[t].name === "th"; ) {
      const s = i[t], o = parseInt(s.getAttribute("colspan") || "1");
      e = e + o, t++;
    }
    return e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class q {
    /**
     * Creates an instance of the table walker.
     *
     * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
     * It walks row by row and column by column in order to output values defined in the constructor.
     * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
     * pass the `includeAllSlots` option to the constructor.
     *
     * The most important values of the iterator are column and row indexes of a cell.
     *
     * See {@link module:table/tablewalker~TableSlot} what values are returned by the table walker.
     *
     * To iterate over a given row:
     *
     * ```ts
     * const tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );
     *
     * for ( const tableSlot of tableWalker ) {
     *   console.log( 'A cell at row', tableSlot.row, 'and column', tableSlot.column );
     * }
     * ```
     *
     * For instance the code above for the following table:
     *
     *  +----+----+----+----+----+----+
     *  | 00      | 02 | 03 | 04 | 05 |
     *  |         +----+----+----+----+
     *  |         | 12      | 14 | 15 |
     *  |         +----+----+----+    +
     *  |         | 22           |    |
     *  |----+----+----+----+----+    +
     *  | 30 | 31 | 32 | 33 | 34 |    |
     *  +----+----+----+----+----+----+
     *
     * will log in the console:
     *
     *  'A cell at row 1 and column 2'
     *  'A cell at row 1 and column 4'
     *  'A cell at row 1 and column 5'
     *  'A cell at row 2 and column 2'
     *
     * To also iterate over spanned cells:
     *
     * ```ts
     * const tableWalker = new TableWalker( table, { row: 1, includeAllSlots: true } );
     *
     * for ( const tableSlot of tableWalker ) {
     *   console.log( 'Slot at', tableSlot.row, 'x', tableSlot.column, ':', tableSlot.isAnchor ? 'is anchored' : 'is spanned' );
     * }
     * ```
     *
     * will log in the console for the table from the previous example:
     *
     *  'Cell at 1 x 0 : is spanned'
     *  'Cell at 1 x 1 : is spanned'
     *  'Cell at 1 x 2 : is anchored'
     *  'Cell at 1 x 3 : is spanned'
     *  'Cell at 1 x 4 : is anchored'
     *  'Cell at 1 x 5 : is anchored'
     *
     * **Note**: Option `row` is a shortcut that sets both `startRow` and `endRow` to the same row.
     * (Use either `row` or `startRow` and `endRow` but never together). Similarly the `column` option sets both `startColumn`
     * and `endColumn` to the same column (Use either `column` or `startColumn` and `endColumn` but never together).
     *
     * @param table A table over which the walker iterates.
     * @param options An object with configuration.
     * @param options.row A row index for which this iterator will output cells. Can't be used together with `startRow` and `endRow`.
     * @param options.startRow A row index from which this iterator should start. Can't be used together with `row`. Default value is 0.
     * @param options.endRow A row index at which this iterator should end. Can't be used together with `row`.
     * @param options.column A column index for which this iterator will output cells.
     * Can't be used together with `startColumn` and `endColumn`.
     * @param options.startColumn A column index from which this iterator should start.
     * Can't be used together with `column`. Default value is 0.
     * @param options.endColumn A column index at which this iterator should end. Can't be used together with `column`.
     * @param options.includeAllSlots Also return values for spanned cells. Default value is "false".
     */
    constructor(e, t = {}) {
      this._jumpedToStartRow = !1, this._table = e, this._startRow = t.row !== void 0 ? t.row : t.startRow || 0, this._endRow = t.row !== void 0 ? t.row : t.endRow, this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0, this._endColumn = t.column !== void 0 ? t.column : t.endColumn, this._includeAllSlots = !!t.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
    }
    /**
     * Iterable interface.
     */
    [Symbol.iterator]() {
      return this;
    }
    /**
     * Gets the next table walker's value.
     *
     * @returns The next table walker's value.
     */
    next() {
      this._canJumpToStartRow() && this._jumpToNonSpannedRowClosestToStartRow();
      const e = this._table.getChild(this._rowIndex);
      if (!e || this._isOverEndRow())
        return { done: !0, value: void 0 };
      if (!e.is("element", "tableRow"))
        return this._rowIndex++, this.next();
      if (this._isOverEndColumn())
        return this._advanceToNextRow();
      let t = null;
      const i = this._getSpanned();
      if (i)
        this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(i.cell, i.row, i.column));
      else {
        const s = e.getChild(this._cellIndex);
        if (!s)
          return this._advanceToNextRow();
        const o = parseInt(s.getAttribute("colspan") || "1"), r = parseInt(s.getAttribute("rowspan") || "1");
        (o > 1 || r > 1) && this._recordSpans(s, r, o), this._shouldSkipSlot() || (t = this._formatOutValue(s)), this._nextCellAtColumn = this._column + o;
      }
      return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t || this.next();
    }
    /**
     * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row
     * to output.
     *
     * @param row The row index to skip.
     */
    skipRow(e) {
      this._skipRows.add(e);
    }
    /**
     * Advances internal cursor to the next row.
     */
    _advanceToNextRow() {
      return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
    }
    /**
     * Checks if the current row is over {@link #_endRow}.
     */
    _isOverEndRow() {
      return this._endRow !== void 0 && this._row > this._endRow;
    }
    /**
     * Checks if the current cell is over {@link #_endColumn}
     */
    _isOverEndColumn() {
      return this._endColumn !== void 0 && this._column > this._endColumn;
    }
    /**
     * A common method for formatting the iterator's output value.
     *
     * @param cell The table cell to output.
     * @param anchorRow The row index of a cell anchor slot.
     * @param anchorColumn The column index of a cell anchor slot.
     */
    _formatOutValue(e, t = this._row, i = this._column) {
      return {
        done: !1,
        value: new h7(this, e, t, i)
      };
    }
    /**
     * Checks if the current slot should be skipped.
     */
    _shouldSkipSlot() {
      const e = this._skipRows.has(this._row), t = this._row < this._startRow, i = this._column < this._startColumn, s = this._endColumn !== void 0 && this._column > this._endColumn;
      return e || t || i || s;
    }
    /**
     * Returns the cell element that is spanned over the current cell location.
     */
    _getSpanned() {
      const e = this._spannedCells.get(this._row);
      return e && e.get(this._column) || null;
    }
    /**
     * Updates spanned cells map relative to the current cell location and its span dimensions.
     *
     * @param cell A cell that is spanned.
     * @param rowspan Cell height.
     * @param colspan Cell width.
     */
    _recordSpans(e, t, i) {
      const s = {
        cell: e,
        row: this._row,
        column: this._column
      };
      for (let o = this._row; o < this._row + t; o++)
        for (let r = this._column; r < this._column + i; r++)
          (o != this._row || r != this._column) && this._markSpannedCell(o, r, s);
    }
    /**
     * Marks the cell location as spanned by another cell.
     *
     * @param row The row index of the cell location.
     * @param column The column index of the cell location.
     * @param data A spanned cell details (cell element, anchor row and column).
     */
    _markSpannedCell(e, t, i) {
      this._spannedCells.has(e) || this._spannedCells.set(e, /* @__PURE__ */ new Map()), this._spannedCells.get(e).set(t, i);
    }
    /**
     * Checks if part of the table can be skipped.
     */
    _canJumpToStartRow() {
      return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow;
    }
    /**
     * Sets the current row to `this._startRow` or the first row before it that has the number of cells
     * equal to the number of columns in the table.
     *
     * Example:
     * 	+----+----+----+
     *  | 00 | 01 | 02 |
     *  |----+----+----+
     *  | 10      | 12 |
     *  |         +----+
     *  |         | 22 |
     *  |         +----+
     *  |         | 32 | <--- Start row
     *  +----+----+----+
     *  | 40 | 41 | 42 |
     *  +----+----+----+
     *
     * If the 4th row is a `this._startRow`, this method will:
     * 1.) Count the number of columns this table has based on the first row (3 columns in this case).
     * 2.) Check if the 4th row contains 3 cells. It doesn't, so go to the row before it.
     * 3.) Check if the 3rd row contains 3 cells. It doesn't, so go to the row before it.
     * 4.) Check if the 2nd row contains 3 cells. It does, so set the current row to that row.
     *
     * Setting the current row this way is necessary to let the `next()`  method loop over the cells
     * spanning multiple rows or columns and update the `this._spannedCells` property.
     */
    _jumpToNonSpannedRowClosestToStartRow() {
      const e = this._getRowLength(0);
      for (let t = this._startRow; !this._jumpedToStartRow; t--)
        e === this._getRowLength(t) && (this._row = t, this._rowIndex = t, this._jumpedToStartRow = !0);
    }
    /**
     * Returns a number of columns in a row taking `colspan` into consideration.
     */
    _getRowLength(e) {
      return [...this._table.getChild(e).getChildren()].reduce((i, s) => i + parseInt(s.getAttribute("colspan") || "1"), 0);
    }
  }
  class h7 {
    /**
     * Creates an instance of the table walker value.
     *
     * @param tableWalker The table walker instance.
     * @param cell The current table cell.
     * @param anchorRow The row index of a cell anchor slot.
     * @param anchorColumn The column index of a cell anchor slot.
     */
    constructor(e, t, i, s) {
      this.cell = t, this.row = e._row, this.column = e._column, this.cellAnchorRow = i, this.cellAnchorColumn = s, this._cellIndex = e._cellIndex, this._rowIndex = e._rowIndex, this._table = e._table;
    }
    // @if CK_DEBUG // public get isSpanned(): unknown { return throwMissingGetterError( 'isSpanned' ); }
    // @if CK_DEBUG // public get colspan(): unknown { return throwMissingGetterError( 'colspan' ); }
    // @if CK_DEBUG // public get rowspan(): unknown { return throwMissingGetterError( 'rowspan' ); }
    // @if CK_DEBUG // public get cellIndex(): unknown { return throwMissingGetterError( 'cellIndex' ); }
    /**
     * Whether the cell is anchored in the current slot.
     */
    get isAnchor() {
      return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
    }
    /**
     * The width of a cell defined by a `colspan` attribute. If the model attribute is not present, it is set to `1`.
     */
    get cellWidth() {
      return parseInt(this.cell.getAttribute("colspan") || "1");
    }
    /**
     * The height of a cell defined by a `rowspan` attribute. If the model attribute is not present, it is set to `1`.
     */
    get cellHeight() {
      return parseInt(this.cell.getAttribute("rowspan") || "1");
    }
    /**
     * The index of the current row element in the table.
     */
    get rowIndex() {
      return this._rowIndex;
    }
    /**
     * Returns the {@link module:engine/model/position~Position} before the table slot.
     */
    getPositionBefore() {
      return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function gh(n, e) {
    return (t, { writer: i }) => {
      const s = t.getAttribute("headingRows") || 0, o = i.createContainerElement("table", null, []), r = i.createContainerElement("figure", { class: "table" }, o);
      s > 0 && i.insert(i.createPositionAt(o, "end"), i.createContainerElement("thead", null, i.createSlot((a) => a.is("element", "tableRow") && a.index < s))), s < n.getRows(t) && i.insert(i.createPositionAt(o, "end"), i.createContainerElement("tbody", null, i.createSlot((a) => a.is("element", "tableRow") && a.index >= s)));
      for (const { positionOffset: a, filter: l } of e.additionalSlots)
        i.insert(i.createPositionAt(o, a), i.createSlot(l));
      return i.insert(i.createPositionAt(o, "after"), i.createSlot((a) => a.is("element", "tableRow") ? !1 : !e.additionalSlots.some(({ filter: l }) => l(a)))), e.asWidget ? m7(r, i) : r;
    };
  }
  function f7() {
    return (n, { writer: e }) => n.isEmpty ? e.createEmptyElement("tr") : e.createContainerElement("tr");
  }
  function ph(n = {}) {
    return (e, { writer: t }) => {
      const i = e.parent, s = i.parent, o = s.getChildIndex(i), r = new q(s, { row: o }), a = s.getAttribute("headingRows") || 0, l = s.getAttribute("headingColumns") || 0;
      let c = null;
      for (const u of r)
        if (u.cell == e) {
          const h = u.row < a || u.column < l ? "th" : "td";
          c = n.asWidget ? Ml(t.createEditableElement(h), t) : t.createContainerElement(h);
          break;
        }
      return c;
    };
  }
  function wh(n = {}) {
    return (e, { writer: t }) => {
      if (!e.parent.is("element", "tableCell") || !Ip(e))
        return null;
      if (n.asWidget)
        return t.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
      {
        const i = t.createContainerElement("p");
        return t.setCustomProperty("dataPipeline:transparentRendering", !0, i), i;
      }
    };
  }
  function Ip(n) {
    return n.parent.childCount == 1 && !g7(n);
  }
  function m7(n, e) {
    return e.setCustomProperty("table", !0, n), cr(n, e, { hasSelectionHandle: !0 });
  }
  function g7(n) {
    return !n.getAttributeKeys().next().done;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class p7 extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = e.document.selection, i = e.schema;
      this.isEnabled = w7(t, i);
    }
    /**
     * Executes the command.
     *
     * Inserts a table with the given number of rows and columns into the editor.
     *
     * @param options.rows The number of rows to create in the inserted table. Default value is 2.
     * @param options.columns The number of columns to create in the inserted table. Default value is 2.
     * @param options.headingRows The number of heading rows. If not provided it will default to
     * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.rows`} table config.
     * @param options.headingColumns The number of heading columns. If not provided it will default to
     * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.columns`} table config.
     * @fires execute
     */
    execute(e = {}) {
      const t = this.editor, i = t.model, s = t.plugins.get("TableUtils"), o = t.config.get("table.defaultHeadings.rows"), r = t.config.get("table.defaultHeadings.columns");
      e.headingRows === void 0 && o && (e.headingRows = o), e.headingColumns === void 0 && r && (e.headingColumns = r), i.change((a) => {
        const l = s.createTable(a, e);
        i.insertObject(l, null, null, { findOptimalPosition: "auto" }), a.setSelection(a.createPositionAt(l.getNodeByPath([0, 0, 0]), 0));
      });
    }
  }
  function w7(n, e) {
    const t = n.getFirstPosition().parent, i = t === t.root ? t : t.parent;
    return e.checkChild(i, "table");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class bh extends V {
    /**
     * Creates a new `InsertRowCommand` instance.
     *
     * @param editor The editor on which this command will be used.
     * @param options.order The order of insertion relative to the row in which the caret is located.
     * Possible values: `"above"` and `"below"`. Default value is "below"
     */
    constructor(e, t = {}) {
      super(e), this.order = t.order || "below";
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model.document.selection, i = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
      this.isEnabled = i;
    }
    /**
     * Executes the command.
     *
     * Depending on the command's {@link #order} value, it inserts a row `'below'` or `'above'` the row in which selection is set.
     *
     * @fires execute
     */
    execute() {
      const e = this.editor, t = e.model.document.selection, i = e.plugins.get("TableUtils"), s = this.order === "above", o = i.getSelectionAffectedTableCells(t), r = i.getRowIndexes(o), a = s ? r.first : r.last, l = o[0].findAncestor("table");
      i.insertRows(l, { at: s ? a : a + 1, copyStructureFromAbove: !s });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class _h extends V {
    /**
     * Creates a new `InsertColumnCommand` instance.
     *
     * @param editor An editor on which this command will be used.
     * @param options.order The order of insertion relative to the column in which the caret is located.
     * Possible values: `"left"` and `"right"`. Default value is "right".
     */
    constructor(e, t = {}) {
      super(e), this.order = t.order || "right";
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model.document.selection, i = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
      this.isEnabled = i;
    }
    /**
     * Executes the command.
     *
     * Depending on the command's {@link #order} value, it inserts a column to the `'left'` or `'right'` of the column
     * in which the selection is set.
     *
     * @fires execute
     */
    execute() {
      const e = this.editor, t = e.model.document.selection, i = e.plugins.get("TableUtils"), s = this.order === "left", o = i.getSelectionAffectedTableCells(t), r = i.getColumnIndexes(o), a = s ? r.first : r.last, l = o[0].findAncestor("table");
      i.insertColumns(l, { columns: 1, at: s ? a : a + 1 });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class vh extends V {
    /**
     * Creates a new `SplitCellCommand` instance.
     *
     * @param editor The editor on which this command will be used.
     * @param options.direction Indicates whether the command should split cells `'horizontally'` or `'vertically'`.
     */
    constructor(e, t = {}) {
      super(e), this.direction = t.direction || "horizontally";
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
      this.isEnabled = t.length === 1;
    }
    /**
     * @inheritDoc
     */
    execute() {
      const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
      this.direction === "horizontally" ? e.splitCellHorizontally(t, 2) : e.splitCellVertically(t, 2);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Pp(n, e, t) {
    const { startRow: i, startColumn: s, endRow: o, endColumn: r } = e, a = t.createElement("table"), l = o - i + 1;
    for (let u = 0; u < l; u++)
      t.insertElement("tableRow", a, "end");
    const c = [...new q(n, { startRow: i, endRow: o, startColumn: s, endColumn: r, includeAllSlots: !0 })];
    for (const { row: u, column: d, cell: h, isAnchor: f, cellAnchorRow: m, cellAnchorColumn: p } of c) {
      const b = u - i, v = a.getChild(b);
      if (!f)
        (m < i || p < s) && Ei(t, t.createPositionAt(v, "end"));
      else {
        const y = t.cloneElement(h);
        t.append(y, v), Bp(y, u, d, o, r, t);
      }
    }
    return b7(a, n, i, s, t), a;
  }
  function Rp(n, e, t = 0) {
    const i = [], s = new q(n, { startRow: t, endRow: e - 1 });
    for (const o of s) {
      const { row: r, cellHeight: a } = o, l = r + a - 1;
      r < e && e <= l && i.push(o);
    }
    return i;
  }
  function Lp(n, e, t) {
    const i = n.parent, s = i.parent, o = i.index, r = parseInt(n.getAttribute("rowspan")), a = e - o, l = {}, c = r - a;
    c > 1 && (l.rowspan = c);
    const u = parseInt(n.getAttribute("colspan") || "1");
    u > 1 && (l.colspan = u);
    const d = o, h = d + a, f = [...new q(s, { startRow: d, endRow: h, includeAllSlots: !0 })];
    let m = null, p;
    for (const b of f) {
      const { row: v, column: y, cell: L } = b;
      L === n && p === void 0 && (p = y), p !== void 0 && p === y && v === h && (m = Ei(t, b.getPositionBefore(), l));
    }
    return se("rowspan", a, n, t), m;
  }
  function Vp(n, e) {
    const t = [], i = new q(n);
    for (const s of i) {
      const { column: o, cellWidth: r } = s, a = o + r - 1;
      o < e && e <= a && t.push(s);
    }
    return t;
  }
  function Mp(n, e, t, i) {
    const s = parseInt(n.getAttribute("colspan")), o = t - e, r = {}, a = s - o;
    a > 1 && (r.colspan = a);
    const l = parseInt(n.getAttribute("rowspan") || "1");
    l > 1 && (r.rowspan = l);
    const c = Ei(i, i.createPositionAfter(n), r);
    return se("colspan", o, n, i), c;
  }
  function Bp(n, e, t, i, s, o) {
    const r = parseInt(n.getAttribute("colspan") || "1"), a = parseInt(n.getAttribute("rowspan") || "1");
    if (t + r - 1 > s) {
      const u = s - t + 1;
      se("colspan", u, n, o, 1);
    }
    if (e + a - 1 > i) {
      const u = i - e + 1;
      se("rowspan", u, n, o, 1);
    }
  }
  function b7(n, e, t, i, s) {
    const o = parseInt(e.getAttribute("headingRows") || "0");
    if (o > 0) {
      const a = o - t;
      se("headingRows", a, n, s, 0);
    }
    const r = parseInt(e.getAttribute("headingColumns") || "0");
    if (r > 0) {
      const a = r - i;
      se("headingColumns", a, n, s, 0);
    }
  }
  function Ra(n, e) {
    const t = e.getColumns(n), i = new Array(t).fill(0);
    for (const { column: o } of new q(n))
      i[o]++;
    const s = i.reduce((o, r, a) => r ? o : [...o, a], []);
    if (s.length > 0) {
      const o = s[s.length - 1];
      return e.removeColumns(n, { at: o }), !0;
    }
    return !1;
  }
  function La(n, e) {
    const t = [], i = e.getRows(n);
    for (let s = 0; s < i; s++)
      n.getChild(s).isEmpty && t.push(s);
    if (t.length > 0) {
      const s = t[t.length - 1];
      return e.removeRows(n, { at: s }), !0;
    }
    return !1;
  }
  function ql(n, e) {
    Ra(n, e) || La(n, e);
  }
  function Op(n, e) {
    const t = Array.from(new q(n, {
      startColumn: e.firstColumn,
      endColumn: e.lastColumn,
      row: e.lastRow
    }));
    if (t.every(({ cellHeight: o }) => o === 1))
      return e.lastRow;
    const s = t[0].cellHeight - 1;
    return e.lastRow + s;
  }
  function Np(n, e) {
    const t = Array.from(new q(n, {
      startRow: e.firstRow,
      endRow: e.lastRow,
      column: e.lastColumn
    }));
    if (t.every(({ cellWidth: o }) => o === 1))
      return e.lastColumn;
    const s = t[0].cellWidth - 1;
    return e.lastColumn + s;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class eo extends V {
    /**
     * Creates a new `MergeCellCommand` instance.
     *
     * @param editor The editor on which this command will be used.
     * @param options.direction Indicates which cell to merge with the currently selected one.
     * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.
     */
    constructor(e, t) {
      super(e), this.direction = t.direction, this.isHorizontal = this.direction == "right" || this.direction == "left";
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this._getMergeableCell();
      this.value = e, this.isEnabled = !!e;
    }
    /**
     * Executes the command.
     *
     * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.
     *
     * @fires execute
     */
    execute() {
      const e = this.editor.model, t = e.document, s = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(t.selection)[0], o = this.value, r = this.direction;
      e.change((a) => {
        const l = r == "right" || r == "down", c = l ? s : o, u = l ? o : s, d = u.parent;
        y7(u, c, a);
        const h = this.isHorizontal ? "colspan" : "rowspan", f = parseInt(s.getAttribute(h) || "1"), m = parseInt(o.getAttribute(h) || "1");
        a.setAttribute(h, f + m, c), a.setSelection(a.createRangeIn(c));
        const p = this.editor.plugins.get("TableUtils"), b = d.findAncestor("table");
        ql(b, p);
      });
    }
    /**
     * Returns a cell that can be merged with the current cell depending on the command's direction.
     */
    _getMergeableCell() {
      const t = this.editor.model.document, i = this.editor.plugins.get("TableUtils"), s = i.getTableCellsContainingSelection(t.selection)[0];
      if (!s)
        return;
      const o = this.isHorizontal ? _7(s, this.direction, i) : v7(s, this.direction, i);
      if (!o)
        return;
      const r = this.isHorizontal ? "rowspan" : "colspan", a = parseInt(s.getAttribute(r) || "1");
      if (parseInt(o.getAttribute(r) || "1") === a)
        return o;
    }
  }
  function _7(n, e, t) {
    const s = n.parent.parent, o = e == "right" ? n.nextSibling : n.previousSibling, r = (s.getAttribute("headingColumns") || 0) > 0;
    if (!o)
      return;
    const a = e == "right" ? n : o, l = e == "right" ? o : n, { column: c } = t.getCellLocation(a), { column: u } = t.getCellLocation(l), d = parseInt(a.getAttribute("colspan") || "1"), h = Pa(t, a), f = Pa(t, l);
    return r && h != f ? void 0 : c + d === u ? o : void 0;
  }
  function v7(n, e, t) {
    const i = n.parent, s = i.parent, o = s.getChildIndex(i);
    if (e == "down" && o === t.getRows(s) - 1 || e == "up" && o === 0)
      return null;
    const r = parseInt(n.getAttribute("rowspan") || "1"), a = s.getAttribute("headingRows") || 0, l = e == "down" && o + r === a, c = e == "up" && o === a;
    if (a && (l || c))
      return null;
    const u = parseInt(n.getAttribute("rowspan") || "1"), d = e == "down" ? o + u : o, h = [...new q(s, { endRow: d })], m = h.find((b) => b.cell === n).column, p = h.find(({ row: b, cellHeight: v, column: y }) => y !== m ? !1 : e == "down" ? b === d : d === b + v);
    return p && p.cell ? p.cell : null;
  }
  function y7(n, e, t) {
    yh(n) || (yh(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(n), t.createPositionAt(e, "end"))), t.remove(n);
  }
  function yh(n) {
    const e = n.getChild(0);
    return n.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class C7 extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), i = t[0];
      if (i) {
        const s = i.findAncestor("table"), r = e.getRows(s) - 1, a = e.getRowIndexes(t), l = a.first === 0 && a.last === r;
        this.isEnabled = !l;
      } else
        this.isEnabled = !1;
    }
    /**
     * @inheritDoc
     */
    execute() {
      const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), i = t.getSelectionAffectedTableCells(e.document.selection), s = t.getRowIndexes(i), o = i[0], r = o.findAncestor("table"), a = t.getCellLocation(o).column;
      e.change((l) => {
        const c = s.last - s.first + 1;
        t.removeRows(r, {
          at: s.first,
          rows: c
        });
        const u = k7(r, s.first, a, t.getRows(r));
        l.setSelection(l.createPositionAt(u, 0));
      });
    }
  }
  function k7(n, e, t, i) {
    const s = n.getChild(Math.min(e, i - 1));
    let o = s.getChild(0), r = 0;
    for (const a of s.getChildren()) {
      if (r > t)
        return o;
      o = a, r += parseInt(a.getAttribute("colspan") || "1");
    }
    return o;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class T7 extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), i = t[0];
      if (i) {
        const s = i.findAncestor("table"), o = e.getColumns(s), { first: r, last: a } = e.getColumnIndexes(t);
        this.isEnabled = a - r < o - 1;
      } else
        this.isEnabled = !1;
    }
    /**
     * @inheritDoc
     */
    execute() {
      const e = this.editor.plugins.get("TableUtils"), [t, i] = A7(this.editor.model.document.selection, e), s = t.parent.parent, o = [...new q(s)], r = {
        first: o.find((l) => l.cell === t).column,
        last: o.find((l) => l.cell === i).column
      }, a = E7(o, t, i, r);
      this.editor.model.change((l) => {
        const c = r.last - r.first + 1;
        e.removeColumns(s, {
          at: r.first,
          columns: c
        }), l.setSelection(l.createPositionAt(a, 0));
      });
    }
  }
  function E7(n, e, t, i) {
    return parseInt(t.getAttribute("colspan") || "1") > 1 ? t : e.previousSibling || t.nextSibling ? t.nextSibling || e.previousSibling : i.first ? n.reverse().find(({ column: o }) => o < i.first).cell : n.reverse().find(({ column: o }) => o > i.last).cell;
  }
  function A7(n, e) {
    const t = e.getSelectionAffectedTableCells(n), i = t[0], s = t.pop(), o = [i, s];
    return i.isBefore(s) ? o : o.reverse();
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class x7 extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, i = e.getSelectionAffectedTableCells(t.document.selection), s = i.length > 0;
      this.isEnabled = s, this.value = s && i.every((o) => this._isInHeading(o, o.parent.parent));
    }
    /**
     * Executes the command.
     *
     * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.
     *
     * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.
     *
     * @fires execute
     * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header rows according to
     * the `forceValue` parameter instead of the current model state.
     */
    execute(e = {}) {
      if (e.forceValue === this.value)
        return;
      const t = this.editor.plugins.get("TableUtils"), i = this.editor.model, s = t.getSelectionAffectedTableCells(i.document.selection), o = s[0].findAncestor("table"), { first: r, last: a } = t.getRowIndexes(s), l = this.value ? r : a + 1, c = o.getAttribute("headingRows") || 0;
      i.change((u) => {
        if (l) {
          const d = l > c ? c : 0, h = Rp(o, l, d);
          for (const { cell: f } of h)
            Lp(f, l, u);
        }
        se("headingRows", l, o, u, 0);
      });
    }
    /**
     * Checks if a table cell is in the heading section.
     */
    _isInHeading(e, t) {
      const i = parseInt(t.getAttribute("headingRows") || "0");
      return !!i && e.parent.index < i;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class S7 extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), i = t.getSelectionAffectedTableCells(e.document.selection), s = i.length > 0;
      this.isEnabled = s, this.value = s && i.every((o) => Pa(t, o));
    }
    /**
     * Executes the command.
     *
     * When the selection is in a non-header column, the command will set the `headingColumns` table attribute to cover that column.
     *
     * When the selection is already in a header column, it will set `headingColumns` so the heading section will end before that column.
     *
     * @fires execute
     * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header columns according to
     * the `forceValue` parameter instead of the current model state.
     */
    execute(e = {}) {
      if (e.forceValue === this.value)
        return;
      const t = this.editor.plugins.get("TableUtils"), i = this.editor.model, s = t.getSelectionAffectedTableCells(i.document.selection), o = s[0].findAncestor("table"), { first: r, last: a } = t.getColumnIndexes(s), l = this.value ? r : a + 1;
      i.change((c) => {
        if (l) {
          const u = Vp(o, l);
          for (const { cell: d, column: h } of u)
            Mp(d, h, l, c);
        }
        se("headingColumns", l, o, c, 0);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const I7 = 5, Va = 40, P7 = 2;
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function R7(n) {
    const e = /* @__PURE__ */ new Set();
    for (const t of n.document.differ.getChanges()) {
      let i = null;
      switch (t.type) {
        case "insert":
          i = ["table", "tableRow", "tableCell"].includes(t.name) ? t.position : null;
          break;
        case "remove":
          i = ["tableRow", "tableCell"].includes(t.name) ? t.position : null;
          break;
        case "attribute":
          t.range.start.nodeAfter && (i = ["table", "tableRow", "tableCell"].includes(t.range.start.nodeAfter.name) ? t.range.start : null);
          break;
      }
      if (!i)
        continue;
      const s = i.nodeAfter && i.nodeAfter.is("element", "table") ? i.nodeAfter : i.findAncestor("table");
      for (const o of n.createRangeOn(s).getItems())
        o.is("element", "table") && Cs(o) && e.add(o);
    }
    return e;
  }
  function L7(n, e) {
    return Va * 100 / Dp(n, e);
  }
  function Dp(n, e) {
    const t = Ch(n, "tbody", e) || Ch(n, "thead", e), i = e.editing.view.domConverter.mapViewToDom(t);
    return Ma(i);
  }
  function Ch(n, e, t) {
    return [...[...t.editing.mapper.toViewElement(n).getChildren()].find((o) => o.is("element", "table")).getChildren()].find((o) => o.is("element", e));
  }
  function Ma(n) {
    const e = E.window.getComputedStyle(n);
    return e.boxSizing === "border-box" ? parseFloat(e.width) - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) - parseFloat(e.borderLeftWidth) - parseFloat(e.borderRightWidth) : parseFloat(e.width);
  }
  function V7(n, e) {
    const t = e.getCellLocation(n).column, i = n.getAttribute("colspan") || 1;
    return {
      leftEdge: t,
      rightEdge: t + i - 1
    };
  }
  function Ie(n) {
    const e = Math.pow(10, P7), t = typeof n == "number" ? n : parseFloat(n);
    return Math.round(t * e) / e;
  }
  function M7(n, e, t) {
    return n <= e ? Ie(e) : n >= t ? Ie(t) : Ie(n);
  }
  function B7(n, e) {
    return Array(n).fill(e);
  }
  function ds(n) {
    return n.map((e) => typeof e == "number" ? e : parseFloat(e)).filter((e) => !Number.isNaN(e)).reduce((e, t) => e + t, 0);
  }
  function Gl(n) {
    const e = n.map((s) => s === "auto" ? s : parseFloat(s.replace("%", "")));
    let t = O7(e);
    const i = ds(t);
    return i !== 100 && (t = t.map((s) => Ie(s * 100 / i)).map((s, o, r) => {
      if (!(o === r.length - 1))
        return s;
      const l = ds(r);
      return Ie(s + 100 - l);
    })), t.map((s) => s + "%");
  }
  function O7(n) {
    const e = n.filter((s) => s === "auto").length;
    if (e === 0)
      return n.map((s) => Ie(s));
    const t = ds(n), i = Math.max((100 - t) / e, I7);
    return n.map((s) => s === "auto" ? i : s).map((s) => Ie(s));
  }
  function N7(n) {
    const e = E.window.getComputedStyle(n);
    return e.boxSizing === "border-box" ? parseInt(e.width) : parseFloat(e.width) + parseFloat(e.paddingLeft) + parseFloat(e.paddingRight) + parseFloat(e.borderWidth);
  }
  function Fp(n, e, t, i) {
    for (let s = 0; s < Math.max(t.length, n.length); s++) {
      const o = n[s], r = t[s];
      r ? o ? i.setAttribute("columnWidth", r, o) : i.appendElement("tableColumn", { columnWidth: r }, e) : i.remove(o);
    }
  }
  function Cs(n) {
    if (n.is("element", "tableColumnGroup"))
      return n;
    const e = n.getChildren();
    return Array.from(e).find((t) => t.is("element", "tableColumnGroup"));
  }
  function ks(n) {
    const e = Cs(n);
    return e ? Array.from(e.getChildren()) : [];
  }
  function D7(n) {
    return ks(n).map((e) => e.getAttribute("columnWidth"));
  }
  function F7(n, e) {
    return ks(n).reduce((i, s) => {
      const o = s.getAttribute("columnWidth"), r = s.getAttribute("colSpan");
      if (!r)
        return i.push(o), i;
      for (let a = 0; a < r; a++)
        i.push(o);
      return e.removeAttribute("colSpan", s), i;
    }, []);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class pe extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableUtils";
    }
    /**
     * @inheritDoc
     */
    init() {
      this.decorate("insertColumns"), this.decorate("insertRows");
    }
    /**
     * Returns the table cell location as an object with table row and table column indexes.
     *
     * For instance, in the table below:
     *
     *      0   1   2   3
     *    +---+---+---+---+
     *  0 | a     | b | c |
     *    +       +   +---+
     *  1 |       |   | d |
     *    +---+---+   +---+
     *  2 | e     |   | f |
     *    +---+---+---+---+
     *
     * the method will return:
     *
     * ```ts
     * const cellA = table.getNodeByPath( [ 0, 0 ] );
     * editor.plugins.get( 'TableUtils' ).getCellLocation( cellA );
     * // will return { row: 0, column: 0 }
     *
     * const cellD = table.getNodeByPath( [ 1, 0 ] );
     * editor.plugins.get( 'TableUtils' ).getCellLocation( cellD );
     * // will return { row: 1, column: 3 }
     * ```
     *
     * @returns Returns a `{row, column}` object.
     */
    getCellLocation(e) {
      const t = e.parent, i = t.parent, s = i.getChildIndex(t), o = new q(i, { row: s });
      for (const { cell: r, row: a, column: l } of o)
        if (r === e)
          return { row: a, column: l };
      /* istanbul ignore next -- @preserve */
    }
    /**
     * Creates an empty table with a proper structure. The table needs to be inserted into the model,
     * for example, by using the {@link module:engine/model/model~Model#insertContent} function.
     *
     * ```ts
     * model.change( ( writer ) => {
     *   // Create a table of 2 rows and 7 columns:
     *   const table = tableUtils.createTable( writer, { rows: 2, columns: 7 } );
     *
     *   // Insert a table to the model at the best position taking the current selection:
     *   model.insertContent( table );
     * }
     * ```
     *
     * @param writer The model writer.
     * @param options.rows The number of rows to create. Default value is 2.
     * @param options.columns The number of columns to create. Default value is 2.
     * @param options.headingRows The number of heading rows. Default value is 0.
     * @param options.headingColumns The number of heading columns. Default value is 0.
     * @returns The created table element.
     */
    createTable(e, t) {
      const i = e.createElement("table"), s = t.rows || 2, o = t.columns || 2;
      return Wr(e, i, 0, s, o), t.headingRows && se("headingRows", Math.min(t.headingRows, s), i, e, 0), t.headingColumns && se("headingColumns", Math.min(t.headingColumns, o), i, e, 0), i;
    }
    /**
     * Inserts rows into a table.
     *
     * ```ts
     * editor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );
     * ```
     *
     * Assuming the table on the left, the above code will transform it to the table on the right:
     *
     *  row index
     *    0 +---+---+---+       `at` = 1,      +---+---+---+ 0
     *      | a | b | c |       `rows` = 2,    | a | b | c |
     *    1 +   +---+---+   <-- insert here    +   +---+---+ 1
     *      |   | d | e |                      |   |   |   |
     *    2 +   +---+---+       will give:     +   +---+---+ 2
     *      |   | f | g |                      |   |   |   |
     *    3 +---+---+---+                      +   +---+---+ 3
     *                                         |   | d | e |
     *                                         +   +---+---+ 4
     *                                         +   + f | g |
     *                                         +---+---+---+ 5
     *
     * @param table The table model element where the rows will be inserted.
     * @param options.at The row index at which the rows will be inserted.  Default value is 0.
     * @param options.rows The number of rows to insert.  Default value is 1.
     * @param options.copyStructureFromAbove The flag for copying row structure. Note that
     * the row structure will not be copied if this option is not provided.
     */
    insertRows(e, t = {}) {
      const i = this.editor.model, s = t.at || 0, o = t.rows || 1, r = t.copyStructureFromAbove !== void 0, a = t.copyStructureFromAbove ? s - 1 : s, l = this.getRows(e), c = this.getColumns(e);
      if (s > l)
        throw new g("tableutils-insertrows-insert-out-of-range", this, { options: t });
      i.change((u) => {
        const d = e.getAttribute("headingRows") || 0;
        if (d > s && se("headingRows", d + o, e, u, 0), !r && (s === 0 || s === l)) {
          Wr(u, e, s, o, c);
          return;
        }
        const h = r ? Math.max(s, a) : s, f = new q(e, { endRow: h }), m = new Array(c).fill(1);
        for (const { row: p, column: b, cellHeight: v, cellWidth: y, cell: L } of f) {
          const M = p + v - 1, D = p < s && s <= M, A = p <= a && a <= M;
          D ? (u.setAttribute("rowspan", v + o, L), m[b] = -y) : r && A && (m[b] = y);
        }
        for (let p = 0; p < o; p++) {
          const b = u.createElement("tableRow");
          u.insert(b, e, s);
          for (let v = 0; v < m.length; v++) {
            const y = m[v], L = u.createPositionAt(b, "end");
            y > 0 && Ei(u, L, y > 1 ? { colspan: y } : void 0), v += Math.abs(y) - 1;
          }
        }
      });
    }
    /**
     * Inserts columns into a table.
     *
     * ```ts
     * editor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );
     * ```
     *
     * Assuming the table on the left, the above code will transform it to the table on the right:
     *
     *  0   1   2   3                   0   1   2   3   4   5
     *  +---+---+---+                   +---+---+---+---+---+
     *  | a     | b |                   | a             | b |
     *  +       +---+                   +               +---+
     *  |       | c |                   |               | c |
     *  +---+---+---+     will give:    +---+---+---+---+---+
     *  | d | e | f |                   | d |   |   | e | f |
     *  +---+   +---+                   +---+---+---+   +---+
     *  | g |   | h |                   | g |   |   |   | h |
     *  +---+---+---+                   +---+---+---+---+---+
     *  | i         |                   | i                 |
     *  +---+---+---+                   +---+---+---+---+---+
     *      ^---- insert here, `at` = 1, `columns` = 2
     *
     * @param table The table model element where the columns will be inserted.
     * @param options.at The column index at which the columns will be inserted. Default value is 0.
     * @param options.columns The number of columns to insert. Default value is 1.
     */
    insertColumns(e, t = {}) {
      const i = this.editor.model, s = t.at || 0, o = t.columns || 1;
      i.change((r) => {
        const a = e.getAttribute("headingColumns");
        s < a && r.setAttribute("headingColumns", a + o, e);
        const l = this.getColumns(e);
        if (s === 0 || l === s) {
          for (const u of e.getChildren())
            u.is("element", "tableRow") && Wi(o, r, r.createPositionAt(u, s ? "end" : 0));
          return;
        }
        const c = new q(e, { column: s, includeAllSlots: !0 });
        for (const u of c) {
          const { row: d, cell: h, cellAnchorColumn: f, cellAnchorRow: m, cellWidth: p, cellHeight: b } = u;
          if (f < s) {
            r.setAttribute("colspan", p + o, h);
            const v = m + b - 1;
            for (let y = d; y <= v; y++)
              c.skipRow(y);
          } else
            Wi(o, r, u.getPositionBefore());
        }
      });
    }
    /**
     * Removes rows from the given `table`.
     *
     * This method re-calculates the table geometry including `rowspan` attribute of table cells overlapping removed rows
     * and table headings values.
     *
     * ```ts
     * editor.plugins.get( 'TableUtils' ).removeRows( table, { at: 1, rows: 2 } );
     * ```
     *
     * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
     *
     *  row index
     *      ┌───┬───┬───┐        `at` = 1        ┌───┬───┬───┐
     *    0 │ a │ b │ c │        `rows` = 2      │ a │ b │ c │ 0
     *      │   ├───┼───┤                        │   ├───┼───┤
     *    1 │   │ d │ e │  <-- remove from here  │   │ d │ g │ 1
     *      │   │   ├───┤        will give:      ├───┼───┼───┤
     *    2 │   │   │ f │                        │ h │ i │ j │ 2
     *      │   │   ├───┤                        └───┴───┴───┘
     *    3 │   │   │ g │
     *      ├───┼───┼───┤
     *    4 │ h │ i │ j │
     *      └───┴───┴───┘
     *
     * @param options.at The row index at which the removing rows will start.
     * @param options.rows The number of rows to remove. Default value is 1.
     */
    removeRows(e, t) {
      const i = this.editor.model, s = t.rows || 1, o = this.getRows(e), r = t.at, a = r + s - 1;
      if (a > o - 1)
        throw new g("tableutils-removerows-row-index-out-of-range", this, { table: e, options: t });
      i.change((l) => {
        const c = { first: r, last: a }, { cellsToMove: u, cellsToTrim: d } = H7(e, c);
        if (u.size) {
          const h = a + 1;
          $7(e, h, u, l);
        }
        for (let h = a; h >= r; h--)
          l.remove(e.getChild(h));
        for (const { rowspan: h, cell: f } of d)
          se("rowspan", h, f, l);
        U7(e, c, l), Ra(e, this) || La(e, this);
      });
    }
    /**
     * Removes columns from the given `table`.
     *
     * This method re-calculates the table geometry including the `colspan` attribute of table cells overlapping removed columns
     * and table headings values.
     *
     * ```ts
     * editor.plugins.get( 'TableUtils' ).removeColumns( table, { at: 1, columns: 2 } );
     * ```
     *
     * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
     *
     *    0   1   2   3   4                       0   1   2
     *  ┌───────────────┬───┐                   ┌───────┬───┐
     *  │ a             │ b │                   │ a     │ b │
     *  │               ├───┤                   │       ├───┤
     *  │               │ c │                   │       │ c │
     *  ├───┬───┬───┬───┼───┤     will give:    ├───┬───┼───┤
     *  │ d │ e │ f │ g │ h │                   │ d │ g │ h │
     *  ├───┼───┼───┤   ├───┤                   ├───┤   ├───┤
     *  │ i │ j │ k │   │ l │                   │ i │   │ l │
     *  ├───┴───┴───┴───┴───┤                   ├───┴───┴───┤
     *  │ m                 │                   │ m         │
     *  └───────────────────┘                   └───────────┘
     *        ^---- remove from here, `at` = 1, `columns` = 2
     *
     * @param options.at The row index at which the removing columns will start.
     * @param options.columns The number of columns to remove.
     */
    removeColumns(e, t) {
      const i = this.editor.model, s = t.at, o = t.columns || 1, r = t.at + o - 1;
      i.change((a) => {
        z7(e, { first: s, last: r }, a);
        const l = ks(e);
        for (let c = r; c >= s; c--) {
          for (const { cell: u, column: d, cellWidth: h } of [...new q(e)])
            d <= c && h > 1 && d + h > c ? se("colspan", h - 1, u, a) : d === c && a.remove(u);
          if (l[c]) {
            const u = c === 0 ? l[1] : l[c - 1], d = parseFloat(l[c].getAttribute("columnWidth")), h = parseFloat(u.getAttribute("columnWidth"));
            a.remove(l[c]), a.setAttribute("columnWidth", d + h + "%", u);
          }
        }
        La(e, this) || Ra(e, this);
      });
    }
    /**
     * Divides a table cell vertically into several ones.
     *
     * The cell will be visually split into more cells by updating colspans of other cells in a column
     * and inserting cells (columns) after that cell.
     *
     * In the table below, if cell "a" is split into 3 cells:
     *
     *  +---+---+---+
     *  | a | b | c |
     *  +---+---+---+
     *  | d | e | f |
     *  +---+---+---+
     *
     * it will result in the table below:
     *
     *  +---+---+---+---+---+
     *  | a |   |   | b | c |
     *  +---+---+---+---+---+
     *  | d         | e | f |
     *  +---+---+---+---+---+
     *
     * So cell "d" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).
     *
     * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder
     * will be left to the original cell:
     *
     *  +---+---+---+
     *  | a         |
     *  +---+---+---+
     *  | b | c | d |
     *  +---+---+---+
     *
     * Splitting cell "a" with `colspan=3` into 2 cells will create 1 cell with a `colspan=a` and cell "a" that will have `colspan=2`:
     *
     *  +---+---+---+
     *  | a     |   |
     *  +---+---+---+
     *  | b | c | d |
     *  +---+---+---+
     */
    splitCellVertically(e, t = 2) {
      const i = this.editor.model, o = e.parent.parent, r = parseInt(e.getAttribute("rowspan") || "1"), a = parseInt(e.getAttribute("colspan") || "1");
      i.change((l) => {
        if (a > 1) {
          const { newCellsSpan: c, updatedSpan: u } = kh(a, t);
          se("colspan", u, e, l);
          const d = {};
          c > 1 && (d.colspan = c), r > 1 && (d.rowspan = r);
          const h = a > t ? t - 1 : a - 1;
          Wi(h, l, l.createPositionAfter(e), d);
        }
        if (a < t) {
          const c = t - a, u = [...new q(o)], { column: d } = u.find(({ cell: p }) => p === e), h = u.filter(({ cell: p, cellWidth: b, column: v }) => {
            const y = p !== e && v === d, L = v < d && v + b > d;
            return y || L;
          });
          for (const { cell: p, cellWidth: b } of h)
            l.setAttribute("colspan", b + c, p);
          const f = {};
          r > 1 && (f.rowspan = r), Wi(c, l, l.createPositionAfter(e), f);
          const m = o.getAttribute("headingColumns") || 0;
          m > d && se("headingColumns", m + c, o, l);
        }
      });
    }
    /**
     * Divides a table cell horizontally into several ones.
     *
     * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell
     * below.
     *
     * If in the table below cell "b" is split into 3 cells:
     *
     *  +---+---+---+
     *  | a | b | c |
     *  +---+---+---+
     *  | d | e | f |
     *  +---+---+---+
     *
     * It will result in the table below:
     *
     *  +---+---+---+
     *  | a | b | c |
     *  +   +---+   +
     *  |   |   |   |
     *  +   +---+   +
     *  |   |   |   |
     *  +---+---+---+
     *  | d | e | f |
     *  +---+---+---+
     *
     * So cells "a" and "b" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.
     *
     * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder
     * will be left to the original cell:
     *
     *  +---+---+---+
     *  | a | b | c |
     *  +   +---+---+
     *  |   | d | e |
     *  +   +---+---+
     *  |   | f | g |
     *  +   +---+---+
     *  |   | h | i |
     *  +---+---+---+
     *
     * Splitting cell "a" with `rowspan=4` into 3 cells will create 2 cells with a `rowspan=1` and cell "a" will have `rowspan=2`:
     *
     *  +---+---+---+
     *  | a | b | c |
     *  +   +---+---+
     *  |   | d | e |
     *  +---+---+---+
     *  |   | f | g |
     *  +---+---+---+
     *  |   | h | i |
     *  +---+---+---+
     */
    splitCellHorizontally(e, t = 2) {
      const i = this.editor.model, s = e.parent, o = s.parent, r = o.getChildIndex(s), a = parseInt(e.getAttribute("rowspan") || "1"), l = parseInt(e.getAttribute("colspan") || "1");
      i.change((c) => {
        if (a > 1) {
          const u = [...new q(o, {
            startRow: r,
            endRow: r + a - 1,
            includeAllSlots: !0
          })], { newCellsSpan: d, updatedSpan: h } = kh(a, t);
          se("rowspan", h, e, c);
          const { column: f } = u.find(({ cell: p }) => p === e), m = {};
          d > 1 && (m.rowspan = d), l > 1 && (m.colspan = l);
          for (const p of u) {
            const { column: b, row: v } = p, y = v >= r + h, L = b === f, M = (v + r + h) % d === 0;
            y && L && M && Wi(1, c, p.getPositionBefore(), m);
          }
        }
        if (a < t) {
          const u = t - a, d = [...new q(o, { startRow: 0, endRow: r })];
          for (const { cell: m, cellHeight: p, row: b } of d)
            if (m !== e && b + p > r) {
              const v = p + u;
              c.setAttribute("rowspan", v, m);
            }
          const h = {};
          l > 1 && (h.colspan = l), Wr(c, o, r + 1, u, 1, h);
          const f = o.getAttribute("headingRows") || 0;
          f > r && se("headingRows", f + u, o, c);
        }
      });
    }
    /**
     * Returns the number of columns for a given table.
     *
     * ```ts
     * editor.plugins.get( 'TableUtils' ).getColumns( table );
     * ```
     *
     * @param table The table to analyze.
     */
    getColumns(e) {
      return [...e.getChild(0).getChildren()].filter((i) => i.is("element", "tableCell")).reduce((i, s) => {
        const o = parseInt(s.getAttribute("colspan") || "1");
        return i + o;
      }, 0);
    }
    /**
     * Returns the number of rows for a given table. Any other element present in the table model is omitted.
     *
     * ```ts
     * editor.plugins.get( 'TableUtils' ).getRows( table );
     * ```
     *
     * @param table The table to analyze.
     */
    getRows(e) {
      return Array.from(e.getChildren()).reduce((t, i) => i.is("element", "tableRow") ? t + 1 : t, 0);
    }
    /**
     * Creates an instance of the table walker.
     *
     * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
     * It walks row by row and column by column in order to output values defined in the options.
     * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
     * pass the `includeAllSlots` option.
     *
     * @internal
     * @param table A table over which the walker iterates.
     * @param options An object with configuration.
     */
    createTableWalker(e, t = {}) {
      return new q(e, t);
    }
    /**
     * Returns all model table cells that are fully selected (from the outside)
     * within the provided model selection's ranges.
     *
     * To obtain the cells selected from the inside, use
     * {@link #getTableCellsContainingSelection}.
     */
    getSelectedTableCells(e) {
      const t = [];
      for (const i of this.sortRanges(e.getRanges())) {
        const s = i.getContainedElement();
        s && s.is("element", "tableCell") && t.push(s);
      }
      return t;
    }
    /**
     * Returns all model table cells that the provided model selection's ranges
     * {@link module:engine/model/range~Range#start} inside.
     *
     * To obtain the cells selected from the outside, use
     * {@link #getSelectedTableCells}.
     */
    getTableCellsContainingSelection(e) {
      const t = [];
      for (const i of e.getRanges()) {
        const s = i.start.findAncestor("tableCell");
        s && t.push(s);
      }
      return t;
    }
    /**
     * Returns all model table cells that are either completely selected
     * by selection ranges or host selection range
     * {@link module:engine/model/range~Range#start start positions} inside them.
     *
     * Combines {@link #getTableCellsContainingSelection} and
     * {@link #getSelectedTableCells}.
     */
    getSelectionAffectedTableCells(e) {
      const t = this.getSelectedTableCells(e);
      return t.length ? t : this.getTableCellsContainingSelection(e);
    }
    /**
     * Returns an object with the `first` and `last` row index contained in the given `tableCells`.
     *
     * ```ts
     * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
     *
     * const { first, last } = getRowIndexes( selectedTableCells );
     *
     * console.log( `Selected rows: ${ first } to ${ last }` );
     * ```
     *
     * @returns Returns an object with the `first` and `last` table row indexes.
     */
    getRowIndexes(e) {
      const t = e.map((i) => i.parent.index);
      return this._getFirstLastIndexesObject(t);
    }
    /**
     * Returns an object with the `first` and `last` column index contained in the given `tableCells`.
     *
     * ```ts
     * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
     *
     * const { first, last } = getColumnIndexes( selectedTableCells );
     *
     * console.log( `Selected columns: ${ first } to ${ last }` );
     * ```
     *
     * @returns Returns an object with the `first` and `last` table column indexes.
     */
    getColumnIndexes(e) {
      const t = e[0].findAncestor("table"), s = [...new q(t)].filter((o) => e.includes(o.cell)).map((o) => o.column);
      return this._getFirstLastIndexesObject(s);
    }
    /**
     * Checks if the selection contains cells that do not exceed rectangular selection.
     *
     * In a table below:
     *
     *  ┌───┬───┬───┬───┐
     *  │ a │ b │ c │ d │
     *  ├───┴───┼───┤   │
     *  │ e     │ f │   │
     *  │       ├───┼───┤
     *  │       │ g │ h │
     *  └───────┴───┴───┘
     *
     * Valid selections are these which create a solid rectangle (without gaps), such as:
     *   - a, b (two horizontal cells)
     *   - c, f (two vertical cells)
     *   - a, b, e (cell "e" spans over four cells)
     *   - c, d, f (cell d spans over a cell in the row below)
     *
     * While an invalid selection would be:
     *   - a, c (the unselected cell "b" creates a gap)
     *   - f, g, h (cell "d" spans over a cell from the row of "f" cell - thus creates a gap)
     */
    isSelectionRectangular(e) {
      if (e.length < 2 || !this._areCellInTheSameTableSection(e))
        return !1;
      const t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
      let s = 0;
      for (const r of e) {
        const { row: a, column: l } = this.getCellLocation(r), c = parseInt(r.getAttribute("rowspan")) || 1, u = parseInt(r.getAttribute("colspan")) || 1;
        t.add(a), i.add(l), c > 1 && t.add(a + c - 1), u > 1 && i.add(l + u - 1), s += c * u;
      }
      return q7(t, i) == s;
    }
    /**
     * Returns array of sorted ranges.
     */
    sortRanges(e) {
      return Array.from(e).sort(W7);
    }
    /**
     * Helper method to get an object with `first` and `last` indexes from an unsorted array of indexes.
     */
    _getFirstLastIndexesObject(e) {
      const t = e.sort((o, r) => o - r), i = t[0], s = t[t.length - 1];
      return { first: i, last: s };
    }
    /**
     * Checks if the selection does not mix a header (column or row) with other cells.
     *
     * For instance, in the table below valid selections consist of cells with the same letter only.
     * So, a-a (same heading row and column) or d-d (body cells) are valid while c-d or a-b are not.
     *
     * header columns
     *    ↓   ↓
     *  ┌───┬───┬───┬───┐
     *  │ a │ a │ b │ b │  ← header row
     *  ├───┼───┼───┼───┤
     *  │ c │ c │ d │ d │
     *  ├───┼───┼───┼───┤
     *  │ c │ c │ d │ d │
     *  └───┴───┴───┴───┘
     */
    _areCellInTheSameTableSection(e) {
      const t = e[0].findAncestor("table"), i = this.getRowIndexes(e), s = parseInt(t.getAttribute("headingRows")) || 0;
      if (!this._areIndexesInSameSection(i, s))
        return !1;
      const o = this.getColumnIndexes(e), r = parseInt(t.getAttribute("headingColumns")) || 0;
      return this._areIndexesInSameSection(o, r);
    }
    /**
     * Unified check if table rows/columns indexes are in the same heading/body section.
     */
    _areIndexesInSameSection({ first: e, last: t }, i) {
      const s = e < i, o = t < i;
      return s === o;
    }
  }
  function Wr(n, e, t, i, s, o = {}) {
    for (let r = 0; r < i; r++) {
      const a = n.createElement("tableRow");
      n.insert(a, e, t), Wi(s, n, n.createPositionAt(a, "end"), o);
    }
  }
  function Wi(n, e, t, i = {}) {
    for (let s = 0; s < n; s++)
      Ei(e, t, i);
  }
  function kh(n, e) {
    if (n < e)
      return { newCellsSpan: 1, updatedSpan: 1 };
    const t = Math.floor(n / e), i = n - t * e + t;
    return { newCellsSpan: t, updatedSpan: i };
  }
  function z7(n, e, t) {
    const i = n.getAttribute("headingColumns") || 0;
    if (i && e.first < i) {
      const s = Math.min(i - 1, e.last) - e.first + 1;
      t.setAttribute("headingColumns", i - s, n);
    }
  }
  function U7(n, { first: e, last: t }, i) {
    const s = n.getAttribute("headingRows") || 0;
    if (e < s) {
      const o = t < s ? s - (t - e + 1) : e;
      se("headingRows", o, n, i, 0);
    }
  }
  function H7(n, { first: e, last: t }) {
    const i = /* @__PURE__ */ new Map(), s = [];
    for (const { row: o, column: r, cellHeight: a, cell: l } of new q(n, { endRow: t })) {
      const c = o + a - 1;
      if (o >= e && o <= t && c > t) {
        const h = t - o + 1, f = a - h;
        i.set(r, {
          cell: l,
          rowspan: f
        });
      }
      if (o < e && c >= e) {
        let h;
        c >= t ? h = t - e + 1 : h = c - e + 1, s.push({
          cell: l,
          rowspan: a - h
        });
      }
    }
    return { cellsToMove: i, cellsToTrim: s };
  }
  function $7(n, e, t, i) {
    const o = [...new q(n, {
      includeAllSlots: !0,
      row: e
    })], r = n.getChild(e);
    let a;
    for (const { column: l, cell: c, isAnchor: u } of o)
      if (t.has(l)) {
        const { cell: d, rowspan: h } = t.get(l), f = a ? i.createPositionAfter(a) : i.createPositionAt(r, 0);
        i.move(i.createRangeOn(d), f), se("rowspan", h, d, i), a = d;
      } else
        u && (a = c);
  }
  function W7(n, e) {
    const t = n.start, i = e.start;
    return t.isBefore(i) ? -1 : 1;
  }
  function q7(n, e) {
    const t = Array.from(n.values()), i = Array.from(e.values()), s = Math.max(...t), o = Math.min(...t), r = Math.max(...i), a = Math.min(...i);
    return (s - o + 1) * (r - a + 1);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class G7 extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.plugins.get(pe), t = e.getSelectedTableCells(this.editor.model.document.selection);
      this.isEnabled = e.isSelectionRectangular(t);
    }
    /**
     * Executes the command.
     *
     * @fires execute
     */
    execute() {
      const e = this.editor.model, t = this.editor.plugins.get(pe);
      e.change((i) => {
        const s = t.getSelectedTableCells(e.document.selection), o = s.shift(), { mergeWidth: r, mergeHeight: a } = K7(o, s, t);
        se("colspan", r, o, i), se("rowspan", a, o, i);
        for (const c of s)
          j7(c, o, i);
        const l = o.findAncestor("table");
        ql(l, t), i.setSelection(o, "in");
      });
    }
  }
  function j7(n, e, t) {
    Th(n) || (Th(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(n), t.createPositionAt(e, "end"))), t.remove(n);
  }
  function Th(n) {
    const e = n.getChild(0);
    return n.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
  }
  function K7(n, e, t) {
    let i = 0, s = 0;
    for (const c of e) {
      const { row: u, column: d } = t.getCellLocation(c);
      i = Eh(c, d, i, "colspan"), s = Eh(c, u, s, "rowspan");
    }
    const { row: o, column: r } = t.getCellLocation(n), a = i - r, l = s - o;
    return { mergeWidth: a, mergeHeight: l };
  }
  function Eh(n, e, t, i) {
    const s = parseInt(n.getAttribute(i) || "1");
    return Math.max(t, e + s);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Z7 extends V {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.affectsData = !1;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
      this.isEnabled = t.length > 0;
    }
    /**
     * @inheritDoc
     */
    execute() {
      const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), i = t.getSelectionAffectedTableCells(e.document.selection), s = t.getRowIndexes(i), o = i[0].findAncestor("table"), r = [];
      for (let a = s.first; a <= s.last; a++)
        for (const l of o.getChild(a).getChildren())
          r.push(e.createRangeOn(l));
      e.change((a) => {
        a.setSelection(r);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class J7 extends V {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.affectsData = !1;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
      this.isEnabled = t.length > 0;
    }
    /**
     * @inheritDoc
     */
    execute() {
      const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, i = e.getSelectionAffectedTableCells(t.document.selection), s = i[0], o = i.pop(), r = s.findAncestor("table"), a = e.getCellLocation(s), l = e.getCellLocation(o), c = Math.min(a.column, l.column), u = Math.max(a.column, l.column), d = [];
      for (const h of new q(r, { startColumn: c, endColumn: u }))
        d.push(t.createRangeOn(h.cell));
      t.change((h) => {
        h.setSelection(d);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function X7(n) {
    n.document.registerPostFixer((e) => Y7(e, n));
  }
  function Y7(n, e) {
    const t = e.document.differ.getChanges();
    let i = !1;
    const s = /* @__PURE__ */ new Set();
    for (const o of t) {
      let r = null;
      o.type == "insert" && o.name == "table" && (r = o.position.nodeAfter), (o.type == "insert" || o.type == "remove") && (o.name == "tableRow" || o.name == "tableCell") && (r = o.position.findAncestor("table")), n4(o) && (r = o.range.start.findAncestor("table")), r && !s.has(r) && (i = Q7(r, n) || i, i = e4(r, n) || i, s.add(r));
    }
    return i;
  }
  function Q7(n, e) {
    let t = !1;
    const i = t4(n);
    if (i.length) {
      t = !0;
      for (const s of i)
        se("rowspan", s.rowspan, s.cell, e, 1);
    }
    return t;
  }
  function e4(n, e) {
    let t = !1;
    const i = i4(n), s = [];
    for (const [l, c] of i.entries())
      !c && n.getChild(l).is("element", "tableRow") && s.push(l);
    if (s.length) {
      t = !0;
      for (const l of s.reverse())
        e.remove(n.getChild(l)), i.splice(l, 1);
    }
    const o = i.filter((l, c) => n.getChild(c).is("element", "tableRow")), r = o[0];
    if (!o.every((l) => l === r)) {
      const l = o.reduce((c, u) => u > c ? u : c, 0);
      for (const [c, u] of o.entries()) {
        const d = l - u;
        if (d) {
          for (let h = 0; h < d; h++)
            Ei(e, e.createPositionAt(n.getChild(c), "end"));
          t = !0;
        }
      }
    }
    return t;
  }
  function t4(n) {
    const e = parseInt(n.getAttribute("headingRows") || "0"), t = Array.from(n.getChildren()).reduce((s, o) => o.is("element", "tableRow") ? s + 1 : s, 0), i = [];
    for (const { row: s, cell: o, cellHeight: r } of new q(n)) {
      if (r < 2)
        continue;
      const l = s < e ? e : t;
      if (s + r > l) {
        const c = l - s;
        i.push({ cell: o, rowspan: c });
      }
    }
    return i;
  }
  function i4(n) {
    const e = new Array(n.childCount).fill(0);
    for (const { rowIndex: t } of new q(n, { includeAllSlots: !0 }))
      e[t]++;
    return e;
  }
  function n4(n) {
    if (n.type !== "attribute")
      return !1;
    const e = n.attributeKey;
    return e === "headingRows" || e === "colspan" || e === "rowspan";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function s4(n) {
    n.document.registerPostFixer((e) => o4(e, n));
  }
  function o4(n, e) {
    const t = e.document.differ.getChanges();
    let i = !1;
    for (const s of t)
      s.type == "insert" && s.name == "table" && (i = r4(s.position.nodeAfter, n) || i), s.type == "insert" && s.name == "tableRow" && (i = zp(s.position.nodeAfter, n) || i), s.type == "insert" && s.name == "tableCell" && (i = Ba(s.position.nodeAfter, n) || i), (s.type == "remove" || s.type == "insert") && a4(s) && (i = Ba(s.position.parent, n) || i);
    return i;
  }
  function r4(n, e) {
    let t = !1;
    for (const i of n.getChildren())
      i.is("element", "tableRow") && (t = zp(i, e) || t);
    return t;
  }
  function zp(n, e) {
    let t = !1;
    for (const i of n.getChildren())
      t = Ba(i, e) || t;
    return t;
  }
  function Ba(n, e) {
    if (n.childCount == 0)
      return e.insertElement("paragraph", n), !0;
    const t = Array.from(n.getChildren()).filter((i) => i.is("$text"));
    for (const i of t)
      e.wrap(e.createRangeOn(i), "paragraph");
    return !!t.length;
  }
  function a4(n) {
    return n.position.parent.is("element", "tableCell") ? n.type == "insert" && n.name == "$text" || n.type == "remove" : !1;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function l4(n, e) {
    const t = n.document.differ;
    for (const i of t.getChanges()) {
      let s, o = !1;
      if (i.type == "attribute") {
        const c = i.range.start.nodeAfter;
        if (!c || !c.is("element", "table") || i.attributeKey != "headingRows" && i.attributeKey != "headingColumns")
          continue;
        s = c, o = i.attributeKey == "headingRows";
      } else
        (i.name == "tableRow" || i.name == "tableCell") && (s = i.position.findAncestor("table"), o = i.name == "tableRow");
      if (!s)
        continue;
      const r = s.getAttribute("headingRows") || 0, a = s.getAttribute("headingColumns") || 0, l = new q(s);
      for (const c of l) {
        const d = c.row < r || c.column < a ? "th" : "td", h = e.mapper.toViewElement(c.cell);
        h && h.is("element") && h.name != d && e.reconvertItem(o ? c.cell.parent : c.cell);
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function c4(n, e) {
    const t = n.document.differ, i = /* @__PURE__ */ new Set();
    for (const s of t.getChanges()) {
      const o = s.type == "attribute" ? s.range.start.parent : s.position.parent;
      o.is("element", "tableCell") && i.add(o);
    }
    for (const s of i.values()) {
      const o = Array.from(s.getChildren()).filter((r) => u4(r, e.mapper));
      for (const r of o)
        e.reconvertItem(r);
    }
  }
  function u4(n, e) {
    if (!n.is("element", "paragraph"))
      return !1;
    const t = e.toViewElement(n);
    return t ? Ip(n) !== t.is("element", "span") : !1;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Ts extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [pe];
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._additionalSlots = [];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model, i = t.schema, s = e.conversion, o = e.plugins.get(pe);
      i.register("table", {
        inheritAllFrom: "$blockObject",
        allowAttributes: ["headingRows", "headingColumns"]
      }), i.register("tableRow", {
        allowIn: "table",
        isLimit: !0
      }), i.register("tableCell", {
        allowContentOf: "$container",
        allowIn: "tableRow",
        allowAttributes: ["colspan", "rowspan"],
        isLimit: !0,
        isSelectable: !0
      }), s.for("upcast").add(r7()), s.for("upcast").add(a7()), s.for("editingDowncast").elementToStructure({
        model: {
          name: "table",
          attributes: ["headingRows"]
        },
        view: gh(o, {
          asWidget: !0,
          additionalSlots: this._additionalSlots
        })
      }), s.for("dataDowncast").elementToStructure({
        model: {
          name: "table",
          attributes: ["headingRows"]
        },
        view: gh(o, {
          additionalSlots: this._additionalSlots
        })
      }), s.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), s.for("upcast").add(l7()), s.for("downcast").elementToElement({
        model: "tableRow",
        view: f7()
      }), s.for("upcast").elementToElement({ model: "tableCell", view: "td" }), s.for("upcast").elementToElement({ model: "tableCell", view: "th" }), s.for("upcast").add(mh("td")), s.for("upcast").add(mh("th")), s.for("editingDowncast").elementToElement({
        model: "tableCell",
        view: ph({ asWidget: !0 })
      }), s.for("dataDowncast").elementToElement({
        model: "tableCell",
        view: ph()
      }), s.for("editingDowncast").elementToElement({
        model: "paragraph",
        view: wh({ asWidget: !0 }),
        converterPriority: "high"
      }), s.for("dataDowncast").elementToElement({
        model: "paragraph",
        view: wh(),
        converterPriority: "high"
      }), s.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), s.for("upcast").attributeToAttribute({
        model: { key: "colspan", value: Ah("colspan") },
        view: "colspan"
      }), s.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), s.for("upcast").attributeToAttribute({
        model: { key: "rowspan", value: Ah("rowspan") },
        view: "rowspan"
      }), e.config.define("table.defaultHeadings.rows", 0), e.config.define("table.defaultHeadings.columns", 0), e.commands.add("insertTable", new p7(e)), e.commands.add("insertTableRowAbove", new bh(e, { order: "above" })), e.commands.add("insertTableRowBelow", new bh(e, { order: "below" })), e.commands.add("insertTableColumnLeft", new _h(e, { order: "left" })), e.commands.add("insertTableColumnRight", new _h(e, { order: "right" })), e.commands.add("removeTableRow", new C7(e)), e.commands.add("removeTableColumn", new T7(e)), e.commands.add("splitTableCellVertically", new vh(e, { direction: "vertically" })), e.commands.add("splitTableCellHorizontally", new vh(e, { direction: "horizontally" })), e.commands.add("mergeTableCells", new G7(e)), e.commands.add("mergeTableCellRight", new eo(e, { direction: "right" })), e.commands.add("mergeTableCellLeft", new eo(e, { direction: "left" })), e.commands.add("mergeTableCellDown", new eo(e, { direction: "down" })), e.commands.add("mergeTableCellUp", new eo(e, { direction: "up" })), e.commands.add("setTableColumnHeader", new S7(e)), e.commands.add("setTableRowHeader", new x7(e)), e.commands.add("selectTableRow", new Z7(e)), e.commands.add("selectTableColumn", new J7(e)), X7(t), s4(t), this.listenTo(t.document, "change:data", () => {
        l4(t, e.editing), c4(t, e.editing);
      });
    }
    /**
     * Registers downcast handler for the additional table slot.
     */
    registerAdditionalSlot(e) {
      this._additionalSlots.push(e);
    }
  }
  function Ah(n) {
    return (e) => {
      const t = parseInt(e.getAttribute(n));
      return Number.isNaN(t) || t <= 0 ? null : t;
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class xh extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = this.bindTemplate;
      this.items = this._createGridCollection(), this.keystrokes = new ne(), this.focusTracker = new Q(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (i, s) => `${s} × ${i}`), this.setTemplate({
        tag: "div",
        attributes: {
          class: ["ck"]
        },
        children: [
          {
            tag: "div",
            attributes: {
              class: ["ck-insert-table-dropdown__grid"]
            },
            on: {
              "mouseover@.ck-insert-table-dropdown-grid-box": t.to("boxover")
            },
            children: this.items
          },
          {
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-insert-table-dropdown__label"
              ],
              "aria-hidden": !0
            },
            children: [
              {
                text: t.to("label")
              }
            ]
          }
        ],
        on: {
          mousedown: t.to((i) => {
            i.preventDefault();
          }),
          click: t.to(() => {
            this.fire("execute");
          })
        }
      }), this.on("boxover", (i, s) => {
        const { row: o, column: r } = s.target.dataset;
        this.items.get((parseInt(o, 10) - 1) * 10 + (parseInt(r, 10) - 1)).focus();
      }), this.focusTracker.on("change:focusedElement", (i, s, o) => {
        if (!o)
          return;
        const { row: r, column: a } = o.dataset;
        this.set({
          rows: parseInt(r),
          columns: parseInt(a)
        });
      }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes());
    }
    render() {
      super.render(), Ka({
        keystrokeHandler: this.keystrokes,
        focusTracker: this.focusTracker,
        gridItems: this.items,
        numberOfColumns: 10,
        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
      });
      for (const e of this.items)
        this.focusTracker.add(e.element);
      this.keystrokes.listenTo(this.element);
    }
    /**
     * Resets the rows and columns selection.
     */
    reset() {
      this.set({
        rows: 1,
        columns: 1
      });
    }
    /**
     * @inheritDoc
     */
    focus() {
      this.items.get(0).focus();
    }
    /**
     * @inheritDoc
     */
    focusLast() {
      this.items.get(0).focus();
    }
    /**
     * Highlights grid boxes depending on rows and columns selected.
     */
    _highlightGridBoxes() {
      const e = this.rows, t = this.columns;
      this.items.map((i, s) => {
        const o = Math.floor(s / 10), r = s % 10, a = o < e && r < t;
        i.set("isOn", a);
      });
    }
    /**
     * Creates a new Button for the grid.
     *
     * @param locale The locale instance.
     * @param row Row number.
     * @param column Column number.
     * @param label The grid button label.
     */
    _createGridButton(e, t, i, s) {
      const o = new P(e);
      return o.set({
        label: s,
        class: "ck-insert-table-dropdown-grid-box"
      }), o.extendTemplate({
        attributes: {
          "data-row": t,
          "data-column": i
        }
      }), o;
    }
    /**
     * @returns A view collection containing boxes to be placed in a table grid.
     */
    _createGridCollection() {
      const e = [];
      for (let t = 0; t < 100; t++) {
        const i = Math.floor(t / 10), s = t % 10, o = `${i + 1} × ${s + 1}`;
        e.push(this._createGridButton(this.locale, i + 1, s + 1, o));
      }
      return this.createCollection(e);
    }
  }
  const d4 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', h4 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', f4 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class m4 extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = this.editor.t, s = e.locale.contentLanguageDirection === "ltr";
      e.ui.componentFactory.add("insertTable", (o) => {
        const r = e.commands.get("insertTable"), a = we(o);
        a.bind("isEnabled").to(r), a.buttonView.set({
          icon: x.table,
          label: t("Insert table"),
          tooltip: !0
        });
        let l;
        return a.on("change:isOpen", () => {
          l || (l = new xh(o), a.panelView.children.add(l), l.delegate("execute").to(a), a.on("execute", () => {
            e.execute("insertTable", { rows: l.rows, columns: l.columns }), e.editing.view.focus();
          }));
        }), a;
      }), e.ui.componentFactory.add("menuBar:insertTable", (o) => {
        const r = e.commands.get("insertTable"), a = new Ke(o), l = new xh(o);
        return l.delegate("execute").to(a), a.on("change:isOpen", (c, u, d) => {
          d || l.reset();
        }), l.on("execute", () => {
          e.execute("insertTable", { rows: l.rows, columns: l.columns }), e.editing.view.focus();
        }), a.buttonView.set({
          label: t("Table"),
          icon: x.table
        }), a.panelView.children.add(l), a.bind("isEnabled").to(r), a;
      }), e.ui.componentFactory.add("tableColumn", (o) => {
        const r = [
          {
            type: "switchbutton",
            model: {
              commandName: "setTableColumnHeader",
              label: t("Header column"),
              bindIsOn: !0
            }
          },
          { type: "separator" },
          {
            type: "button",
            model: {
              commandName: s ? "insertTableColumnLeft" : "insertTableColumnRight",
              label: t("Insert column left")
            }
          },
          {
            type: "button",
            model: {
              commandName: s ? "insertTableColumnRight" : "insertTableColumnLeft",
              label: t("Insert column right")
            }
          },
          {
            type: "button",
            model: {
              commandName: "removeTableColumn",
              label: t("Delete column")
            }
          },
          {
            type: "button",
            model: {
              commandName: "selectTableColumn",
              label: t("Select column")
            }
          }
        ];
        return this._prepareDropdown(t("Column"), d4, r, o);
      }), e.ui.componentFactory.add("tableRow", (o) => {
        const r = [
          {
            type: "switchbutton",
            model: {
              commandName: "setTableRowHeader",
              label: t("Header row"),
              bindIsOn: !0
            }
          },
          { type: "separator" },
          {
            type: "button",
            model: {
              commandName: "insertTableRowAbove",
              label: t("Insert row above")
            }
          },
          {
            type: "button",
            model: {
              commandName: "insertTableRowBelow",
              label: t("Insert row below")
            }
          },
          {
            type: "button",
            model: {
              commandName: "removeTableRow",
              label: t("Delete row")
            }
          },
          {
            type: "button",
            model: {
              commandName: "selectTableRow",
              label: t("Select row")
            }
          }
        ];
        return this._prepareDropdown(t("Row"), h4, r, o);
      }), e.ui.componentFactory.add("mergeTableCells", (o) => {
        const r = [
          {
            type: "button",
            model: {
              commandName: "mergeTableCellUp",
              label: t("Merge cell up")
            }
          },
          {
            type: "button",
            model: {
              commandName: s ? "mergeTableCellRight" : "mergeTableCellLeft",
              label: t("Merge cell right")
            }
          },
          {
            type: "button",
            model: {
              commandName: "mergeTableCellDown",
              label: t("Merge cell down")
            }
          },
          {
            type: "button",
            model: {
              commandName: s ? "mergeTableCellLeft" : "mergeTableCellRight",
              label: t("Merge cell left")
            }
          },
          { type: "separator" },
          {
            type: "button",
            model: {
              commandName: "splitTableCellVertically",
              label: t("Split cell vertically")
            }
          },
          {
            type: "button",
            model: {
              commandName: "splitTableCellHorizontally",
              label: t("Split cell horizontally")
            }
          }
        ];
        return this._prepareMergeSplitButtonDropdown(t("Merge cells"), f4, r, o);
      });
    }
    /**
     * Creates a dropdown view from a set of options.
     *
     * @param label The dropdown button label.
     * @param icon An icon for the dropdown button.
     * @param options The list of options for the dropdown.
     */
    _prepareDropdown(e, t, i, s) {
      const o = this.editor, r = we(s), a = this._fillDropdownWithListOptions(r, i);
      return r.buttonView.set({
        label: e,
        icon: t,
        tooltip: !0
      }), r.bind("isEnabled").toMany(a, "isEnabled", (...l) => l.some((c) => c)), this.listenTo(r, "execute", (l) => {
        o.execute(l.source.commandName), l.source instanceof ir || o.editing.view.focus();
      }), r;
    }
    /**
     * Creates a dropdown view with a {@link module:ui/dropdown/button/splitbuttonview~SplitButtonView} for
     * merge (and split)–related commands.
     *
     * @param label The dropdown button label.
     * @param icon An icon for the dropdown button.
     * @param options The list of options for the dropdown.
     */
    _prepareMergeSplitButtonDropdown(e, t, i, s) {
      const o = this.editor, r = we(s, sr), a = "mergeTableCells", l = o.commands.get(a), c = this._fillDropdownWithListOptions(r, i);
      return r.buttonView.set({
        label: e,
        icon: t,
        tooltip: !0,
        isEnabled: !0
      }), r.bind("isEnabled").toMany([l, ...c], "isEnabled", (...u) => u.some((d) => d)), this.listenTo(r.buttonView, "execute", () => {
        o.execute(a), o.editing.view.focus();
      }), this.listenTo(r, "execute", (u) => {
        o.execute(u.source.commandName), o.editing.view.focus();
      }), r;
    }
    /**
     * Injects a {@link module:ui/list/listview~ListView} into the passed dropdown with buttons
     * which execute editor commands as configured in passed options.
     *
     * @param options The list of options for the dropdown.
     * @returns Commands the list options are interacting with.
     */
    _fillDropdownWithListOptions(e, t) {
      const i = this.editor, s = [], o = new Ce();
      for (const r of t)
        g4(r, i, s, o);
      return Kt(e, o), s;
    }
  }
  function g4(n, e, t, i) {
    if (n.type === "button" || n.type === "switchbutton") {
      const s = n.model = new yi(n.model), { commandName: o, bindIsOn: r } = n.model, a = e.commands.get(o);
      t.push(a), s.set({ commandName: o }), s.bind("isEnabled").to(a), r && s.bind("isOn").to(a, "value"), s.set({
        withText: !0
      });
    }
    i.add(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ci extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableSelection";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [pe, pe];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model, i = e.editing.view;
      this.listenTo(t, "deleteContent", (s, o) => this._handleDeleteContent(s, o), { priority: "high" }), this.listenTo(i.document, "insertText", (s, o) => this._handleInsertTextEvent(s, o), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
    }
    /**
     * Returns the currently selected table cells or `null` if it is not a table cells selection.
     */
    getSelectedTableCells() {
      const e = this.editor.plugins.get(pe), t = this.editor.model.document.selection, i = e.getSelectedTableCells(t);
      return i.length == 0 ? null : i;
    }
    /**
     * Returns the selected table fragment as a document fragment.
     */
    getSelectionAsFragment() {
      const e = this.editor.plugins.get(pe), t = this.getSelectedTableCells();
      return t ? this.editor.model.change((i) => {
        const s = i.createDocumentFragment(), { first: o, last: r } = e.getColumnIndexes(t), { first: a, last: l } = e.getRowIndexes(t), c = t[0].findAncestor("table");
        let u = l, d = r;
        if (e.isSelectionRectangular(t)) {
          const m = {
            firstColumn: o,
            lastColumn: r,
            firstRow: a,
            lastRow: l
          };
          u = Op(c, m), d = Np(c, m);
        }
        const f = Pp(c, {
          startRow: a,
          startColumn: o,
          endRow: u,
          endColumn: d
        }, i);
        return i.insert(f, s, 0), s;
      }) : null;
    }
    /**
     * Sets the model selection based on given anchor and target cells (can be the same cell).
     * Takes care of setting the backward flag.
     *
     * ```ts
     * const modelRoot = editor.model.document.getRoot();
     * const firstCell = modelRoot.getNodeByPath( [ 0, 0, 0 ] );
     * const lastCell = modelRoot.getNodeByPath( [ 0, 0, 1 ] );
     *
     * const tableSelection = editor.plugins.get( 'TableSelection' );
     * tableSelection.setCellSelection( firstCell, lastCell );
     * ```
     */
    setCellSelection(e, t) {
      const i = this._getCellsToSelect(e, t);
      this.editor.model.change((s) => {
        s.setSelection(i.cells.map((o) => s.createRangeOn(o)), { backward: i.backward });
      });
    }
    /**
     * Returns the focus cell from the current selection.
     */
    getFocusCell() {
      const i = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
      return i && i.is("element", "tableCell") ? i : null;
    }
    /**
     * Returns the anchor cell from the current selection.
     */
    getAnchorCell() {
      const e = this.editor.model.document.selection, i = me(e.getRanges()).getContainedElement();
      return i && i.is("element", "tableCell") ? i : null;
    }
    /**
     * Defines a selection converter which marks the selected cells with a specific class.
     *
     * The real DOM selection is put in the last cell. Since the order of ranges is dependent on whether the
     * selection is backward or not, the last cell will usually be close to the "focus" end of the selection
     * (a selection has anchor and focus).
     *
     * The real DOM selection is then hidden with CSS.
     */
    _defineSelectionConverter() {
      const e = this.editor, t = /* @__PURE__ */ new Set();
      e.conversion.for("editingDowncast").add((s) => s.on("selection", (o, r, a) => {
        const l = a.writer;
        i(l);
        const c = this.getSelectedTableCells();
        if (!c)
          return;
        for (const d of c) {
          const h = a.mapper.toViewElement(d);
          l.addClass("ck-editor__editable_selected", h), t.add(h);
        }
        const u = a.mapper.toViewElement(c[c.length - 1]);
        l.setSelection(u, 0);
      }, { priority: "lowest" }));
      function i(s) {
        for (const o of t)
          s.removeClass("ck-editor__editable_selected", o);
        t.clear();
      }
    }
    /**
     * Creates a listener that reacts to changes in {@link #isEnabled} and, if the plugin was disabled,
     * it collapses the multi-cell selection to a regular selection placed inside a table cell.
     *
     * This listener helps features that disable the table selection plugin bring the selection
     * to a clear state they can work with (for instance, because they don't support multiple cell selection).
     */
    _enablePluginDisabling() {
      const e = this.editor;
      this.on("change:isEnabled", () => {
        if (!this.isEnabled) {
          const t = this.getSelectedTableCells();
          if (!t)
            return;
          e.model.change((i) => {
            const s = i.createPositionAt(t[0], 0), o = e.model.schema.getNearestSelectionRange(s);
            i.setSelection(o);
          });
        }
      });
    }
    /**
     * Overrides the default `model.deleteContent()` behavior over a selected table fragment.
     *
     * @param args Delete content method arguments.
     */
    _handleDeleteContent(e, t) {
      const i = this.editor.plugins.get(pe), s = t[0], o = t[1], r = this.editor.model, a = !o || o.direction == "backward", l = i.getSelectedTableCells(s);
      l.length && (e.stop(), r.change((c) => {
        const u = l[a ? l.length - 1 : 0];
        r.change((h) => {
          for (const f of l)
            r.deleteContent(h.createSelection(f, "in"));
        });
        const d = r.schema.getNearestSelectionRange(c.createPositionAt(u, 0));
        s.is("documentSelection") ? c.setSelection(d) : s.setTo(d);
      }));
    }
    /**
     * This handler makes it possible to remove the content of all selected cells by starting to type.
     * If you take a look at {@link #_defineSelectionConverter} you will find out that despite the multi-cell selection being set
     * in the model, the view selection is collapsed in the last cell (because most browsers are unable to render multi-cell selections;
     * yes, it's a hack).
     *
     * When multiple cells are selected in the model and the user starts to type, the
     * {@link module:engine/view/document~Document#event:insertText} event carries information provided by the
     * beforeinput DOM  event, that in turn only knows about this collapsed DOM selection in the last cell.
     *
     * As a result, the selected cells have no chance to be cleaned up. To fix this, this listener intercepts
     * the event and injects the custom view selection in the data that translates correctly to the actual state
     * of the multi-cell selection in the model.
     *
     * @param data Insert text event data.
     */
    _handleInsertTextEvent(e, t) {
      const i = this.editor, s = this.getSelectedTableCells();
      if (!s)
        return;
      const o = i.editing.view, r = i.editing.mapper, a = s.map((l) => o.createRangeOn(r.toViewElement(l)));
      t.selection = o.createSelection(a);
    }
    /**
     * Returns an array of table cells that should be selected based on the
     * given anchor cell and target (focus) cell.
     *
     * The cells are returned in a reverse direction if the selection is backward.
     */
    _getCellsToSelect(e, t) {
      const i = this.editor.plugins.get("TableUtils"), s = i.getCellLocation(e), o = i.getCellLocation(t), r = Math.min(s.row, o.row), a = Math.max(s.row, o.row), l = Math.min(s.column, o.column), c = Math.max(s.column, o.column), u = new Array(a - r + 1).fill(null).map(() => []), d = {
        startRow: r,
        endRow: a,
        startColumn: l,
        endColumn: c
      };
      for (const { row: m, cell: p } of new q(e.findAncestor("table"), d))
        u[m - r].push(p);
      const h = o.row < s.row, f = o.column < s.column;
      return h && u.reverse(), f && u.forEach((m) => m.reverse()), {
        cells: u.flat(),
        backward: h || f
      };
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class p4 extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableClipboard";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Hn, Xe, ci, pe];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.editing.view.document;
      this.listenTo(t, "copy", (i, s) => this._onCopyCut(i, s)), this.listenTo(t, "cut", (i, s) => this._onCopyCut(i, s)), this.listenTo(e.model, "insertContent", (i, [s, o]) => this._onInsertContent(i, s, o), { priority: "high" }), this.decorate("_replaceTableSlotCell");
    }
    /**
     * Copies table content to a clipboard on "copy" & "cut" events.
     *
     * @param evt An object containing information about the handled event.
     * @param data Clipboard event data.
     */
    _onCopyCut(e, t) {
      const i = this.editor.editing.view, s = this.editor.plugins.get(ci), o = this.editor.plugins.get(Hn);
      s.getSelectedTableCells() && (e.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection) || (t.preventDefault(), e.stop(), this.editor.model.enqueueChange({ isUndoable: e.name === "cut" }, () => {
        const r = o._copySelectedFragmentWithMarkers(e.name, this.editor.model.document.selection, () => s.getSelectionAsFragment());
        i.document.fire("clipboardOutput", {
          dataTransfer: t.dataTransfer,
          content: this.editor.data.toView(r),
          method: e.name
        });
      })));
    }
    /**
     * Overrides default {@link module:engine/model/model~Model#insertContent `model.insertContent()`} method to handle pasting table inside
     * selected table fragment.
     *
     * Depending on selected table fragment:
     * - If a selected table fragment is smaller than paste table it will crop pasted table to match dimensions.
     * - If dimensions are equal it will replace selected table fragment with a pasted table contents.
     *
     * @param content The content to insert.
     * @param selectable The selection into which the content should be inserted.
     * If not provided the current model document selection will be used.
     */
    _onInsertContent(e, t, i) {
      if (i && !i.is("documentSelection"))
        return;
      const s = this.editor.model, o = this.editor.plugins.get(pe), r = this.editor.plugins.get(Hn), a = this.getTableIfOnlyTableInContent(t, s);
      if (!a)
        return;
      const l = o.getSelectionAffectedTableCells(s.document.selection);
      if (!l.length) {
        ql(a, o);
        return;
      }
      e.stop(), t.is("documentFragment") ? r._pasteMarkersIntoTransformedElement(t.markers, (c) => this._replaceSelectedCells(a, l, c)) : this.editor.model.change((c) => {
        this._replaceSelectedCells(a, l, c);
      });
    }
    /**
     * Inserts provided `selectedTableCells` into `pastedTable`.
     */
    _replaceSelectedCells(e, t, i) {
      const s = this.editor.plugins.get(pe), o = {
        width: s.getColumns(e),
        height: s.getRows(e)
      }, r = w4(t, o, i, s), a = r.lastRow - r.firstRow + 1, l = r.lastColumn - r.firstColumn + 1, c = {
        startRow: 0,
        startColumn: 0,
        endRow: Math.min(a, o.height) - 1,
        endColumn: Math.min(l, o.width) - 1
      };
      e = Pp(e, c, i);
      const u = t[0].findAncestor("table"), d = this._replaceSelectedCellsWithPasted(e, o, u, r, i);
      if (this.editor.plugins.get("TableSelection").isEnabled) {
        const h = s.sortRanges(d.map((f) => i.createRangeOn(f)));
        i.setSelection(h);
      } else
        i.setSelection(d[0], 0);
      return u;
    }
    /**
     * Replaces the part of selectedTable with pastedTable.
     */
    _replaceSelectedCellsWithPasted(e, t, i, s, o) {
      const { width: r, height: a } = t, l = _4(e, r, a), c = [...new q(i, {
        startRow: s.firstRow,
        endRow: s.lastRow,
        startColumn: s.firstColumn,
        endColumn: s.lastColumn,
        includeAllSlots: !0
      })], u = [];
      let d;
      for (const b of c) {
        const { row: v, column: y } = b;
        y === s.firstColumn && (d = b.getPositionBefore());
        const L = v - s.firstRow, M = y - s.firstColumn, D = l[L % a][M % r], A = D ? o.cloneElement(D) : null, R = this._replaceTableSlotCell(b, A, d, o);
        R && (Bp(R, v, y, s.lastRow, s.lastColumn, o), u.push(R), d = o.createPositionAfter(R));
      }
      const h = parseInt(i.getAttribute("headingRows") || "0"), f = parseInt(i.getAttribute("headingColumns") || "0"), m = s.firstRow < h && h <= s.lastRow, p = s.firstColumn < f && f <= s.lastColumn;
      if (m) {
        const b = { first: s.firstColumn, last: s.lastColumn }, v = Oa(i, h, b, o, s.firstRow);
        u.push(...v);
      }
      if (p) {
        const b = { first: s.firstRow, last: s.lastRow }, v = Na(i, f, b, o);
        u.push(...v);
      }
      return u;
    }
    /**
     * Replaces a single table slot.
     *
     * @returns Inserted table cell or null if slot should remain empty.
     * @private
     */
    _replaceTableSlotCell(e, t, i, s) {
      const { cell: o, isAnchor: r } = e;
      return r && s.remove(o), t ? (s.insert(t, i), t) : null;
    }
    /**
     * Extracts the table for pasting into a table.
     *
     * @param content The content to insert.
     * @param model The editor model.
     */
    getTableIfOnlyTableInContent(e, t) {
      if (!e.is("documentFragment") && !e.is("element"))
        return null;
      if (e.is("element", "table"))
        return e;
      if (e.childCount == 1 && e.getChild(0).is("element", "table"))
        return e.getChild(0);
      const i = t.createRangeIn(e);
      for (const s of i.getItems())
        if (s.is("element", "table")) {
          const o = t.createRange(i.start, t.createPositionBefore(s));
          if (t.hasContent(o, { ignoreWhitespaces: !0 }))
            return null;
          const r = t.createRange(t.createPositionAfter(s), i.end);
          return t.hasContent(r, { ignoreWhitespaces: !0 }) ? null : s;
        }
      return null;
    }
  }
  function w4(n, e, t, i) {
    const s = n[0].findAncestor("table"), o = i.getColumnIndexes(n), r = i.getRowIndexes(n), a = {
      firstColumn: o.first,
      lastColumn: o.last,
      firstRow: r.first,
      lastRow: r.last
    }, l = n.length === 1;
    return l && (a.lastRow += e.height - 1, a.lastColumn += e.width - 1, b4(s, a.lastRow + 1, a.lastColumn + 1, i)), l || !i.isSelectionRectangular(n) ? v4(s, a, t) : (a.lastRow = Op(s, a), a.lastColumn = Np(s, a)), a;
  }
  function b4(n, e, t, i) {
    const s = i.getColumns(n), o = i.getRows(n);
    t > s && i.insertColumns(n, {
      at: s,
      columns: t - s
    }), e > o && i.insertRows(n, {
      at: o,
      rows: e - o
    });
  }
  function _4(n, e, t) {
    const i = new Array(t).fill(null).map(() => new Array(e).fill(null));
    for (const { column: s, row: o, cell: r } of new q(n))
      i[o][s] = r;
    return i;
  }
  function v4(n, e, t) {
    const { firstRow: i, lastRow: s, firstColumn: o, lastColumn: r } = e, a = { first: i, last: s }, l = { first: o, last: r };
    Na(n, o, a, t), Na(n, r + 1, a, t), Oa(n, i, l, t), Oa(n, s + 1, l, t, i);
  }
  function Oa(n, e, t, i, s = 0) {
    return e < 1 ? void 0 : Rp(n, e, s).filter(({ column: a, cellWidth: l }) => Up(a, l, t)).map(({ cell: a }) => Lp(a, e, i));
  }
  function Na(n, e, t, i) {
    return e < 1 ? void 0 : Vp(n, e).filter(({ row: r, cellHeight: a }) => Up(r, a, t)).map(({ cell: r, column: a }) => Mp(r, a, e, i));
  }
  function Up(n, e, t) {
    const i = n + e - 1, { first: s, last: o } = t, r = n >= s && n <= o, a = n < s && i >= s;
    return r || a;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class y4 extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableKeyboard";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [ci, pe];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, i = e.editing.view.document, s = e.t;
      this.listenTo(i, "arrowKey", (...o) => this._onArrowKey(...o), { context: "table" }), this.listenTo(i, "tab", (...o) => this._handleTabOnSelectedTable(...o), { context: "figure" }), this.listenTo(i, "tab", (...o) => this._handleTab(...o), { context: ["th", "td"] }), e.accessibility.addKeystrokeInfoGroup({
        id: "table",
        label: s("Keystrokes that can be used in a table cell"),
        keystrokes: [
          {
            label: s("Move the selection to the next cell"),
            keystroke: "Tab"
          },
          {
            label: s("Move the selection to the previous cell"),
            keystroke: "Shift+Tab"
          },
          {
            label: s("Insert a new table row (when in the last cell of a table)"),
            keystroke: "Tab"
          },
          {
            label: s("Navigate through the table"),
            keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
          }
        ]
      });
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
     * when the table widget is selected.
     */
    _handleTabOnSelectedTable(e, t) {
      const i = this.editor, o = i.model.document.selection.getSelectedElement();
      !o || !o.is("element", "table") || (t.preventDefault(), t.stopPropagation(), e.stop(), i.model.change((r) => {
        r.setSelection(r.createRangeIn(o.getChild(0).getChild(0)));
      }));
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
     * inside table cells.
     */
    _handleTab(e, t) {
      const i = this.editor, s = this.editor.plugins.get(pe), o = this.editor.plugins.get("TableSelection"), r = i.model.document.selection, a = !t.shiftKey;
      let l = s.getTableCellsContainingSelection(r)[0];
      if (l || (l = o.getFocusCell()), !l)
        return;
      t.preventDefault(), t.stopPropagation(), e.stop();
      const c = l.parent, u = c.parent, d = u.getChildIndex(c), h = c.getChildIndex(l), f = h === 0;
      if (!a && f && d === 0) {
        i.model.change((v) => {
          v.setSelection(v.createRangeOn(u));
        });
        return;
      }
      const m = h === c.childCount - 1, p = d === s.getRows(u) - 1;
      if (a && p && m && (i.execute("insertTableRowBelow"), d === s.getRows(u) - 1)) {
        i.model.change((v) => {
          v.setSelection(v.createRangeOn(u));
        });
        return;
      }
      let b;
      if (a && m)
        b = u.getChild(d + 1).getChild(0);
      else if (!a && f) {
        const v = u.getChild(d - 1);
        b = v.getChild(v.childCount - 1);
      } else
        b = c.getChild(h + (a ? 1 : -1));
      i.model.change((v) => {
        v.setSelection(v.createRangeIn(b));
      });
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.
     */
    _onArrowKey(e, t) {
      const i = this.editor, s = t.keyCode, o = ul(s, i.locale.contentLanguageDirection);
      this._handleArrowKeys(o, t.shiftKey) && (t.preventDefault(), t.stopPropagation(), e.stop());
    }
    /**
     * Handles arrow keys to move the selection around the table.
     *
     * @param direction The direction of the arrow key.
     * @param expandSelection If the current selection should be expanded.
     * @returns Returns `true` if key was handled.
     */
    _handleArrowKeys(e, t) {
      const i = this.editor.plugins.get(pe), s = this.editor.plugins.get("TableSelection"), o = this.editor.model, r = o.document.selection, a = ["right", "down"].includes(e), l = i.getSelectedTableCells(r);
      if (l.length) {
        let u;
        return t ? u = s.getFocusCell() : u = a ? l[l.length - 1] : l[0], this._navigateFromCellInDirection(u, e, t), !0;
      }
      const c = r.focus.findAncestor("tableCell");
      /* istanbul ignore if: paranoid check -- @preserve */
      if (!c)
        return !1;
      if (!r.isCollapsed)
        if (t) {
          if (r.isBackward == a && !r.containsEntireContent(c))
            return !1;
        } else {
          const u = r.getSelectedElement();
          if (!u || !o.schema.isObject(u))
            return !1;
        }
      return this._isSelectionAtCellEdge(r, c, a) ? (this._navigateFromCellInDirection(c, e, t), !0) : !1;
    }
    /**
     * Returns `true` if the selection is at the boundary of a table cell according to the navigation direction.
     *
     * @param selection The current selection.
     * @param tableCell The current table cell element.
     * @param isForward The expected navigation direction.
     */
    _isSelectionAtCellEdge(e, t, i) {
      const s = this.editor.model, o = this.editor.model.schema, r = i ? e.getLastPosition() : e.getFirstPosition();
      if (!o.getLimitElement(r).is("element", "tableCell"))
        return s.createPositionAt(t, i ? "end" : 0).isTouching(r);
      const a = s.createSelection(r);
      return s.modifySelection(a, { direction: i ? "forward" : "backward" }), r.isEqual(a.focus);
    }
    /**
     * Moves the selection from the given table cell in the specified direction.
     *
     * @param focusCell The table cell that is current multi-cell selection focus.
     * @param direction Direction in which selection should move.
     * @param expandSelection If the current selection should be expanded. Default value is false.
     */
    _navigateFromCellInDirection(e, t, i = !1) {
      const s = this.editor.model, o = e.findAncestor("table"), r = [...new q(o, { includeAllSlots: !0 })], { row: a, column: l } = r[r.length - 1], c = r.find(({ cell: y }) => y == e);
      let { row: u, column: d } = c;
      switch (t) {
        case "left":
          d--;
          break;
        case "up":
          u--;
          break;
        case "right":
          d += c.cellWidth;
          break;
        case "down":
          u += c.cellHeight;
          break;
      }
      const h = u < 0 || u > a, f = d < 0 && u <= 0, m = d > l && u >= a;
      if (h || f || m) {
        s.change((y) => {
          y.setSelection(y.createRangeOn(o));
        });
        return;
      }
      d < 0 ? (d = i ? 0 : l, u--) : d > l && (d = i ? l : 0, u++);
      const p = r.find((y) => y.row == u && y.column == d).cell, b = ["right", "down"].includes(t), v = this.editor.plugins.get("TableSelection");
      if (i && v.isEnabled) {
        const y = v.getAnchorCell() || e;
        v.setCellSelection(y, p);
      } else {
        const y = s.createPositionAt(p, b ? 0 : "end");
        s.change((L) => {
          L.setSelection(y);
        });
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Hp extends Gt {
    constructor() {
      super(...arguments), this.domEventType = [
        "mousemove",
        "mouseleave"
      ];
    }
    /**
     * @inheritDoc
     */
    onDomEvent(e) {
      this.fire(e.type, e);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class C4 extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableMouse";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [ci, pe];
    }
    /**
     * @inheritDoc
     */
    init() {
      this.editor.editing.view.addObserver(Hp), this._enableShiftClickSelection(), this._enableMouseDragSelection();
    }
    /**
     * Enables making cells selection by <kbd>Shift</kbd>+click. Creates a selection from the cell which previously held
     * the selection to the cell which was clicked. It can be the same cell, in which case it selects a single cell.
     */
    _enableShiftClickSelection() {
      const e = this.editor, t = e.plugins.get(pe);
      let i = !1;
      const s = e.plugins.get(ci);
      this.listenTo(e.editing.view.document, "mousedown", (o, r) => {
        const a = e.model.document.selection;
        if (!this.isEnabled || !s.isEnabled || !r.domEvent.shiftKey)
          return;
        const l = s.getAnchorCell() || t.getTableCellsContainingSelection(a)[0];
        if (!l)
          return;
        const c = this._getModelTableCellFromDomEvent(r);
        c && Sh(l, c) && (i = !0, s.setCellSelection(l, c), r.preventDefault());
      }), this.listenTo(e.editing.view.document, "mouseup", () => {
        i = !1;
      }), this.listenTo(e.editing.view.document, "selectionChange", (o) => {
        i && o.stop();
      }, { priority: "highest" });
    }
    /**
     * Enables making cells selection by dragging.
     *
     * The selection is made only on mousemove. Mouse tracking is started on mousedown.
     * However, the cells selection is enabled only after the mouse cursor left the anchor cell.
     * Thanks to that normal text selection within one cell works just fine. However, you can still select
     * just one cell by leaving the anchor cell and moving back to it.
     */
    _enableMouseDragSelection() {
      const e = this.editor;
      let t, i, s = !1, o = !1;
      const r = e.plugins.get(ci);
      this.listenTo(e.editing.view.document, "mousedown", (a, l) => {
        !this.isEnabled || !r.isEnabled || l.domEvent.shiftKey || l.domEvent.ctrlKey || l.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(l));
      }), this.listenTo(e.editing.view.document, "mousemove", (a, l) => {
        if (!l.domEvent.buttons || !t)
          return;
        const c = this._getModelTableCellFromDomEvent(l);
        c && Sh(t, c) && (i = c, !s && i != t && (s = !0)), s && (o = !0, r.setCellSelection(t, i), l.preventDefault());
      }), this.listenTo(e.editing.view.document, "mouseup", () => {
        s = !1, o = !1, t = null, i = null;
      }), this.listenTo(e.editing.view.document, "selectionChange", (a) => {
        o && a.stop();
      }, { priority: "highest" });
    }
    /**
     * Returns the model table cell element based on the target element of the passed DOM event.
     *
     * @returns Returns the table cell or `undefined`.
     */
    _getModelTableCellFromDomEvent(e) {
      const t = e.target, i = this.editor.editing.view.createPositionAt(t, 0);
      return this.editor.editing.mapper.toModelPosition(i).parent.findAncestor("tableCell", { includeSelf: !0 });
    }
  }
  function Sh(n, e) {
    return n.parent.parent == e.parent.parent;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class k4 extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ts, m4, ci, C4, y4, p4, gn];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Table";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function $p(n) {
    const e = Wp(n);
    return e || fr(n);
  }
  function Wp(n) {
    const e = n.getSelectedElement();
    return e && qp(e) ? e : null;
  }
  function fr(n) {
    const e = n.getFirstPosition();
    if (!e)
      return null;
    let t = e.parent;
    for (; t; ) {
      if (t.is("element") && qp(t))
        return t;
      t = t.parent;
    }
    return null;
  }
  function qp(n) {
    return !!n.getCustomProperty("table") && re(n);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class T4 extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Po];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableToolbar";
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      const e = this.editor, t = e.t, i = e.plugins.get(Po), s = e.config.get("table.contentToolbar"), o = e.config.get("table.tableToolbar");
      s && i.register("tableContent", {
        ariaLabel: t("Table toolbar"),
        items: s,
        getRelatedElement: fr
      }), o && i.register("table", {
        ariaLabel: t("Table toolbar"),
        items: o,
        getRelatedElement: Wp
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class E4 extends T {
    /**
     * Creates an instance of the color input view.
     *
     * @param locale The locale instance.
     * @param options The input options.
     * @param options.colorDefinitions The colors to be displayed in the palette inside the input's dropdown.
     * @param options.columns The number of columns in which the colors will be displayed.
     * @param options.defaultColorValue If specified, the color input view will replace the "Remove color" button with
     * the "Restore default" button. Instead of clearing the input field, the default color value will be set.
     */
    constructor(e, t) {
      super(e), this.set("value", ""), this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isEmpty", !0), this.options = t, this.focusTracker = new Q(), this._focusables = new ke(), this.dropdownView = this._createDropdownView(), this.inputView = this._createInputTextView(), this.keystrokes = new ne(), this._stillTyping = !1, this.focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
          focusPrevious: "shift + tab",
          // Navigate items forwards using the <kbd>Tab</kbd> key.
          focusNext: "tab"
        }
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-input-color"
          ]
        },
        children: [
          this.dropdownView,
          this.inputView
        ]
      }), this.on("change:value", (i, s, o) => this._setInputValue(o));
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), [this.inputView, this.dropdownView.buttonView].forEach((e) => {
        this.focusTracker.add(e.element), this._focusables.add(e);
      }), this.keystrokes.listenTo(this.element);
    }
    /**
     * Focuses the view.
     */
    focus(e) {
      e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Creates and configures the {@link #dropdownView}.
     */
    _createDropdownView() {
      const e = this.locale, t = e.t, i = this.bindTemplate, s = this._createColorSelector(e), o = we(e), r = new T();
      return r.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-input-color__button__preview"
          ],
          style: {
            backgroundColor: i.to("value")
          }
        },
        children: [{
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-input-color__button__preview__no-color-indicator",
              i.if("value", "ck-hidden", (a) => a != "")
            ]
          }
        }]
      }), o.buttonView.extendTemplate({
        attributes: {
          class: "ck-input-color__button"
        }
      }), o.buttonView.children.add(r), o.buttonView.label = t("Color picker"), o.buttonView.tooltip = !0, o.panelPosition = e.uiLanguageDirection === "rtl" ? "se" : "sw", o.panelView.children.add(s), o.bind("isEnabled").to(this, "isReadOnly", (a) => !a), o.on("change:isOpen", (a, l, c) => {
        c && (s.updateSelectedColors(), s.showColorGridsFragment());
      }), o;
    }
    /**
     * Creates and configures an instance of {@link module:ui/inputtext/inputtextview~InputTextView}.
     *
     * @returns A configured instance to be set as {@link #inputView}.
     */
    _createInputTextView() {
      const e = this.locale, t = new vg(e);
      return t.extendTemplate({
        on: {
          blur: t.bindTemplate.to("blur")
        }
      }), t.value = this.value, t.bind("isReadOnly", "hasError").to(this), this.bind("isFocused", "isEmpty").to(t), t.on("input", () => {
        const i = t.element.value, s = this.options.colorDefinitions.find((o) => i === o.label);
        this._stillTyping = !0, this.value = s && s.color || i;
      }), t.on("blur", () => {
        this._stillTyping = !1, this._setInputValue(t.element.value);
      }), t.delegate("input").to(this), t;
    }
    /**
     * Creates and configures the panel with "color grid" and "color picker" inside the {@link #dropdownView}.
     */
    _createColorSelector(e) {
      const t = e.t, i = this.options.defaultColorValue || "", s = t(i ? "Restore default" : "Remove color"), o = new Vl(e, {
        colors: this.options.colorDefinitions,
        columns: this.options.columns,
        removeButtonLabel: s,
        colorPickerLabel: t("Color picker"),
        colorPickerViewConfig: this.options.colorPickerConfig === !1 ? !1 : {
          ...this.options.colorPickerConfig,
          hideInput: !0
        }
      });
      o.appendUI(), o.on("execute", (a, l) => {
        if (l.source === "colorPickerSaveButton") {
          this.dropdownView.isOpen = !1;
          return;
        }
        this.value = l.value || i, this.fire("input"), l.source !== "colorPicker" && (this.dropdownView.isOpen = !1);
      });
      let r = this.value;
      return o.on("colorPicker:cancel", () => {
        this.value = r, this.fire("input"), this.dropdownView.isOpen = !1;
      }), o.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
        r = this.value;
      }), o.bind("selectedColor").to(this, "value"), o;
    }
    /**
     * Sets {@link #inputView}'s value property to the color value or color label,
     * if there is one and the user is not typing.
     *
     * Handles cases like:
     *
     * * Someone picks the color in the grid.
     * * The color is set from the plugin level.
     *
     * @param inputValue Color value to be set.
     */
    _setInputValue(e) {
      if (!this._stillTyping) {
        const t = Ih(e), i = this.options.colorDefinitions.find((s) => t === Ih(s.color));
        i ? this.inputView.value = i.label : this.inputView.value = e || "";
      }
    }
  }
  function Ih(n) {
    return n.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ");
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const jl = (n) => n === "";
  function Kl(n) {
    return {
      none: n("None"),
      solid: n("Solid"),
      dotted: n("Dotted"),
      dashed: n("Dashed"),
      double: n("Double"),
      groove: n("Groove"),
      ridge: n("Ridge"),
      inset: n("Inset"),
      outset: n("Outset")
    };
  }
  function Gp(n) {
    return n('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".');
  }
  function jp(n) {
    return n('The value is invalid. Try "10px" or "2em" or simply "2".');
  }
  function Vo(n) {
    return n = n.trim().toLowerCase(), jl(n) || Qm(n);
  }
  function Wn(n) {
    return n = n.trim(), jl(n) || Jp(n) || tr(n) || eg(n);
  }
  function Kp(n) {
    return n = n.trim(), jl(n) || Jp(n) || tr(n);
  }
  function Zp(n, e) {
    const t = new Ce(), i = Kl(n.t);
    for (const s in i) {
      const o = {
        type: "button",
        model: new yi({
          _borderStyleValue: s,
          label: i[s],
          role: "menuitemradio",
          withText: !0
        })
      };
      s === "none" ? o.model.bind("isOn").to(n, "borderStyle", (r) => e === "none" ? !r : r === s) : o.model.bind("isOn").to(n, "borderStyle", (r) => r === s), t.add(o);
    }
    return t;
  }
  function Da(n) {
    const { view: e, icons: t, toolbar: i, labels: s, propertyName: o, nameToValue: r, defaultValue: a } = n;
    for (const l in s) {
      const c = new P(e.locale);
      c.set({
        label: s[l],
        icon: t[l],
        tooltip: s[l]
      });
      const u = r ? r(l) : l;
      c.bind("isOn").to(e, o, (d) => {
        let h = d;
        return d === "" && a && (h = a), u === h;
      }), c.on("execute", () => {
        e[o] = u;
      }), i.items.add(c);
    }
  }
  const Mo = [
    {
      color: "hsl(0, 0%, 0%)",
      label: "Black"
    },
    {
      color: "hsl(0, 0%, 30%)",
      label: "Dim grey"
    },
    {
      color: "hsl(0, 0%, 60%)",
      label: "Grey"
    },
    {
      color: "hsl(0, 0%, 90%)",
      label: "Light grey"
    },
    {
      color: "hsl(0, 0%, 100%)",
      label: "White",
      hasBorder: !0
    },
    {
      color: "hsl(0, 75%, 60%)",
      label: "Red"
    },
    {
      color: "hsl(30, 75%, 60%)",
      label: "Orange"
    },
    {
      color: "hsl(60, 75%, 60%)",
      label: "Yellow"
    },
    {
      color: "hsl(90, 75%, 60%)",
      label: "Light green"
    },
    {
      color: "hsl(120, 75%, 60%)",
      label: "Green"
    },
    {
      color: "hsl(150, 75%, 60%)",
      label: "Aquamarine"
    },
    {
      color: "hsl(180, 75%, 60%)",
      label: "Turquoise"
    },
    {
      color: "hsl(210, 75%, 60%)",
      label: "Light blue"
    },
    {
      color: "hsl(240, 75%, 60%)",
      label: "Blue"
    },
    {
      color: "hsl(270, 75%, 60%)",
      label: "Purple"
    }
  ];
  function Bo(n) {
    return (e, t, i) => {
      const s = new E4(e.locale, {
        colorDefinitions: A4(n.colorConfig),
        columns: n.columns,
        defaultColorValue: n.defaultColorValue,
        colorPickerConfig: n.colorPickerConfig
      });
      return s.inputView.set({
        id: t,
        ariaDescribedById: i
      }), s.bind("isReadOnly").to(e, "isEnabled", (o) => !o), s.bind("hasError").to(e, "errorText", (o) => !!o), s.on("input", () => {
        e.errorText = null;
      }), e.bind("isEmpty", "isFocused").to(s), s;
    };
  }
  function Jp(n) {
    const e = parseFloat(n);
    return !Number.isNaN(e) && n === String(e);
  }
  function A4(n) {
    return n.map((e) => ({
      color: e.model,
      label: e.label,
      options: {
        hasBorder: e.hasBorder
      }
    }));
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Be extends T {
    /**
     * Creates an instance of the form row class.
     *
     * @param locale The locale instance.
     * @param options.labelView When passed, the row gets the `group` and `aria-labelledby`
     * DOM attributes and gets described by the label.
     */
    constructor(e, t = {}) {
      super(e);
      const i = this.bindTemplate;
      this.set("class", t.class || null), this.children = this.createCollection(), t.children && t.children.forEach((s) => this.children.add(s)), this.set("_role", null), this.set("_ariaLabelledBy", null), t.labelView && this.set({
        _role: "group",
        _ariaLabelledBy: t.labelView.id
      }), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-form__row",
            i.to("class")
          ],
          role: i.to("_role"),
          "aria-labelledby": i.to("_ariaLabelledBy")
        },
        children: this.children
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Ph = {
    left: x.alignLeft,
    center: x.alignCenter,
    right: x.alignRight,
    justify: x.alignJustify,
    top: x.alignTop,
    middle: x.alignMiddle,
    bottom: x.alignBottom
  };
  class x4 extends T {
    /**
     * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
     * @param options Additional configuration of the view.
     * @param options.borderColors A configuration of the border color palette used by the
     * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#borderColorInput}.
     * @param options.backgroundColors A configuration of the background color palette used by the
     * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#backgroundInput}.
     * @param options.defaultTableCellProperties The default table cell properties.
     */
    constructor(e, t) {
      super(e), this.set({
        borderStyle: "",
        borderWidth: "",
        borderColor: "",
        padding: "",
        backgroundColor: "",
        width: "",
        height: "",
        horizontalAlignment: "",
        verticalAlignment: ""
      }), this.options = t;
      const { borderStyleDropdown: i, borderWidthInput: s, borderColorInput: o, borderRowLabel: r } = this._createBorderFields(), { backgroundRowLabel: a, backgroundInput: l } = this._createBackgroundFields(), { widthInput: c, operatorLabel: u, heightInput: d, dimensionsLabel: h } = this._createDimensionFields(), { horizontalAlignmentToolbar: f, verticalAlignmentToolbar: m, alignmentLabel: p } = this._createAlignmentFields();
      this.focusTracker = new Q(), this.keystrokes = new ne(), this.children = this.createCollection(), this.borderStyleDropdown = i, this.borderWidthInput = s, this.borderColorInput = o, this.backgroundInput = l, this.paddingInput = this._createPaddingField(), this.widthInput = c, this.heightInput = d, this.horizontalAlignmentToolbar = f, this.verticalAlignmentToolbar = m;
      const { saveButtonView: b, cancelButtonView: v } = this._createActionButtons();
      this.saveButtonView = b, this.cancelButtonView = v, this._focusables = new ke(), this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      }), this.children.add(new rr(e, {
        label: this.t("Cell properties")
      })), this.children.add(new Be(e, {
        labelView: r,
        children: [
          r,
          i,
          o,
          s
        ],
        class: "ck-table-form__border-row"
      })), this.children.add(new Be(e, {
        labelView: a,
        children: [
          a,
          l
        ],
        class: "ck-table-form__background-row"
      })), this.children.add(new Be(e, {
        children: [
          // Dimensions row.
          new Be(e, {
            labelView: h,
            children: [
              h,
              c,
              u,
              d
            ],
            class: "ck-table-form__dimensions-row"
          }),
          // Padding row.
          new Be(e, {
            children: [
              this.paddingInput
            ],
            class: "ck-table-cell-properties-form__padding-row"
          })
        ]
      })), this.children.add(new Be(e, {
        labelView: p,
        children: [
          p,
          f,
          m
        ],
        class: "ck-table-cell-properties-form__alignment-row"
      })), this.children.add(new Be(e, {
        children: [
          this.saveButtonView,
          this.cancelButtonView
        ],
        class: "ck-table-form__action-row"
      })), this.setTemplate({
        tag: "form",
        attributes: {
          class: [
            "ck",
            "ck-form",
            "ck-table-form",
            "ck-table-cell-properties-form"
          ],
          // https://github.com/ckeditor/ckeditor5-link/issues/90
          tabindex: "-1"
        },
        children: this.children
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), an({
        view: this
      }), [this.borderColorInput, this.backgroundInput].forEach((e) => {
        e.fieldView.focusCycler.on("forwardCycle", (t) => {
          this._focusCycler.focusNext(), t.stop();
        }), e.fieldView.focusCycler.on("backwardCycle", (t) => {
          this._focusCycler.focusPrevious(), t.stop();
        });
      }), [
        this.borderStyleDropdown,
        this.borderColorInput,
        this.borderWidthInput,
        this.backgroundInput,
        this.widthInput,
        this.heightInput,
        this.paddingInput,
        this.horizontalAlignmentToolbar,
        this.verticalAlignmentToolbar,
        this.saveButtonView,
        this.cancelButtonView
      ].forEach((e) => {
        this._focusables.add(e), this.focusTracker.add(e.element);
      }), this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the fist focusable field in the form.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #borderStyleDropdown},
     * * {@link #borderWidthInput},
     * * {@link #borderColorInput}.
     */
    _createBorderFields() {
      const e = this.options.defaultTableCellProperties, t = {
        style: e.borderStyle,
        width: e.borderWidth,
        color: e.borderColor
      }, i = Bo({
        colorConfig: this.options.borderColors,
        columns: 5,
        defaultColorValue: t.color,
        colorPickerConfig: this.options.colorPickerConfig
      }), s = this.locale, o = this.t, r = o("Style"), a = new Fe(s);
      a.text = o("Border");
      const l = Kl(o), c = new he(s, Eg);
      c.set({
        label: r,
        class: "ck-table-form__border-style"
      }), c.fieldView.buttonView.set({
        ariaLabel: r,
        ariaLabelledBy: void 0,
        isOn: !1,
        withText: !0,
        tooltip: r
      }), c.fieldView.buttonView.bind("label").to(this, "borderStyle", (h) => l[h || "none"]), c.fieldView.on("execute", (h) => {
        this.borderStyle = h.source._borderStyleValue;
      }), c.bind("isEmpty").to(this, "borderStyle", (h) => !h), Kt(c.fieldView, Zp(this, t.style), {
        role: "menu",
        ariaLabel: r
      });
      const u = new he(s, ze);
      u.set({
        label: o("Width"),
        class: "ck-table-form__border-width"
      }), u.fieldView.bind("value").to(this, "borderWidth"), u.bind("isEnabled").to(this, "borderStyle", to), u.fieldView.on("input", () => {
        this.borderWidth = u.fieldView.element.value;
      });
      const d = new he(s, i);
      return d.set({
        label: o("Color"),
        class: "ck-table-form__border-color"
      }), d.fieldView.bind("value").to(this, "borderColor"), d.bind("isEnabled").to(this, "borderStyle", to), d.fieldView.on("input", () => {
        this.borderColor = d.fieldView.value;
      }), this.on("change:borderStyle", (h, f, m, p) => {
        to(m) || (this.borderColor = "", this.borderWidth = ""), to(p) || (this.borderColor = t.color, this.borderWidth = t.width);
      }), {
        borderRowLabel: a,
        borderStyleDropdown: c,
        borderColorInput: d,
        borderWidthInput: u
      };
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #backgroundInput}.
     */
    _createBackgroundFields() {
      const e = this.locale, t = this.t, i = new Fe(e);
      i.text = t("Background");
      const s = Bo({
        colorConfig: this.options.backgroundColors,
        columns: 5,
        defaultColorValue: this.options.defaultTableCellProperties.backgroundColor,
        colorPickerConfig: this.options.colorPickerConfig
      }), o = new he(e, s);
      return o.set({
        label: t("Color"),
        class: "ck-table-cell-properties-form__background"
      }), o.fieldView.bind("value").to(this, "backgroundColor"), o.fieldView.on("input", () => {
        this.backgroundColor = o.fieldView.value;
      }), {
        backgroundRowLabel: i,
        backgroundInput: o
      };
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #widthInput}.
     * * {@link #heightInput}.
     */
    _createDimensionFields() {
      const e = this.locale, t = this.t, i = new Fe(e);
      i.text = t("Dimensions");
      const s = new he(e, ze);
      s.set({
        label: t("Width"),
        class: "ck-table-form__dimensions-row__width"
      }), s.fieldView.bind("value").to(this, "width"), s.fieldView.on("input", () => {
        this.width = s.fieldView.element.value;
      });
      const o = new T(e);
      o.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck-table-form__dimension-operator"
          ]
        },
        children: [
          { text: "×" }
        ]
      });
      const r = new he(e, ze);
      return r.set({
        label: t("Height"),
        class: "ck-table-form__dimensions-row__height"
      }), r.fieldView.bind("value").to(this, "height"), r.fieldView.on("input", () => {
        this.height = r.fieldView.element.value;
      }), {
        dimensionsLabel: i,
        widthInput: s,
        operatorLabel: o,
        heightInput: r
      };
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #paddingInput}.
     */
    _createPaddingField() {
      const e = this.locale, t = this.t, i = new he(e, ze);
      return i.set({
        label: t("Padding"),
        class: "ck-table-cell-properties-form__padding"
      }), i.fieldView.bind("value").to(this, "padding"), i.fieldView.on("input", () => {
        this.padding = i.fieldView.element.value;
      }), i;
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #horizontalAlignmentToolbar},
     * * {@link #verticalAlignmentToolbar}.
     */
    _createAlignmentFields() {
      const e = this.locale, t = this.t, i = new Fe(e);
      i.text = t("Table cell text alignment");
      const s = new en(e), o = e.contentLanguageDirection === "rtl";
      s.set({
        isCompact: !0,
        ariaLabel: t("Horizontal text alignment toolbar")
      }), Da({
        view: this,
        icons: Ph,
        toolbar: s,
        labels: this._horizontalAlignmentLabels,
        propertyName: "horizontalAlignment",
        nameToValue: (a) => {
          if (o) {
            if (a === "left")
              return "right";
            if (a === "right")
              return "left";
          }
          return a;
        },
        defaultValue: this.options.defaultTableCellProperties.horizontalAlignment
      });
      const r = new en(e);
      return r.set({
        isCompact: !0,
        ariaLabel: t("Vertical text alignment toolbar")
      }), Da({
        view: this,
        icons: Ph,
        toolbar: r,
        labels: this._verticalAlignmentLabels,
        propertyName: "verticalAlignment",
        defaultValue: this.options.defaultTableCellProperties.verticalAlignment
      }), {
        horizontalAlignmentToolbar: s,
        verticalAlignmentToolbar: r,
        alignmentLabel: i
      };
    }
    /**
     * Creates the following form controls:
     *
     * * {@link #saveButtonView},
     * * {@link #cancelButtonView}.
     */
    _createActionButtons() {
      const e = this.locale, t = this.t, i = new P(e), s = new P(e), o = [
        this.borderWidthInput,
        this.borderColorInput,
        this.backgroundInput,
        this.paddingInput
      ];
      return i.set({
        label: t("Save"),
        icon: x.check,
        class: "ck-button-save",
        type: "submit",
        withText: !0
      }), i.bind("isEnabled").toMany(o, "errorText", (...r) => r.every((a) => !a)), s.set({
        label: t("Cancel"),
        icon: x.cancel,
        class: "ck-button-cancel",
        withText: !0
      }), s.delegate("execute").to(this, "cancel"), {
        saveButtonView: i,
        cancelButtonView: s
      };
    }
    /**
     * Provides localized labels for {@link #horizontalAlignmentToolbar} buttons.
     */
    get _horizontalAlignmentLabels() {
      const e = this.locale, t = this.t, i = t("Align cell text to the left"), s = t("Align cell text to the center"), o = t("Align cell text to the right"), r = t("Justify cell text");
      return e.uiLanguageDirection === "rtl" ? { right: o, center: s, left: i, justify: r } : { left: i, center: s, right: o, justify: r };
    }
    /**
     * Provides localized labels for {@link #verticalAlignmentToolbar} buttons.
     */
    get _verticalAlignmentLabels() {
      const e = this.t;
      return {
        top: e("Align cell text to the top"),
        middle: e("Align cell text to the middle"),
        bottom: e("Align cell text to the bottom")
      };
    }
  }
  function to(n) {
    return n !== "none";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const ii = ye.defaultPositions, Fa = [
    ii.northArrowSouth,
    ii.northArrowSouthWest,
    ii.northArrowSouthEast,
    ii.southArrowNorth,
    ii.southArrowNorthWest,
    ii.southArrowNorthEast,
    ii.viewportStickyNorth
  ];
  function Xp(n, e) {
    const t = n.plugins.get("ContextualBalloon"), i = n.editing.view.document.selection;
    let s;
    e === "cell" ? fr(i) && (s = Qp(n)) : $p(i) && (s = Yp(n)), s && t.updatePosition(s);
  }
  function Yp(n) {
    const e = n.model.document.selection, t = li(e), i = n.editing.mapper.toViewElement(t);
    return {
      target: n.editing.view.domConverter.mapViewToDom(i),
      positions: Fa
    };
  }
  function Qp(n) {
    const e = n.editing.mapper, t = n.editing.view.domConverter, i = n.model.document.selection;
    if (i.rangeCount > 1)
      return {
        target: () => S4(i.getRanges(), n),
        positions: Fa
      };
    const s = ew(i.getFirstPosition()), o = e.toViewElement(s);
    return {
      target: t.mapViewToDom(o),
      positions: Fa
    };
  }
  function ew(n) {
    return n.nodeAfter && n.nodeAfter.is("element", "tableCell") ? n.nodeAfter : n.findAncestor("tableCell");
  }
  function S4(n, e) {
    const t = e.editing.mapper, i = e.editing.view.domConverter, s = Array.from(n).map((o) => {
      const r = ew(o.start), a = t.toViewElement(r);
      return new O(i.mapViewToDom(a));
    });
    return O.getBoundingRect(s);
  }
  const I4 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ai(n) {
    if (!n || !J(n))
      return n;
    const { top: e, right: t, bottom: i, left: s } = n;
    if (e == t && t == i && i == s)
      return e;
  }
  function xi(n, e) {
    const t = parseFloat(n);
    return Number.isNaN(t) || String(t) !== String(n) ? n : `${t}${e}`;
  }
  function Es(n, e = {}) {
    const t = {
      borderStyle: "none",
      borderWidth: "",
      borderColor: "",
      backgroundColor: "",
      width: "",
      height: "",
      ...n
    };
    return e.includeAlignmentProperty && !t.alignment && (t.alignment = "center"), e.includePaddingProperty && !t.padding && (t.padding = ""), e.includeVerticalAlignmentProperty && !t.verticalAlignment && (t.verticalAlignment = "middle"), e.includeHorizontalAlignmentProperty && !t.horizontalAlignment && (t.horizontalAlignment = e.isRightToLeftContent ? "right" : "left"), t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const P4 = 500, Rh = {
    borderStyle: "tableCellBorderStyle",
    borderColor: "tableCellBorderColor",
    borderWidth: "tableCellBorderWidth",
    height: "tableCellHeight",
    width: "tableCellWidth",
    padding: "tableCellPadding",
    backgroundColor: "tableCellBackgroundColor",
    horizontalAlignment: "tableCellHorizontalAlignment",
    verticalAlignment: "tableCellVerticalAlignment"
  };
  class R4 extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [$t];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableCellPropertiesUI";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("table.tableCellProperties", {
        borderColors: Mo,
        backgroundColors: Mo
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t;
      this._defaultTableCellProperties = Es(e.config.get("table.tableCellProperties.defaultProperties"), {
        includeVerticalAlignmentProperty: !0,
        includeHorizontalAlignmentProperty: !0,
        includePaddingProperty: !0,
        isRightToLeftContent: e.locale.contentLanguageDirection === "rtl"
      }), this._balloon = e.plugins.get($t), this.view = null, this._isReady = !1, e.ui.componentFactory.add("tableCellProperties", (i) => {
        const s = new P(i);
        s.set({
          label: t("Cell properties"),
          icon: I4,
          tooltip: !0
        }), this.listenTo(s, "execute", () => this._showView());
        const o = Object.values(Rh).map((r) => e.commands.get(r));
        return s.bind("isEnabled").toMany(o, "isEnabled", (...r) => r.some((a) => a)), s;
      });
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.view && this.view.destroy();
    }
    /**
     * Creates the {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView} instance.
     *
     * @returns The cell properties form view instance.
     */
    _createPropertiesView() {
      const e = this.editor, t = e.config.get("table.tableCellProperties"), i = ss(t.borderColors), s = ns(e.locale, i), o = ss(t.backgroundColors), r = ns(e.locale, o), a = t.colorPicker !== !1, l = new x4(e.locale, {
        borderColors: s,
        backgroundColors: r,
        defaultTableCellProperties: this._defaultTableCellProperties,
        colorPickerConfig: a ? t.colorPicker || {} : !1
      }), c = e.t;
      l.render(), this.listenTo(l, "submit", () => {
        this._hideView();
      }), this.listenTo(l, "cancel", () => {
        this._undoStepBatch.operations.length && e.execute("undo", this._undoStepBatch), this._hideView();
      }), l.keystrokes.set("Esc", (h, f) => {
        this._hideView(), f();
      }), rn({
        emitter: l,
        activator: () => this._isViewInBalloon,
        contextElements: [this._balloon.view.element],
        callback: () => this._hideView()
      });
      const u = Gp(c), d = jp(c);
      return l.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle")), l.on("change:borderColor", this._getValidatedPropertyChangeCallback({
        viewField: l.borderColorInput,
        commandName: "tableCellBorderColor",
        errorText: u,
        validator: Vo
      })), l.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
        viewField: l.borderWidthInput,
        commandName: "tableCellBorderWidth",
        errorText: d,
        validator: Kp
      })), l.on("change:padding", this._getValidatedPropertyChangeCallback({
        viewField: l.paddingInput,
        commandName: "tableCellPadding",
        errorText: d,
        validator: Wn
      })), l.on("change:width", this._getValidatedPropertyChangeCallback({
        viewField: l.widthInput,
        commandName: "tableCellWidth",
        errorText: d,
        validator: Wn
      })), l.on("change:height", this._getValidatedPropertyChangeCallback({
        viewField: l.heightInput,
        commandName: "tableCellHeight",
        errorText: d,
        validator: Wn
      })), l.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
        viewField: l.backgroundInput,
        commandName: "tableCellBackgroundColor",
        errorText: u,
        validator: Vo
      })), l.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment")), l.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment")), l;
    }
    /**
     * In this method the "editor data -> UI" binding is happening.
     *
     * When executed, this method obtains selected cell property values from various table commands
     * and passes them to the {@link #view}.
     *
     * This way, the UI stays up–to–date with the editor data.
     */
    _fillViewFormFromCommandValues() {
      const e = this.editor.commands, t = e.get("tableCellBorderStyle");
      Object.entries(Rh).map(([i, s]) => {
        const o = this._defaultTableCellProperties[i] || "";
        return [
          i,
          e.get(s).value || o
        ];
      }).forEach(([i, s]) => {
        (i === "borderColor" || i === "borderWidth") && t.value === "none" || this.view.set(i, s);
      }), this._isReady = !0;
    }
    /**
     * Shows the {@link #view} in the {@link #_balloon}.
     *
     * **Note**: Each time a view is shown, a new {@link #_undoStepBatch} is created. It contains
     * all changes made to the document when the view is visible, allowing a single undo step
     * for all of them.
     */
    _showView() {
      const e = this.editor;
      this.view || (this.view = this._createPropertiesView()), this.listenTo(e.ui, "update", () => {
        this._updateView();
      }), this._fillViewFormFromCommandValues(), this._balloon.add({
        view: this.view,
        position: Qp(e)
      }), this._undoStepBatch = e.model.createBatch(), this.view.focus();
    }
    /**
     * Removes the {@link #view} from the {@link #_balloon}.
     */
    _hideView() {
      const e = this.editor;
      this.stopListening(e.ui, "update"), this._isReady = !1, this.view.saveButtonView.focus(), this._balloon.remove(this.view), this.editor.editing.view.focus();
    }
    /**
     * Repositions the {@link #_balloon} or hides the {@link #view} if a table cell is no longer selected.
     */
    _updateView() {
      const e = this.editor, t = e.editing.view.document;
      fr(t.selection) ? this._isViewVisible && Xp(e, "cell") : this._hideView();
    }
    /**
     * Returns `true` when the {@link #view} is visible in the {@link #_balloon}.
     */
    get _isViewVisible() {
      return !!this.view && this._balloon.visibleView === this.view;
    }
    /**
     * Returns `true` when the {@link #view} is in the {@link #_balloon}.
     */
    get _isViewInBalloon() {
      return !!this.view && this._balloon.hasView(this.view);
    }
    /**
     * Creates a callback that when executed upon the {@link #view view's} property change
     * executes a related editor command with the new property value.
     *
     * @param defaultValue The default value of the command.
     */
    _getPropertyChangeCallback(e) {
      return (t, i, s) => {
        this._isReady && this.editor.execute(e, {
          value: s,
          batch: this._undoStepBatch
        });
      };
    }
    /**
     * Creates a callback that when executed upon the {@link #view view's} property change:
     * * Executes a related editor command with the new property value if the value is valid,
     * * Or sets the error text next to the invalid field, if the value did not pass the validation.
     */
    _getValidatedPropertyChangeCallback(e) {
      const { commandName: t, viewField: i, validator: s, errorText: o } = e, r = Rt(() => {
        i.errorText = o;
      }, P4);
      return (a, l, c) => {
        r.cancel(), this._isReady && (s(c) ? (this.editor.execute(t, {
          value: c,
          batch: this._undoStepBatch
        }), i.errorText = null) : r());
      };
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Bt extends V {
    /**
     * Creates a new `TableCellPropertyCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param attributeName Table cell attribute name.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t, i) {
      super(e), this.attributeName = t, this._defaultValue = i;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor, i = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e.model.document.selection);
      this.isEnabled = !!i.length, this.value = this._getSingleValue(i);
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param options.value If set, the command will set the attribute on selected table cells.
     * If it is not set, the command will remove the attribute from the selected table cells.
     * @param options.batch Pass the model batch instance to the command to aggregate changes,
     * for example to allow a single undo step for multiple executions.
     */
    execute(e = {}) {
      const { value: t, batch: i } = e, s = this.editor.model, r = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(s.document.selection), a = this._getValueToSet(t);
      s.enqueueChange(i, (l) => {
        a ? r.forEach((c) => l.setAttribute(this.attributeName, a, c)) : r.forEach((c) => l.removeAttribute(this.attributeName, c));
      });
    }
    /**
     * Returns the attribute value for a table cell.
     */
    _getAttribute(e) {
      if (!e)
        return;
      const t = e.getAttribute(this.attributeName);
      if (t !== this._defaultValue)
        return t;
    }
    /**
     * Returns the proper model value. It can be used to add a default unit to numeric values.
     */
    _getValueToSet(e) {
      if (e !== this._defaultValue)
        return e;
    }
    /**
     * Returns a single value for all selected table cells. If the value is the same for all cells,
     * it will be returned (`undefined` otherwise).
     */
    _getSingleValue(e) {
      const t = this._getAttribute(e[0]);
      return e.every((s) => this._getAttribute(s) === t) ? t : void 0;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class L4 extends Bt {
    /**
     * Creates a new `TableCellWidthCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableCellWidth", t);
    }
    /**
     * @inheritDoc
     */
    _getValueToSet(e) {
      if (e = xi(e, "px"), e !== this._defaultValue)
        return e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class tw extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableCellWidthEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ts];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = Es(e.config.get("table.tableCellProperties.defaultProperties"));
      fo(e.model.schema, e.conversion, {
        modelAttribute: "tableCellWidth",
        styleName: "width",
        defaultValue: t.width
      }), e.commands.add("tableCellWidth", new L4(e, t.width));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class V4 extends Bt {
    /**
     * Creates a new `TableCellPaddingCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableCellPadding", t);
    }
    /**
     * @inheritDoc
     */
    _getAttribute(e) {
      if (!e)
        return;
      const t = Ai(e.getAttribute(this.attributeName));
      if (t !== this._defaultValue)
        return t;
    }
    /**
     * @inheritDoc
     */
    _getValueToSet(e) {
      const t = xi(e, "px");
      if (t !== this._defaultValue)
        return t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class M4 extends Bt {
    /**
     * Creates a new `TableCellHeightCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableCellHeight", t);
    }
    /**
     * @inheritDoc
     */
    _getValueToSet(e) {
      const t = xi(e, "px");
      if (t !== this._defaultValue)
        return t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class B4 extends Bt {
    /**
     * Creates a new `TableCellBackgroundColorCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableCellBackgroundColor", t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class O4 extends Bt {
    /**
     * Creates a new `TableCellVerticalAlignmentCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value for the "alignment" attribute.
     */
    constructor(e, t) {
      super(e, "tableCellVerticalAlignment", t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class N4 extends Bt {
    /**
     * Creates a new `TableCellHorizontalAlignmentCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value for the "alignment" attribute.
     */
    constructor(e, t) {
      super(e, "tableCellHorizontalAlignment", t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class D4 extends Bt {
    /**
     * Creates a new `TableCellBorderStyleCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableCellBorderStyle", t);
    }
    /**
     * @inheritDoc
     */
    _getAttribute(e) {
      if (!e)
        return;
      const t = Ai(e.getAttribute(this.attributeName));
      if (t !== this._defaultValue)
        return t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class F4 extends Bt {
    /**
     * Creates a new `TableCellBorderColorCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableCellBorderColor", t);
    }
    /**
     * @inheritDoc
     */
    _getAttribute(e) {
      if (!e)
        return;
      const t = Ai(e.getAttribute(this.attributeName));
      if (t !== this._defaultValue)
        return t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class z4 extends Bt {
    /**
     * Creates a new `TableCellBorderWidthCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableCellBorderWidth", t);
    }
    /**
     * @inheritDoc
     */
    _getAttribute(e) {
      if (!e)
        return;
      const t = Ai(e.getAttribute(this.attributeName));
      if (t !== this._defaultValue)
        return t;
    }
    /**
     * @inheritDoc
     */
    _getValueToSet(e) {
      const t = xi(e, "px");
      if (t !== this._defaultValue)
        return t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Lh = /^(top|middle|bottom)$/, Vh = /^(left|center|right|justify)$/;
  class U4 extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableCellPropertiesEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ts, tw];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.schema, i = e.conversion;
      e.config.define("table.tableCellProperties.defaultProperties", {});
      const s = Es(e.config.get("table.tableCellProperties.defaultProperties"), {
        includeVerticalAlignmentProperty: !0,
        includeHorizontalAlignmentProperty: !0,
        includePaddingProperty: !0,
        isRightToLeftContent: e.locale.contentLanguageDirection === "rtl"
      });
      e.data.addStyleProcessorRules(ig), H4(t, i, {
        color: s.borderColor,
        style: s.borderStyle,
        width: s.borderWidth
      }), e.commands.add("tableCellBorderStyle", new D4(e, s.borderStyle)), e.commands.add("tableCellBorderColor", new F4(e, s.borderColor)), e.commands.add("tableCellBorderWidth", new z4(e, s.borderWidth)), fo(t, i, {
        modelAttribute: "tableCellHeight",
        styleName: "height",
        defaultValue: s.height
      }), e.commands.add("tableCellHeight", new M4(e, s.height)), e.data.addStyleProcessorRules(DE), fo(t, i, {
        modelAttribute: "tableCellPadding",
        styleName: "padding",
        reduceBoxSides: !0,
        defaultValue: s.padding
      }), e.commands.add("tableCellPadding", new V4(e, s.padding)), e.data.addStyleProcessorRules(El), fo(t, i, {
        modelAttribute: "tableCellBackgroundColor",
        styleName: "background-color",
        defaultValue: s.backgroundColor
      }), e.commands.add("tableCellBackgroundColor", new B4(e, s.backgroundColor)), $4(t, i, s.horizontalAlignment), e.commands.add("tableCellHorizontalAlignment", new N4(e, s.horizontalAlignment)), W4(t, i, s.verticalAlignment), e.commands.add("tableCellVerticalAlignment", new O4(e, s.verticalAlignment));
    }
  }
  function H4(n, e, t) {
    const i = {
      width: "tableCellBorderWidth",
      color: "tableCellBorderColor",
      style: "tableCellBorderStyle"
    };
    n.extend("tableCell", {
      allowAttributes: Object.values(i)
    }), Ia(e, "td", i, t), Ia(e, "th", i, t), $n(e, { modelElement: "tableCell", modelAttribute: i.style, styleName: "border-style" }), $n(e, { modelElement: "tableCell", modelAttribute: i.color, styleName: "border-color" }), $n(e, { modelElement: "tableCell", modelAttribute: i.width, styleName: "border-width" });
  }
  function $4(n, e, t) {
    n.extend("tableCell", {
      allowAttributes: ["tableCellHorizontalAlignment"]
    }), e.for("downcast").attributeToAttribute({
      model: {
        name: "tableCell",
        key: "tableCellHorizontalAlignment"
      },
      view: (i) => ({
        key: "style",
        value: {
          "text-align": i
        }
      })
    }), e.for("upcast").attributeToAttribute({
      view: {
        name: /^(td|th)$/,
        styles: {
          "text-align": Vh
        }
      },
      model: {
        key: "tableCellHorizontalAlignment",
        value: (i) => {
          const s = i.getStyle("text-align");
          return s === t ? null : s;
        }
      }
    }).attributeToAttribute({
      view: {
        name: /^(td|th)$/,
        attributes: {
          align: Vh
        }
      },
      model: {
        key: "tableCellHorizontalAlignment",
        value: (i) => {
          const s = i.getAttribute("align");
          return s === t ? null : s;
        }
      }
    });
  }
  function W4(n, e, t) {
    n.extend("tableCell", {
      allowAttributes: ["tableCellVerticalAlignment"]
    }), e.for("downcast").attributeToAttribute({
      model: {
        name: "tableCell",
        key: "tableCellVerticalAlignment"
      },
      view: (i) => ({
        key: "style",
        value: {
          "vertical-align": i
        }
      })
    }), e.for("upcast").attributeToAttribute({
      view: {
        name: /^(td|th)$/,
        styles: {
          "vertical-align": Lh
        }
      },
      model: {
        key: "tableCellVerticalAlignment",
        value: (i) => {
          const s = i.getStyle("vertical-align");
          return s === t ? null : s;
        }
      }
    }).attributeToAttribute({
      view: {
        name: /^(td|th)$/,
        attributes: {
          valign: Lh
        }
      },
      model: {
        key: "tableCellVerticalAlignment",
        value: (i) => {
          const s = i.getAttribute("valign");
          return s === t ? null : s;
        }
      }
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class q4 extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableCellProperties";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [U4, R4];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Si extends V {
    /**
     * Creates a new `TablePropertyCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param attributeName Table cell attribute name.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t, i) {
      super(e), this.attributeName = t, this._defaultValue = i;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const t = this.editor.model.document.selection, i = li(t);
      this.isEnabled = !!i, this.value = this._getValue(i);
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param options.value If set, the command will set the attribute on the selected table.
     * If not set, the command will remove the attribute from the selected table.
     * @param options.batch Pass the model batch instance to the command to aggregate changes,
     * for example, to allow a single undo step for multiple executions.
     */
    execute(e = {}) {
      const t = this.editor.model, i = t.document.selection, { value: s, batch: o } = e, r = li(i), a = this._getValueToSet(s);
      t.enqueueChange(o, (l) => {
        a ? l.setAttribute(this.attributeName, a, r) : l.removeAttribute(this.attributeName, r);
      });
    }
    /**
     * Returns the attribute value for a table.
     */
    _getValue(e) {
      if (!e)
        return;
      const t = e.getAttribute(this.attributeName);
      if (t !== this._defaultValue)
        return t;
    }
    /**
     * Returns the proper model value. It can be used to add a default unit to numeric values.
     */
    _getValueToSet(e) {
      if (e !== this._defaultValue)
        return e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class G4 extends Si {
    /**
     * Creates a new `TableBackgroundColorCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableBackgroundColor", t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class j4 extends Si {
    /**
     * Creates a new `TableBorderColorCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableBorderColor", t);
    }
    /**
     * @inheritDoc
     */
    _getValue(e) {
      if (!e)
        return;
      const t = Ai(e.getAttribute(this.attributeName));
      if (t !== this._defaultValue)
        return t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class K4 extends Si {
    /**
     * Creates a new `TableBorderStyleCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableBorderStyle", t);
    }
    /**
     * @inheritDoc
     */
    _getValue(e) {
      if (!e)
        return;
      const t = Ai(e.getAttribute(this.attributeName));
      if (t !== this._defaultValue)
        return t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Z4 extends Si {
    /**
     * Creates a new `TableBorderWidthCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableBorderWidth", t);
    }
    /**
     * @inheritDoc
     */
    _getValue(e) {
      if (!e)
        return;
      const t = Ai(e.getAttribute(this.attributeName));
      if (t !== this._defaultValue)
        return t;
    }
    /**
     * @inheritDoc
     */
    _getValueToSet(e) {
      const t = xi(e, "px");
      if (t !== this._defaultValue)
        return t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class J4 extends Si {
    /**
     * Creates a new `TableWidthCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableWidth", t);
    }
    /**
     * @inheritDoc
     */
    _getValueToSet(e) {
      if (e = xi(e, "px"), e !== this._defaultValue)
        return e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class X4 extends Si {
    /**
     * Creates a new `TableHeightCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value of the attribute.
     */
    constructor(e, t) {
      super(e, "tableHeight", t);
    }
    /**
     * @inheritDoc
     */
    _getValueToSet(e) {
      if (e = xi(e, "px"), e !== this._defaultValue)
        return e;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Y4 extends Si {
    /**
     * Creates a new `TableAlignmentCommand` instance.
     *
     * @param editor An editor in which this command will be used.
     * @param defaultValue The default value for the "alignment" attribute.
     */
    constructor(e, t) {
      super(e, "tableAlignment", t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Q4 = /^(left|center|right)$/, eV = /^(left|none|right)$/;
  class tV extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TablePropertiesEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ts];
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.schema, i = e.conversion;
      e.config.define("table.tableProperties.defaultProperties", {});
      const s = Es(e.config.get("table.tableProperties.defaultProperties"), {
        includeAlignmentProperty: !0
      });
      e.data.addStyleProcessorRules(ig), iV(t, i, {
        color: s.borderColor,
        style: s.borderStyle,
        width: s.borderWidth
      }), e.commands.add("tableBorderColor", new j4(e, s.borderColor)), e.commands.add("tableBorderStyle", new K4(e, s.borderStyle)), e.commands.add("tableBorderWidth", new Z4(e, s.borderWidth)), nV(t, i, s.alignment), e.commands.add("tableAlignment", new Y4(e, s.alignment)), Mh(t, i, {
        modelAttribute: "tableWidth",
        styleName: "width",
        defaultValue: s.width
      }), e.commands.add("tableWidth", new J4(e, s.width)), Mh(t, i, {
        modelAttribute: "tableHeight",
        styleName: "height",
        defaultValue: s.height
      }), e.commands.add("tableHeight", new X4(e, s.height)), e.data.addStyleProcessorRules(El), sV(t, i, {
        modelAttribute: "tableBackgroundColor",
        styleName: "background-color",
        defaultValue: s.backgroundColor
      }), e.commands.add("tableBackgroundColor", new G4(e, s.backgroundColor));
    }
  }
  function iV(n, e, t) {
    const i = {
      width: "tableBorderWidth",
      color: "tableBorderColor",
      style: "tableBorderStyle"
    };
    n.extend("table", {
      allowAttributes: Object.values(i)
    }), Ia(e, "table", i, t), uo(e, { modelAttribute: i.color, styleName: "border-color" }), uo(e, { modelAttribute: i.style, styleName: "border-style" }), uo(e, { modelAttribute: i.width, styleName: "border-width" });
  }
  function nV(n, e, t) {
    n.extend("table", {
      allowAttributes: ["tableAlignment"]
    }), e.for("downcast").attributeToAttribute({
      model: {
        name: "table",
        key: "tableAlignment"
      },
      view: (i) => ({
        key: "style",
        value: {
          // Model: `alignment:center` => CSS: `float:none`.
          float: i === "center" ? "none" : i
        }
      }),
      converterPriority: "high"
    }), e.for("upcast").attributeToAttribute({
      view: {
        name: /^(table|figure)$/,
        styles: {
          float: eV
        }
      },
      model: {
        key: "tableAlignment",
        value: (i) => {
          let s = i.getStyle("float");
          return s === "none" && (s = "center"), s === t ? null : s;
        }
      }
    }).attributeToAttribute({
      view: {
        attributes: {
          align: Q4
        }
      },
      model: {
        name: "table",
        key: "tableAlignment",
        value: (i) => {
          const s = i.getAttribute("align");
          return s === t ? null : s;
        }
      }
    });
  }
  function sV(n, e, t) {
    const { modelAttribute: i } = t;
    n.extend("table", {
      allowAttributes: [i]
    }), Wl(e, { viewElement: "table", ...t }), uo(e, t);
  }
  function Mh(n, e, t) {
    const { modelAttribute: i } = t;
    n.extend("table", {
      allowAttributes: [i]
    }), Wl(e, {
      viewElement: /^(table|figure)$/,
      shouldUpcast: (s) => !(s.name == "table" && s.parent.name == "figure"),
      ...t
    }), $n(e, { modelElement: "table", ...t });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const oV = {
    left: x.objectLeft,
    center: x.objectCenter,
    right: x.objectRight
  };
  class rV extends T {
    /**
     * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
     * @param options Additional configuration of the view.
     */
    constructor(e, t) {
      super(e), this.set({
        borderStyle: "",
        borderWidth: "",
        borderColor: "",
        backgroundColor: "",
        width: "",
        height: "",
        alignment: ""
      }), this.options = t;
      const { borderStyleDropdown: i, borderWidthInput: s, borderColorInput: o, borderRowLabel: r } = this._createBorderFields(), { backgroundRowLabel: a, backgroundInput: l } = this._createBackgroundFields(), { widthInput: c, operatorLabel: u, heightInput: d, dimensionsLabel: h } = this._createDimensionFields(), { alignmentToolbar: f, alignmentLabel: m } = this._createAlignmentFields();
      this.focusTracker = new Q(), this.keystrokes = new ne(), this.children = this.createCollection(), this.borderStyleDropdown = i, this.borderWidthInput = s, this.borderColorInput = o, this.backgroundInput = l, this.widthInput = c, this.heightInput = d, this.alignmentToolbar = f;
      const { saveButtonView: p, cancelButtonView: b } = this._createActionButtons();
      this.saveButtonView = p, this.cancelButtonView = b, this._focusables = new ke(), this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      }), this.children.add(new rr(e, {
        label: this.t("Table properties")
      })), this.children.add(new Be(e, {
        labelView: r,
        children: [
          r,
          i,
          o,
          s
        ],
        class: "ck-table-form__border-row"
      })), this.children.add(new Be(e, {
        labelView: a,
        children: [
          a,
          l
        ],
        class: "ck-table-form__background-row"
      })), this.children.add(new Be(e, {
        children: [
          // Dimensions row.
          new Be(e, {
            labelView: h,
            children: [
              h,
              c,
              u,
              d
            ],
            class: "ck-table-form__dimensions-row"
          }),
          // Alignment row.
          new Be(e, {
            labelView: m,
            children: [
              m,
              f
            ],
            class: "ck-table-properties-form__alignment-row"
          })
        ]
      })), this.children.add(new Be(e, {
        children: [
          this.saveButtonView,
          this.cancelButtonView
        ],
        class: "ck-table-form__action-row"
      })), this.setTemplate({
        tag: "form",
        attributes: {
          class: [
            "ck",
            "ck-form",
            "ck-table-form",
            "ck-table-properties-form"
          ],
          // https://github.com/ckeditor/ckeditor5-link/issues/90
          tabindex: "-1"
        },
        children: this.children
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), an({
        view: this
      }), [this.borderColorInput, this.backgroundInput].forEach((e) => {
        e.fieldView.focusCycler.on("forwardCycle", (t) => {
          this._focusCycler.focusNext(), t.stop();
        }), e.fieldView.focusCycler.on("backwardCycle", (t) => {
          this._focusCycler.focusPrevious(), t.stop();
        });
      }), [
        this.borderStyleDropdown,
        this.borderColorInput,
        this.borderWidthInput,
        this.backgroundInput,
        this.widthInput,
        this.heightInput,
        this.alignmentToolbar,
        this.saveButtonView,
        this.cancelButtonView
      ].forEach((e) => {
        this._focusables.add(e), this.focusTracker.add(e.element);
      }), this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the fist focusable field in the form.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #borderStyleDropdown},
     * * {@link #borderWidthInput},
     * * {@link #borderColorInput}.
     */
    _createBorderFields() {
      const e = this.options.defaultTableProperties, t = {
        style: e.borderStyle,
        width: e.borderWidth,
        color: e.borderColor
      }, i = Bo({
        colorConfig: this.options.borderColors,
        columns: 5,
        defaultColorValue: t.color,
        colorPickerConfig: this.options.colorPickerConfig
      }), s = this.locale, o = this.t, r = o("Style"), a = new Fe(s);
      a.text = o("Border");
      const l = Kl(o), c = new he(s, Eg);
      c.set({
        label: r,
        class: "ck-table-form__border-style"
      }), c.fieldView.buttonView.set({
        ariaLabel: r,
        ariaLabelledBy: void 0,
        isOn: !1,
        withText: !0,
        tooltip: r
      }), c.fieldView.buttonView.bind("label").to(this, "borderStyle", (h) => l[h || "none"]), c.fieldView.on("execute", (h) => {
        this.borderStyle = h.source._borderStyleValue;
      }), c.bind("isEmpty").to(this, "borderStyle", (h) => !h), Kt(c.fieldView, Zp(this, t.style), {
        role: "menu",
        ariaLabel: r
      });
      const u = new he(s, ze);
      u.set({
        label: o("Width"),
        class: "ck-table-form__border-width"
      }), u.fieldView.bind("value").to(this, "borderWidth"), u.bind("isEnabled").to(this, "borderStyle", io), u.fieldView.on("input", () => {
        this.borderWidth = u.fieldView.element.value;
      });
      const d = new he(s, i);
      return d.set({
        label: o("Color"),
        class: "ck-table-form__border-color"
      }), d.fieldView.bind("value").to(this, "borderColor"), d.bind("isEnabled").to(this, "borderStyle", io), d.fieldView.on("input", () => {
        this.borderColor = d.fieldView.value;
      }), this.on("change:borderStyle", (h, f, m, p) => {
        io(m) || (this.borderColor = "", this.borderWidth = ""), io(p) || (this.borderColor = t.color, this.borderWidth = t.width);
      }), {
        borderRowLabel: a,
        borderStyleDropdown: c,
        borderColorInput: d,
        borderWidthInput: u
      };
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #backgroundInput}.
     */
    _createBackgroundFields() {
      const e = this.locale, t = this.t, i = new Fe(e);
      i.text = t("Background");
      const s = Bo({
        colorConfig: this.options.backgroundColors,
        columns: 5,
        defaultColorValue: this.options.defaultTableProperties.backgroundColor,
        colorPickerConfig: this.options.colorPickerConfig
      }), o = new he(e, s);
      return o.set({
        label: t("Color"),
        class: "ck-table-properties-form__background"
      }), o.fieldView.bind("value").to(this, "backgroundColor"), o.fieldView.on("input", () => {
        this.backgroundColor = o.fieldView.value;
      }), {
        backgroundRowLabel: i,
        backgroundInput: o
      };
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #widthInput},
     * * {@link #heightInput}.
     */
    _createDimensionFields() {
      const e = this.locale, t = this.t, i = new Fe(e);
      i.text = t("Dimensions");
      const s = new he(e, ze);
      s.set({
        label: t("Width"),
        class: "ck-table-form__dimensions-row__width"
      }), s.fieldView.bind("value").to(this, "width"), s.fieldView.on("input", () => {
        this.width = s.fieldView.element.value;
      });
      const o = new T(e);
      o.setTemplate({
        tag: "span",
        attributes: {
          class: [
            "ck-table-form__dimension-operator"
          ]
        },
        children: [
          { text: "×" }
        ]
      });
      const r = new he(e, ze);
      return r.set({
        label: t("Height"),
        class: "ck-table-form__dimensions-row__height"
      }), r.fieldView.bind("value").to(this, "height"), r.fieldView.on("input", () => {
        this.height = r.fieldView.element.value;
      }), {
        dimensionsLabel: i,
        widthInput: s,
        operatorLabel: o,
        heightInput: r
      };
    }
    /**
     * Creates the following form fields:
     *
     * * {@link #alignmentToolbar}.
     */
    _createAlignmentFields() {
      const e = this.locale, t = this.t, i = new Fe(e);
      i.text = t("Alignment");
      const s = new en(e);
      return s.set({
        isCompact: !0,
        ariaLabel: t("Table alignment toolbar")
      }), Da({
        view: this,
        icons: oV,
        toolbar: s,
        labels: this._alignmentLabels,
        propertyName: "alignment",
        defaultValue: this.options.defaultTableProperties.alignment
      }), {
        alignmentLabel: i,
        alignmentToolbar: s
      };
    }
    /**
     * Creates the following form controls:
     *
     * * {@link #saveButtonView},
     * * {@link #cancelButtonView}.
     */
    _createActionButtons() {
      const e = this.locale, t = this.t, i = new P(e), s = new P(e), o = [
        this.borderWidthInput,
        this.borderColorInput,
        this.backgroundInput,
        this.widthInput,
        this.heightInput
      ];
      return i.set({
        label: t("Save"),
        icon: x.check,
        class: "ck-button-save",
        type: "submit",
        withText: !0
      }), i.bind("isEnabled").toMany(o, "errorText", (...r) => r.every((a) => !a)), s.set({
        label: t("Cancel"),
        icon: x.cancel,
        class: "ck-button-cancel",
        withText: !0
      }), s.delegate("execute").to(this, "cancel"), {
        saveButtonView: i,
        cancelButtonView: s
      };
    }
    /**
     * Provides localized labels for {@link #alignmentToolbar} buttons.
     */
    get _alignmentLabels() {
      const e = this.locale, t = this.t, i = t("Align table to the left"), s = t("Center table"), o = t("Align table to the right");
      return e.uiLanguageDirection === "rtl" ? { right: o, center: s, left: i } : { left: i, center: s, right: o };
    }
  }
  function io(n) {
    return n !== "none";
  }
  const aV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>';
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const lV = 500, Bh = {
    borderStyle: "tableBorderStyle",
    borderColor: "tableBorderColor",
    borderWidth: "tableBorderWidth",
    backgroundColor: "tableBackgroundColor",
    width: "tableWidth",
    height: "tableHeight",
    alignment: "tableAlignment"
  };
  class cV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [$t];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TablePropertiesUI";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.view = null, e.config.define("table.tableProperties", {
        borderColors: Mo,
        backgroundColors: Mo
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t;
      this._defaultTableProperties = Es(e.config.get("table.tableProperties.defaultProperties"), {
        includeAlignmentProperty: !0
      }), this._balloon = e.plugins.get($t), e.ui.componentFactory.add("tableProperties", (i) => {
        const s = new P(i);
        s.set({
          label: t("Table properties"),
          icon: aV,
          tooltip: !0
        }), this.listenTo(s, "execute", () => this._showView());
        const o = Object.values(Bh).map((r) => e.commands.get(r));
        return s.bind("isEnabled").toMany(o, "isEnabled", (...r) => r.some((a) => a)), s;
      });
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.view && this.view.destroy();
    }
    /**
     * Creates the {@link module:table/tableproperties/ui/tablepropertiesview~TablePropertiesView} instance.
     *
     * @returns The table properties form view instance.
     */
    _createPropertiesView() {
      const e = this.editor, t = e.config.get("table.tableProperties"), i = ss(t.borderColors), s = ns(e.locale, i), o = ss(t.backgroundColors), r = ns(e.locale, o), a = t.colorPicker !== !1, l = new rV(e.locale, {
        borderColors: s,
        backgroundColors: r,
        defaultTableProperties: this._defaultTableProperties,
        colorPickerConfig: a ? t.colorPicker || {} : !1
      }), c = e.t;
      l.render(), this.listenTo(l, "submit", () => {
        this._hideView();
      }), this.listenTo(l, "cancel", () => {
        this._undoStepBatch.operations.length && e.execute("undo", this._undoStepBatch), this._hideView();
      }), l.keystrokes.set("Esc", (h, f) => {
        this._hideView(), f();
      }), rn({
        emitter: l,
        activator: () => this._isViewInBalloon,
        contextElements: [this._balloon.view.element],
        callback: () => this._hideView()
      });
      const u = Gp(c), d = jp(c);
      return l.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle")), l.on("change:borderColor", this._getValidatedPropertyChangeCallback({
        viewField: l.borderColorInput,
        commandName: "tableBorderColor",
        errorText: u,
        validator: Vo
      })), l.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
        viewField: l.borderWidthInput,
        commandName: "tableBorderWidth",
        errorText: d,
        validator: Kp
      })), l.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
        viewField: l.backgroundInput,
        commandName: "tableBackgroundColor",
        errorText: u,
        validator: Vo
      })), l.on("change:width", this._getValidatedPropertyChangeCallback({
        viewField: l.widthInput,
        commandName: "tableWidth",
        errorText: d,
        validator: Wn
      })), l.on("change:height", this._getValidatedPropertyChangeCallback({
        viewField: l.heightInput,
        commandName: "tableHeight",
        errorText: d,
        validator: Wn
      })), l.on("change:alignment", this._getPropertyChangeCallback("tableAlignment")), l;
    }
    /**
     * In this method the "editor data -> UI" binding is happening.
     *
     * When executed, this method obtains selected table property values from various table commands
     * and passes them to the {@link #view}.
     *
     * This way, the UI stays up–to–date with the editor data.
     */
    _fillViewFormFromCommandValues() {
      const e = this.editor.commands, t = e.get("tableBorderStyle");
      Object.entries(Bh).map(([i, s]) => {
        const o = i, r = this._defaultTableProperties[o] || "";
        return [o, e.get(s).value || r];
      }).forEach(([i, s]) => {
        (i === "borderColor" || i === "borderWidth") && t.value === "none" || this.view.set(i, s);
      }), this._isReady = !0;
    }
    /**
     * Shows the {@link #view} in the {@link #_balloon}.
     *
     * **Note**: Each time a view is shown, the new {@link #_undoStepBatch} is created that contains
     * all changes made to the document when the view is visible, allowing a single undo step
     * for all of them.
     */
    _showView() {
      const e = this.editor;
      this.view || (this.view = this._createPropertiesView()), this.listenTo(e.ui, "update", () => {
        this._updateView();
      }), this._fillViewFormFromCommandValues(), this._balloon.add({
        view: this.view,
        position: Yp(e)
      }), this._undoStepBatch = e.model.createBatch(), this.view.focus();
    }
    /**
     * Removes the {@link #view} from the {@link #_balloon}.
     */
    _hideView() {
      const e = this.editor;
      this.stopListening(e.ui, "update"), this._isReady = !1, this.view.saveButtonView.focus(), this._balloon.remove(this.view), this.editor.editing.view.focus();
    }
    /**
     * Repositions the {@link #_balloon} or hides the {@link #view} if a table is no longer selected.
     */
    _updateView() {
      const e = this.editor, t = e.editing.view.document;
      $p(t.selection) ? this._isViewVisible && Xp(e, "table") : this._hideView();
    }
    /**
     * Returns `true` when the {@link #view} is the visible in the {@link #_balloon}.
     */
    get _isViewVisible() {
      return !!this.view && this._balloon.visibleView === this.view;
    }
    /**
     * Returns `true` when the {@link #view} is in the {@link #_balloon}.
     */
    get _isViewInBalloon() {
      return !!this.view && this._balloon.hasView(this.view);
    }
    /**
     * Creates a callback that when executed upon {@link #view view's} property change
     * executes a related editor command with the new property value.
     *
     * If new value will be set to the default value, the command will not be executed.
     *
     * @param commandName The command that will be executed.
     */
    _getPropertyChangeCallback(e) {
      return (t, i, s) => {
        this._isReady && this.editor.execute(e, {
          value: s,
          batch: this._undoStepBatch
        });
      };
    }
    /**
     * Creates a callback that when executed upon {@link #view view's} property change:
     * * executes a related editor command with the new property value if the value is valid,
     * * or sets the error text next to the invalid field, if the value did not pass the validation.
     */
    _getValidatedPropertyChangeCallback(e) {
      const { commandName: t, viewField: i, validator: s, errorText: o } = e, r = Rt(() => {
        i.errorText = o;
      }, lV);
      return (a, l, c) => {
        r.cancel(), this._isReady && (s(c) ? (this.editor.execute(t, {
          value: c,
          batch: this._undoStepBatch
        }), i.errorText = null) : r());
      };
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class uV extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableProperties";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [tV, cV];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function dV(n) {
    n.document.registerPostFixer((e) => hV(e, n));
  }
  function hV(n, e) {
    const t = e.document.differ.getChanges();
    let i = !1;
    for (const s of t) {
      if (s.type != "insert")
        continue;
      const o = s.position.parent;
      if (o.is("element", "table") || s.name == "table") {
        const r = s.name == "table" ? s.position.nodeAfter : o, a = Array.from(r.getChildren()).filter((c) => c.is("element", "caption")), l = a.shift();
        if (!l)
          continue;
        for (const c of a)
          n.move(n.createRangeIn(c), l, "end"), n.remove(c);
        l.nextSibling && (n.move(n.createRangeOn(l), r, "end"), i = !0), i = !!a.length || i;
      }
    }
    return i;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Oh(n) {
    return !!n && n.is("element", "table");
  }
  function za(n) {
    for (const e of n.getChildren())
      if (e.is("element", "caption"))
        return e;
    return null;
  }
  function fV(n) {
    const e = li(n);
    return e ? za(e) : null;
  }
  function mV(n) {
    const e = n.parent;
    return n.name == "figcaption" && e && e.is("element", "figure") && e.hasClass("table") ? { name: !0 } : n.name == "caption" && e && e.is("element", "table") ? { name: !0 } : null;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class gV extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor, t = li(e.model.document.selection);
      this.isEnabled = !!t, this.isEnabled ? this.value = !!za(t) : this.value = !1;
    }
    /**
     * Executes the command.
     *
     * ```ts
     * editor.execute( 'toggleTableCaption' );
     * ```
     *
     * @param options Options for the executed command.
     * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
     * @fires execute
     */
    execute({ focusCaptionOnShow: e = !1 } = {}) {
      this.editor.model.change((t) => {
        this.value ? this._hideTableCaption(t) : this._showTableCaption(t, e);
      });
    }
    /**
     * Shows the table caption. Also:
     *
     * * it attempts to restore the caption content from the `TableCaptionEditing` caption registry,
     * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
     *
     * @param focusCaptionOnShow Default focus behavior when showing the caption.
     */
    _showTableCaption(e, t) {
      const i = this.editor.model, s = li(i.document.selection), a = this.editor.plugins.get("TableCaptionEditing")._getSavedCaption(s) || e.createElement("caption");
      i.insertContent(a, s, "end"), t && e.setSelection(a, "in");
    }
    /**
     * Hides the caption of a selected table (or an table caption the selection is anchored to).
     *
     * The content of the caption is stored in the `TableCaptionEditing` caption registry to make this
     * a reversible action.
     */
    _hideTableCaption(e) {
      const t = this.editor.model, i = li(t.document.selection), s = this.editor.plugins.get("TableCaptionEditing"), o = za(i);
      s._saveCaption(i, o), t.deleteContent(e.createSelection(o, "on"));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class pV extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableCaptionEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.schema, i = e.editing.view, s = e.t;
      t.isRegistered("caption") ? t.extend("caption", {
        allowIn: "table"
      }) : t.register("caption", {
        allowIn: "table",
        allowContentOf: "$block",
        isLimit: !0
      }), e.commands.add("toggleTableCaption", new gV(this.editor)), e.conversion.for("upcast").elementToElement({
        view: mV,
        model: "caption"
      }), e.conversion.for("dataDowncast").elementToElement({
        model: "caption",
        view: (o, { writer: r }) => Oh(o.parent) ? r.createContainerElement("figcaption") : null
      }), e.conversion.for("editingDowncast").elementToElement({
        model: "caption",
        view: (o, { writer: r }) => {
          if (!Oh(o.parent))
            return null;
          const a = r.createEditableElement("figcaption");
          return r.setCustomProperty("tableCaption", !0, a), a.placeholder = s("Enter table caption"), ml({
            view: i,
            element: a,
            keepOnFocus: !0
          }), Ml(a, r);
        }
      }), dV(e.model);
    }
    /**
     * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
     * of a table model element.
     *
     * See {@link #_saveCaption}.
     *
     * @internal
     * @param tableModelElement The model element the caption should be returned for.
     * @returns The model caption element or `null` if there is none.
     */
    _getSavedCaption(e) {
      const t = this._savedCaptionsMap.get(e);
      return t ? W.fromJSON(t) : null;
    }
    /**
     * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
     * a table element to allow restoring it in the future.
     *
     * A caption is saved every time it gets hidden. The
     * user should be able to restore it on demand.
     *
     * **Note**: The caption cannot be stored in the table model element attribute because,
     * for instance, when the model state propagates to collaborators, the attribute would get
     * lost (mainly because it does not convert to anything when the caption is hidden) and
     * the states of collaborators' models would de-synchronize causing numerous issues.
     *
     * See {@link #_getSavedCaption}.
     *
     * @internal
     * @param tableModelElement The model element the caption is saved for.
     * @param caption The caption model element to be saved.
     */
    _saveCaption(e, t) {
      this._savedCaptionsMap.set(e, t.toJSON());
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class wV extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableCaptionUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.editing.view, i = e.t;
      e.ui.componentFactory.add("toggleTableCaption", (s) => {
        const o = e.commands.get("toggleTableCaption"), r = new P(s);
        return r.set({
          icon: x.caption,
          tooltip: !0,
          isToggleable: !0
        }), r.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), r.bind("label").to(o, "value", (a) => i(a ? "Toggle caption off" : "Toggle caption on")), this.listenTo(r, "execute", () => {
          if (e.execute("toggleTableCaption", { focusCaptionOnShow: !0 }), o.value) {
            const a = fV(e.model.document.selection), l = e.editing.mapper.toViewElement(a);
            if (!l)
              return;
            t.scrollToTheSelection(), t.change((c) => {
              c.addClass("table__caption_highlighted", l);
            });
          }
          e.editing.view.focus();
        }), r;
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class bV extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableCaption";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [pV, wV];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class _V extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      this.isEnabled = !0;
    }
    /**
     * Updated the `tableWidth` attribute of the table and the `columnWidth` attribute of the columns of that table.
     */
    execute(e = {}) {
      const { model: t, plugins: i } = this.editor;
      let { table: s = t.document.selection.getSelectedElement(), columnWidths: o, tableWidth: r } = e;
      o && (o = Array.isArray(o) ? o : o.split(",")), t.change((a) => {
        r ? a.setAttribute("tableWidth", r, s) : a.removeAttribute("tableWidth", s);
        const l = i.get("TableColumnResizeEditing").getColumnGroupElement(s);
        if (!o && !l)
          return;
        if (!o)
          return a.remove(l);
        const c = Gl(o);
        if (l)
          Array.from(l.getChildren()).forEach((u, d) => a.setAttribute("columnWidth", c[d], u));
        else {
          const u = a.createElement("tableColumnGroup");
          c.forEach((d) => a.appendElement("tableColumn", { columnWidth: d }, u)), a.append(u, s);
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function vV(n) {
    return (e) => e.on("element:colgroup", (t, i, s) => {
      const o = i.modelCursor.findAncestor("table"), r = Cs(o);
      if (!r)
        return;
      const a = ks(r), l = n.getColumns(o);
      let c = F7(r, s.writer);
      c = Array.from({ length: l }, (u, d) => c[d] || "auto"), (c.length != a.length || c.includes("auto")) && Fp(a, r, Gl(c), s.writer);
    }, { priority: "low" });
  }
  function yV() {
    return (n) => n.on("insert:table", (e, t, i) => {
      const s = i.writer, o = t.item, r = i.mapper.toViewElement(o), a = r.is("element", "table") ? r : Array.from(r.getChildren()).find((c) => c.is("element", "table"));
      Cs(o) ? s.addClass("ck-table-resized", a) : s.removeClass("ck-table-resized", a);
    }, { priority: "low" });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class CV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ts, pe];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableColumnResizeEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._isResizingActive = !1, this.set("_isResizingAllowed", !0), this._resizingData = null, this._domEmitter = new (Me())(), this._tableUtilsPlugin = e.plugins.get("TableUtils"), this.on("change:_isResizingAllowed", (t, i, s) => {
        const o = s ? "removeClass" : "addClass";
        e.editing.view.change((r) => {
          for (const a of e.editing.view.document.roots)
            r[o]("ck-column-resize_disabled", e.editing.view.document.getRoot(a.rootName));
        });
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      this._extendSchema(), this._registerPostFixer(), this._registerConverters(), this._registerResizingListeners(), this._registerResizerInserter();
      const e = this.editor, t = e.plugins.get("TableColumnResize");
      e.plugins.get("TableEditing").registerAdditionalSlot({
        filter: (o) => o.is("element", "tableColumnGroup"),
        positionOffset: 0
      });
      const s = new _V(e);
      e.commands.add("resizeTableWidth", s), e.commands.add("resizeColumnWidths", s), this.bind("_isResizingAllowed").to(e, "isReadOnly", t, "isEnabled", s, "isEnabled", (o, r, a) => !o && r && a);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      this._domEmitter.stopListening(), super.destroy();
    }
    /**
     * Returns a 'tableColumnGroup' element from the 'table'.
     *
     * @param element A 'table' or 'tableColumnGroup' element.
     * @returns A 'tableColumnGroup' element.
     */
    getColumnGroupElement(e) {
      return Cs(e);
    }
    /**
     * Returns an array of 'tableColumn' elements.
     *
     * @param element A 'table' or 'tableColumnGroup' element.
     * @returns An array of 'tableColumn' elements.
     */
    getTableColumnElements(e) {
      return ks(e);
    }
    /**
     * Returns an array of table column widths.
     *
     * @param element A 'table' or 'tableColumnGroup' element.
     * @returns An array of table column widths.
     */
    getTableColumnsWidths(e) {
      return D7(e);
    }
    /**
     * Registers new attributes for a table model element.
     */
    _extendSchema() {
      this.editor.model.schema.extend("table", {
        allowAttributes: ["tableWidth"]
      }), this.editor.model.schema.register("tableColumnGroup", {
        allowIn: "table",
        isLimit: !0
      }), this.editor.model.schema.register("tableColumn", {
        allowIn: "tableColumnGroup",
        allowAttributes: ["columnWidth", "colSpan"],
        isLimit: !0
      });
    }
    /**
     * Registers table column resize post-fixer.
     *
     * It checks if the change from the differ concerns a table-related element or attribute. For detected changes it:
     *  * Adjusts the `columnWidths` attribute to guarantee that the sum of the widths from all columns is 100%.
     *  * Checks if the `columnWidths` attribute gets updated accordingly after columns have been added or removed.
     */
    _registerPostFixer() {
      const t = this.editor.model;
      t.document.registerPostFixer((o) => {
        let r = !1;
        for (const a of R7(t)) {
          const l = this.getColumnGroupElement(a), c = this.getTableColumnElements(l), u = this.getTableColumnsWidths(l);
          let d = Gl(u);
          d = i(d, a, this), !_o(u, d) && (Fp(c, l, d, o), r = !0);
        }
        return r;
      });
      function i(o, r, a) {
        const l = a._tableUtilsPlugin.getColumns(r);
        if (l - o.length === 0)
          return o;
        const u = o.map((h) => Number(h.replace("%", ""))), d = s(a.editor.model.document.differ, r);
        for (const h of d) {
          const f = l - u.length;
          if (f === 0)
            continue;
          const m = f > 0, p = a._tableUtilsPlugin.getCellLocation(h).column;
          if (m) {
            const b = L7(r, a.editor), v = B7(f, b);
            u.splice(p, 0, ...v);
          } else {
            const b = u.splice(p, Math.abs(f));
            u[p] += ds(b);
          }
        }
        return u.map((h) => h + "%");
      }
      function s(o, r) {
        const a = /* @__PURE__ */ new Set();
        for (const l of o.getChanges())
          if (l.type == "insert" && l.position.nodeAfter && l.position.nodeAfter.name == "tableCell" && l.position.nodeAfter.getAncestors().includes(r))
            a.add(l.position.nodeAfter);
          else if (l.type == "remove") {
            const c = l.position.nodeBefore || l.position.nodeAfter;
            c.name == "tableCell" && c.getAncestors().includes(r) && a.add(c);
          }
        return a;
      }
    }
    /**
     * Registers table column resize converters.
     */
    _registerConverters() {
      const t = this.editor.conversion;
      t.for("upcast").attributeToAttribute({
        view: {
          name: "figure",
          key: "style",
          value: {
            width: /[\s\S]+/
          }
        },
        model: {
          name: "table",
          key: "tableWidth",
          value: (i) => i.getStyle("width")
        }
      }), t.for("downcast").attributeToAttribute({
        model: {
          name: "table",
          key: "tableWidth"
        },
        view: (i) => ({
          name: "figure",
          key: "style",
          value: {
            width: i
          }
        })
      }), t.elementToElement({ model: "tableColumnGroup", view: "colgroup" }), t.elementToElement({ model: "tableColumn", view: "col" }), t.for("downcast").add(yV()), t.for("upcast").add(vV(this._tableUtilsPlugin)), t.for("upcast").attributeToAttribute({
        view: {
          name: "col",
          styles: {
            width: /.*/
          }
        },
        model: {
          key: "columnWidth",
          value: (i) => {
            const s = i.getStyle("width");
            return !s || !s.endsWith("%") && !s.endsWith("pt") ? "auto" : s;
          }
        }
      }), t.for("upcast").attributeToAttribute({
        view: {
          name: "col",
          key: "span"
        },
        model: "colSpan"
      }), t.for("downcast").attributeToAttribute({
        model: {
          name: "tableColumn",
          key: "columnWidth"
        },
        view: (i) => ({ key: "style", value: { width: i } })
      });
    }
    /**
     * Registers listeners to handle resizing process.
     */
    _registerResizingListeners() {
      const e = this.editor.editing.view;
      e.addObserver(Hp), e.document.on("mousedown", this._onMouseDownHandler.bind(this), { priority: "high" }), this._domEmitter.listenTo(E.window.document, "mousemove", Zi(this._onMouseMoveHandler.bind(this), 50)), this._domEmitter.listenTo(E.window.document, "mouseup", this._onMouseUpHandler.bind(this));
    }
    /**
     * Handles the `mousedown` event on column resizer element:
     *  * calculates the initial column pixel widths,
     *  * inserts the `<colgroup>` element if it is not present in the `<table>`,
     *  * puts the necessary data in the temporary storage,
     *  * applies the attributes to the `<table>` view element.
     *
     * @param eventInfo An object containing information about the fired event.
     * @param domEventData The data related to the DOM event.
     */
    _onMouseDownHandler(e, t) {
      const i = t.target;
      if (!i.hasClass("ck-table-column-resizer") || !this._isResizingAllowed)
        return;
      const s = this.editor, o = s.editing.mapper.toModelElement(i.findAncestor("figure"));
      if (!s.model.canEditAt(o))
        return;
      t.preventDefault(), e.stop();
      const r = c(o, this._tableUtilsPlugin, s), a = i.findAncestor("table"), l = s.editing.view;
      Array.from(a.getChildren()).find((h) => h.is("element", "colgroup")) || l.change((h) => {
        u(h, r, a);
      }), this._isResizingActive = !0, this._resizingData = this._getResizingData(t, r), l.change((h) => d(h, a, this._resizingData));
      function c(h, f, m) {
        const p = Array(f.getColumns(h)), b = new q(h);
        for (const v of b) {
          const y = m.editing.mapper.toViewElement(v.cell), L = m.editing.view.domConverter.mapViewToDom(y), M = N7(L);
          (!p[v.column] || M < p[v.column]) && (p[v.column] = Ie(M));
        }
        return p;
      }
      function u(h, f, m) {
        const p = h.createContainerElement("colgroup");
        for (let b = 0; b < f.length; b++) {
          const v = h.createEmptyElement("col"), y = `${Ie(f[b] / ds(f) * 100)}%`;
          h.setStyle("width", y, v), h.insert(h.createPositionAt(p, "end"), v);
        }
        h.insert(h.createPositionAt(m, 0), p);
      }
      function d(h, f, m) {
        const p = m.widths.viewFigureWidth / m.widths.viewFigureParentWidth;
        h.addClass("ck-table-resized", f), h.addClass("ck-table-column-resizer__active", m.elements.viewResizer), h.setStyle("width", `${Ie(p * 100)}%`, f.findAncestor("figure"));
      }
    }
    /**
     * Handles the `mousemove` event.
     *  * If resizing process is not in progress, it does nothing.
     *  * If resizing is active but not allowed, it stops the resizing process instantly calling the `mousedown` event handler.
     *  * Otherwise it dynamically updates the widths of the resized columns.
     *
     * @param eventInfo An object containing information about the fired event.
     * @param mouseEventData The native DOM event.
     */
    _onMouseMoveHandler(e, t) {
      if (!this._isResizingActive)
        return;
      if (!this._isResizingAllowed) {
        this._onMouseUpHandler();
        return;
      }
      const { columnPosition: i, flags: { isRightEdge: s, isTableCentered: o, isLtrContent: r }, elements: { viewFigure: a, viewLeftColumn: l, viewRightColumn: c }, widths: { viewFigureParentWidth: u, tableWidth: d, leftColumnWidth: h, rightColumnWidth: f } } = this._resizingData, m = -h + Va, p = s ? u - d : f - Va, b = (r ? 1 : -1) * (s && o ? 2 : 1), v = M7((t.clientX - i) * b, Math.min(m, 0), Math.max(p, 0));
      v !== 0 && this.editor.editing.view.change((y) => {
        const L = Ie((h + v) * 100 / d);
        if (y.setStyle("width", `${L}%`, l), s) {
          const M = Ie((d + v) * 100 / u);
          y.setStyle("width", `${M}%`, a);
        } else {
          const M = Ie((f - v) * 100 / d);
          y.setStyle("width", `${M}%`, c);
        }
      });
    }
    /**
     * Handles the `mouseup` event.
     *  * If resizing process is not in progress, it does nothing.
     *  * If resizing is active but not allowed, it cancels the resizing process restoring the original widths.
     *  * Otherwise it propagates the changes from view to the model by executing the adequate commands.
     */
    _onMouseUpHandler() {
      if (!this._isResizingActive)
        return;
      const { viewResizer: e, modelTable: t, viewFigure: i, viewColgroup: s } = this._resizingData.elements, o = this.editor, r = o.editing.view, a = this.getColumnGroupElement(t), l = Array.from(s.getChildren()).filter((p) => p.is("view:element")), c = a ? this.getTableColumnsWidths(a) : null, u = l.map((p) => p.getStyle("width")), d = !_o(c, u), h = t.getAttribute("tableWidth"), f = i.getStyle("width"), m = h !== f;
      (d || m) && (this._isResizingAllowed ? o.execute("resizeTableWidth", {
        table: t,
        tableWidth: `${Ie(f)}%`,
        columnWidths: u
      }) : r.change((p) => {
        if (c)
          for (const b of l)
            p.setStyle("width", c.shift(), b);
        else
          p.remove(s);
        m && (h ? p.setStyle("width", h, i) : p.removeStyle("width", i)), !c && !h && p.removeClass("ck-table-resized", [...i.getChildren()].find((b) => b.name === "table"));
      })), r.change((p) => {
        p.removeClass("ck-table-column-resizer__active", e);
      }), this._isResizingActive = !1, this._resizingData = null;
    }
    /**
     * Retrieves and returns required data needed for the resizing process.
     *
     * @param domEventData The data of the `mousedown` event.
     * @param columnWidths The current widths of the columns.
     * @returns The data needed for the resizing process.
     */
    _getResizingData(e, t) {
      const i = this.editor, s = e.domEvent.clientX, o = e.target, r = o.findAncestor("td") || o.findAncestor("th"), a = i.editing.mapper.toModelElement(r), l = a.findAncestor("table"), c = V7(a, this._tableUtilsPlugin).rightEdge, u = this._tableUtilsPlugin.getColumns(l) - 1, d = c === u, h = !l.hasAttribute("tableAlignment"), f = i.locale.contentLanguageDirection !== "rtl", m = r.findAncestor("table"), p = m.findAncestor("figure"), b = [...m.getChildren()].find((S) => S.is("element", "colgroup")), v = b.getChild(c), y = d ? void 0 : b.getChild(c + 1), L = Ma(i.editing.view.domConverter.mapViewToDom(p.parent)), M = Ma(i.editing.view.domConverter.mapViewToDom(p)), D = Dp(l, i), A = t[c], R = d ? void 0 : t[c + 1];
      return {
        columnPosition: s,
        flags: {
          isRightEdge: d,
          isTableCentered: h,
          isLtrContent: f
        },
        elements: {
          viewResizer: o,
          modelTable: l,
          viewFigure: p,
          viewColgroup: b,
          viewLeftColumn: v,
          viewRightColumn: y
        },
        widths: {
          viewFigureParentWidth: L,
          viewFigureWidth: M,
          tableWidth: D,
          leftColumnWidth: A,
          rightColumnWidth: R
        }
      };
    }
    /**
     * Registers a listener ensuring that each resizable cell have a resizer handle.
     */
    _registerResizerInserter() {
      this.editor.conversion.for("editingDowncast").add((e) => {
        e.on("insert:tableCell", (t, i, s) => {
          const o = i.item, r = s.mapper.toViewElement(o), a = s.writer;
          a.insert(a.createPositionAt(r, "end"), a.createUIElement("div", { class: "ck-table-column-resizer" }));
        }, { priority: "lowest" });
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class kV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [CV, tw];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "TableColumnResize";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const TV = { autoRefresh: !0 }, Nh = 36e5;
  class Zl extends $() {
    /**
     * Creates `Token` instance.
     * Method `init` should be called after using the constructor or use `create` method instead.
     *
     * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
     * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
     */
    constructor(e, t = {}) {
      if (super(), !e)
        throw new g("token-missing-token-url", this);
      t.initValue && this._validateTokenValue(t.initValue), this.set("value", t.initValue), typeof e == "function" ? this._refresh = e : this._refresh = () => EV(e), this._options = { ...TV, ...t };
    }
    /**
     * Initializes the token.
     */
    init() {
      return new Promise((e, t) => {
        if (!this.value) {
          this.refreshToken().then(e).catch(t);
          return;
        }
        this._options.autoRefresh && this._registerRefreshTokenTimeout(), e(this);
      });
    }
    /**
     * Refresh token method. Useful in a method form as it can be override in tests.
     */
    refreshToken() {
      return this._refresh().then((e) => (this._validateTokenValue(e), this.set("value", e), this._options.autoRefresh && this._registerRefreshTokenTimeout(), this));
    }
    /**
     * Destroys token instance. Stops refreshing.
     */
    destroy() {
      clearTimeout(this._tokenRefreshTimeout);
    }
    /**
     * Checks whether the provided token follows the JSON Web Tokens (JWT) format.
     *
     * @param tokenValue The token to validate.
     */
    _validateTokenValue(e) {
      const t = typeof e == "string", i = !/^".*"$/.test(e), s = t && e.split(".").length === 3;
      if (!(i && s))
        throw new g("token-not-in-jwt-format", this);
    }
    /**
     * Registers a refresh token timeout for the time taken from token.
     */
    _registerRefreshTokenTimeout() {
      const e = this._getTokenRefreshTimeoutTime();
      clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
        this.refreshToken();
      }, e);
    }
    /**
     * Returns token refresh timeout time calculated from expire time in the token payload.
     *
     * If the token parse fails or the token payload doesn't contain, the default DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME is returned.
     */
    _getTokenRefreshTimeoutTime() {
      try {
        const [, e] = this.value.split("."), { exp: t } = JSON.parse(atob(e));
        return t ? Math.floor((t * 1e3 - Date.now()) / 2) : Nh;
      } catch (e) {
        return Nh;
      }
    }
    /**
     * Creates a initialized {@link module:cloud-services/token/token~Token} instance.
     *
     * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
     * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
     */
    static create(e, t = {}) {
      return new Zl(e, t).init();
    }
  }
  function EV(n) {
    return new Promise((e, t) => {
      const i = new XMLHttpRequest();
      i.open("GET", n), i.addEventListener("load", () => {
        const s = i.status, o = i.response;
        return s < 200 || s > 299 ? t(new g("token-cannot-download-new-token", null)) : e(o);
      }), i.addEventListener("error", () => t(new Error("Network Error"))), i.addEventListener("abort", () => t(new Error("Abort"))), i.send();
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const Ua = /^data:(\S*?);base64,/;
  class AV extends G() {
    /**
     * Creates `FileUploader` instance.
     *
     * @param fileOrData A blob object or a data string encoded with Base64.
     * @param token Token used for authentication.
     * @param apiAddress API address.
     */
    constructor(e, t, i) {
      if (super(), !e)
        throw new g("fileuploader-missing-file", null);
      if (!t)
        throw new g("fileuploader-missing-token", null);
      if (!i)
        throw new g("fileuploader-missing-api-address", null);
      this.file = SV(e) ? xV(e) : e, this._token = t, this._apiAddress = i;
    }
    /**
     * Registers callback on `progress` event.
     */
    onProgress(e) {
      return this.on("progress", (t, i) => e(i)), this;
    }
    /**
     * Registers callback on `error` event. Event is called once when error occurs.
     */
    onError(e) {
      return this.once("error", (t, i) => e(i)), this;
    }
    /**
     * Aborts upload process.
     */
    abort() {
      this.xhr.abort();
    }
    /**
     * Sends XHR request to API.
     */
    send() {
      return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
    }
    /**
     * Prepares XHR request.
     */
    _prepareRequest() {
      const e = new XMLHttpRequest();
      e.open("POST", this._apiAddress), e.setRequestHeader("Authorization", this._token.value), e.responseType = "json", this.xhr = e;
    }
    /**
     * Attaches listeners to the XHR.
     */
    _attachXHRListeners() {
      const e = this.xhr, t = (i) => () => this.fire("error", i);
      e.addEventListener("error", t("Network Error")), e.addEventListener("abort", t("Abort"));
      /* istanbul ignore else -- @preserve */
      e.upload && e.upload.addEventListener("progress", (i) => {
        i.lengthComputable && this.fire("progress", {
          total: i.total,
          uploaded: i.loaded
        });
      }), e.addEventListener("load", () => {
        const i = e.status, s = e.response;
        if (i < 200 || i > 299)
          return this.fire("error", s.message || s.error);
      });
    }
    /**
     * Sends XHR request.
     */
    _sendRequest() {
      const e = new FormData(), t = this.xhr;
      return e.append("file", this.file), new Promise((i, s) => {
        t.addEventListener("load", () => {
          const o = t.status, r = t.response;
          return o < 200 || o > 299 ? r.message ? s(new g("fileuploader-uploading-data-failed", this, { message: r.message })) : s(r.error) : i(r);
        }), t.addEventListener("error", () => s(new Error("Network Error"))), t.addEventListener("abort", () => s(new Error("Abort"))), t.send(e);
      });
    }
  }
  function xV(n, e = 512) {
    try {
      const t = n.match(Ua)[1], i = atob(n.replace(Ua, "")), s = [];
      for (let o = 0; o < i.length; o += e) {
        const r = i.slice(o, o + e), a = new Array(r.length);
        for (let l = 0; l < r.length; l++)
          a[l] = r.charCodeAt(l);
        s.push(new Uint8Array(a));
      }
      return new Blob(s, { type: t });
    } catch (t) {
      throw new g("fileuploader-decoding-image-data-error", null);
    }
  }
  function SV(n) {
    if (typeof n != "string")
      return !1;
    const e = n.match(Ua);
    return !!(e && e.length);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class IV {
    /**
     * Creates `UploadGateway` instance.
     *
     * @param token Token used for authentication.
     * @param apiAddress API address.
     */
    constructor(e, t) {
      if (!e)
        throw new g("uploadgateway-missing-token", null);
      if (!t)
        throw new g("uploadgateway-missing-api-address", null);
      this._token = e, this._apiAddress = t;
    }
    /**
     * Creates a {@link module:cloud-services/uploadgateway/fileuploader~FileUploader} instance that wraps
     * file upload process. The file is being sent at a time when the
     * {@link module:cloud-services/uploadgateway/fileuploader~FileUploader#send} method is called.
     *
     * ```ts
     * const token = await Token.create( 'https://token-endpoint' );
     * new UploadGateway( token, 'https://example.org' )
     * 	.upload( 'FILE' )
     * 	.onProgress( ( data ) => console.log( data ) )
     * 	.send()
     * 	.then( ( response ) => console.log( response ) );
     * ```
     *
     * @param {Blob|String} fileOrData A blob object or a data string encoded with Base64.
     * @returns {module:cloud-services/uploadgateway/fileuploader~FileUploader} Returns `FileUploader` instance.
     */
    upload(e) {
      return new AV(e, this._token, this._apiAddress);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class PV extends Zo {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "CloudServicesCore";
    }
    /**
     * Creates the {@link module:cloud-services/token/token~Token} instance.
     *
     * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
     * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
     * @param options.initValue Initial value of the token.
     * @param options.autoRefresh Specifies whether to start the refresh automatically.
     */
    createToken(e, t) {
      return new Zl(e, t);
    }
    /**
     * Creates the {@link module:cloud-services/uploadgateway/uploadgateway~UploadGateway} instance.
     *
     * @param token Token used for authentication.
     * @param apiAddress API address.
     */
    createUploadGateway(e, t) {
      return new IV(e, t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class RV extends Zo {
    constructor() {
      super(...arguments), this.token = null, this._tokens = /* @__PURE__ */ new Map();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "CloudServices";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [PV];
    }
    /**
     * @inheritDoc
     */
    async init() {
      const t = this.context.config.get("cloudServices") || {};
      for (const [s, o] of Object.entries(t))
        this[s] = o;
      if (!this.tokenUrl) {
        this.token = null;
        return;
      }
      const i = this.context.plugins.get("CloudServicesCore");
      this.token = await i.createToken(this.tokenUrl).init(), this._tokens.set(this.tokenUrl, this.token);
    }
    /**
     * Registers an additional authentication token URL for CKEditor Cloud Services or a callback to the token value promise. See the
     * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} for more details.
     *
     * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
     */
    async registerTokenUrl(e) {
      if (this._tokens.has(e))
        return this.getTokenFor(e);
      const i = await this.context.plugins.get("CloudServicesCore").createToken(e).init();
      return this._tokens.set(e, i), i;
    }
    /**
     * Returns an authentication token provider previously registered by {@link #registerTokenUrl}.
     *
     * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
     */
    getTokenFor(e) {
      const t = this._tokens.get(e);
      if (!t)
        throw new g("cloudservices-token-not-registered", this);
      return t;
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy();
      for (const e of this._tokens.values())
        e.destroy();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ot(n, e, t, i) {
    let s, o = null;
    typeof i == "function" ? s = i : (o = n.commands.get(i), s = () => {
      n.execute(i);
    }), n.model.document.on("change:data", (r, a) => {
      if (o && !o.isEnabled || !e.isEnabled)
        return;
      const l = me(n.model.document.selection.getRanges());
      if (!l.isCollapsed || a.isUndo || !a.isLocal)
        return;
      const c = Array.from(n.model.document.differ.getChanges()), u = c[0];
      if (c.length != 1 || u.type !== "insert" || u.name != "$text" || u.length != 1)
        return;
      const d = u.position.parent;
      if (d.is("element", "codeBlock") || d.is("element", "listItem") && typeof i != "function" && !["numberedList", "bulletedList", "todoList"].includes(i) || o && o.value === !0)
        return;
      const h = d.getChild(0), f = n.model.createRangeOn(h);
      if (!f.containsRange(l) && !l.end.isEqual(f.end))
        return;
      const m = t.exec(h.data.substr(0, l.end.offset));
      m && n.model.enqueueChange((p) => {
        const b = p.createPositionAt(d, 0), v = p.createPositionAt(d, m[0].length), y = new Pe(b, v);
        if (s({ match: m }) !== !1) {
          p.remove(y);
          const M = n.model.document.selection.getFirstRange(), D = p.createRangeIn(d);
          d.isEmpty && !D.isEqual(M) && !D.containsRange(M, !0) && p.remove(d);
        }
        y.detach(), n.model.enqueueChange(() => {
          n.plugins.get("Delete").requestUndoOnBackspace();
        });
      });
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function Ni(n, e, t, i) {
    let s, o;
    t instanceof RegExp ? s = t : o = t, o = o || ((r) => {
      let a;
      const l = [], c = [];
      for (; (a = s.exec(r)) !== null && !(a && a.length < 4); ) {
        let { index: u, "1": d, "2": h, "3": f } = a;
        const m = d + h + f;
        u += a[0].length - m.length;
        const p = [
          u,
          u + d.length
        ], b = [
          u + d.length + h.length,
          u + d.length + h.length + f.length
        ];
        l.push(p), l.push(b), c.push([u + d.length, u + d.length + h.length]);
      }
      return {
        remove: l,
        format: c
      };
    }), n.model.document.on("change:data", (r, a) => {
      if (a.isUndo || !a.isLocal || !e.isEnabled)
        return;
      const l = n.model, c = l.document.selection;
      if (!c.isCollapsed)
        return;
      const u = Array.from(l.document.differ.getChanges()), d = u[0];
      if (u.length != 1 || d.type !== "insert" || d.name != "$text" || d.length != 1)
        return;
      const h = c.focus, f = h.parent, { text: m, range: p } = LV(l.createRange(l.createPositionAt(f, 0), h), l), b = o(m), v = Dh(p.start, b.format, l), y = Dh(p.start, b.remove, l);
      v.length && y.length && l.enqueueChange((L) => {
        if (i(L, v) !== !1) {
          for (const D of y.reverse())
            L.remove(D);
          l.enqueueChange(() => {
            n.plugins.get("Delete").requestUndoOnBackspace();
          });
        }
      });
    });
  }
  function Dh(n, e, t) {
    return e.filter((i) => i[0] !== void 0 && i[1] !== void 0).map((i) => t.createRange(n.getShiftedBy(i[0]), n.getShiftedBy(i[1])));
  }
  function LV(n, e) {
    let t = n.start;
    return { text: Array.from(n.getItems()).reduce((s, o) => !(o.is("$text") || o.is("$textProxy")) || o.getAttribute("code") ? (t = e.createPositionAfter(o), "") : s + o.data, ""), range: e.createRange(t, n.end) };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class VV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [bt];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Autoformat";
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      const e = this.editor, t = this.editor.t;
      this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats(), e.accessibility.addKeystrokeInfos({
        keystrokes: [
          {
            label: t("Revert autoformatting action"),
            keystroke: "Backspace"
          }
        ]
      });
    }
    /**
     * Adds autoformatting related to the {@link module:list/list~List}.
     *
     * When typed:
     * - `* ` or `- ` &ndash; A paragraph will be changed into a bulleted list.
     * - `1. ` or `1) ` &ndash; A paragraph will be changed into a numbered list ("1" can be any digit or a list of digits).
     * - `[] ` or `[ ] ` &ndash; A paragraph will be changed into a to-do list.
     * - `[x] ` or `[ x ] ` &ndash; A paragraph will be changed into a checked to-do list.
     */
    _addListAutoformats() {
      const e = this.editor.commands;
      e.get("bulletedList") && Ot(this.editor, this, /^[*-]\s$/, "bulletedList"), e.get("numberedList") && Ot(this.editor, this, /^1[.|)]\s$/, "numberedList"), e.get("todoList") && Ot(this.editor, this, /^\[\s?\]\s$/, "todoList"), e.get("checkTodoList") && Ot(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
        this.editor.execute("todoList"), this.editor.execute("checkTodoList");
      });
    }
    /**
     * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},
     * {@link module:basic-styles/italic~Italic}, {@link module:basic-styles/code~Code}
     * and {@link module:basic-styles/strikethrough~Strikethrough}
     *
     * When typed:
     * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,
     * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,
     * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,
     * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,
     * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code,
     * - `~~foobar~~` &ndash; `~~` characters are removed and `foobar` is set to strikethrough.
     */
    _addBasicStylesAutoformats() {
      const e = this.editor.commands;
      if (e.get("bold")) {
        const t = no(this.editor, "bold");
        Ni(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t), Ni(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t);
      }
      if (e.get("italic")) {
        const t = no(this.editor, "italic");
        Ni(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t), Ni(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t);
      }
      if (e.get("code")) {
        const t = no(this.editor, "code");
        Ni(this.editor, this, /(`)([^`]+)(`)$/g, t);
      }
      if (e.get("strikethrough")) {
        const t = no(this.editor, "strikethrough");
        Ni(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
      }
    }
    /**
     * Adds autoformatting related to {@link module:heading/heading~Heading}.
     *
     * It is using a number at the end of the command name to associate it with the proper trigger:
     *
     * * `heading` with a `heading1` value will be executed when typing `#`,
     * * `heading` with a `heading2` value will be executed when typing `##`,
     * * ... up to `heading6` for `######`.
     */
    _addHeadingAutoformats() {
      const e = this.editor.commands.get("heading");
      e && e.modelElements.filter((t) => t.match(/^heading[1-6]$/)).forEach((t) => {
        const i = t[7], s = new RegExp(`^(#{${i}})\\s$`);
        Ot(this.editor, this, s, () => {
          if (!e.isEnabled || e.value === t)
            return !1;
          this.editor.execute("heading", { value: t });
        });
      });
    }
    /**
     * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.
     *
     * When typed:
     * * `> ` &ndash; A paragraph will be changed to a block quote.
     */
    _addBlockQuoteAutoformats() {
      this.editor.commands.get("blockQuote") && Ot(this.editor, this, /^>\s$/, "blockQuote");
    }
    /**
     * Adds autoformatting related to {@link module:code-block/codeblock~CodeBlock}.
     *
     * When typed:
     * - `` ``` `` &ndash; A paragraph will be changed to a code block.
     */
    _addCodeBlockAutoformats() {
      const e = this.editor, t = e.model.document.selection;
      e.commands.get("codeBlock") && Ot(e, this, /^```$/, () => {
        if (t.getFirstPosition().parent.is("element", "listItem"))
          return !1;
        this.editor.execute("codeBlock", {
          usePreviousLanguageChoice: !0
        });
      });
    }
    /**
     * Adds autoformatting related to {@link module:horizontal-line/horizontalline~HorizontalLine}.
     *
     * When typed:
     * - `` --- `` &ndash; Will be replaced with a horizontal line.
     */
    _addHorizontalLineAutoformats() {
      this.editor.commands.get("horizontalLine") && Ot(this.editor, this, /^---$/, "horizontalLine");
    }
  }
  function no(n, e) {
    return (t, i) => {
      if (!n.commands.get(e).isEnabled)
        return !1;
      const o = n.model.schema.getValidRanges(i, e);
      for (const r of o)
        t.setAttribute(e, !0, r);
      t.removeSelectionAttribute(e);
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function MV(n) {
    return n.createContainerElement("span", { class: "image-inline" }, n.createEmptyElement("img"));
  }
  function Fh(n) {
    return n.createContainerElement("figure", { class: "image" }, [
      n.createEmptyElement("img"),
      n.createSlot("children")
    ]);
  }
  function iw(n, e) {
    const t = n.plugins.get("ImageUtils"), i = n.plugins.has("ImageInlineEditing") && n.plugins.has("ImageBlockEditing");
    return (o) => t.isInlineImageView(o) ? i && (o.getStyle("display") == "block" || o.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : s(o) : null;
    function s(o) {
      const r = {
        name: !0
      };
      return o.hasAttribute("src") && (r.attributes = ["src"]), r;
    }
  }
  function Jl(n, e) {
    const t = me(e.getSelectedBlocks());
    return !t || n.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline";
  }
  function Oo(n) {
    return n && n.endsWith("px") ? parseInt(n) : null;
  }
  function No(n) {
    const e = Oo(n.getStyle("width")), t = Oo(n.getStyle("height"));
    return !!(e && t);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const BV = /^(image|image-inline)$/;
  class Ae extends w {
    constructor() {
      super(...arguments), this._domEmitter = new (Me())();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageUtils";
    }
    /**
     * Checks if the provided model element is an `image` or `imageInline`.
     */
    isImage(e) {
      return this.isInlineImage(e) || this.isBlockImage(e);
    }
    /**
     * Checks if the provided view element represents an inline image.
     *
     * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
     */
    isInlineImageView(e) {
      return !!e && e.is("element", "img");
    }
    /**
     * Checks if the provided view element represents a block image.
     *
     * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
     */
    isBlockImageView(e) {
      return !!e && e.is("element", "figure") && e.hasClass("image");
    }
    /**
     * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}
     * method.
     *
     * ```ts
     * const imageUtils = editor.plugins.get( 'ImageUtils' );
     *
     * imageUtils.insertImage( { src: 'path/to/image.jpg' } );
     * ```
     *
     * @param attributes Attributes of the inserted image.
     * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.
     * @param selectable Place to insert the image. If not specified,
     * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images
     * and `model.document.selection` for the inline images.
     *
     * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)
     * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.
     *
     * @param imageType Image type of inserted image. If not specified,
     * it will be determined automatically depending of editor config or place of the insertion.
     * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
     * The default is `true`.
     * @return The inserted model image element.
     */
    insertImage(e = {}, t = null, i = null, s = {}) {
      const o = this.editor, r = o.model, a = r.document.selection, l = nw(o, t || a, i);
      e = {
        ...Object.fromEntries(a.getAttributes()),
        ...e
      };
      for (const c in e)
        r.schema.checkAttribute(l, c) || delete e[c];
      return r.change((c) => {
        const { setImageSizes: u = !0 } = s, d = c.createElement(l, e);
        return r.insertObject(d, t, null, {
          setSelection: "on",
          // If we want to insert a block image (for whatever reason) then we don't want to split text blocks.
          // This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).
          findOptimalPosition: !t && l != "imageInline" ? "auto" : void 0
        }), d.parent ? (u && this.setImageNaturalSizeAttributes(d), d) : null;
      });
    }
    /**
     * Reads original image sizes and sets them as `width` and `height`.
     *
     * The `src` attribute may not be available if the user is using an upload adapter. In such a case,
     * this method is called again after the upload process is complete and the `src` attribute is available.
     */
    setImageNaturalSizeAttributes(e) {
      const t = e.getAttribute("src");
      t && (e.getAttribute("width") || e.getAttribute("height") || this.editor.model.change((i) => {
        const s = new E.window.Image();
        this._domEmitter.listenTo(s, "load", () => {
          !e.getAttribute("width") && !e.getAttribute("height") && this.editor.model.enqueueChange(i.batch, (o) => {
            o.setAttribute("width", s.naturalWidth, e), o.setAttribute("height", s.naturalHeight, e);
          }), this._domEmitter.stopListening(s, "load");
        }), s.src = t;
      }));
    }
    /**
     * Returns an image widget editing view element if one is selected or is among the selection's ancestors.
     */
    getClosestSelectedImageWidget(e) {
      const t = e.getFirstPosition();
      if (!t)
        return null;
      const i = e.getSelectedElement();
      if (i && this.isImageWidget(i))
        return i;
      let s = t.parent;
      for (; s; ) {
        if (s.is("element") && this.isImageWidget(s))
          return s;
        s = s.parent;
      }
      return null;
    }
    /**
     * Returns a image model element if one is selected or is among the selection's ancestors.
     */
    getClosestSelectedImageElement(e) {
      const t = e.getSelectedElement();
      return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock");
    }
    /**
     * Returns an image widget editing view based on the passed image view.
     */
    getImageWidgetFromImageView(e) {
      return e.findAncestor({ classes: BV });
    }
    /**
     * Checks if image can be inserted at current model selection.
     *
     * @internal
     */
    isImageAllowed() {
      const t = this.editor.model.document.selection;
      return OV(this.editor, t) && NV(t);
    }
    /**
     * Converts a given {@link module:engine/view/element~Element} to an image widget:
     * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget
     * element.
     * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
     *
     * @param writer An instance of the view writer.
     * @param label The element's label. It will be concatenated with the image `alt` attribute if one is present.
     */
    toImageWidget(e, t, i) {
      return t.setCustomProperty("image", !0, e), cr(e, t, { label: () => {
        const r = this.findViewImgElement(e).getAttribute("alt");
        return r ? `${r} ${i}` : i;
      } });
    }
    /**
     * Checks if a given view element is an image widget.
     */
    isImageWidget(e) {
      return !!e.getCustomProperty("image") && re(e);
    }
    /**
     * Checks if the provided model element is an `image`.
     */
    isBlockImage(e) {
      return !!e && e.is("element", "imageBlock");
    }
    /**
     * Checks if the provided model element is an `imageInline`.
     */
    isInlineImage(e) {
      return !!e && e.is("element", "imageInline");
    }
    /**
     * Get the view `<img>` from another view element, e.g. a widget (`<figure class="image">`), a link (`<a>`).
     *
     * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.
     */
    findViewImgElement(e) {
      if (this.isInlineImageView(e))
        return e;
      const t = this.editor.editing.view;
      for (const { item: i } of t.createRangeIn(e))
        if (this.isInlineImageView(i))
          return i;
    }
    /**
     * @inheritDoc
     */
    destroy() {
      return this._domEmitter.stopListening(), super.destroy();
    }
  }
  function OV(n, e) {
    if (nw(n, e, null) == "imageBlock") {
      const i = DV(e, n.model);
      if (n.model.schema.checkChild(i, "imageBlock"))
        return !0;
    } else if (n.model.schema.checkChild(e.focus, "imageInline"))
      return !0;
    return !1;
  }
  function NV(n) {
    return [...n.focus.getAncestors()].every((e) => !e.is("element", "imageBlock"));
  }
  function DV(n, e) {
    const i = Bl(n, e).start.parent;
    return i.isEmpty && !i.is("element", "$root") ? i.parent : i;
  }
  function nw(n, e, t) {
    const i = n.model.schema, s = n.config.get("image.insert.type");
    return n.plugins.has("ImageBlockEditing") ? n.plugins.has("ImageInlineEditing") ? t || (s === "inline" ? "imageInline" : s !== "auto" ? "imageBlock" : e.is("selection") ? Jl(i, e) : i.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const FV = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));
  class zV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ol, Ae, Nl, bt];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "AutoImage";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._timeoutId = null, this._positionToInsert = null;
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.document, i = e.plugins.get("ClipboardPipeline");
      this.listenTo(i, "inputTransformation", () => {
        const s = t.selection.getFirstRange(), o = le.fromPosition(s.start);
        o.stickiness = "toPrevious";
        const r = le.fromPosition(s.end);
        r.stickiness = "toNext", t.once("change:data", () => {
          this._embedImageBetweenPositions(o, r), o.detach(), r.detach();
        }, { priority: "high" });
      }), e.commands.get("undo").on("execute", () => {
        this._timeoutId && (E.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
      }, { priority: "high" });
    }
    /**
     * Analyzes the part of the document between provided positions in search for a URL representing an image.
     * When the URL is found, it is automatically converted into an image.
     *
     * @param leftPosition Left position of the selection.
     * @param rightPosition Right position of the selection.
     */
    _embedImageBetweenPositions(e, t) {
      const i = this.editor, s = new Pe(e, t), o = s.getWalker({ ignoreElementEnd: !0 }), r = Object.fromEntries(i.model.document.selection.getAttributes()), a = this.editor.plugins.get("ImageUtils");
      let l = "";
      for (const c of o)
        c.item.is("$textProxy") && (l += c.item.data);
      if (l = l.trim(), !l.match(FV)) {
        s.detach();
        return;
      }
      this._positionToInsert = le.fromPosition(e), this._timeoutId = setTimeout(() => {
        if (!i.commands.get("insertImage").isEnabled) {
          s.detach();
          return;
        }
        i.model.change((d) => {
          this._timeoutId = null, d.remove(s), s.detach();
          let h;
          this._positionToInsert.root.rootName !== "$graveyard" && (h = this._positionToInsert.toPosition()), a.insertImage({ ...r, src: l }, h), this._positionToInsert.detach(), this._positionToInsert = null;
        }), i.plugins.get("Delete").requestUndoOnBackspace();
      }, 100);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class UV extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const i = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
      this.isEnabled = !!i, this.isEnabled && i.hasAttribute("alt") ? this.value = i.getAttribute("alt") : this.value = !1;
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param options
     * @param options.newValue The new value of the `alt` attribute to set.
     */
    execute(e) {
      const t = this.editor, i = t.plugins.get("ImageUtils"), s = t.model, o = i.getClosestSelectedImageElement(s.document.selection);
      s.change((r) => {
        r.setAttribute("alt", e.newValue, o);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class HV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageTextAlternativeEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      this.editor.commands.add("imageTextAlternative", new UV(this.editor));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class $V extends T {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = this.locale.t;
      this.focusTracker = new Q(), this.keystrokes = new ne(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(t("Save"), x.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(t("Cancel"), x.cancel, "ck-button-cancel", "cancel"), this._focusables = new ke(), this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      }), this.setTemplate({
        tag: "form",
        attributes: {
          class: [
            "ck",
            "ck-text-alternative-form",
            "ck-responsive-form"
          ],
          // https://github.com/ckeditor/ckeditor5-image/issues/40
          tabindex: "-1"
        },
        children: [
          this.labeledInput,
          this.saveButtonView,
          this.cancelButtonView
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), this.keystrokes.listenTo(this.element), an({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((e) => {
        this._focusables.add(e), this.focusTracker.add(e.element);
      });
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Creates the button view.
     *
     * @param label The button label
     * @param icon The button's icon.
     * @param className The additional button CSS class name.
     * @param eventName The event name that the ButtonView#execute event will be delegated to.
     * @returns The button view instance.
     */
    _createButton(e, t, i, s) {
      const o = new P(this.locale);
      return o.set({
        label: e,
        icon: t,
        tooltip: !0
      }), o.extendTemplate({
        attributes: {
          class: i
        }
      }), s && o.delegate("execute").to(this, s), o;
    }
    /**
     * Creates an input with a label.
     *
     * @returns Labeled field view instance.
     */
    _createLabeledInputView() {
      const e = this.locale.t, t = new he(this.locale, ze);
      return t.label = e("Text alternative"), t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function WV(n) {
    const e = n.plugins.get("ContextualBalloon");
    if (n.plugins.get("ImageUtils").getClosestSelectedImageWidget(n.editing.view.document.selection)) {
      const i = sw(n);
      e.updatePosition(i);
    }
  }
  function sw(n) {
    const e = n.editing.view, t = ye.defaultPositions, i = n.plugins.get("ImageUtils");
    return {
      target: e.domConverter.mapViewToDom(i.getClosestSelectedImageWidget(e.document.selection)),
      positions: [
        t.northArrowSouth,
        t.northArrowSouthWest,
        t.northArrowSouthEast,
        t.southArrowNorth,
        t.southArrowNorthWest,
        t.southArrowNorthEast,
        t.viewportStickyNorth
      ]
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class qV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [$t];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageTextAlternativeUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      this._createButton();
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this._form && this._form.destroy();
    }
    /**
     * Creates a button showing the balloon panel for changing the image text alternative and
     * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
     */
    _createButton() {
      const e = this.editor, t = e.t;
      e.ui.componentFactory.add("imageTextAlternative", (i) => {
        const s = e.commands.get("imageTextAlternative"), o = new P(i);
        return o.set({
          label: t("Change image text alternative"),
          icon: x.textAlternative,
          tooltip: !0
        }), o.bind("isEnabled").to(s, "isEnabled"), o.bind("isOn").to(s, "value", (r) => !!r), this.listenTo(o, "execute", () => {
          this._showForm();
        }), o;
      });
    }
    /**
     * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
     * form.
     */
    _createForm() {
      const e = this.editor, i = e.editing.view.document, s = e.plugins.get("ImageUtils");
      this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (ja($V))(e.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
        e.execute("imageTextAlternative", {
          newValue: this._form.labeledInput.fieldView.element.value
        }), this._hideForm(!0);
      }), this.listenTo(this._form, "cancel", () => {
        this._hideForm(!0);
      }), this._form.keystrokes.set("Esc", (o, r) => {
        this._hideForm(!0), r();
      }), this.listenTo(e.ui, "update", () => {
        s.getClosestSelectedImageWidget(i.selection) ? this._isVisible && WV(e) : this._hideForm(!0);
      }), rn({
        emitter: this._form,
        activator: () => this._isVisible,
        contextElements: () => [this._balloon.view.element],
        callback: () => this._hideForm()
      });
    }
    /**
     * Shows the {@link #_form} in the {@link #_balloon}.
     */
    _showForm() {
      if (this._isVisible)
        return;
      this._form || this._createForm();
      const e = this.editor, t = e.commands.get("imageTextAlternative"), i = this._form.labeledInput;
      this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({
        view: this._form,
        position: sw(e)
      }), i.fieldView.value = i.fieldView.element.value = t.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
    }
    /**
     * Removes the {@link #_form} from the {@link #_balloon}.
     *
     * @param focusEditable Controls whether the editing view is focused afterwards.
     */
    _hideForm(e = !1) {
      this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus());
    }
    /**
     * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
     */
    get _isVisible() {
      return !!this._balloon && this._balloon.visibleView === this._form;
    }
    /**
     * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
     */
    get _isInBalloon() {
      return !!this._balloon && this._balloon.hasView(this._form);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ow extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [HV, qV];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageTextAlternative";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function GV(n) {
    const e = (t, i, s) => {
      if (!s.consumable.test(i.viewItem, { name: !0, classes: "image" }))
        return;
      const o = n.findViewImgElement(i.viewItem);
      if (!o || !s.consumable.test(o, { name: !0 }))
        return;
      s.consumable.consume(i.viewItem, { name: !0, classes: "image" });
      const r = s.convertItem(o, i.modelCursor), a = me(r.modelRange.getItems());
      if (!a) {
        s.consumable.revert(i.viewItem, { name: !0, classes: "image" });
        return;
      }
      s.convertChildren(i.viewItem, a), s.updateConversionResult(a, i);
    };
    return (t) => {
      t.on("element:figure", e);
    };
  }
  function rw(n, e) {
    const t = (i, s, o) => {
      if (!o.consumable.consume(s.item, i.name))
        return;
      const r = o.writer, a = o.mapper.toViewElement(s.item), l = n.findViewImgElement(a);
      s.attributeNewValue === null ? (r.removeAttribute("srcset", l), r.removeAttribute("sizes", l)) : s.attributeNewValue && (r.setAttribute("srcset", s.attributeNewValue, l), r.setAttribute("sizes", "100vw", l));
    };
    return (i) => {
      i.on(`attribute:srcset:${e}`, t);
    };
  }
  function Do(n, e, t) {
    const i = (s, o, r) => {
      if (!r.consumable.consume(o.item, s.name))
        return;
      const a = r.writer, l = r.mapper.toViewElement(o.item), c = n.findViewImgElement(l);
      a.setAttribute(o.attributeKey, o.attributeNewValue || "", c);
    };
    return (s) => {
      s.on(`attribute:${t}:${e}`, i);
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Xl extends _t {
    /**
     * @inheritDoc
     */
    observe(e) {
      this.listenTo(e, "load", (t, i) => {
        const s = i.target;
        this.checkShouldIgnoreEventFromTarget(s) || s.tagName == "IMG" && this._fireEvents(i);
      }, { useCapture: !0 });
    }
    /**
     * @inheritDoc
     */
    stopObserving(e) {
      this.stopListening(e);
    }
    /**
     * Fires {@link module:engine/view/document~Document#event:layoutChanged} and
     * {@link module:engine/view/document~Document#event:imageLoaded}
     * if observer {@link #isEnabled is enabled}.
     *
     * @param domEvent The DOM event.
     */
    _fireEvents(e) {
      this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e));
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class jV extends V {
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e);
      const t = e.config.get("image.insert.type");
      e.plugins.has("ImageBlockEditing") || t === "block" && z("image-block-plugin-required"), e.plugins.has("ImageInlineEditing") || t === "inline" && z("image-inline-plugin-required");
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor.plugins.get("ImageUtils");
      this.isEnabled = e.isImageAllowed();
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param options Options for the executed command.
     * @param options.source The image source or an array of image sources to insert.
     * See the documentation of the command to learn more about accepted formats.
     */
    execute(e) {
      const t = Z(e.source), i = this.editor.model.document.selection, s = this.editor.plugins.get("ImageUtils"), o = Object.fromEntries(i.getAttributes());
      t.forEach((r, a) => {
        const l = i.getSelectedElement();
        if (typeof r == "string" && (r = { src: r }), a && l && s.isImage(l)) {
          const c = this.editor.model.createPositionAfter(l);
          s.insertImage({ ...r, ...o }, c);
        } else
          s.insertImage({ ...r, ...o });
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class KV extends V {
    constructor(e) {
      super(e), this.decorate("cleanupImage");
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const t = this.editor.plugins.get("ImageUtils"), i = this.editor.model.document.selection.getSelectedElement();
      this.isEnabled = t.isImage(i), this.value = this.isEnabled ? i.getAttribute("src") : null;
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param options Options for the executed command.
     * @param options.source The image source to replace.
     */
    execute(e) {
      const t = this.editor.model.document.selection.getSelectedElement(), i = this.editor.plugins.get("ImageUtils");
      this.editor.model.change((s) => {
        s.setAttribute("src", e.source, t), this.cleanupImage(s, t), i.setImageNaturalSizeAttributes(t);
      });
    }
    /**
     * Cleanup image attributes that are not relevant to the new source.
     *
     * Removed attributes are: 'srcset', 'sizes', 'sources', 'width', 'height', 'alt'.
     *
     * This method is decorated, to allow custom cleanup logic.
     * For example, to remove 'myImageId' attribute after 'src' has changed:
     *
     * ```ts
     * replaceImageSourceCommand.on( 'cleanupImage', ( eventInfo, [ writer, image ] ) => {
     * 	writer.removeAttribute( 'myImageId', image );
     * } );
     * ```
     */
    cleanupImage(e, t) {
      e.removeAttribute("srcset", t), e.removeAttribute("sizes", t), e.removeAttribute("sources", t), e.removeAttribute("width", t), e.removeAttribute("height", t), e.removeAttribute("alt", t);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class aw extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.conversion;
      e.editing.view.addObserver(Xl), t.for("upcast").attributeToAttribute({
        view: {
          name: "img",
          key: "alt"
        },
        model: "alt"
      }).attributeToAttribute({
        view: {
          name: "img",
          key: "srcset"
        },
        model: "srcset"
      });
      const i = new jV(e), s = new KV(e);
      e.commands.add("insertImage", i), e.commands.add("replaceImageSource", s), e.commands.add("imageInsert", i);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class lw extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageSizeAttributes";
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline");
    }
    /**
     * Registers the `width` and `height` attributes for inline and block images.
     */
    _registerSchema() {
      this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["width", "height"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["width", "height"] });
    }
    /**
     * Registers converters for `width` and `height` attributes.
     */
    _registerConverters(e) {
      const t = this.editor, i = t.plugins.get("ImageUtils"), s = e === "imageBlock" ? "figure" : "img";
      t.conversion.for("upcast").attributeToAttribute({
        view: {
          name: s,
          styles: {
            width: /.+/
          }
        },
        model: {
          key: "width",
          value: (r) => No(r) ? Oo(r.getStyle("width")) : null
        }
      }).attributeToAttribute({
        view: {
          name: s,
          key: "width"
        },
        model: "width"
      }).attributeToAttribute({
        view: {
          name: s,
          styles: {
            height: /.+/
          }
        },
        model: {
          key: "height",
          value: (r) => No(r) ? Oo(r.getStyle("height")) : null
        }
      }).attributeToAttribute({
        view: {
          name: s,
          key: "height"
        },
        model: "height"
      }), t.conversion.for("editingDowncast").add((r) => {
        o(r, "width", "width", !0), o(r, "height", "height", !0);
      }), t.conversion.for("dataDowncast").add((r) => {
        o(r, "width", "width", !1), o(r, "height", "height", !1);
      });
      function o(r, a, l, c) {
        r.on(`attribute:${a}:${e}`, (u, d, h) => {
          if (!h.consumable.consume(d.item, u.name))
            return;
          const f = h.writer, m = h.mapper.toViewElement(d.item), p = i.findViewImgElement(m);
          if (d.attributeNewValue !== null ? f.setAttribute(l, d.attributeNewValue, p) : f.removeAttribute(l, p), d.item.hasAttribute("sources"))
            return;
          const b = d.item.hasAttribute("resizedWidth");
          if (e === "imageInline" && !b && !c)
            return;
          const v = d.item.getAttribute("width"), y = d.item.getAttribute("height");
          v && y && f.setStyle("aspect-ratio", `${v}/${y}`, p);
        });
      }
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class cw extends V {
    /**
     * @inheritDoc
     *
     * @param modelElementName Model element name the command converts to.
     */
    constructor(e, t) {
      super(e), this._modelElementName = t;
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const t = this.editor.plugins.get("ImageUtils"), i = t.getClosestSelectedImageElement(this.editor.model.document.selection);
      this._modelElementName === "imageBlock" ? this.isEnabled = t.isInlineImage(i) : this.isEnabled = t.isBlockImage(i);
    }
    /**
     * Executes the command and changes the type of a selected image.
     *
     * @fires execute
     * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
     * The default is `true`.
     * @returns An object containing references to old and new model image elements
     * (for before and after the change) so external integrations can hook into the decorated
     * `execute` event and handle this change. `null` if the type change failed.
     */
    execute(e = {}) {
      const t = this.editor, i = this.editor.model, s = t.plugins.get("ImageUtils"), o = s.getClosestSelectedImageElement(i.document.selection), r = Object.fromEntries(o.getAttributes());
      return !r.src && !r.uploadId ? null : i.change((a) => {
        const { setImageSizes: l = !0 } = e, c = Array.from(i.markers).filter((h) => h.getRange().containsItem(o)), u = s.insertImage(r, i.createSelection(o, "on"), this._modelElementName, { setImageSizes: l });
        if (!u)
          return null;
        const d = a.createRangeOn(u);
        for (const h of c) {
          const f = h.getRange(), m = f.root.rootName != "$graveyard" ? f.getJoined(d, !0) : d;
          a.updateMarker(h, { range: m });
        }
        return {
          oldElement: o,
          newElement: u
        };
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class uw extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImagePlaceholder";
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      this._setupSchema(), this._setupConversion(), this._setupLoadListener();
    }
    /**
     * Extends model schema.
     */
    _setupSchema() {
      const e = this.editor.model.schema;
      e.isRegistered("imageBlock") && e.extend("imageBlock", {
        allowAttributes: ["placeholder"]
      }), e.isRegistered("imageInline") && e.extend("imageInline", {
        allowAttributes: ["placeholder"]
      });
    }
    /**
     * Registers converters.
     */
    _setupConversion() {
      const e = this.editor, t = e.conversion, i = e.plugins.get("ImageUtils");
      t.for("editingDowncast").add((s) => {
        s.on("attribute:placeholder", (o, r, a) => {
          if (!a.consumable.test(r.item, o.name) || !r.item.is("element", "imageBlock") && !r.item.is("element", "imageInline"))
            return;
          a.consumable.consume(r.item, o.name);
          const l = a.writer, c = a.mapper.toViewElement(r.item), u = i.findViewImgElement(c);
          r.attributeNewValue ? (l.addClass("image_placeholder", u), l.setStyle("background-image", `url(${r.attributeNewValue})`, u), l.setCustomProperty("editingPipeline:doNotReuseOnce", !0, u)) : (l.removeClass("image_placeholder", u), l.removeStyle("background-image", u));
        });
      });
    }
    /**
     * Prepares listener for image load.
     */
    _setupLoadListener() {
      const e = this.editor, t = e.model, i = e.editing, s = i.view, o = e.plugins.get("ImageUtils");
      s.addObserver(Xl), this.listenTo(s.document, "imageLoaded", (r, a) => {
        const l = s.domConverter.mapDomToView(a.target);
        if (!l)
          return;
        const c = o.getImageWidgetFromImageView(l);
        if (!c)
          return;
        const u = i.mapper.toModelElement(c);
        !u || !u.hasAttribute("placeholder") || t.enqueueChange({ isUndoable: !1 }, (d) => {
          d.removeAttribute("placeholder", u);
        });
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class dw extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [aw, lw, Ae, uw, Xe];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageBlockEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.model.schema.register("imageBlock", {
        inheritAllFrom: "$blockObject",
        allowAttributes: ["alt", "src", "srcset"]
      }), this._setupConversion(), e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new cw(this.editor, "imageBlock")), this._setupClipboardIntegration());
    }
    /**
     * Configures conversion pipelines to support upcasting and downcasting
     * block images (block image widgets) and their attributes.
     */
    _setupConversion() {
      const e = this.editor, t = e.t, i = e.conversion, s = e.plugins.get("ImageUtils");
      i.for("dataDowncast").elementToStructure({
        model: "imageBlock",
        view: (o, { writer: r }) => Fh(r)
      }), i.for("editingDowncast").elementToStructure({
        model: "imageBlock",
        view: (o, { writer: r }) => s.toImageWidget(Fh(r), r, t("image widget"))
      }), i.for("downcast").add(Do(s, "imageBlock", "src")).add(Do(s, "imageBlock", "alt")).add(rw(s, "imageBlock")), i.for("upcast").elementToElement({
        view: iw(e, "imageBlock"),
        model: (o, { writer: r }) => r.createElement("imageBlock", o.hasAttribute("src") ? { src: o.getAttribute("src") } : void 0)
      }).add(GV(s));
    }
    /**
     * Integrates the plugin with the clipboard pipeline.
     *
     * Idea is that the feature should recognize the user's intent when an **inline** image is
     * pasted or dropped. If such an image is pasted/dropped:
     *
     * * into an empty block (e.g. an empty paragraph),
     * * on another object (e.g. some block widget).
     *
     * it gets converted into a block image on the fly. We assume this is the user's intent
     * if they decided to put their image there.
     *
     * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.
     *
     * The feature also sets image `width` and `height` attributes on paste.
     */
    _setupClipboardIntegration() {
      const e = this.editor, t = e.model, i = e.editing.view, s = e.plugins.get("ImageUtils"), o = e.plugins.get("ClipboardPipeline");
      this.listenTo(o, "inputTransformation", (r, a) => {
        const l = Array.from(a.content.getChildren());
        let c;
        if (!l.every(s.isInlineImageView))
          return;
        a.targetRanges ? c = e.editing.mapper.toModelRange(a.targetRanges[0]) : c = t.document.selection.getFirstRange();
        const u = t.createSelection(c);
        if (Jl(t.schema, u) === "imageBlock") {
          const d = new Mt(i.document), h = l.map((f) => d.createElement("figure", { class: "image" }, f));
          a.content = d.createDocumentFragment(h);
        }
      }), this.listenTo(o, "contentInsertion", (r, a) => {
        a.method === "paste" && t.change((l) => {
          const c = l.createRangeIn(a.content);
          for (const u of c.getItems())
            u.is("element", "imageBlock") && s.setImageNaturalSizeAttributes(u);
        });
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ZV extends T {
    /**
     * Creates a view for the dropdown panel of {@link module:image/imageinsert/imageinsertui~ImageInsertUI}.
     *
     * @param locale The localization services instance.
     * @param integrations An integrations object that contains components (or tokens for components) to be shown in the panel view.
     */
    constructor(e, t = []) {
      super(e), this.focusTracker = new Q(), this.keystrokes = new ne(), this._focusables = new ke(), this.children = this.createCollection(), this._focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      });
      for (const i of t)
        this.children.add(i), this._focusables.add(i), i instanceof ug && this._focusables.addMany(i.children);
      if (this._focusables.length > 1)
        for (const i of this._focusables)
          JV(i) && (i.focusCycler.on("forwardCycle", (s) => {
            this._focusCycler.focusNext(), s.stop();
          }), i.focusCycler.on("backwardCycle", (s) => {
            this._focusCycler.focusPrevious(), s.stop();
          }));
      this.setTemplate({
        tag: "form",
        attributes: {
          class: [
            "ck",
            "ck-image-insert-form"
          ],
          tabindex: -1
        },
        children: this.children
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render(), an({
        view: this
      });
      for (const t of this._focusables)
        this.focusTracker.add(t.element);
      this.keystrokes.listenTo(this.element);
      const e = (t) => t.stopPropagation();
      this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Focuses the first {@link #_focusables focusable} in the form.
     */
    focus() {
      this._focusCycler.focusFirst();
    }
  }
  function JV(n) {
    return "focusCycler" in n;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class As extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageInsertUI";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae];
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._integrations = /* @__PURE__ */ new Map(), e.config.define("image.insert.integrations", [
        "upload",
        "assetManager",
        "url"
      ]);
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.document.selection, i = e.plugins.get("ImageUtils");
      this.set("isImageSelected", !1), this.listenTo(e.model.document, "change", () => {
        this.isImageSelected = i.isImage(t.getSelectedElement());
      });
      const s = (o) => this._createToolbarComponent(o);
      e.ui.componentFactory.add("insertImage", s), e.ui.componentFactory.add("imageInsert", s);
    }
    /**
     * Registers the insert image dropdown integration.
     */
    registerIntegration({ name: e, observable: t, buttonViewCreator: i, formViewCreator: s, requiresForm: o }) {
      this._integrations.has(e) && z("image-insert-integration-exists", { name: e }), this._integrations.set(e, {
        observable: t,
        buttonViewCreator: i,
        formViewCreator: s,
        requiresForm: !!o
      });
    }
    /**
     * Creates the toolbar component.
     */
    _createToolbarComponent(e) {
      const t = this.editor, i = e.t, s = this._prepareIntegrations();
      if (!s.length)
        return null;
      let o;
      const r = s[0];
      if (s.length == 1) {
        if (!r.requiresForm)
          return r.buttonViewCreator(!0);
        o = r.buttonViewCreator(!0);
      } else {
        const c = r.buttonViewCreator(!1);
        o = new sr(e, c), o.tooltip = !0, o.bind("label").to(this, "isImageSelected", (u) => i(u ? "Replace image" : "Insert image"));
      }
      const a = this.dropdownView = we(e, o), l = s.map(({ observable: c }) => typeof c == "function" ? c() : c);
      return a.bind("isEnabled").toMany(l, "isEnabled", (...c) => c.some((u) => u)), a.once("change:isOpen", () => {
        const c = s.map(({ formViewCreator: d }) => d(s.length == 1)), u = new ZV(t.locale, c);
        a.panelView.children.add(u);
      }), a;
    }
    /**
     * Validates the integrations list.
     */
    _prepareIntegrations() {
      const t = this.editor.config.get("image.insert.integrations"), i = [];
      if (!t.length)
        return z("image-insert-integrations-not-specified"), i;
      for (const s of t) {
        if (!this._integrations.has(s)) {
          ["upload", "assetManager", "url"].includes(s) || z("image-insert-unknown-integration", { item: s });
          continue;
        }
        i.push(this._integrations.get(s));
      }
      return i.length || z("image-insert-integrations-not-registered"), i;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class XV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [dw, gn, ow, As];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageBlock";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class YV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [aw, lw, Ae, uw, Xe];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageInlineEditing";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.schema;
      t.register("imageInline", {
        inheritAllFrom: "$inlineObject",
        allowAttributes: ["alt", "src", "srcset"]
      }), t.addChildCheck((i, s) => {
        if (i.endsWith("caption") && s.name === "imageInline")
          return !1;
      }), this._setupConversion(), e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new cw(this.editor, "imageInline")), this._setupClipboardIntegration());
    }
    /**
     * Configures conversion pipelines to support upcasting and downcasting
     * inline images (inline image widgets) and their attributes.
     */
    _setupConversion() {
      const e = this.editor, t = e.t, i = e.conversion, s = e.plugins.get("ImageUtils");
      i.for("dataDowncast").elementToElement({
        model: "imageInline",
        view: (o, { writer: r }) => r.createEmptyElement("img")
      }), i.for("editingDowncast").elementToStructure({
        model: "imageInline",
        view: (o, { writer: r }) => s.toImageWidget(MV(r), r, t("image widget"))
      }), i.for("downcast").add(Do(s, "imageInline", "src")).add(Do(s, "imageInline", "alt")).add(rw(s, "imageInline")), i.for("upcast").elementToElement({
        view: iw(e, "imageInline"),
        model: (o, { writer: r }) => r.createElement("imageInline", o.hasAttribute("src") ? { src: o.getAttribute("src") } : void 0)
      });
    }
    /**
     * Integrates the plugin with the clipboard pipeline.
     *
     * Idea is that the feature should recognize the user's intent when an **block** image is
     * pasted or dropped. If such an image is pasted/dropped into a non-empty block
     * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.
     *
     * We assume this is the user's intent if they decided to put their image there.
     *
     * **Note**: If a block image has a caption, it will not be converted to an inline image
     * to avoid the confusion. Captions are added on purpose and they should never be lost
     * in the clipboard pipeline.
     *
     * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.
     *
     * The feature also sets image `width` and `height` attributes when pasting.
     */
    _setupClipboardIntegration() {
      const e = this.editor, t = e.model, i = e.editing.view, s = e.plugins.get("ImageUtils"), o = e.plugins.get("ClipboardPipeline");
      this.listenTo(o, "inputTransformation", (r, a) => {
        const l = Array.from(a.content.getChildren());
        let c;
        if (!l.every(s.isBlockImageView))
          return;
        a.targetRanges ? c = e.editing.mapper.toModelRange(a.targetRanges[0]) : c = t.document.selection.getFirstRange();
        const u = t.createSelection(c);
        if (Jl(t.schema, u) === "imageInline") {
          const d = new Mt(i.document), h = l.map((f) => f.childCount === 1 ? (Array.from(f.getAttributes()).forEach((m) => d.setAttribute(...m, s.findViewImgElement(f))), f.getChild(0)) : f);
          a.content = d.createDocumentFragment(h);
        }
      }), this.listenTo(o, "contentInsertion", (r, a) => {
        a.method === "paste" && t.change((l) => {
          const c = l.createRangeIn(a.content);
          for (const u of c.getItems())
            u.is("element", "imageInline") && s.setImageNaturalSizeAttributes(u);
        });
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class QV extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [YV, gn, ow, As];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageInline";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class eM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [XV, QV];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Image";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class hw extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageCaptionUtils";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae];
    }
    /**
     * Returns the caption model element from a given image element. Returns `null` if no caption is found.
     */
    getCaptionFromImageModelElement(e) {
      for (const t of e.getChildren())
        if (t && t.is("element", "caption"))
          return t;
      return null;
    }
    /**
     * Returns the caption model element for a model selection. Returns `null` if the selection has no caption element ancestor.
     */
    getCaptionFromModelSelection(e) {
      const t = this.editor.plugins.get("ImageUtils"), i = e.getFirstPosition().findAncestor("caption");
      return i && t.isBlockImage(i.parent) ? i : null;
    }
    /**
     * {@link module:engine/view/matcher~Matcher} pattern. Checks if a given element is a `<figcaption>` element that is placed
     * inside the image `<figure>` element.
     * @returns Returns the object accepted by {@link module:engine/view/matcher~Matcher} or `null` if the element
     * cannot be matched.
     */
    matchImageCaptionViewElement(e) {
      const t = this.editor.plugins.get("ImageUtils");
      return e.name == "figcaption" && t.isBlockImageView(e.parent) ? { name: !0 } : null;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class tM extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor, t = e.plugins.get("ImageCaptionUtils"), i = e.plugins.get("ImageUtils");
      if (!e.plugins.has(dw)) {
        this.isEnabled = !1, this.value = !1;
        return;
      }
      const s = e.model.document.selection, o = s.getSelectedElement();
      if (!o) {
        const r = t.getCaptionFromModelSelection(s);
        this.isEnabled = !!r, this.value = !!r;
        return;
      }
      this.isEnabled = i.isImage(o), this.isEnabled ? this.value = !!t.getCaptionFromImageModelElement(o) : this.value = !1;
    }
    /**
     * Executes the command.
     *
     * ```ts
     * editor.execute( 'toggleImageCaption' );
     * ```
     *
     * @param options Options for the executed command.
     * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
     * @fires execute
     */
    execute(e = {}) {
      const { focusCaptionOnShow: t } = e;
      this.editor.model.change((i) => {
        this.value ? this._hideImageCaption(i) : this._showImageCaption(i, t);
      });
    }
    /**
     * Shows the caption of the `<imageBlock>` or `<imageInline>`. Also:
     *
     * * it converts `<imageInline>` to `<imageBlock>` to show the caption,
     * * it attempts to restore the caption content from the `ImageCaptionEditing` caption registry,
     * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
     */
    _showImageCaption(e, t) {
      const s = this.editor.model.document.selection, o = this.editor.plugins.get("ImageCaptionEditing"), r = this.editor.plugins.get("ImageUtils");
      let a = s.getSelectedElement();
      const l = o._getSavedCaption(a);
      r.isInlineImage(a) && (this.editor.execute("imageTypeBlock"), a = s.getSelectedElement());
      const c = l || e.createElement("caption");
      e.append(c, a), t && e.setSelection(c, "in");
    }
    /**
     * Hides the caption of a selected image (or an image caption the selection is anchored to).
     *
     * The content of the caption is stored in the `ImageCaptionEditing` caption registry to make this
     * a reversible action.
     */
    _hideImageCaption(e) {
      const t = this.editor, i = t.model.document.selection, s = t.plugins.get("ImageCaptionEditing"), o = t.plugins.get("ImageCaptionUtils");
      let r = i.getSelectedElement(), a;
      r ? a = o.getCaptionFromImageModelElement(r) : (a = o.getCaptionFromModelSelection(i), r = a.parent), s._saveCaption(r, a), e.setSelection(r, "on"), e.remove(a);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class iM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae, hw];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageCaptionEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.schema;
      t.isRegistered("caption") ? t.extend("caption", {
        allowIn: "imageBlock"
      }) : t.register("caption", {
        allowIn: "imageBlock",
        allowContentOf: "$block",
        isLimit: !0
      }), e.commands.add("toggleImageCaption", new tM(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion();
    }
    /**
     * Configures conversion pipelines to support upcasting and downcasting
     * image captions.
     */
    _setupConversion() {
      const e = this.editor, t = e.editing.view, i = e.plugins.get("ImageUtils"), s = e.plugins.get("ImageCaptionUtils"), o = e.t;
      e.conversion.for("upcast").elementToElement({
        view: (r) => s.matchImageCaptionViewElement(r),
        model: "caption"
      }), e.conversion.for("dataDowncast").elementToElement({
        model: "caption",
        view: (r, { writer: a }) => i.isBlockImage(r.parent) ? a.createContainerElement("figcaption") : null
      }), e.conversion.for("editingDowncast").elementToElement({
        model: "caption",
        view: (r, { writer: a }) => {
          if (!i.isBlockImage(r.parent))
            return null;
          const l = a.createEditableElement("figcaption");
          a.setCustomProperty("imageCaption", !0, l), l.placeholder = o("Enter image caption"), ml({
            view: t,
            element: l,
            keepOnFocus: !0
          });
          const c = r.parent.getAttribute("alt"), u = c ? o("Caption for image: %0", [c]) : o("Caption for the image");
          return Ml(l, a, { label: u });
        }
      });
    }
    /**
     * Integrates with {@link module:image/image/imagetypecommand~ImageTypeCommand image type commands}
     * to make sure the caption is preserved when the type of an image changes so it can be restored
     * in the future if the user decides they want their caption back.
     */
    _setupImageTypeCommandsIntegration() {
      const e = this.editor, t = e.plugins.get("ImageUtils"), i = e.plugins.get("ImageCaptionUtils"), s = e.commands.get("imageTypeInline"), o = e.commands.get("imageTypeBlock"), r = (a) => {
        if (!a.return)
          return;
        const { oldElement: l, newElement: c } = a.return;
        /* istanbul ignore if: paranoid check -- @preserve */
        if (!l)
          return;
        if (t.isBlockImage(l)) {
          const d = i.getCaptionFromImageModelElement(l);
          if (d) {
            this._saveCaption(c, d);
            return;
          }
        }
        const u = this._getSavedCaption(l);
        u && this._saveCaption(c, u);
      };
      s && this.listenTo(s, "execute", r, { priority: "low" }), o && this.listenTo(o, "execute", r, { priority: "low" });
    }
    /**
     * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
     * of an image model element.
     *
     * See {@link #_saveCaption}.
     *
     * @internal
     * @param imageModelElement The model element the caption should be returned for.
     * @returns The model caption element or `null` if there is none.
     */
    _getSavedCaption(e) {
      const t = this._savedCaptionsMap.get(e);
      return t ? W.fromJSON(t) : null;
    }
    /**
     * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
     * an image element to allow restoring it in the future.
     *
     * A caption is saved every time it gets hidden and/or the type of an image changes. The
     * user should be able to restore it on demand.
     *
     * **Note**: The caption cannot be stored in the image model element attribute because,
     * for instance, when the model state propagates to collaborators, the attribute would get
     * lost (mainly because it does not convert to anything when the caption is hidden) and
     * the states of collaborators' models would de-synchronize causing numerous issues.
     *
     * See {@link #_getSavedCaption}.
     *
     * @internal
     * @param imageModelElement The model element the caption is saved for.
     * @param caption The caption model element to be saved.
     */
    _saveCaption(e, t) {
      this._savedCaptionsMap.set(e, t.toJSON());
    }
    /**
     * Reconverts image caption when image alt attribute changes.
     * The change of alt attribute is reflected in caption's aria-label attribute.
     */
    _registerCaptionReconversion() {
      const e = this.editor, t = e.model, i = e.plugins.get("ImageUtils"), s = e.plugins.get("ImageCaptionUtils");
      t.document.on("change:data", () => {
        const o = t.document.differ.getChanges();
        for (const r of o) {
          if (r.attributeKey !== "alt")
            continue;
          const a = r.range.start.nodeAfter;
          if (i.isBlockImage(a)) {
            const l = s.getCaptionFromImageModelElement(a);
            if (!l)
              return;
            e.editing.reconvertItem(l);
          }
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class nM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [hw];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageCaptionUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.editing.view, i = e.plugins.get("ImageCaptionUtils"), s = e.t;
      e.ui.componentFactory.add("toggleImageCaption", (o) => {
        const r = e.commands.get("toggleImageCaption"), a = new P(o);
        return a.set({
          icon: x.caption,
          tooltip: !0,
          isToggleable: !0
        }), a.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), a.bind("label").to(r, "value", (l) => s(l ? "Toggle caption off" : "Toggle caption on")), this.listenTo(a, "execute", () => {
          e.execute("toggleImageCaption", { focusCaptionOnShow: !0 });
          const l = i.getCaptionFromModelSelection(e.model.document.selection);
          if (l) {
            const c = e.editing.mapper.toViewElement(l);
            t.scrollToTheSelection(), t.change((u) => {
              u.addClass("image__caption_highlighted", c);
            });
          }
          e.editing.view.focus();
        }), a;
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class sM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [iM, nM];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageCaption";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function fw(n) {
    const e = n.map((t) => t.replace("+", "\\+"));
    return new RegExp(`^image\\/(${e.join("|")})$`);
  }
  function oM(n) {
    return new Promise((e, t) => {
      const i = n.getAttribute("src");
      fetch(i).then((s) => s.blob()).then((s) => {
        const o = mw(s, i), a = `image.${o.replace("image/", "")}`, l = new File([s], a, { type: o });
        e(l);
      }).catch((s) => s && s.name === "TypeError" ? aM(i).then(e).catch(t) : t(s));
    });
  }
  function rM(n, e) {
    return !n.isInlineImageView(e) || !e.getAttribute("src") ? !1 : !!e.getAttribute("src").match(/^data:image\/\w+;base64,/g) || !!e.getAttribute("src").match(/^blob:/g);
  }
  function mw(n, e) {
    return n.type ? n.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
  }
  function aM(n) {
    return lM(n).then((e) => {
      const t = mw(e, n), s = `image.${t.replace("image/", "")}`;
      return new File([e], s, { type: t });
    });
  }
  function lM(n) {
    return new Promise((e, t) => {
      const i = E.document.createElement("img");
      i.addEventListener("load", () => {
        const s = E.document.createElement("canvas");
        s.width = i.width, s.height = i.height, s.getContext("2d").drawImage(i, 0, 0), s.toBlob((r) => r ? e(r) : t());
      }), i.addEventListener("error", () => t()), i.src = n;
    });
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class cM extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageUploadUI";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.t, i = () => {
        const s = this._createButton(cg);
        return s.set({
          label: t("Upload image from computer"),
          tooltip: !0
        }), s;
      };
      if (e.ui.componentFactory.add("uploadImage", i), e.ui.componentFactory.add("imageUpload", i), e.ui.componentFactory.add("menuBar:uploadImage", () => {
        const s = this._createButton(Og);
        return s.label = t("Image from computer"), s;
      }), e.plugins.has("ImageInsertUI")) {
        const s = e.plugins.get("ImageInsertUI");
        s.registerIntegration({
          name: "upload",
          observable: () => e.commands.get("uploadImage"),
          buttonViewCreator: () => {
            const o = e.ui.componentFactory.create("uploadImage");
            return o.bind("label").to(s, "isImageSelected", (r) => t(r ? "Replace image from computer" : "Upload image from computer")), o;
          },
          formViewCreator: () => {
            const o = e.ui.componentFactory.create("uploadImage");
            return o.withText = !0, o.bind("label").to(s, "isImageSelected", (r) => t(r ? "Replace from computer" : "Upload from computer")), o.on("execute", () => {
              s.dropdownView.isOpen = !1;
            }), o;
          }
        });
      }
    }
    /**
     * Creates a button for image upload command to use either in toolbar or in menu bar.
     */
    _createButton(e) {
      const t = this.editor, i = t.locale, s = t.commands.get("uploadImage"), o = t.config.get("image.upload.types"), r = fw(o), a = new e(t.locale), l = i.t;
      return a.set({
        acceptedType: o.map((c) => `image/${c}`).join(","),
        allowMultipleFiles: !0,
        label: l("Upload image from computer"),
        icon: x.imageUpload
      }), a.bind("isEnabled").to(s), a.on("done", (c, u) => {
        const d = Array.from(u).filter((h) => r.test(h.type));
        d.length && (t.execute("uploadImage", { file: d }), t.editing.view.focus());
      }), a;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class uM extends $() {
    /**
     * Creates an instance of the FileReader.
     */
    constructor() {
      super();
      const e = new window.FileReader();
      this._reader = e, this._data = void 0, this.set("loaded", 0), e.onprogress = (t) => {
        this.loaded = t.loaded;
      };
    }
    /**
     * Returns error that occurred during file reading.
     */
    get error() {
      return this._reader.error;
    }
    /**
     * Holds the data of an already loaded file. The file must be first loaded
     * by using {@link module:upload/filereader~FileReader#read `read()`}.
     */
    get data() {
      return this._data;
    }
    /**
     * Reads the provided file.
     *
     * @param file Native File object.
     * @returns Returns a promise that will be resolved with file's content.
     * The promise will be rejected in case of an error or when the reading process is aborted.
     */
    read(e) {
      const t = this._reader;
      return this.total = e.size, new Promise((i, s) => {
        t.onload = () => {
          const o = t.result;
          this._data = o, i(o);
        }, t.onerror = () => {
          s("error");
        }, t.onabort = () => {
          s("aborted");
        }, this._reader.readAsDataURL(e);
      });
    }
    /**
     * Aborts file reader.
     */
    abort() {
      this._reader.abort();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ui extends w {
    constructor() {
      super(...arguments), this.loaders = new Ce(), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null;
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "FileRepository";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Vu];
    }
    /**
     * @inheritDoc
     */
    init() {
      this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e, t) => t ? e / t * 100 : 0);
    }
    /**
     * Returns the loader associated with specified file or promise.
     *
     * To get loader by id use `fileRepository.loaders.get( id )`.
     *
     * @param fileOrPromise Native file or promise handle.
     */
    getLoader(e) {
      return this._loadersMap.get(e) || null;
    }
    /**
     * Creates a loader instance for the given file.
     *
     * Requires {@link #createUploadAdapter} factory to be defined.
     *
     * @param fileOrPromise Native File object or native Promise object which resolves to a File.
     */
    createLoader(e) {
      if (!this.createUploadAdapter)
        return z("filerepository-no-upload-adapter"), null;
      const t = new zh(Promise.resolve(e), this.createUploadAdapter);
      return this.loaders.add(t), this._loadersMap.set(e, t), e instanceof Promise && t.file.then((i) => {
        this._loadersMap.set(i, t);
      }).catch(() => {
      }), t.on("change:uploaded", () => {
        let i = 0;
        for (const s of this.loaders)
          i += s.uploaded;
        this.uploaded = i;
      }), t.on("change:uploadTotal", () => {
        let i = 0;
        for (const s of this.loaders)
          s.uploadTotal && (i += s.uploadTotal);
        this.uploadTotal = i;
      }), t;
    }
    /**
     * Destroys the given loader.
     *
     * @param fileOrPromiseOrLoader File or Promise associated with that loader or loader itself.
     */
    destroyLoader(e) {
      const t = e instanceof zh ? e : this.getLoader(e);
      t._destroy(), this.loaders.remove(t), this._loadersMap.forEach((i, s) => {
        i === t && this._loadersMap.delete(s);
      });
    }
    /**
     * Registers or deregisters pending action bound with upload progress.
     */
    _updatePendingAction() {
      const e = this.editor.plugins.get(Vu);
      if (this.loaders.length) {
        if (!this._pendingAction) {
          const t = this.editor.t, i = (s) => `${t("Upload in progress")} ${parseInt(s)}%.`;
          this._pendingAction = e.add(i(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", i);
        }
      } else
        e.remove(this._pendingAction), this._pendingAction = null;
    }
  }
  class zh extends $() {
    /**
     * Creates a new instance of `FileLoader`.
     *
     * @param filePromise A promise which resolves to a file instance.
     * @param uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.
     */
    constructor(e, t) {
      super(), this.id = Ze(), this._filePromiseWrapper = this._createFilePromiseWrapper(e), this._adapter = t(this), this._reader = new uM(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (i, s) => s ? i / s * 100 : 0), this.set("uploadResponse", null);
    }
    /**
     * A `Promise` which resolves to a `File` instance associated with this file loader.
     */
    get file() {
      return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((e) => this._filePromiseWrapper ? e : null) : Promise.resolve(null);
    }
    /**
     * Returns the file data. To read its data, you need for first load the file
     * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.
     */
    get data() {
      return this._reader.data;
    }
    /**
     * Reads file using {@link module:upload/filereader~FileReader}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status
     * is different than `idle`.
     *
     * Example usage:
     *
     * ```ts
     * fileLoader.read()
     * 	.then( data => { ... } )
     * 	.catch( err => {
     * 		if ( err === 'aborted' ) {
     * 			console.log( 'Reading aborted.' );
     * 		} else {
     * 			console.log( 'Reading error.', err );
     * 		}
     * 	} );
     * ```
     *
     * @returns Returns promise that will be resolved with read data. Promise will be rejected if error
     * occurs or if read process is aborted.
     */
    read() {
      if (this.status != "idle")
        throw new g("filerepository-read-wrong-status", this);
      return this.status = "reading", this.file.then((e) => this._reader.read(e)).then((e) => {
        if (this.status !== "reading")
          throw this.status;
        return this.status = "idle", e;
      }).catch((e) => {
        throw e === "aborted" ? (this.status = "aborted", "aborted") : (this.status = "error", this._reader.error ? this._reader.error : e);
      });
    }
    /**
     * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status
     * is different than `idle`.
     * Example usage:
     *
     * ```ts
     * fileLoader.upload()
     * 	.then( data => { ... } )
     * 	.catch( e => {
     * 		if ( e === 'aborted' ) {
     * 			console.log( 'Uploading aborted.' );
     * 		} else {
     * 			console.log( 'Uploading error.', e );
     * 		}
     * 	} );
     * ```
     *
     * @returns Returns promise that will be resolved with response data. Promise will be rejected if error
     * occurs or if read process is aborted.
     */
    upload() {
      if (this.status != "idle")
        throw new g("filerepository-upload-wrong-status", this);
      return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((e) => (this.uploadResponse = e, this.status = "idle", e)).catch((e) => {
        throw this.status === "aborted" ? "aborted" : (this.status = "error", e);
      });
    }
    /**
     * Aborts loading process.
     */
    abort() {
      const e = this.status;
      this.status = "aborted", this._filePromiseWrapper.isFulfilled ? e == "reading" ? this._reader.abort() : e == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
      }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
    }
    /**
     * Performs cleanup.
     *
     * @internal
     */
    _destroy() {
      this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
    }
    /**
     * Wraps a given file promise into another promise giving additional
     * control (resolving, rejecting, checking if fulfilled) over it.
     *
     * @param filePromise The initial file promise to be wrapped.
     */
    _createFilePromiseWrapper(e) {
      const t = {};
      return t.promise = new Promise((i, s) => {
        t.rejecter = s, t.isFulfilled = !1, e.then((o) => {
          t.isFulfilled = !0, i(o);
        }).catch((o) => {
          t.isFulfilled = !0, s(o);
        });
      }), t;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class dM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [ui];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "Base64UploadAdapter";
    }
    /**
     * @inheritDoc
     */
    init() {
      this.editor.plugins.get(ui).createUploadAdapter = (e) => new hM(e);
    }
  }
  class hM {
    /**
     * Creates a new adapter instance.
     */
    constructor(e) {
      this.loader = e;
    }
    /**
     * Starts the upload process.
     *
     * @see module:upload/filerepository~UploadAdapter#upload
     */
    upload() {
      return new Promise((e, t) => {
        const i = this.reader = new window.FileReader();
        i.addEventListener("load", () => {
          e({ default: i.result });
        }), i.addEventListener("error", (s) => {
          t(s);
        }), i.addEventListener("abort", () => {
          t();
        }), this.loader.file.then((s) => {
          i.readAsDataURL(s);
        });
      });
    }
    /**
     * Aborts the upload process.
     *
     * @see module:upload/filerepository~UploadAdapter#abort
     */
    abort() {
      this.reader.abort();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class fM extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageUploadProgress";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this.uploadStatusChange = (t, i, s) => {
        const o = this.editor, r = i.item, a = r.getAttribute("uploadId");
        if (!s.consumable.consume(i.item, t.name))
          return;
        const l = o.plugins.get("ImageUtils"), c = o.plugins.get(ui), u = a ? i.attributeNewValue : null, d = this.placeholder, h = o.editing.mapper.toViewElement(r), f = s.writer;
        if (u == "reading") {
          Uh(h, f), Hh(l, d, h, f);
          return;
        }
        if (u == "uploading") {
          const m = c.loaders.get(a);
          Uh(h, f), m ? ($h(h, f), gM(h, f, m, o.editing.view), vM(l, h, f, m)) : Hh(l, d, h, f);
          return;
        }
        u == "complete" && c.loaders.get(a) && wM(h, f, o.editing.view), pM(h, f), $h(h, f), mM(h, f);
      }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor;
      e.plugins.has("ImageBlockEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), e.plugins.has("ImageInlineEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
    }
  }
  function Uh(n, e) {
    n.hasClass("ck-appear") || e.addClass("ck-appear", n);
  }
  function mM(n, e) {
    e.removeClass("ck-appear", n);
  }
  function Hh(n, e, t, i) {
    t.hasClass("ck-image-upload-placeholder") || i.addClass("ck-image-upload-placeholder", t);
    const s = n.findViewImgElement(t);
    s.getAttribute("src") !== e && i.setAttribute("src", e, s), gw(t, "placeholder") || i.insert(i.createPositionAfter(s), _M(i));
  }
  function $h(n, e) {
    n.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", n), pw(n, e, "placeholder");
  }
  function gM(n, e, t, i) {
    const s = bM(e);
    e.insert(e.createPositionAt(n, "end"), s), t.on("change:uploadedPercent", (o, r, a) => {
      i.change((l) => {
        l.setStyle("width", a + "%", s);
      });
    });
  }
  function pM(n, e) {
    pw(n, e, "progressBar");
  }
  function wM(n, e, t) {
    const i = e.createUIElement("div", { class: "ck-image-upload-complete-icon" });
    e.insert(e.createPositionAt(n, "end"), i), setTimeout(() => {
      t.change((s) => s.remove(s.createRangeOn(i)));
    }, 3e3);
  }
  function bM(n) {
    const e = n.createUIElement("div", { class: "ck-progress-bar" });
    return n.setCustomProperty("progressBar", !0, e), e;
  }
  function _M(n) {
    const e = n.createUIElement("div", { class: "ck-upload-placeholder-loader" });
    return n.setCustomProperty("placeholder", !0, e), e;
  }
  function gw(n, e) {
    for (const t of n.getChildren())
      if (t.getCustomProperty(e))
        return t;
  }
  function pw(n, e, t) {
    const i = gw(n, t);
    i && e.remove(e.createRangeOn(i));
  }
  function vM(n, e, t, i) {
    if (i.data) {
      const s = n.findViewImgElement(e);
      t.setAttribute("src", i.data, s);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class yM extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor, t = e.plugins.get("ImageUtils"), i = e.model.document.selection.getSelectedElement();
      this.isEnabled = t.isImageAllowed() || t.isImage(i);
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param options Options for the executed command.
     * @param options.file The image file or an array of image files to upload.
     */
    execute(e) {
      const t = Z(e.file), i = this.editor.model.document.selection, s = this.editor.plugins.get("ImageUtils"), o = Object.fromEntries(i.getAttributes());
      t.forEach((r, a) => {
        const l = i.getSelectedElement();
        if (a && l && s.isImage(l)) {
          const c = this.editor.model.createPositionAfter(l);
          this._uploadImage(r, o, c);
        } else
          this._uploadImage(r, o);
      });
    }
    /**
     * Handles uploading single file.
     */
    _uploadImage(e, t, i) {
      const s = this.editor, r = s.plugins.get(ui).createLoader(e), a = s.plugins.get("ImageUtils");
      r && a.insertImage({ ...t, uploadId: r.id }, i);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class CM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [ui, od, Xe, Ae];
    }
    static get pluginName() {
      return "ImageUploadEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("image", {
        upload: {
          types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]
        }
      }), this._uploadImageElements = /* @__PURE__ */ new Map();
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.model.document, i = e.conversion, s = e.plugins.get(ui), o = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline"), a = fw(e.config.get("image.upload.types")), l = new yM(e);
      e.commands.add("uploadImage", l), e.commands.add("imageUpload", l), i.for("upcast").attributeToAttribute({
        view: {
          name: "img",
          key: "uploadId"
        },
        model: "uploadId"
      }), this.listenTo(e.editing.view.document, "clipboardInput", (c, u) => {
        if (kM(u.dataTransfer))
          return;
        const d = Array.from(u.dataTransfer.files).filter((h) => h ? a.test(h.type) : !1);
        d.length && (c.stop(), e.model.change((h) => {
          u.targetRanges && h.setSelection(u.targetRanges.map((f) => e.editing.mapper.toModelRange(f))), e.execute("uploadImage", { file: d });
        }));
      }), this.listenTo(r, "inputTransformation", (c, u) => {
        const d = Array.from(e.editing.view.createRangeIn(u.content)).map((f) => f.item).filter((f) => rM(o, f) && !f.getAttribute("uploadProcessed")).map((f) => ({ promise: oM(f), imageElement: f }));
        if (!d.length)
          return;
        const h = new Mt(e.editing.view.document);
        for (const f of d) {
          h.setAttribute("uploadProcessed", !0, f.imageElement);
          const m = s.createLoader(f.promise);
          m && (h.setAttribute("src", "", f.imageElement), h.setAttribute("uploadId", m.id, f.imageElement));
        }
      }), e.editing.view.document.on("dragover", (c, u) => {
        u.preventDefault();
      }), t.on("change", () => {
        const c = t.differ.getChanges({ includeChangesInGraveyard: !0 }).reverse(), u = /* @__PURE__ */ new Set();
        for (const d of c)
          if (d.type == "insert" && d.name != "$text") {
            const h = d.position.nodeAfter, f = d.position.root.rootName == "$graveyard";
            for (const m of TM(e, h)) {
              const p = m.getAttribute("uploadId");
              if (!p)
                continue;
              const b = s.loaders.get(p);
              b && (f ? u.has(p) || b.abort() : (u.add(p), this._uploadImageElements.set(p, m), b.status == "idle" && this._readAndUpload(b)));
            }
          }
      }), this.on("uploadComplete", (c, { imageElement: u, data: d }) => {
        const h = d.urls ? d.urls : d;
        this.editor.model.change((f) => {
          f.setAttribute("src", h.default, u), this._parseAndSetSrcsetAttributeOnImage(h, u, f), o.setImageNaturalSizeAttributes(u);
        });
      }, { priority: "low" });
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      const e = this.editor.model.schema;
      this.editor.plugins.has("ImageBlockEditing") && e.extend("imageBlock", {
        allowAttributes: ["uploadId", "uploadStatus"]
      }), this.editor.plugins.has("ImageInlineEditing") && e.extend("imageInline", {
        allowAttributes: ["uploadId", "uploadStatus"]
      });
    }
    /**
     * Reads and uploads an image.
     *
     * The image is read from the disk and as a Base64-encoded string it is set temporarily to
     * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target
     * image's URL (the URL to the uploaded image on the server).
     */
    _readAndUpload(e) {
      const t = this.editor, i = t.model, s = t.locale.t, o = t.plugins.get(ui), r = t.plugins.get(od), a = t.plugins.get("ImageUtils"), l = this._uploadImageElements;
      return i.enqueueChange({ isUndoable: !1 }, (u) => {
        u.setAttribute("uploadStatus", "reading", l.get(e.id));
      }), e.read().then(() => {
        const u = e.upload(), d = l.get(e.id);
        /* istanbul ignore next -- @preserve */
        if (B.isSafari) {
          const h = t.editing.mapper.toViewElement(d), f = a.findViewImgElement(h);
          t.editing.view.once("render", () => {
            if (!f.parent)
              return;
            const m = t.editing.view.domConverter.mapViewToDom(f.parent);
            if (!m)
              return;
            const p = m.style.display;
            m.style.display = "none", m._ckHack = m.offsetHeight, m.style.display = p;
          });
        }
        return i.enqueueChange({ isUndoable: !1 }, (h) => {
          h.setAttribute("uploadStatus", "uploading", d);
        }), u;
      }).then((u) => {
        i.enqueueChange({ isUndoable: !1 }, (d) => {
          const h = l.get(e.id);
          d.setAttribute("uploadStatus", "complete", h), this.fire("uploadComplete", { data: u, imageElement: h });
        }), c();
      }).catch((u) => {
        if (e.status !== "error" && e.status !== "aborted")
          throw u;
        e.status == "error" && u && r.showWarning(u, {
          title: s("Upload failed"),
          namespace: "upload"
        }), i.enqueueChange({ isUndoable: !1 }, (d) => {
          d.remove(l.get(e.id));
        }), c();
      });
      function c() {
        i.enqueueChange({ isUndoable: !1 }, (u) => {
          const d = l.get(e.id);
          u.removeAttribute("uploadId", d), u.removeAttribute("uploadStatus", d), l.delete(e.id);
        }), o.destroyLoader(e);
      }
    }
    /**
     * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.
     *
     * @param data Data object from which `srcset` will be created.
     * @param image The image element on which the `srcset` attribute will be set.
     */
    _parseAndSetSrcsetAttributeOnImage(e, t, i) {
      let s = 0;
      const o = Object.keys(e).filter((r) => {
        const a = parseInt(r, 10);
        if (!isNaN(a))
          return s = Math.max(s, a), !0;
      }).map((r) => `${e[r]} ${r}w`).join(", ");
      if (o != "") {
        const r = {
          srcset: o
        };
        !t.hasAttribute("width") && !t.hasAttribute("height") && (r.width = s), i.setAttributes(r, t);
      }
    }
  }
  function kM(n) {
    return Array.from(n.types).includes("text/html") && n.getData("text/html") !== "";
  }
  function TM(n, e) {
    const t = n.plugins.get("ImageUtils");
    return Array.from(n.model.createRangeOn(e)).filter((i) => t.isImage(i.item)).map((i) => i.item);
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class ww extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageUpload";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [CM, cM, fM];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class EM extends T {
    /**
     * Creates a view for the dropdown panel of {@link module:image/imageinsert/imageinsertui~ImageInsertUI}.
     *
     * @param locale The localization services instance.
     */
    constructor(e) {
      super(e), this.set("imageURLInputValue", ""), this.set("isImageSelected", !1), this.set("isEnabled", !0), this.focusTracker = new Q(), this.keystrokes = new ne(), this._focusables = new ke(), this.focusCycler = new _e({
        focusables: this._focusables,
        focusTracker: this.focusTracker,
        keystrokeHandler: this.keystrokes,
        actions: {
          // Navigate form fields backwards using the Shift + Tab keystroke.
          focusPrevious: "shift + tab",
          // Navigate form fields forwards using the Tab key.
          focusNext: "tab"
        }
      }), this.urlInputView = this._createUrlInputView(), this.insertButtonView = this._createInsertButton(), this.cancelButtonView = this._createCancelButton(), this._focusables.addMany([
        this.urlInputView,
        this.insertButtonView,
        this.cancelButtonView
      ]), this.setTemplate({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-image-insert-url"
          ]
        },
        children: [
          this.urlInputView,
          {
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-image-insert-url__action-row"
              ]
            },
            children: [
              this.insertButtonView,
              this.cancelButtonView
            ]
          }
        ]
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render();
      for (const e of this._focusables)
        this.focusTracker.add(e.element);
      this.keystrokes.listenTo(this.element);
    }
    /**
     * @inheritDoc
     */
    destroy() {
      super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
    }
    /**
     * Creates the {@link #urlInputView}.
     */
    _createUrlInputView() {
      const e = this.locale, t = e.t, i = new he(e, ze);
      return i.bind("label").to(this, "isImageSelected", (s) => t(s ? "Update image URL" : "Insert image via URL")), i.bind("isEnabled").to(this), i.fieldView.placeholder = "https://example.com/image.png", i.fieldView.bind("value").to(this, "imageURLInputValue", (s) => s || ""), i.fieldView.on("input", () => {
        this.imageURLInputValue = i.fieldView.element.value.trim();
      }), i;
    }
    /**
     * Creates the {@link #insertButtonView}.
     */
    _createInsertButton() {
      const e = this.locale, t = e.t, i = new P(e);
      return i.set({
        icon: x.check,
        class: "ck-button-save",
        type: "submit",
        withText: !0
      }), i.bind("label").to(this, "isImageSelected", (s) => t(s ? "Update" : "Insert")), i.bind("isEnabled").to(this, "imageURLInputValue", this, "isEnabled", (...s) => s.every((o) => o)), i.delegate("execute").to(this, "submit"), i;
    }
    /**
     * Creates the {@link #cancelButtonView}.
     */
    _createCancelButton() {
      const e = this.locale, t = e.t, i = new P(e);
      return i.set({
        label: t("Cancel"),
        icon: x.cancel,
        class: "ck-button-cancel",
        withText: !0
      }), i.bind("isEnabled").to(this), i.delegate("execute").to(this, "cancel"), i;
    }
    /**
     * Focuses the view.
     */
    focus(e) {
      e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst();
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class AM extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageInsertViaUrlUI";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [As];
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      this._imageInsertUI = this.editor.plugins.get("ImageInsertUI"), this._imageInsertUI.registerIntegration({
        name: "url",
        observable: () => this.editor.commands.get("insertImage"),
        requiresForm: !0,
        buttonViewCreator: (e) => this._createInsertUrlButton(e),
        formViewCreator: (e) => this._createInsertUrlView(e)
      });
    }
    /**
     * Creates the view displayed in the dropdown.
     */
    _createInsertUrlView(e) {
      const t = this.editor, i = t.locale, s = i.t, o = t.commands.get("replaceImageSource"), r = t.commands.get("insertImage"), a = new EM(i), l = e ? null : new ug(i, [a]);
      return a.bind("isImageSelected").to(this._imageInsertUI), a.bind("isEnabled").toMany([r, o], "isEnabled", (...c) => c.some((u) => u)), a.imageURLInputValue = o.value || "", this._imageInsertUI.dropdownView.on("change:isOpen", () => {
        this._imageInsertUI.dropdownView.isOpen && (a.imageURLInputValue = o.value || "", l && (l.isCollapsed = !0));
      }, { priority: "low" }), a.on("submit", () => {
        o.isEnabled ? t.execute("replaceImageSource", { source: a.imageURLInputValue }) : t.execute("insertImage", { source: a.imageURLInputValue }), this._closePanel();
      }), a.on("cancel", () => this._closePanel()), l ? (l.set({
        isCollapsed: !0
      }), l.bind("label").to(this._imageInsertUI, "isImageSelected", (c) => s(c ? "Update image URL" : "Insert image via URL")), l) : a;
    }
    /**
     * Creates the toolbar button.
     */
    _createInsertUrlButton(e) {
      const t = e ? Sl : P, i = this.editor, s = new t(i.locale), o = i.locale.t;
      return s.set({
        icon: x.imageUrl,
        tooltip: !0
      }), s.bind("label").to(this._imageInsertUI, "isImageSelected", (r) => o(r ? "Update image URL" : "Insert image via URL")), s;
    }
    /**
     * Closes the dropdown.
     */
    _closePanel() {
      this.editor.editing.view.focus(), this._imageInsertUI.dropdownView.isOpen = !1;
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class xM extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageInsertViaUrl";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [AM, As];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class SM extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageInsert";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [ww, xM, As];
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class IM extends V {
    /**
     * @inheritDoc
     */
    refresh() {
      const e = this.editor, i = e.plugins.get("ImageUtils").getClosestSelectedImageElement(e.model.document.selection);
      this.isEnabled = !!i, !i || !i.hasAttribute("resizedWidth") ? this.value = null : this.value = {
        width: i.getAttribute("resizedWidth"),
        height: null
      };
    }
    /**
     * Executes the command.
     *
     * ```ts
     * // Sets the width to 50%:
     * editor.execute( 'resizeImage', { width: '50%' } );
     *
     * // Removes the width attribute:
     * editor.execute( 'resizeImage', { width: null } );
     * ```
     *
     * @param options
     * @param options.width The new width of the image.
     * @fires execute
     */
    execute(e) {
      const t = this.editor, i = t.model, s = t.plugins.get("ImageUtils"), o = s.getClosestSelectedImageElement(i.document.selection);
      this.value = {
        width: e.width,
        height: null
      }, o && i.change((r) => {
        r.setAttribute("resizedWidth", e.width, o), r.removeAttribute("resizedHeight", o), s.setImageNaturalSizeAttributes(o);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class bw extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageResizeEditing";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), e.config.define("image", {
        resizeUnit: "%",
        resizeOptions: [
          {
            name: "resizeImage:original",
            value: null,
            icon: "original"
          },
          {
            name: "resizeImage:25",
            value: "25",
            icon: "small"
          },
          {
            name: "resizeImage:50",
            value: "50",
            icon: "medium"
          },
          {
            name: "resizeImage:75",
            value: "75",
            icon: "large"
          }
        ]
      });
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = new IM(e);
      this._registerConverters("imageBlock"), this._registerConverters("imageInline"), e.commands.add("resizeImage", t), e.commands.add("imageResize", t);
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      this._registerSchema();
    }
    _registerSchema() {
      this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["resizedWidth", "resizedHeight"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["resizedWidth", "resizedHeight"] });
    }
    /**
     * Registers image resize converters.
     *
     * @param imageType The type of the image.
     */
    _registerConverters(e) {
      const t = this.editor, i = t.plugins.get("ImageUtils");
      t.conversion.for("downcast").add((s) => s.on(`attribute:resizedWidth:${e}`, (o, r, a) => {
        if (!a.consumable.consume(r.item, o.name))
          return;
        const l = a.writer, c = a.mapper.toViewElement(r.item);
        r.attributeNewValue !== null ? (l.setStyle("width", r.attributeNewValue, c), l.addClass("image_resized", c)) : (l.removeStyle("width", c), l.removeClass("image_resized", c));
      })), t.conversion.for("dataDowncast").attributeToAttribute({
        model: {
          name: e,
          key: "resizedHeight"
        },
        view: (s) => ({
          key: "style",
          value: {
            height: s
          }
        })
      }), t.conversion.for("editingDowncast").add((s) => s.on(`attribute:resizedHeight:${e}`, (o, r, a) => {
        if (!a.consumable.consume(r.item, o.name))
          return;
        const l = a.writer, c = a.mapper.toViewElement(r.item), u = e === "imageInline" ? i.findViewImgElement(c) : c;
        r.attributeNewValue !== null ? l.setStyle("height", r.attributeNewValue, u) : l.removeStyle("height", u);
      })), t.conversion.for("upcast").attributeToAttribute({
        view: {
          name: e === "imageBlock" ? "figure" : "img",
          styles: {
            width: /.+/
          }
        },
        model: {
          key: "resizedWidth",
          value: (s) => No(s) ? null : s.getStyle("width")
        }
      }), t.conversion.for("upcast").attributeToAttribute({
        view: {
          name: e === "imageBlock" ? "figure" : "img",
          styles: {
            height: /.+/
          }
        },
        model: {
          key: "resizedHeight",
          value: (s) => No(s) ? null : s.getStyle("height")
        }
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const qr = {
    small: x.objectSizeSmall,
    medium: x.objectSizeMedium,
    large: x.objectSizeLarge,
    original: x.objectSizeFull
  };
  class PM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [bw];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageResizeButtons";
    }
    /**
     * @inheritDoc
     */
    constructor(e) {
      super(e), this._resizeUnit = e.config.get("image.resizeUnit");
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor, t = e.config.get("image.resizeOptions"), i = e.commands.get("resizeImage");
      this.bind("isEnabled").to(i);
      for (const s of t)
        this._registerImageResizeButton(s);
      this._registerImageResizeDropdown(t);
    }
    /**
     * A helper function that creates a standalone button component for the plugin.
     *
     * @param resizeOption A model of the resize option.
     */
    _registerImageResizeButton(e) {
      const t = this.editor, { name: i, value: s, icon: o } = e, r = s ? s + this._resizeUnit : null;
      t.ui.componentFactory.add(i, (a) => {
        const l = new P(a), c = t.commands.get("resizeImage"), u = this._getOptionLabelValue(e, !0);
        if (!qr[o])
          throw new g("imageresizebuttons-missing-icon", t, e);
        return l.set({
          // Use the `label` property for a verbose description (because of ARIA).
          label: u,
          icon: qr[o],
          tooltip: u,
          isToggleable: !0
        }), l.bind("isEnabled").to(this), l.bind("isOn").to(c, "value", Wh(r)), this.listenTo(l, "execute", () => {
          t.execute("resizeImage", { width: r });
        }), l;
      });
    }
    /**
     * A helper function that creates a dropdown component for the plugin containing all the resize options defined in
     * the editor configuration.
     *
     * @param options An array of configured options.
     */
    _registerImageResizeDropdown(e) {
      const t = this.editor, i = t.t, s = e.find((r) => !r.value), o = (r) => {
        const a = t.commands.get("resizeImage"), l = we(r, Sl), c = l.buttonView, u = i("Resize image");
        return c.set({
          tooltip: u,
          commandValue: s.value,
          icon: qr.medium,
          isToggleable: !0,
          label: this._getOptionLabelValue(s),
          withText: !0,
          class: "ck-resize-image-button",
          ariaLabel: u,
          ariaLabelledBy: void 0
        }), c.bind("label").to(a, "value", (d) => d && d.width ? d.width : this._getOptionLabelValue(s)), l.bind("isEnabled").to(this), Kt(l, () => this._getResizeDropdownListItemDefinitions(e, a), {
          ariaLabel: i("Image resize list"),
          role: "menu"
        }), this.listenTo(l, "execute", (d) => {
          t.execute(d.source.commandName, { width: d.source.commandValue }), t.editing.view.focus();
        }), l;
      };
      t.ui.componentFactory.add("resizeImage", o), t.ui.componentFactory.add("imageResize", o);
    }
    /**
     * A helper function for creating an option label value string.
     *
     * @param option A resize option object.
     * @param forTooltip An optional flag for creating a tooltip label.
     * @returns A user-defined label combined from the numeric value and the resize unit or the default label
     * for reset options (`Original`).
     */
    _getOptionLabelValue(e, t = !1) {
      const i = this.editor.t;
      return e.label ? e.label : t ? e.value ? i("Resize image to %0", e.value + this._resizeUnit) : i("Resize image to the original size") : e.value ? e.value + this._resizeUnit : i("Original");
    }
    /**
     * A helper function that parses the resize options and returns list item definitions ready for use in the dropdown.
     *
     * @param options The resize options.
     * @param command The resize image command.
     * @returns Dropdown item definitions.
     */
    _getResizeDropdownListItemDefinitions(e, t) {
      const i = new Ce();
      return e.map((s) => {
        const o = s.value ? s.value + this._resizeUnit : null, r = {
          type: "button",
          model: new yi({
            commandName: "resizeImage",
            commandValue: o,
            label: this._getOptionLabelValue(s),
            role: "menuitemradio",
            withText: !0,
            icon: null
          })
        };
        r.model.bind("isOn").to(t, "value", Wh(o)), i.add(r);
      }), i;
    }
  }
  function Wh(n) {
    return (e) => {
      const t = e;
      return n === null && t === n ? !0 : t !== null && t.width === n;
    };
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const RM = "figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img", Gr = "image_resized";
  class LM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Fr, Ae];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageResizeHandles";
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor.commands.get("resizeImage");
      this.bind("isEnabled").to(e), this._setupResizerCreator();
    }
    /**
     * Attaches the listeners responsible for creating a resizer for each image, except for images inside the HTML embed preview.
     */
    _setupResizerCreator() {
      const e = this.editor, t = e.editing.view, i = e.plugins.get("ImageUtils");
      t.addObserver(Xl), this.listenTo(t.document, "imageLoaded", (s, o) => {
        if (!o.target.matches(RM))
          return;
        const r = e.editing.view.domConverter, a = r.domToView(o.target), l = i.getImageWidgetFromImageView(a);
        let c = this.editor.plugins.get(Fr).getResizerByViewElement(l);
        if (c) {
          c.redraw();
          return;
        }
        const u = e.editing.mapper, d = u.toModelElement(l);
        c = e.plugins.get(Fr).attachTo({
          unit: e.config.get("image.resizeUnit"),
          modelElement: d,
          viewElement: l,
          editor: e,
          getHandleHost(h) {
            return h.querySelector("img");
          },
          getResizeHost() {
            return r.mapViewToDom(u.toViewElement(d.parent));
          },
          isCentered() {
            return d.getAttribute("imageStyle") == "alignCenter";
          },
          onCommit(h) {
            t.change((f) => {
              f.removeClass(Gr, l);
            }), e.execute("resizeImage", { width: h });
          }
        }), c.on("updateSize", () => {
          l.hasClass(Gr) || t.change((f) => {
            f.addClass(Gr, l);
          });
          const h = d.name === "imageInline" ? a : l;
          h.getStyle("height") && t.change((f) => {
            f.removeStyle("height", h);
          });
        }), c.bind("isEnabled").to(this);
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class VM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [bw, LM, PM];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageResize";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class MM extends V {
    /**
     * Creates an instance of the image style command. When executed, the command applies one of
     * {@link module:image/imageconfig~ImageStyleConfig#options style options} to the currently selected image.
     *
     * @param editor The editor instance.
     * @param styles The style options that this command supports.
     */
    constructor(e, t) {
      super(e), this._defaultStyles = {
        imageBlock: !1,
        imageInline: !1
      }, this._styles = new Map(t.map((i) => {
        if (i.isDefault)
          for (const s of i.modelElements)
            this._defaultStyles[s] = i.name;
        return [i.name, i];
      }));
    }
    /**
     * @inheritDoc
     */
    refresh() {
      const i = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
      this.isEnabled = !!i, this.isEnabled ? i.hasAttribute("imageStyle") ? this.value = i.getAttribute("imageStyle") : this.value = this._defaultStyles[i.name] : this.value = !1;
    }
    /**
     * Executes the command and applies the style to the currently selected image:
     *
     * ```ts
     * editor.execute( 'imageStyle', { value: 'side' } );
     * ```
     *
     * **Note**: Executing this command may change the image model element if the desired style requires an image
     * of a different type. Learn more about {@link module:image/imageconfig~ImageStyleOptionDefinition#modelElements model element}
     * configuration for the style option.
     *
     * @param options.value The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
     * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
     * The default is `true`.
     * @fires execute
     */
    execute(e = {}) {
      const t = this.editor, i = t.model, s = t.plugins.get("ImageUtils");
      i.change((o) => {
        const r = e.value, { setImageSizes: a = !0 } = e;
        let l = s.getClosestSelectedImageElement(i.document.selection);
        r && this.shouldConvertImageType(r, l) && (this.editor.execute(s.isBlockImage(l) ? "imageTypeInline" : "imageTypeBlock", { setImageSizes: a }), l = s.getClosestSelectedImageElement(i.document.selection)), !r || this._styles.get(r).isDefault ? o.removeAttribute("imageStyle", l) : o.setAttribute("imageStyle", r, l), a && s.setImageNaturalSizeAttributes(l);
      });
    }
    /**
     * Returns `true` if requested style change would trigger the image type change.
     *
     * @param requestedStyle The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
     * @param imageElement The image model element.
     */
    shouldConvertImageType(e, t) {
      return !this._styles.get(e).modelElements.includes(t.name);
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  const { objectFullWidth: BM, objectInline: _w, objectLeft: vw, objectRight: Ha, objectCenter: $a, objectBlockLeft: yw, objectBlockRight: Cw } = x, mo = {
    // This style represents an image placed in the line of text.
    get inline() {
      return {
        name: "inline",
        title: "In line",
        icon: _w,
        modelElements: ["imageInline"],
        isDefault: !0
      };
    },
    // This style represents an image aligned to the left and wrapped with text.
    get alignLeft() {
      return {
        name: "alignLeft",
        title: "Left aligned image",
        icon: vw,
        modelElements: ["imageBlock", "imageInline"],
        className: "image-style-align-left"
      };
    },
    // This style represents an image aligned to the left.
    get alignBlockLeft() {
      return {
        name: "alignBlockLeft",
        title: "Left aligned image",
        icon: yw,
        modelElements: ["imageBlock"],
        className: "image-style-block-align-left"
      };
    },
    // This style represents a centered image.
    get alignCenter() {
      return {
        name: "alignCenter",
        title: "Centered image",
        icon: $a,
        modelElements: ["imageBlock"],
        className: "image-style-align-center"
      };
    },
    // This style represents an image aligned to the right and wrapped with text.
    get alignRight() {
      return {
        name: "alignRight",
        title: "Right aligned image",
        icon: Ha,
        modelElements: ["imageBlock", "imageInline"],
        className: "image-style-align-right"
      };
    },
    // This style represents an image aligned to the right.
    get alignBlockRight() {
      return {
        name: "alignBlockRight",
        title: "Right aligned image",
        icon: Cw,
        modelElements: ["imageBlock"],
        className: "image-style-block-align-right"
      };
    },
    // This option is equal to the situation when no style is applied.
    get block() {
      return {
        name: "block",
        title: "Centered image",
        icon: $a,
        modelElements: ["imageBlock"],
        isDefault: !0
      };
    },
    // This represents a side image.
    get side() {
      return {
        name: "side",
        title: "Side image",
        icon: Ha,
        modelElements: ["imageBlock"],
        className: "image-style-side"
      };
    }
  }, kw = {
    full: BM,
    left: yw,
    right: Cw,
    center: $a,
    inlineLeft: vw,
    inlineRight: Ha,
    inline: _w
  }, Tw = [{
    name: "imageStyle:wrapText",
    title: "Wrap text",
    defaultItem: "imageStyle:alignLeft",
    items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
  }, {
    name: "imageStyle:breakText",
    title: "Break text",
    defaultItem: "imageStyle:block",
    items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
  }];
  function OM(n) {
    return (n.configuredStyles.options || []).map((i) => FM(i)).filter((i) => zM(i, n));
  }
  function NM(n, e) {
    return n && e ? {
      options: [
        "inline",
        "alignLeft",
        "alignRight",
        "alignCenter",
        "alignBlockLeft",
        "alignBlockRight",
        "block",
        "side"
      ]
    } : n ? {
      options: ["block", "side"]
    } : e ? {
      options: ["inline", "alignLeft", "alignRight"]
    } : {};
  }
  function DM(n) {
    return n.has("ImageBlockEditing") && n.has("ImageInlineEditing") ? [...Tw] : [];
  }
  function FM(n) {
    return typeof n == "string" ? mo[n] ? n = { ...mo[n] } : n = { name: n } : n = UM(mo[n.name], n), typeof n.icon == "string" && (n.icon = kw[n.icon] || n.icon), n;
  }
  function zM(n, { isBlockPluginLoaded: e, isInlinePluginLoaded: t }) {
    const { modelElements: i, name: s } = n;
    if (!i || !i.length || !s)
      return Ew({ style: n }), !1;
    {
      const o = [e ? "imageBlock" : null, t ? "imageInline" : null];
      if (!i.some((r) => o.includes(r)))
        return z("image-style-missing-dependency", {
          style: n,
          missingPlugins: i.map((r) => r === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")
        }), !1;
    }
    return !0;
  }
  function UM(n, e) {
    const t = { ...e };
    for (const i in n)
      Object.prototype.hasOwnProperty.call(e, i) || (t[i] = n[i]);
    return t;
  }
  function Ew(n) {
    z("image-style-configuration-definition-invalid", n);
  }
  const Wa = {
    normalizeStyles: OM,
    getDefaultStylesConfiguration: NM,
    getDefaultDropdownDefinitions: DM,
    warnInvalidStyle: Ew,
    DEFAULT_OPTIONS: mo,
    DEFAULT_ICONS: kw,
    DEFAULT_DROPDOWN_DEFINITIONS: Tw
  };
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  function HM(n) {
    return (e, t, i) => {
      if (!i.consumable.consume(t.item, e.name))
        return;
      const s = qh(t.attributeNewValue, n), o = qh(t.attributeOldValue, n), r = i.mapper.toViewElement(t.item), a = i.writer;
      o && a.removeClass(o.className, r), s && a.addClass(s.className, r);
    };
  }
  function $M(n) {
    const e = {
      imageInline: n.filter((t) => !t.isDefault && t.modelElements.includes("imageInline")),
      imageBlock: n.filter((t) => !t.isDefault && t.modelElements.includes("imageBlock"))
    };
    return (t, i, s) => {
      if (!i.modelRange)
        return;
      const o = i.viewItem, r = me(i.modelRange.getItems());
      if (r && s.schema.checkAttribute(r, "imageStyle"))
        for (const a of e[r.name])
          s.consumable.consume(o, { classes: a.className }) && s.writer.setAttribute("imageStyle", a.name, r);
    };
  }
  function qh(n, e) {
    for (const t of e)
      if (t.name === n)
        return t;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class Aw extends w {
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageStyleEditing";
    }
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Ae];
    }
    /**
     * @inheritDoc
     */
    init() {
      const { normalizeStyles: e, getDefaultStylesConfiguration: t } = Wa, i = this.editor, s = i.plugins.has("ImageBlockEditing"), o = i.plugins.has("ImageInlineEditing");
      i.config.define("image.styles", t(s, o)), this.normalizedStyles = e({
        configuredStyles: i.config.get("image.styles"),
        isBlockPluginLoaded: s,
        isInlinePluginLoaded: o
      }), this._setupConversion(s, o), this._setupPostFixer(), i.commands.add("imageStyle", new MM(i, this.normalizedStyles));
    }
    /**
     * Sets the editor conversion taking the presence of
     * {@link module:image/image/imageinlineediting~ImageInlineEditing `ImageInlineEditing`}
     * and {@link module:image/image/imageblockediting~ImageBlockEditing `ImageBlockEditing`} plugins into consideration.
     */
    _setupConversion(e, t) {
      const i = this.editor, s = i.model.schema, o = HM(this.normalizedStyles), r = $M(this.normalizedStyles);
      i.editing.downcastDispatcher.on("attribute:imageStyle", o), i.data.downcastDispatcher.on("attribute:imageStyle", o), e && (s.extend("imageBlock", { allowAttributes: "imageStyle" }), i.data.upcastDispatcher.on("element:figure", r, { priority: "low" })), t && (s.extend("imageInline", { allowAttributes: "imageStyle" }), i.data.upcastDispatcher.on("element:img", r, { priority: "low" }));
    }
    /**
     * Registers a post-fixer that will make sure that the style attribute value is correct for a specific image type (block vs inline).
     */
    _setupPostFixer() {
      const e = this.editor, t = e.model.document, i = e.plugins.get(Ae), s = new Map(this.normalizedStyles.map((o) => [o.name, o]));
      t.registerPostFixer((o) => {
        let r = !1;
        for (const a of t.differ.getChanges())
          if (a.type == "insert" || a.type == "attribute" && a.attributeKey == "imageStyle") {
            let l = a.type == "insert" ? a.position.nodeAfter : a.range.start.nodeAfter;
            if (l && l.is("element", "paragraph") && l.childCount > 0 && (l = l.getChild(0)), !i.isImage(l))
              continue;
            const c = l.getAttribute("imageStyle");
            if (!c)
              continue;
            const u = s.get(c);
            (!u || !u.modelElements.includes(l.name)) && (o.removeAttribute("imageStyle", l), r = !0);
          }
        return r;
      });
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class WM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Aw];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageStyleUI";
    }
    /**
     * Returns the default localized style titles provided by the plugin.
     *
     * The following localized titles corresponding with
     * {@link module:image/imagestyle/utils#DEFAULT_OPTIONS} are available:
     *
     * * `'Wrap text'`,
     * * `'Break text'`,
     * * `'In line'`,
     * * `'Full size image'`,
     * * `'Side image'`,
     * * `'Left aligned image'`,
     * * `'Centered image'`,
     * * `'Right aligned image'`
     */
    get localizedDefaultStylesTitles() {
      const e = this.editor.t;
      return {
        "Wrap text": e("Wrap text"),
        "Break text": e("Break text"),
        "In line": e("In line"),
        "Full size image": e("Full size image"),
        "Side image": e("Side image"),
        "Left aligned image": e("Left aligned image"),
        "Centered image": e("Centered image"),
        "Right aligned image": e("Right aligned image")
      };
    }
    /**
     * @inheritDoc
     */
    init() {
      const e = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [], i = e.get("ImageStyleEditing"), s = Gh(i.normalizedStyles, this.localizedDefaultStylesTitles);
      for (const r of s)
        this._createButton(r);
      const o = Gh([
        ...t.filter(J),
        ...Wa.getDefaultDropdownDefinitions(e)
      ], this.localizedDefaultStylesTitles);
      for (const r of o)
        this._createDropdown(r, s);
    }
    /**
     * Creates a dropdown and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
     */
    _createDropdown(e, t) {
      const i = this.editor.ui.componentFactory;
      i.add(e.name, (s) => {
        let o;
        const { defaultItem: r, items: a, title: l } = e, c = a.filter((f) => t.find(({ name: m }) => jh(m) === f)).map((f) => {
          const m = i.create(f);
          return f === r && (o = m), m;
        });
        a.length !== c.length && Wa.warnInvalidStyle({ dropdown: e });
        const u = we(s, sr), d = u.buttonView, h = d.arrowView;
        return or(u, c, { enableActiveItemFocusOnDropdownOpen: !0 }), d.set({
          label: Kh(l, o.label),
          class: null,
          tooltip: !0
        }), h.unbind("label"), h.set({
          label: l
        }), d.bind("icon").toMany(c, "isOn", (...f) => {
          const m = f.findIndex(Ft);
          return m < 0 ? o.icon : c[m].icon;
        }), d.bind("label").toMany(c, "isOn", (...f) => {
          const m = f.findIndex(Ft);
          return Kh(l, m < 0 ? o.label : c[m].label);
        }), d.bind("isOn").toMany(c, "isOn", (...f) => f.some(Ft)), d.bind("class").toMany(c, "isOn", (...f) => f.some(Ft) ? "ck-splitbutton_flatten" : void 0), d.on("execute", () => {
          c.some(({ isOn: f }) => f) ? u.isOpen = !u.isOpen : o.fire("execute");
        }), u.bind("isEnabled").toMany(c, "isEnabled", (...f) => f.some(Ft)), this.listenTo(u, "execute", () => {
          this.editor.editing.view.focus();
        }), u;
      });
    }
    /**
     * Creates a button and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
     */
    _createButton(e) {
      const t = e.name;
      this.editor.ui.componentFactory.add(jh(t), (i) => {
        const s = this.editor.commands.get("imageStyle"), o = new P(i);
        return o.set({
          label: e.title,
          icon: e.icon,
          tooltip: !0,
          isToggleable: !0
        }), o.bind("isEnabled").to(s, "isEnabled"), o.bind("isOn").to(s, "value", (r) => r === t), o.on("execute", this._executeCommand.bind(this, t)), o;
      });
    }
    _executeCommand(e) {
      this.editor.execute("imageStyle", { value: e }), this.editor.editing.view.focus();
    }
  }
  function Gh(n, e) {
    for (const t of n)
      e[t.title] && (t.title = e[t.title]);
    return n;
  }
  function jh(n) {
    return `imageStyle:${n}`;
  }
  function Kh(n, e) {
    return (n ? n + ": " : "") + e;
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class qM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Aw, WM];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageStyle";
    }
  }
  /**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   */
  class GM extends w {
    /**
     * @inheritDoc
     */
    static get requires() {
      return [Po, Ae];
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
      return "ImageToolbar";
    }
    /**
     * @inheritDoc
     */
    afterInit() {
      const e = this.editor, t = e.t, i = e.plugins.get(Po), s = e.plugins.get("ImageUtils");
      i.register("image", {
        ariaLabel: t("Image toolbar"),
        items: jM(e.config.get("image.toolbar") || []),
        getRelatedElement: (o) => s.getClosestSelectedImageWidget(o)
      });
    }
  }
  function jM(n) {
    return n.map((e) => J(e) ? e.name : e);
  }
  class KM {
    /**
     * Plugin's constructor - receives an editor instance on creation.
     */
    constructor(e) {
      this.editor = e;
    }
    /**
     * Sets the conversion up and extends the table & image features schema.
     *
     * Schema extending must be done in the "afterInit()" call because plugins define their schema in "init()".
     */
    afterInit() {
      const e = this.editor;
      so("img", "imageBlock", e), so("img", "imageInline", e), so("table", "table", e), so("span", "$blockObject", e), e.conversion.for("upcast").add(xw("figure"), { priority: "low" });
    }
  }
  function so(n, e, t) {
    t.model.schema.extend(e, { allowAttributes: ["customClass"] }), t.conversion.for("upcast").add(xw(n), { priority: "low" }), t.conversion.for("downcast").add(ZM(e), { priority: "low" });
  }
  function xw(n) {
    return (e) => e.on(`element:${n}`, (t, i, s) => {
      const o = i.viewItem, r = i.modelRange, a = r && r.start.nodeAfter;
      if (!a)
        return;
      const l = a.getAttribute("customClass") || [];
      l.push(...o.getClassNames()), s.writer.setAttribute("customClass", l, a);
    });
  }
  function ZM(n) {
    return (e) => e.on(`insert:${n}`, (t, i, s) => {
      const o = i.item, r = s.mapper.toViewElement(o);
      r && s.writer.addClass(o.getAttribute("customClass"), r);
    });
  }
  const JM = [
    "undo",
    "redo",
    "|",
    "heading",
    "fontSize",
    "fontFamily",
    "bold",
    "italic",
    "underline",
    "strikethrough",
    "code",
    "fontColor",
    "fontBackgroundColor",
    "superscript",
    "subscript",
    "|",
    "alignment",
    "numberedList",
    "bulletedList",
    "outdent",
    "indent",
    "|",
    "horizontalLine",
    "blockQuote",
    "link",
    "|",
    "insertImage",
    "insertTable",
    "specialCharacters"
  ], Sw = {
    language: "en",
    placeholder: "Please enter content",
    fontSize: {
      options: [
        8,
        9,
        10,
        11,
        12,
        14,
        "default",
        18,
        20,
        22,
        24,
        26,
        28,
        36,
        48,
        72
      ]
    },
    heading: {
      options: [
        { model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" },
        { model: "heading1", view: "h1", title: "Heading 1", class: "ck-heading_heading1" },
        { model: "heading2", view: "h2", title: "Heading 2", class: "ck-heading_heading2" },
        { model: "heading3", view: "h3", title: "Heading 3", class: "ck-heading_heading3" }
      ]
    },
    toolbar: {
      items: JM,
      shouldNotGroupWhenFull: !1
    },
    image: {
      toolbar: [
        "imageStyle:inline",
        "imageStyle:wrapText",
        "imageStyle:breakText",
        "|",
        "toggleImageCaption",
        "imageTextAlternative"
      ]
    },
    table: {
      contentToolbar: ["tableRow", "tableColumn", "tableProperties", "tableCellProperties", "mergeTableCells"]
    },
    alignment: {
      options: ["left", "center", "right", "justify"]
    },
    plugins: [
      iP,
      _s,
      mP,
      $P,
      GP,
      XP,
      tR,
      oR,
      cR,
      fR,
      wR,
      CR,
      dp,
      cp,
      IR,
      hp,
      pp,
      PR,
      gp,
      mp,
      fp,
      nL,
      cL,
      aL,
      pL,
      vL,
      ZL,
      p3,
      o7,
      k4,
      T4,
      kV,
      bV,
      q4,
      uV,
      zS,
      RV,
      VV,
      zV,
      SM,
      eM,
      sM,
      VM,
      qM,
      GM,
      i3,
      ww,
      dM
    ],
    extraPlugins: [KM]
  };
  class Iw {
    constructor(e, t, i) {
      Ii(this, "start_in_before");
      Ii(this, "start_in_after");
      Ii(this, "length");
      Ii(this, "end_in_before");
      Ii(this, "end_in_after");
      this.start_in_before = e, this.start_in_after = t, this.length = i, this.end_in_before = e + i - 1, this.end_in_after = t + i - 1;
    }
  }
  const XM = (n) => n === ">", Zh = (n) => n === "<", Jh = (n) => /^\s+$/.test(n), Yl = (n) => /^\s*<img\b/.test(n), Pw = (n) => /^\s*<[^>]+>\s*$/.test(n), YM = (n) => !Pw(n), QM = (n) => Yl(n) || YM(n), e6 = (n) => !Yl(n) && Pw(n);
  function Xh(n) {
    let e = "char", t = "";
    const i = [];
    for (const s of n)
      switch (e) {
        case "tag":
          XM(s) ? (t += ">", i.push(t), t = "", Jh(s) ? e = "whitespace" : e = "char") : t += s;
          break;
        case "char":
          Zh(s) ? (t && i.push(t), t = "<", e = "tag") : /\s/.test(s) ? (t && i.push(t), t = s, e = "whitespace") : /[\w\#@]+/i.test(s) ? t += s : (t && i.push(t), t = s);
          break;
        case "whitespace":
          Zh(s) ? (t && i.push(t), t = "<", e = "tag") : Jh(s) ? t += s : (t && i.push(t), t = s, e = "char");
          break;
        default:
          throw new Error(`Unknown mode ${e}`);
      }
    return t && i.push(t), i;
  }
  function t6(n, e, t, i, s, o, r) {
    let a = i, l = o, c = 0, u = {};
    for (let d = i; d < s; d++) {
      const h = {}, f = n[d], m = t[f] || [];
      for (const p of m) {
        if (p < o)
          continue;
        if (p >= r)
          break;
        u[p - 1] || (u[p - 1] = 0);
        const b = u[p - 1] + 1;
        h[p] = b, b > c && (a = d - b + 1, l = p - b + 1, c = b);
      }
      u = h;
    }
    if (c !== 0)
      return new Iw(a, l, c);
  }
  function qa(n, e, t, i, s, o, r, a) {
    const l = t6(
      n,
      e,
      t,
      i,
      s,
      o,
      r
    );
    return l && (i < l.start_in_before && o < l.start_in_after && qa(
      n,
      e,
      t,
      i,
      l.start_in_before,
      o,
      l.start_in_after,
      a
    ), a.push(l), l.end_in_before <= s && l.end_in_after <= r && qa(
      n,
      e,
      t,
      l.end_in_before + 1,
      s,
      l.end_in_after + 1,
      r,
      a
    )), a;
  }
  function i6(n) {
    if (!n.find_these)
      throw new Error("params must have find_these key");
    if (!n.in_these)
      throw new Error("params must have in_these key");
    const e = {};
    for (const t of n.find_these) {
      e[t] = [];
      let i = n.in_these.indexOf(t);
      for (; i !== -1; )
        e[t].push(i), i = n.in_these.indexOf(t, i + 1);
    }
    return e;
  }
  function n6(n, e) {
    const t = [], i = i6({
      find_these: n,
      in_these: e
    });
    return qa(
      n,
      e,
      i,
      0,
      n.length,
      0,
      e.length,
      t
    );
  }
  function s6(n, e) {
    if (!n)
      throw new Error("before_tokens?");
    if (!e)
      throw new Error("after_tokens?");
    let t = 0, i = 0;
    const s = [], o = {
      "false,false": "replace",
      "true,false": "insert",
      "false,true": "delete",
      "true,true": "none"
    }, r = n6(n, e);
    r.push(new Iw(n.length, e.length, 0));
    for (const u of r) {
      const d = t === u.start_in_before, h = i === u.start_in_after, f = o[[d, h].toString()];
      f !== "none" && s.push({
        action: f,
        start_in_before: t,
        end_in_before: f === "insert" ? void 0 : u.start_in_before - 1,
        start_in_after: i,
        end_in_after: f === "delete" ? void 0 : u.start_in_after - 1
      }), u.length !== 0 && s.push({
        action: "equal",
        start_in_before: u.start_in_before,
        end_in_before: u.end_in_before,
        start_in_after: u.start_in_after,
        end_in_after: u.end_in_after
      }), t = u.end_in_before + 1, i = u.end_in_after + 1;
    }
    const a = [];
    let l = { action: "none", start_in_before: 0, start_in_after: 0 };
    const c = (u) => u.action !== "equal" || u.end_in_before - u.start_in_before !== 0 ? !1 : /^\s$/.test(n[u.start_in_before]);
    for (const u of s)
      c(u) && l.action === "replace" || u.action === "replace" && l.action === "replace" ? (l.end_in_before = u.end_in_before, l.end_in_after = u.end_in_after) : (a.push(u), l = u);
    return a;
  }
  function Yh(n, e, t) {
    e = e.slice(n);
    let i;
    for (const [s, o] of e.entries()) {
      const r = t(o);
      if (r && (i = s), !r)
        break;
    }
    return i !== void 0 ? e.slice(0, i + 1) : [];
  }
  function Qh(n, e, t) {
    let i = "", s = 0;
    const o = e.length;
    for (; s < o; ) {
      const r = Yh(s, e, QM);
      if (s += r.length, r.length !== 0 && (Yl(r[0]) ? i += r[0].replace("<img", `<img class="Spendit-Editor-Image-${t === "insert" ? "Insert" : "Delete"}" `) : i += `<${n} style="background-color: ${t === "insert" ? "rgba(30,174,49,.35)" : "rgba(229,102,134,.35)"}; ${t === "delete" ? "text-decoration: line-through" : ""}">${r.join("")}</${n}>`), s >= o)
        break;
      const a = Yh(s, e, e6);
      s += a.length, i += a.join("");
    }
    return i;
  }
  const Ga = {
    equal: (n, e, t) => e.slice(n.start_in_before, n.end_in_before + 1).join(""),
    insert: (n, e, t) => {
      const i = t.slice(n.start_in_after, n.end_in_after + 1);
      return Qh("span", i, "insert");
    },
    delete: (n, e, t) => {
      const i = e.slice(n.start_in_before, n.end_in_before + 1);
      return Qh("span", i, "delete");
    },
    replace(n, e, t) {
      const i = Ga.delete(n, e, t), s = Ga.insert(n, e, t);
      return i.startsWith("<img") && s.startsWith("<img") ? `${i}</figure><figure class="image">${s}` : i + s;
    }
  };
  function o6(n, e, t) {
    let i = "";
    for (const s of t)
      i += Ga[s.action](s, n, e);
    return i;
  }
  function Rw(n, e) {
    if (n === e)
      return n;
    const t = Xh(n), i = Xh(e), s = s6(t, i);
    return o6(t, i, s);
  }
  const jr = async ({
    targetId: n,
    lang: e = "en",
    initialData: t = "",
    placeholder: i = "",
    onContentChange: s,
    debounceDelay: o = 3e3,
    onBlur: r
  }) => {
    const a = document.getElementById(n);
    if (!a)
      return console.error("[CKEditor 경고] targetId에 해당하는 요소가 없습니다. targetId를 확인해주세요."), null;
    const l = {
      ...Sw,
      initialData: t,
      language: e,
      placeholder: i
    }, c = xS(() => s(u.getData()), o), u = await bs.create(a, l).then((d) => (s && d.model.document.on("change:data", () => {
      c();
    }), r && d.ui.focusTracker.on("change:isFocused", (h, f, m) => {
      m || r(d.getData());
    }), d)).catch((d) => (console.error("[CKEditor 에러] 에디터를 초기화하는 중 오류가 발생했습니다.", d), null));
    return { editor: u };
  }, r6 = ({
    editor: n,
    initialHeight: e = 200,
    minHeight: t = 200,
    maxHeight: i = 700,
    gapHeight: s = 100,
    sizingButtonPosition: o = "outer",
    resizeButtonCallback: r = () => {
    }
  }) => {
    const a = document.querySelector(".ck-editor"), l = document.querySelector(".ck-content"), c = m(o), u = c.querySelector(".Spendit-Sizing-Top"), d = c.querySelector(".Spendit-Sizing-Bottom"), h = c.querySelector(".Spendit-Sizing-Up"), f = c.querySelector(".Spendit-Sizing-Down");
    n.editing.view.change((v) => {
      v.setStyle("height", `${e}px`, n.editing.view.document.getRoot()), v.setStyle("min-height", `${t}px`, n.editing.view.document.getRoot()), v.setStyle("max-height", `${i}px`, n.editing.view.document.getRoot());
    }), u.onclick = () => b("top"), h.onclick = () => b("up"), f.onclick = () => b("down"), d.onclick = () => b("bottom");
    function m(v) {
      const y = document.createElement("div");
      y.classList.add("Spendit-Editor-Sizing-Buttons"), y.classList.add(v === "inner" ? "Spendit-Editor-Sizing-Buttons-Inner" : "Spendit-Editor-Sizing-Buttons-Outer");
      const L = p(["Spendit-Sizing-Top", ...t === e ? ["Spendit-Sizing-Top-Disabled"] : []]), M = p(["Spendit-Sizing-Up", ...t === e ? ["Spendit-Sizing-Up-Disabled"] : []]), D = p(["Spendit-Sizing-Down", ...i === e ? ["Spendit-Sizing-Down-Disabled"] : []]), A = p(["Spendit-Sizing-Bottom", ...i === e ? ["Spendit-Sizing-Bottom-Disabled"] : []]);
      return y == null || y.appendChild(L), y == null || y.appendChild(M), y == null || y.appendChild(D), y == null || y.appendChild(A), a == null || a.appendChild(y), y;
    }
    function p(v) {
      const y = document.createElement("button");
      return y.classList.add("Spendit-Editor-Sizing-Button"), v.forEach((L) => y.classList.add(L)), y;
    }
    function b(v) {
      let y = 0;
      v === "top" ? y = t : v === "bottom" ? y = i : v === "up" ? y = l.offsetHeight - s : v === "down" && (y = l.offsetHeight + s), n.editing.view.change((L) => {
        const M = y >= i, D = y <= t, A = M ? i : D ? t : y;
        L.setStyle("height", `${A}px`, n.editing.view.document.getRoot());
        const R = u.classList.contains("Spendit-Sizing-Top-Disabled"), S = d.classList.contains("Spendit-Sizing-Bottom-Disabled");
        D && R || M && S || (D ? (u.classList.add("Spendit-Sizing-Top-Disabled"), h.classList.add("Spendit-Sizing-Up-Disabled"), d.classList.remove("Spendit-Sizing-Bottom-Disabled"), f.classList.remove("Spendit-Sizing-Down-Disabled")) : M ? (u.classList.remove("Spendit-Sizing-Top-Disabled"), h.classList.remove("Spendit-Sizing-Up-Disabled"), d.classList.add("Spendit-Sizing-Bottom-Disabled"), f.classList.add("Spendit-Sizing-Down-Disabled")) : (u.classList.remove("Spendit-Sizing-Top-Disabled"), h.classList.remove("Spendit-Sizing-Up-Disabled"), d.classList.remove("Spendit-Sizing-Bottom-Disabled"), f.classList.remove("Spendit-Sizing-Down-Disabled")));
      }), r(y);
    }
  }, a6 = async ({
    targetId: n,
    lang: e = "en",
    textPrevious: t = "",
    textCurrent: i = ""
  }) => {
    const s = document.getElementById(n);
    if (!s)
      return console.error("[CKEditor 경고] targetId에 해당하는 요소가 없습니다. targetId를 확인해주세요."), null;
    const o = Rw(t, i), r = {
      ...Sw,
      initialData: o,
      language: e
    };
    return { editor: await bs.create(s, r).then((l) => (l.enableReadOnlyMode(""), l.ui.view.toolbar.element.style.display = "none", l)).catch((l) => (console.error("[CKEditor 에러] 에디터를 초기화하는 중 오류가 발생했습니다.", l), null)) };
  }, l6 = async () => {
    const { editor: n } = await jr({
      targetId: "sample-editor",
      lang: "en",
      initialData: "<p>Initial content</p>",
      maxContentSize: 10,
      placeholder: "Please enter content",
      onContentChange: (s) => {
        console.log("change", s);
      },
      debounceDelay: 2e3,
      onBlur: (s) => {
        console.log("blur", s);
      }
    });
    r6({
      editor: n,
      sizingButtonPosition: "inner"
    });
    const { editor: e } = await a6({
      targetId: "sample-diff-editor",
      lang: "en",
      textPrevious: "Same content, removed this!!",
      textCurrent: "Same content, added this!!"
    }), { editor: t } = await jr({
      targetId: "sample-diff-editor-previous",
      lang: "en",
      maxContentSize: 10,
      placeholder: "Please enter content",
      initialData: "Same content, removed this!!"
    }), { editor: i } = await jr({
      targetId: "sample-diff-editor-current",
      lang: "en",
      placeholder: "Please enter content",
      initialData: "Same content, added this!!"
    });
    return {
      editor: n,
      diffEditor: e,
      previousEditor: t,
      currentEditor: i
    };
  };
  (async () => {
    const { editor: n, currentEditor: e, diffEditor: t, previousEditor: i } = await l6(), s = document.getElementById("readonly-button"), o = document.getElementById("edit-button"), r = document.getElementById("diff-button");
    s.addEventListener("click", () => {
      n.enableReadOnlyMode("test"), n.ui.view.toolbar.element.style.display = "none";
    }), o.addEventListener("click", () => {
      n.disableReadOnlyMode("test"), n.ui.view.toolbar.element.style.display = "block";
    }), r.addEventListener("click", async () => {
      const a = i.getData(), l = e.getData(), c = Rw(a, l);
      t.setData(c);
    });
  })();
});
export default c6();
